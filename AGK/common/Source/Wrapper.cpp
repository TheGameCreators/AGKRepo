// Includes
//#include "Wrapper.h"
#include "agk.h"
#include "DebugDraw.h"
#include "Box2D/Box2D.h"
#include "SimplexNoise.h"

#ifdef AGK_HTML5
	#include "emscripten.h"
#endif

#ifdef AGK_IOS
    #import <StoreKit/StoreKit.h>
#endif

#include "OpenGL2/OpenGL2.h"
#ifndef DISABLE_VULKAN
	#include "Vulkan/AGKVulkan.h"
#endif

#define AGK_MAX_PRINT_LENGTH 100000

extern unsigned int libImageTrialWatermark[];

extern "C" void AGKError( const char* msg )
{
	agk::Error( msg );
}

// Namespace
namespace AGK
{

// file entry class

cHashedList<cFileEntry*> cFileEntry::g_cFileList(256);

void cFileEntry::AddNewFile( const char *szFullPath )
{
	return; // this won't work with UTF-8

	cFileEntry *pEntry = new cFileEntry();
	pEntry->m_sReal.SetStr( szFullPath );
	pEntry->m_sLowercase.SetStr( szFullPath );
	pEntry->m_sLowercase.Lower();

	pEntry->m_sReal.Replace( '\\', '/' );
	pEntry->m_sLowercase.Replace( '\\', '/' );

    if ( !g_cFileList.GetItem(pEntry->m_sLowercase) )
    {
        g_cFileList.AddItem( pEntry, pEntry->m_sLowercase );
    }
    else 
    {
        delete pEntry;
    }
}

void cFileEntry::ConvertToReal( uString &path )
{
	path.Replace( '\\', '/' );

	uString path2( path );
	path2.Lower();
	
	cFileEntry *pEntry = g_cFileList.GetItem( path2.GetStr() );
	if ( pEntry )
	{
		if ( path.CompareTo( pEntry->m_sReal ) != 0 )
		{
			int pos = path.RevFind('/');
			uString basename;
			if ( pos >= 0 ) path.SubString( basename, pos+1 );
			else basename.SetStr( path );

			uString info;
			info.Format( "File path case for \"%s\" does not match the filename on disk, this will cause an error on Android", basename.GetStr() );
			agk::Warning( info );
		}
		path.SetStr( pEntry->m_sReal );
	}
}

void cFileEntry::ClearAll()
{
	cFileEntry *pEntry = g_cFileList.GetFirst();
	while ( pEntry )
	{
		delete pEntry;
		pEntry = g_cFileList.GetNext();
	}
	g_cFileList.ClearAll();
}

//
// Setup and Core functions go direct to platform specific implementations (i.e WindowsCore.cpp, AppleCore.cpp)
//

// *********************
// Variables
// *********************

Renderer* agk::g_pRenderer = 0;

bool agk::g_bIsExternal = 0;
void (*agk::SwapExternal)(void*) = 0;
void* agk::g_pSwapParam = 0;

// 3D phsyics variables
/*btBroadphaseInterface *agk::m_pBroadphase = 0; 
btDefaultCollisionConfiguration* agk::m_pCollisionConfiguration = 0; 
btCollisionDispatcher* agk::m_pDispatcher = 0; 
btSequentialImpulseConstraintSolver* agk::m_pSolver = 0; 
btDiscreteDynamicsWorld* agk::m_pDynamicsWorld = 0;*/ 

// Time variables
double agk::m_fTimeStart = 0.0f;
double agk::m_fTimeCurr = 0.0f;
double agk::m_fTimeFrameStart = 0.0f;
double agk::m_fTimeLimitFrameStart = 0.0f;
float agk::m_fTimeDelta = 0.016f;
float agk::m_fFps = 0.0f;
uint32_t agk::m_iTimeMilliseconds = 0;

// Calculated viewport variables
/*
float agk::m_iViewportX = 0;
float agk::m_iViewportY = 0;
float agk::m_iViewportWidth = 0;
float agk::m_iViewportHeight = 0;
*/

float agk::m_fTargetViewportX = 0;
float agk::m_fTargetViewportY = 0;
float agk::m_fTargetViewportWidth = 0;
float agk::m_fTargetViewportHeight = 0;

int agk::m_iScissorX = 0;
int agk::m_iScissorY = 0;
int agk::m_iScissorWidth = 0;
int agk::m_iScissorHeight = 0;
bool agk::m_bScissorEnabled = false;
bool agk::m_bScissorUser = false;
float agk::m_fScissorUserX = 0;
float agk::m_fScissorUserY = 0;
float agk::m_fScissorUserX2 = 0;
float agk::m_fScissorUserY2 = 0;

uint32_t agk::m_iDefaultFBCleared = 0;

int agk::m_iUseNewDefaultFonts = 0;

// Default states
int agk::m_iRealDeviceWidth	 = 0;
int agk::m_iRealDeviceHeight = 0;
int agk::m_iRenderWidth		 = 0;
int agk::m_iRenderHeight	 = 0;
int agk::m_iDisplayWidth	 = 0;
int agk::m_iDisplayHeight	 = 0;
float agk::m_iDisplayExtraX	 = 0;
float agk::m_iDisplayExtraY	 = 0;
int agk::m_iDisplayIsLandscape = 0;
int agk::m_iResolutionMode = 0;
int agk::m_iExtraAGKPlayerAssetsMode = 1;
int agk::m_iOrientation = 1;
uint32_t agk::m_bAGKFlags = AGK_FLAG_PORTRAIT | AGK_FLAG_PORTRAIT2 | AGK_FLAG_LANDSCAPE | AGK_FLAG_LANDSCAPE2 | AGK_FLAG_CAN_RESIZE;
uint32_t agk::m_iDefaultMagFilter = 1;
uint32_t agk::m_iDefaultMinFilter = 1;
uint32_t agk::m_iDefaultWrapU = 0;
uint32_t agk::m_iDefaultWrapV = 0;
uString agk::m_sCompanyName;
uString agk::m_sAppName;
float agk::m_fClearRed = 0;
float agk::m_fClearGreen = 0;
float agk::m_fClearBlue = 0;
float agk::m_fBorderRed = 0;
float agk::m_fBorderGreen = 0;
float agk::m_fBorderBlue = 0;
bool agk::m_bIsCapturing = false;
uint32_t agk::m_iUncollectedCaptureImage = 0;
bool agk::m_bIsChoosing = false;
cImage* agk::m_pUncollectedChosenImage = 0;

uint32_t agk::m_iPulleySprite1 = 0;
uint32_t agk::m_iPulleySprite2 = 0;
float agk::m_iPulleyRatio = 0;
int agk::m_iPulleyColConnected = 0;

int agk::wasMusicPlaying = 0;
int agk::wasVideoPlaying = 0;
int agk::m_iPaused = 0;
int agk::m_iResumed = 0;
int agk::m_iResumed2 = 0;

int agk::m_iVideoPlayMode = 0;
uint32_t agk::m_iVideoTextureRaw = 0;
cImage* agk::m_pVideoTexture = 0;
cObject3D* agk::m_pVideoTextureQuad = 0;
AGKShader* agk::m_pVideoTextureShader = 0;
AGKFrameBuffer* agk::m_pVideoTextureFBO = 0;

cImage* agk::m_pCameraTexture = 0;
int agk::m_iDeviceCameraID = -1;
int agk::m_iDeviceCameraType = 0;

int agk::m_iSGX540GPU = 0;

// iPhone aspect ratio, matches most phones fairly well
float agk::m_fDisplayAspect	= (2.0f/3.0f);
bool agk::m_bUsingDisplayAspect = false;
bool agk::m_bUsingDeviceAspect = false;
float agk::m_fStretchValue = m_fDisplayAspect;

// Music manager
cMusicMgr agk::m_cMusicMgr;
int agk::m_iDeviceVolume = 100;

// Global lists
cHashedList<cImage*> agk::m_cImageList(512);
cHashedList<cSprite*> agk::m_cSpriteList(32768);
cHashedList<cText*> agk::m_cTextList(1024);
cHashedList<AGKFont*> agk::m_cFontList(16);
cHashedList<b2Joint*> agk::m_cJointList(1024);
cHashedList<cForce*> agk::m_cForceList(32);
cHashedList<cFile*> agk::m_cFileList(512);
cHashedList<cFolder*> agk::m_cFolderList(128);
cHashedList<cNetwork*> agk::m_cNetworkList(16);
cHashedList<cNetworkMessage*> agk::m_cNetMessageList(64);
cHashedList<cHTTPConnection*> agk::m_cHTTPList(32);
cHashedList<BroadcastListener*> agk::m_cBroadcastListenerList(16);
cHashedList<AGKSocket*> agk::m_cSocketList(64);
cHashedList<cNetworkListener*> agk::m_cSocketListenerList(64);
cHashedList<UDPManager*> agk::m_cUDPListenerList(32);
cHashedList<cParticleEmitter*> agk::m_cParticleEmitterList(64);
cHashedList<cEditBox*> agk::m_cEditBoxList(128);
cHashedList<ZipFile*> agk::m_cZipFileList(16);
cHashedList<cMemblock*> agk::m_cMemblockList(512);
cHashedList<Skeleton2D*> agk::m_cSkeleton2DList(128);
cHashedList<Tween*> agk::m_cTweenList(2048);
cHashedList<TweenChain*> agk::m_cTweenChainList(512);

cHashedList<cObject3D*> agk::m_cObject3DList(16384);
cHashedList<cCamera*> agk::m_cCameraList(32);
cHashedList<AGKShader*> agk::m_cShaderList(1024);
cHashedList<AGK3DParticleEmitter*> agk::m_3DParticleEmitterList(256);
cHashedList<AGKPointLight*> agk::m_cPointLightList(32);
AGKDirectionalLight agk::m_cDirectionalLight;
AGKVector agk::m_AmbientColor(0.3f,0.3f,0.3f);

cHashedList<AGKMusicOGG*> agk::m_cMusicOGGList(64);

AGKSkyBox *agk::m_pSkyBox = 0;

//cSpriteMgr agk::m_cSpriteMgr;
cSpriteMgrEx agk::m_cSpriteMgrFront;
cObjectMgr agk::m_cObjectMgr;

// error variables
int agk::m_iErrorMode = 2; //report
uString agk::m_sLastError( "", 100 );
bool agk::m_bErrorOccurred = false;
cLock agk::m_kErrorLock;
void(*agk::m_fWarningCallback)(const char*) = 0; 
void(*agk::m_fErrorCallback)(const char*) = 0;
void(*agk::m_fDebugCallback)(const char*, const char*) = 0;

// misc vars
int agk::m_iPrintSizeChanged = 0;
cImage* agk::m_pPrintDefaultFont = 0;
cImage* agk::m_pPrintDefaultFontExt = 0;
cText* agk::m_pPrintText = 0;
uString agk::m_cPrintStr( "", 100 );
char agk::m_szConvStr[ 256 ];
bool agk::m_bGenerateMipmaps = false;
cSprite* agk::m_pLastColCheck = 0;
cSprite* agk::m_pLastColCheck2 = 0;
uint32_t agk::m_iRandSeed = 1;
float agk::m_fViewOffsetX = 0;
float agk::m_fViewOffsetY = 0;
float agk::m_fViewZoom = 1.0f;
int agk::m_iViewZoomMode = 0;
cSprite* agk::m_pSplashSprite = 0;
bool agk::m_bFirstSync = true;
float agk::m_fSyncTime = 1/60.0f;
int agk::m_iSyncMode = 0;
bool agk::m_bOrientationSet = false;
int agk::m_iCurrentOrientationMode = 0;
uString agk::m_sPNToken("");

AGKUnorderedArray<uString*> agk::m_pVulkanDeviceExtensions;
AGKUnorderedArray<uString*> agk::m_pVulkanInstanceExtensions;

uint32_t agk::m_iPolygonsDrawn = 0;
uint32_t agk::m_iShadowPolygonsDrawn = 0;
uint32_t agk::m_iVerticesProcessed = 0;

int agk::m_iRandMTIndex = 0;
uint32_t agk::m_iRandMTArray[ 624 ];

int agk::m_iDrawingCount = 0;

// directory variables
uString agk::m_sCurrentDir;
uString agk::m_sOrigSetDir;
cDirectoryItem *agk::m_pCurrentDirectories = 0;
cDirectoryItem *agk::m_pCurrentFiles = 0;
cDirectoryItem *agk::m_pCurrentDirectoryIter = 0;
cDirectoryItem *agk::m_pCurrentFileIter = 0;
int agk::m_iCurrentDirectoryMode = 2;
int agk::m_iCurrentFileMode = 2;
bool agk::m_bUpdateFileLists = true;

// date/time variables
int agk::m_pMonthDays[ 12 ] = { 31,28,31,30,31,30,31,31,30,31,30,31 };

//advert variables
uString agk::m_sAdMobCode;
uString agk::m_sAdMobRewardAdCode;
uString agk::m_sInneractiveCode;
uString agk::m_sChartboostCode1;
uString agk::m_sChartboostCode2;
uString agk::m_sAdClientID;
uString agk::m_sInneractiveURL;
uString agk::m_sInneractiveImage;
cImage* agk::m_pAdImage = 0;
cSprite* agk::m_pAdSprite = 0;
cHTTPConnection* agk::pHTTPInneractive = 0;
float agk::m_fAdStartTime = 0;
int agk::m_iInneractiveStage = 0;
float agk::m_fAdX = -1;
float agk::m_fAdY = -1;
float agk::m_fAdWidth = 0;
float agk::m_fAdOffsetX = 0;
float agk::m_fAdOffsetY = 0;
int agk::m_iAdType = 0;
int agk::m_iAdHorz = 1;
int agk::m_iAdVert = 0;
int agk::m_iAdTest = 1;
int agk::m_iAdVisible = 1;

float agk::m_fVideoX = 0;
float agk::m_fVideoY = 0;
float agk::m_fVideoWidth = 100;
float agk::m_fVideoHeight = 100;
	
float agk::m_fUpdateTime = 0;
float agk::m_fPhysicsTime = 0;
float agk::m_fDrawingSetupTime = 0;
float agk::m_f3DDrawingSetupTime = 0;
float agk::m_fDrawingTime = 0;

// input variables
// mouse
cMouse* agk::m_pMouse[ 4 ] = { 0 };

// accelerometer
float agk::m_fAccelX = 0;
float agk::m_fAccelY = 0;
float agk::m_fAccelZ = 0;
float agk::m_fFakeAccelX = 0;
float agk::m_fFakeAccelY = 0;

float agk::m_fGyroX = 0;
float agk::m_fGyroY = 0;
float agk::m_fGyroZ = 0;

float agk::m_fProximityDist = 0;

float agk::m_fLightLevel = 0;

float agk::m_fMagneticX = 0;
float agk::m_fMagneticY = 0;
float agk::m_fMagneticZ = 0;

float agk::m_fRotVecX = 0;
float agk::m_fRotVecY = 0;
float agk::m_fRotVecZ = 0;
float agk::m_fRotVecW = 0;

float agk::m_fGPSLong = 0;
float agk::m_fGPSLat = 0;
float agk::m_fGPSAltitude = 0;

uint32_t agk::m_bSensorFlags = 0;

// keyboard
unsigned char agk::m_iPrevKeyDown[ AGK_MAX_KEYS ] = { 0 };
unsigned char agk::m_iKeyDown[ AGK_MAX_KEYS ] = { 0 };
unsigned char agk::m_iResetKey[ AGK_MAX_KEYS ] = { 0 };
unsigned int agk::m_iLastKey = 0;
uString agk::m_sCharBuffer;

// joystick
cJoystick* agk::m_pJoystick[ AGK_NUM_JOYSTICKS ] = { 0 };
cVirtualJoystick* agk::m_pVirtualJoystick[ 4 ] = { 0 };

// virtual buttons
cVirtualButton* agk::m_pVirtualButton[ AGK_MAX_VIRTUAL_BUTTONS ] = { 0 };

// pointer
int agk::m_iLastPointerDown = 0;
int agk::m_iPointerDown = 0;
float agk::m_fPointerX = 0;
float agk::m_fPointerY = 0;

//   AGK joystick
float agk::m_fFakeJoystickX = 0;
float agk::m_fFakeJoystickY = 0;
float agk::m_fJoystickDeadZone = 0.15f;

// text input variables
bool agk::m_bInputStartedPrev = false;
bool agk::m_bInputStarted = false;
bool agk::m_bInputCancelled = false;
uString agk::m_sCurrInput( "", 30 );
int agk::m_iLastChar = 0;
int agk::m_iCurrChar = 0;
float agk::m_fCursorBlinkDelay = 0.6f;
uint32_t agk::m_iInputMaxChars = 0;
uString agk::m_sInputLabel;

// Physics variables
b2World *agk::m_phyWorld = 0;
b2Body *agk::m_phyGroundBody = 0;
MyDestructionListener *agk::m_DestructionListener = 0;

b2Body *agk::groundBodyBottom = 0;
b2Body *agk::groundBodyRight = 0;
b2Body *agk::groundBodyTop = 0;
b2Body *agk::groundBodyLeft = 0;
	
float agk::m_phyScale = 0.2f;
bool agk::m_bDrawDebug = false;
int agk::m_iVelIterations = 10;
int agk::m_iPosIterations = 10;
bool agk::m_bPhysicsStepped = false;

DebugDraw g_DebugDraw;
MyRayCastCallback g_RayCastCallback;
b2Contact *agk::m_pContactIter = 0;
cSprite *agk::m_pSpriteContactIter = 0;

int agk::m_iMaxPolygonPoints = 8;

// 3D variables
AGKMatrix4 agk::m_matOrtho;
cCamera* agk::m_pCurrentCamera = 0;
int agk::m_i3DDepth = 5000;

// fog variables
int agk::m_iFogMode = 0;
uint32_t agk::m_iFogColor1 = 0; // 161,186,193
uint32_t agk::m_iFogColor2 = 0; // 255,230,179
int agk::m_iFogColor2IsSet = 0;
float agk::m_fFogMinDist = 50;
float agk::m_fFogMaxDist = 700;

// shadow variables
int agk::m_iShadowMode = 0;
int agk::m_iShadowSmoothing = 1;
int agk::m_iShadowMapWidth = 1024;
int agk::m_iShadowMapHeight = 1024;
float agk::m_fShadowRange = -1;
float agk::m_fShadowBias = 0.001f;
float agk::m_fShadowLightStep = 0.0f;
float agk::m_fShadowCascade1 = 0.125f;
float agk::m_fShadowCascade2 = 0.25f;
float agk::m_fShadowCascade3 = 0.5f;
AGKFrameBuffer* agk::m_pShadowMapFBO = 0;
AGKFrameBuffer* agk::m_pShadowMapFBO2 = 0;
AGKFrameBuffer* agk::m_pShadowMapFBO3 = 0;
AGKFrameBuffer* agk::m_pShadowMapFBO4 = 0;
cImage* agk::m_pShadowMap = 0;
cImage* agk::m_pShadowMap2 = 0;
cImage* agk::m_pShadowMap3 = 0;
cImage* agk::m_pShadowMap4 = 0;

// drawing variables
float* agk::m_pLineVertexData = 0;
uint32_t agk::m_iNumLineVertices = 0;
uint32_t agk::m_iLineArraySize = 0;
void* agk::m_pInternalLinesVertices = 0;
void* agk::m_pInternalLinesPipeline = 0;
void* agk::m_pInternalLinesConstants = 0;
AGKRenderState agk::m_linesRenderState;
AGKVertexLayout agk::m_linesVertexLayout;
AGKShader* agk::m_pLinesShader = 0;

// collision variables
CollisionResults agk::m_cCollisionResults(4);

// sensors
int agk::m_iAccelerometerExists = 0;
int agk::m_iGyroSensorExists = 0;
int agk::m_iProximitySensorExists = 0;
int agk::m_iLightSensorExists = 0;
int agk::m_iMagneticSensorExists = 0;
int agk::m_iRotationSensorExists = 0;
int agk::m_iGPSSensorExists = 0;

int agk::m_iNumProcessors = 0;

// noise
SimplexNoise* agk::m_pNoise = NULL;

// ************************************
// Internal public functions (should only be called by automated processes)
// ************************************

void agk::SetCompanyName( const char* company )
{
	m_sCompanyName.SetStr( company );
	m_sCompanyName.Replace( '/', '_' );
	m_sCompanyName.Replace( '\\', '_' );
	m_sCompanyName.Replace( '.', '_' );
	m_sCompanyName.Replace( ':', '_' );
	m_sCompanyName.Strip( "\\/.:\t*" );

	if ( m_sCompanyName.GetLength() > 30 ) m_sCompanyName.Trunc2( m_sCompanyName.GetLength()-30 );
}

void agk::SetAppName( const char* name )
{
	if ( strlen( name ) == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to set app name, must have a length greater than 0." );
#endif
		return;
	}

	m_sAppName.SetStr( name );

	m_sAppName.Replace( '/', '_' );
	m_sAppName.Replace( '\\', '_' );
	m_sAppName.Replace( '.', '_' );
	m_sAppName.Replace( ':', '_' );

	PlatformUpdateWritePath();
    
    agk::SetCurrentDir("");
    agk::MakeFolder("media");
    agk::SetCurrentDir("media");

	cFileEntry::ClearAll();
	cFileEntry::InitFileList();
}

void agk::RestoreWriteDir( void )
{
	PlatformRestoreWritePath();

	cFileEntry::ClearAll();
	cFileEntry::InitFileList();
}

// clears all sprites, images, etc, and resets internal variables to default values
void agk::MasterReset()
{
	agk::StopScreenRecording();
	agk::StopSpeaking();

	agk::DeleteAdvert();
	agk::ARDestroy();

	agk::UseNewDefaultFonts( 0 );
	agk::RestoreWriteDir();

	agk::SetRawMouseVisible( 1 );

	SetPresentMode( 1 );
	SetWindowTitle( "AppGameKit Player" );
	SetWindowSize( 1024, 768, 0 );
	//SetSyncRate( 60, 0 );
	agk::SetVSync( 1 );
	SetErrorMode( 1 );
	agk::SetScreenResolution( 0,0 );
	agk::SetVirtualResolution( 100, 100 );
	SetAntialiasMode( 0 );
	if ( m_pPrintText )
	{
		m_pPrintText->SetFontImage( m_pPrintDefaultFont );
		m_pPrintText->SetExtendedFontImage( m_pPrintDefaultFontExt );
	}
	SetImmersiveMode( 0 );

	SetShadowMappingMode( 0 );
	SetShadowSmoothing( 1 );
	SetShadowMapSize( 1024, 1024 );
	SetShadowRange( -1 );
	SetShadowBias( 0.001f );
	SetShadowLightStepSize( 0 );
	SetShadowCascadeValues( 0.125f, 0.25f, 0.5f );
    
    SocialPluginsDestroy();
	InAppPurchaseReset();
    
	if ( m_sAdMobCode.GetLength() > 0 ) SetAdMobTesting( 0 );
    m_sAdMobCode.SetStr("");
	m_sAdMobRewardAdCode.SetStr("");
    m_sInneractiveCode.SetStr("");
	m_sChartboostCode1.SetStr("");
	m_sChartboostCode2.SetStr("");
	
	m_bScissorUser = false;
	SetVirtualResolution( 100, 100 );
	SetDisplayAspect( 2.0f/3.0f );
	SetOrientationAllowed( 1,1,1,1 );
	m_bOrientationSet = false;
	m_iCurrentOrientationMode = 0;
	
	SetDefaultMagFilter( 1 );
	SetDefaultMinFilter( 1 );
	m_iDefaultWrapU = 0;
	m_iDefaultWrapV = 0;
	
	SetClearColor( 0,0,0 );
	SetBorderColor( 0,0,0 );

	DeleteVideo();
	SetDeviceCameraToImage( 0, 0 );

	// Music manager
	m_cMusicMgr.Stop();
	m_cMusicMgr.ClearAll();
	m_iDeviceVolume = 100;

	agk::SetTextDefaultFontImage( 0 );
	agk::SetTextDefaultExtendedFontImage( 0 );

	// Global lists
	cImage *pImage = m_cImageList.GetFirst();
	while ( pImage )
	{
		delete pImage;		
		pImage = m_cImageList.GetNext();
	}
	m_cImageList.ClearAll();

	cSprite *pSprite = m_cSpriteList.GetFirst();
	while ( pSprite )
	{
		delete pSprite;		
		pSprite = m_cSpriteList.GetNext();
	}
	m_cSpriteList.ClearAll();

	cText *pText = m_cTextList.GetFirst();
	while ( pText )
	{
		delete pText;		
		pText = m_cTextList.GetNext();
	}
	m_cTextList.ClearAll();

	AGKFont *pFont = m_cFontList.GetFirst();
	while ( pFont )
	{
		delete pFont;		
		pFont = m_cFontList.GetNext();
	}
	m_cFontList.ClearAll();

	m_cJointList.ClearAll();

	cForce *pForce = m_cForceList.GetFirst();
	while ( pForce )
	{
		delete pForce;		
		pForce = m_cForceList.GetNext();
	}
	m_cForceList.ClearAll();

	cFile *pFile = m_cFileList.GetFirst();
	while ( pFile )
	{
		delete pFile;		
		pFile = m_cFileList.GetNext();
	}
	m_cFileList.ClearAll();

	cFolder *pFolder = m_cFolderList.GetFirst();
	while ( pFolder )
	{
		delete pFolder;		
		pFolder = m_cFolderList.GetNext();
	}
	m_cFolderList.ClearAll();

	cNetwork *pNetwork = m_cNetworkList.GetFirst();
	while ( pNetwork )
	{
		delete pNetwork;		
		pNetwork = m_cNetworkList.GetNext();
	}
	m_cNetworkList.ClearAll();

	cNetworkMessage *pMsg = m_cNetMessageList.GetFirst();
	while ( pMsg )
	{
		delete pMsg;		
		pMsg = m_cNetMessageList.GetNext();
	}
	m_cNetMessageList.ClearAll();

	cHTTPConnection *pHTTP = m_cHTTPList.GetFirst();
	while ( pHTTP )
	{
		delete pHTTP;		
		pHTTP = m_cHTTPList.GetNext();
	}
	m_cHTTPList.ClearAll();

	BroadcastListener *pListener = m_cBroadcastListenerList.GetFirst();
	while ( pListener )
	{
		delete pListener;		
		pListener = m_cBroadcastListenerList.GetNext();
	}
	m_cBroadcastListenerList.ClearAll();

	AGKSocket *pSocket = m_cSocketList.GetFirst();
	while ( pSocket )
	{
		delete pSocket;		
		pSocket = m_cSocketList.GetNext();
	}
	m_cSocketList.ClearAll();

	cNetworkListener *pSocketListener = m_cSocketListenerList.GetFirst();
	while ( pSocketListener )
	{
		delete pSocketListener;		
		pSocketListener = m_cSocketListenerList.GetNext();
	}
	m_cSocketListenerList.ClearAll();

	UDPManager *pUDPListener = m_cUDPListenerList.GetFirst();
	while ( pUDPListener )
	{
		delete pUDPListener;		
		pUDPListener = m_cUDPListenerList.GetNext();
	}
	m_cUDPListenerList.ClearAll();

	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetFirst();
	while ( pEmitter )
	{
		delete pEmitter;		
		pEmitter = m_cParticleEmitterList.GetNext();
	}
	m_cParticleEmitterList.ClearAll();

	cEditBox *pEditBox = m_cEditBoxList.GetFirst();
	while ( pEditBox )
	{
		delete pEditBox;		
		pEditBox = m_cEditBoxList.GetNext();
	}
	m_cEditBoxList.ClearAll();

	ZipFile *pZipFile = m_cZipFileList.GetFirst();
	while ( pZipFile )
	{
		delete pZipFile;		
		pZipFile = m_cZipFileList.GetNext();
	}
	m_cZipFileList.ClearAll();

	// clean up memblocks
	cMemblock *pMem = m_cMemblockList.GetFirst();
	while( pMem )
	{
		delete pMem;
		pMem = m_cMemblockList.GetNext();
	}
	m_cMemblockList.ClearAll();

	// skeletons
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetFirst();
	while ( pSkeleton )
	{
		delete pSkeleton;		
		pSkeleton = m_cSkeleton2DList.GetNext();
	}
	m_cSkeleton2DList.ClearAll();

	// clean up tweens
	TweenInstance::ClearAll();

	Tween *pTween = m_cTweenList.GetFirst();
	while ( pTween )
	{
		delete pTween;		
		pTween = m_cTweenList.GetNext();
	}
	m_cTweenList.ClearAll();

	TweenChain *pChain = m_cTweenChainList.GetFirst();
	while ( pChain )
	{
		delete pChain;		
		pChain = m_cTweenChainList.GetNext();
	}
	m_cTweenChainList.ClearAll();

	//m_cSpriteMgr.ClearAll();
	m_cSpriteMgrFront.ClearAll();
	m_cObjectMgr.ClearAll();

	// 3D Physics Cleanup
	if ( DynamicsWorldArray.size() > 0 ) agk::Delete3DPhysicsWorld();

	// 3D cleanup
	cObject3D *pObject = m_cObject3DList.GetFirst();
	while ( pObject )
	{
		delete pObject;		
		pObject = m_cObject3DList.GetNext();
	}
	m_cObject3DList.ClearAll();

	cCamera *pCamera = m_cCameraList.GetFirst();
	while ( pCamera )
	{
		delete pCamera;		
		pCamera = m_cCameraList.GetNext();
	}
	m_cCameraList.ClearAll();

	// add main camera back
	if ( g_pRenderer )
	{
		cCamera *mainCamera = new cCamera();
		m_cCameraList.AddItem( mainCamera, 1 );
		mainCamera->SetPosition( 0, 10, -20 );
		mainCamera->LookAt( 0,0,0, 0 );
		m_pCurrentCamera = mainCamera;
		AGKShader::g_varShadowParams.SetVector4( mainCamera->GetFarRange(), m_fShadowBias, 1.0f/m_iShadowMapWidth, 1.0f/m_iShadowMapHeight );
	}

	AGKShader *pShader = m_cShaderList.GetFirst();
	while ( pShader )
	{
		delete pShader;		
		pShader = m_cShaderList.GetNext();
	}
	m_cShaderList.ClearAll();

	AGK3DParticleEmitter *p3DEmitter = m_3DParticleEmitterList.GetFirst();
	while ( p3DEmitter )
	{
		delete p3DEmitter;		
		p3DEmitter = m_3DParticleEmitterList.GetNext();
	}
	m_3DParticleEmitterList.ClearAll();

	// music clean up
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetFirst();
	while ( pMusic )
	{
		delete pMusic;		
		pMusic = m_cMusicOGGList.GetNext();
	}
	m_cMusicOGGList.ClearAll();

	// lights clean up
	AGKPointLight *pPointLight = m_cPointLightList.GetFirst();
	while ( pPointLight )
	{
		delete pPointLight;		
		pPointLight = m_cPointLightList.GetNext();
	}
	m_cPointLightList.ClearAll();

	m_cDirectionalLight.Reset();
	m_AmbientColor.Set( 0.3f, 0.3f, 0.3f );

	AGKShader::g_varDirLightDir.SetVector3( m_cDirectionalLight.m_direction.x, m_cDirectionalLight.m_direction.y, m_cDirectionalLight.m_direction.z );
	AGKShader::g_varDirLightColor.SetVector3( m_cDirectionalLight.m_color.x, m_cDirectionalLight.m_color.y, m_cDirectionalLight.m_color.z );
	AGKShader::g_varLightAmbient.SetVector3( m_AmbientColor.x, m_AmbientColor.y, m_AmbientColor.z );

	SetFogMode( 0 );
	SetFogColor( 161, 186, 209 ); 
	m_iFogColor2IsSet = 0;
	SetFogRange( 50, 700 );

	if ( m_pSkyBox ) 
	{
		m_pSkyBox->Reset();
		m_pSkyBox->SetActive( 0 );
	}

	b2Vec2 gravity;
	gravity.Set(0.0f, 10.0f);

	// must only delete entire physics universe here (after other physics handling completed (above))
	if ( m_phyWorld ) 
	{
		if ( groundBodyBottom ) 
		{
			m_phyWorld->DestroyBody( groundBodyBottom );
			groundBodyBottom = 0;
		}
		if ( groundBodyTop ) 
		{
			m_phyWorld->DestroyBody( groundBodyTop );
			groundBodyTop = 0;
		}
		if ( groundBodyLeft ) 
		{
			m_phyWorld->DestroyBody( groundBodyLeft );
			groundBodyLeft = 0;
		}
		if ( groundBodyRight ) 
		{
			m_phyWorld->DestroyBody( groundBodyRight );
			groundBodyRight = 0;
		}
	
		delete m_phyWorld;

		m_phyWorld = new b2World(gravity);
		m_phyWorld->SetDebugDraw( &g_DebugDraw );
		if ( !m_DestructionListener ) m_DestructionListener = new MyDestructionListener();
		m_phyWorld->SetDestructionListener( m_DestructionListener );
	}
	
	// misc vars
	m_cPrintStr.ClearTemp();
	m_iPrintSizeChanged = 0;
	SetPrintColor(255,255,255);
	m_bGenerateMipmaps = false;
	m_pLastColCheck = 0;
	m_pLastColCheck2 = 0;
	m_iRandSeed = 1;
	m_fViewOffsetX = 0;
	m_fViewOffsetY = 0;
	m_fViewZoom = 1.0f;
	m_iViewZoomMode = 0;
	m_pSplashSprite = 0;
	m_bFirstSync = true;
	m_iSyncMode = 0;
	m_fSyncTime = 1/60.0f;

	m_sCurrentDir.SetStr("media/");
	ParseCurrentDirectory();
		
	m_fUpdateTime = 0;
	m_fPhysicsTime = 0;
	m_fDrawingSetupTime = 0;
	m_fDrawingTime = 0;

	// input variables
	
	// accelerometer
	m_fAccelX = 0;
	m_fAccelY = 0;
	m_fAccelZ = 0;
	m_fFakeAccelX = 0;
	m_fFakeAccelY = 0;

	m_fGyroX = 0;
	m_fGyroY = 0;
	m_fGyroZ = 0;

	m_fProximityDist = 0;

	m_fLightLevel = 0;

	m_fMagneticX = 0;
	m_fMagneticY = 0;
	m_fMagneticZ = 0;

	m_fRotVecX = 0;
	m_fRotVecY = 0;
	m_fRotVecZ = 0;
	m_fRotVecW = 0;

	m_fGPSLong = 0;
	m_fGPSLat = 0;
	m_fGPSAltitude = 0;

	// keyboard
	for ( int i = 0; i < AGK_MAX_KEYS; i++ ) m_iPrevKeyDown[ i ] = 0;
	for ( int i = 0; i < AGK_MAX_KEYS; i++ ) m_iKeyDown[ i ] = 0;
	for ( int i = 0; i < AGK_MAX_KEYS; i++ ) m_iResetKey[ i ] = 0;
	m_iLastKey = 0;

	// joystick
	for ( int i = 1; i <= 4; i++ )
	{
		if ( GetVirtualJoystickExists( i ) ) DeleteVirtualJoystick( i );
	}
	
	// virtual buttons
	for ( int i = 1; i <= AGK_MAX_VIRTUAL_BUTTONS; i++ )
	{
		if ( GetVirtualButtonExists( i ) ) DeleteVirtualButton( i );
	}
	
	// pointer
	m_iLastPointerDown = 0;
	m_iPointerDown = 0;

	cTouch::ClearAll();
	for ( int i = 0 ; i < 4; i++ )
	{
		if ( m_pMouse[ i ] ) m_pMouse[ i ]->Reset();
	}

	//   AGK joystick
	m_fFakeJoystickX = 0;
	m_fFakeJoystickY = 0;
	m_fJoystickDeadZone = 0.15f;

	// text input variables
	if ( m_bInputStarted ) agk::StopTextInput();
	m_bInputStartedPrev = false;
	m_bInputStarted = false;
	m_bInputCancelled = false;
	m_sCurrInput.SetStr( "" );
	m_iLastChar = 0;
	m_iCurrChar = 0;

	// Physics variables
	if ( m_phyWorld )
	{
		SetPhysicsWallBottom( 1 );
		SetPhysicsWallTop( 1 );
		SetPhysicsWallLeft( 1 );
		SetPhysicsWallRight( 1 );
	}
		
	m_phyScale = 0.2f;
	m_bDrawDebug = false;
	m_iVelIterations = 10;
	m_iPosIterations = 10;
	m_bPhysicsStepped = false;

	m_pContactIter = 0;
	m_pSpriteContactIter = 0;

	m_iMaxPolygonPoints = 8;

	// sounds
	cSoundMgr::DeleteFile(0);
    
    SocialPluginsSetup();
}

void agk::FlipOrthoMatrix()
{
	m_matOrtho.mat[1][1] = -m_matOrtho.mat[1][1];
	m_matOrtho.mat[3][1] = -m_matOrtho.mat[3][1];
	AGKShader::g_varOrtho.SetMatrix4( &m_matOrtho.mat[0][0] );
}

char* agk::CreateString( unsigned int size )
//***2
{
	if ( !size ) return 0;
	return new char[ size ];
}

void agk::DeleteString( char* str )
//***2
{
	if ( str ) delete [] str;
}

// Notifies the AGK of a touch press event
void agk::TouchPressed(uint32_t id, int x, int y)
{
	float fX = DeviceToScreenX( x );
	float fY = DeviceToScreenY( y );
	float fWorldX = ScreenToWorldX( fX );
	float fWorldY = ScreenToWorldY( fY );

	if ( m_bInputStarted ) 
	{
		if ( agk::PlatformInputPointerPressed(fX, fY) ) return;
	}

	cTouch *pPoint = cTouch::NewPoint( id );
	if ( pPoint == 0 ) return;

	// check if pressed on advert
	if ( m_pAdSprite && m_pAdSprite->GetVisible() && m_pAdSprite->GetHitTest( fWorldX, fWorldY ) )
	{
		pPoint->CaptureTouch();
		if ( m_sInneractiveURL.GetLength() > 0 )
		{
			agk::OpenBrowser( m_sInneractiveURL );
		}
	}

	// check if pressed on a virtual joystick
	for ( uint32_t i = 0; i < 4; i++ )
	{
		if ( !m_pVirtualJoystick[ i ] ) continue;
		if ( m_pVirtualJoystick[ i ]->GetHitTest( fWorldX, fWorldY ) )
		{
			pPoint->CaptureTouch();
			m_pVirtualJoystick[ i ]->CaptureTouch( pPoint );
		}
	}

	// check if pressed on a virtual button
	for ( uint32_t i = 0; i < AGK_MAX_VIRTUAL_BUTTONS; i++ )
	{
		if ( !m_pVirtualButton[ i ] ) continue;
		if ( m_pVirtualButton[ i ]->GetHitTest( fWorldX, fWorldY ) )
		{
			pPoint->CaptureTouch();
			m_pVirtualButton[ i ]->CaptureTouch( pPoint );
		}
	}

	// check if pressed on an edit box
	if ( m_cEditBoxList.GetCount() > 0 )
	{
		cEditBox *pFound = 0;
		cEditBox *pEditBox = m_cEditBoxList.GetFirst();
		while ( pEditBox )
		{
			if ( pEditBox->GetHitTest( fWorldX, fWorldY ) && pEditBox->GetVisible() && pEditBox->GetActive() ) 
			{
				pFound = pEditBox;
				break;
			}
					
			pEditBox = m_cEditBoxList.GetNext();
		}

		if ( pFound )
		{
			pPoint->CaptureTouch();
			cEditBox *pCurr = cEditBox::GetCurrentFocus();
			if ( pFound != pCurr )
			{
				// if the current edit box has a different multiline mode to the new one then the keyboard
				// needs to be hidden and re-shown on Android
				if ( pCurr && pCurr->GetMultiLine() != pFound->GetMultiLine() )
				{
					pCurr->SetFocus( false );
				}

				pFound->SetFocus( true );
				
				if ( pCurr )
				{
					pCurr->SetFocus( false );
				}
			}
			
			pFound->SetCursorLocation( fWorldX, fWorldY );
		}
		else
		{
			int editbox = agk::GetCurrentEditBox();
			if ( editbox > 0 )
			{
				agk::SetEditBoxFocus( editbox, 0 );
			}
		}
	}

	if ( !pPoint->IsCaptured() )
	{
		m_fPointerX = fX;
		m_fPointerY = fY;
	}
	pPoint->Pressed( fX, fY );
}

// Notifies the AGK of a touch release event
void agk::TouchMoved(uint32_t id, int x, int y)
{
	float fX = DeviceToScreenX( x );
	float fY = DeviceToScreenY( y );

	cTouch *pPoint = cTouch::GetEvent( id );
	if ( pPoint == 0 ) return;
	if ( pPoint->GetReleased() ) return;

	if ( !pPoint->IsCaptured() )
	{
		m_fPointerX = fX;
		m_fPointerY = fY;
	}
	pPoint->Moved( fX, fY );
}

// Notifies the AGK of a touch move event
void agk::TouchReleased(uint32_t id, int x, int y)
{
	float fX = DeviceToScreenX( x );
	float fY = DeviceToScreenY( y );

	cTouch *pPoint = cTouch::GetEvent( id );
	if ( pPoint == 0 ) return;

	if ( !pPoint->IsCaptured() )
	{
		m_fPointerX = fX;
		m_fPointerY = fY;
	}
	pPoint->Released( fX, fY );
}

void agk::MouseLeftButton(uint32_t id, int state)
{
	if ( id > 3 ) return;

	if ( !m_pMouse[ id ] ) m_pMouse[ id ] = new cMouse();
	m_pMouse[ id ]->SetButton( 0, state );

	float fWorldX = ScreenToWorldX( m_pMouse[ id ]->GetX() );
	float fWorldY = ScreenToWorldY( m_pMouse[ id ]->GetY() );

	//if ( m_bInputStarted && state == 1 ) return;
	if ( m_bInputStarted && state == 1 ) 
	{
		agk::PlatformInputPointerPressed( m_pMouse[ id ]->GetX(), m_pMouse[ id ]->GetY() );
		return;
	}

	if ( state == 1 )
	{
		// check if pressed on advert
		if ( m_pAdSprite && m_pAdSprite->GetVisible() && m_pAdSprite->GetHitTest( fWorldX, fWorldY ) )
		{
			m_pMouse[ id ]->CaptureMouse();
			if ( m_sInneractiveURL.GetLength() > 0 )
			{
				agk::OpenBrowser( m_sInneractiveURL );
			}
		}

		// check if pressed on a virtual joystick/button
		for ( uint32_t i = 0; i < 4; i++ )
		{
			if ( !m_pVirtualJoystick[ i ] ) continue;
			if ( m_pVirtualJoystick[ i ]->GetHitTest( fWorldX, fWorldY ) )
			{
				m_pMouse[ id ]->CaptureMouse();
				m_pVirtualJoystick[ i ]->CaptureMouse( m_pMouse[ id ] );
			}
		}

		for ( uint32_t i = 0; i < AGK_MAX_VIRTUAL_BUTTONS; i++ )
		{
			if ( !m_pVirtualButton[ i ] ) continue;
			if ( m_pVirtualButton[ i ]->GetHitTest( fWorldX, fWorldY ) )
			{
				m_pMouse[ id ]->CaptureMouse();
				m_pVirtualButton[ i ]->CaptureMouse( m_pMouse[ id ] );
			}
		}

		// check if pressed on an edit box
		if ( m_cEditBoxList.GetCount() > 0 )
		{
			bool bFound = false;
			cEditBox *pEditBox = m_cEditBoxList.GetFirst();
			while ( pEditBox )
			{
				if ( bFound ) pEditBox->SetFocus( false );
				else
				{				
					if ( !pEditBox->GetHitTest( fWorldX, fWorldY ) || !pEditBox->GetVisible() || !pEditBox->GetActive() ) pEditBox->SetFocus( false );
					else
					{
						m_pMouse[ id ]->CaptureMouse();
						pEditBox->SetFocus( true );
						pEditBox->SetCursorLocation( fWorldX, fWorldY );
						bFound = true;
					}
				}
				
				pEditBox = m_cEditBoxList.GetNext();
			}
		}
	}
}

void agk::MouseRightButton(uint32_t id, int state)
{
	if ( id > 3 ) return;

	if ( m_bInputStarted && state == 1 ) return;

	if ( !m_pMouse[ id ] ) m_pMouse[ id ] = new cMouse();
	m_pMouse[ id ]->SetButton( 1, state );
}

void agk::MouseMiddleButton(uint32_t id, int state)
{
	if ( id > 3 ) return;

	if ( m_bInputStarted && state == 1 ) return;

	if ( !m_pMouse[ id ] ) m_pMouse[ id ] = new cMouse();
	m_pMouse[ id ]->SetButton( 2, state );
}

void agk::MouseFourthButton(uint32_t id, int state)
{
	if ( id > 3 ) return;

	if ( m_bInputStarted && state == 1 ) return;

	if ( !m_pMouse[ id ] ) m_pMouse[ id ] = new cMouse();
	m_pMouse[ id ]->SetButton( 3, state );
}

void agk::MouseFifthButton(uint32_t id, int state)
{
	if ( id > 3 ) return;

	if ( m_bInputStarted && state == 1 ) return;

	if ( !m_pMouse[ id ] ) m_pMouse[ id ] = new cMouse();
	m_pMouse[ id ]->SetButton( 4, state );
}

void agk::MouseMove(uint32_t id, int x, int y)
{
	if ( id > 3 ) return;

	float fX = DeviceToScreenX( x );
	float fY = DeviceToScreenY( y );

	if ( m_pMouse[ id ] && !m_pMouse[ id ]->IsCaptured() )
	{
		m_fPointerX = fX;
		m_fPointerY = fY;
	}
	if ( !m_pMouse[ id ] ) m_pMouse[ id ] = new cMouse();
	m_pMouse[ id ]->SetPosition( fX, fY );
}

void agk::MouseWheel(uint32_t id, float w)
{
	if ( id > 3 ) return;

	if ( !m_pMouse[ id ] ) m_pMouse[ id ] = new cMouse();
	m_pMouse[ id ]->MoveWheel( w );
}

void agk::Accelerometer( float x, float y, float z )
{
	m_fAccelX = x;
	m_fAccelY = y;
	m_fAccelZ = z;
}

void agk::Gyro( float x, float y, float z )
{
	m_fGyroX = x;
	m_fGyroY = y;
	m_fGyroZ = z;
}

void agk::Proximity( float distance )
{
	m_fProximityDist = distance;
}

void agk::LightSensor( float light )
{
	m_fLightLevel = light;
}

void agk::Magnetic( float x, float y, float z )
{
	m_fMagneticX = x;
	m_fMagneticY = y;
	m_fMagneticZ = z;
}

void agk::RotationSensor( float x, float y, float z, float w )
{
	m_fRotVecX = x;
	m_fRotVecY = y;
	m_fRotVecZ = z;
	m_fRotVecW = w;//agk::Sqrt( 1 - (x*x + y*y + z*z) );
}

void agk::GPS( float longitude, float latitude, float altitude )
{
	m_fGPSLong = longitude;
	m_fGPSLat = latitude;
	m_fGPSAltitude = altitude;
}


void agk::KeyDown( uint32_t index )
{
	if ( index > AGK_MAX_KEYS-1 ) 
	{
		uString sErr( "KeyDown index out of range: ", 40 ); sErr += index;
		agk::Warning( sErr );
		return;
	}
    
	m_iLastKey = index;
	m_iKeyDown[ index ] = 1;
}

void agk::KeyUp( uint32_t index )
{
	if ( index > AGK_MAX_KEYS-1 ) 
	{
		uString sErr( "KeyUp index out of range: ", 40 ); sErr += index;
		agk::Warning( sErr );
		return;
	}
    
    if ( m_iPrevKeyDown[ index ] == 0 && m_iKeyDown[ index ] == 1 )
	{
		// this means the down an up events have been sent at the same time and down hasn't had enough time to be picked up
		m_iResetKey[ index ] = 1;
	}
	else
	{
		m_iKeyDown[ index ] = 0;
	}
}

void agk::CharDown( uint32_t c )
{
	if ( c > 0x10FFFF ) return;
	if ( c < 32 ) return;

	m_iLastChar = 0;
	m_iCurrChar = c;

	if ( m_sCharBuffer.GetLength() < 1024 )	m_sCharBuffer.AppendUnicode( c );
}

void agk::JoystickAxis( void* pDevice, int stick, int axis, float value )
{
	if ( value < -1 ) value = -1;
	if ( value > 1 ) value = 1;
	
	for ( int i = 0; i < AGK_NUM_JOYSTICKS; i++ )
	{
		if ( !m_pJoystick[ i ] ) continue;
		
		if ( m_pJoystick[ i ]->m_pDevice == pDevice )
		{
			switch( stick )
			{
				case 0: 
				{
					switch( axis )
					{
						case 0: m_pJoystick[ i ]->m_fX = value; break;
						case 1: m_pJoystick[ i ]->m_fY = value; break;
						case 2: m_pJoystick[ i ]->m_fZ = value; break;
					}
					break;
				}
					
				case 1: 
				{
					switch( axis )
					{
						case 0: m_pJoystick[ i ]->m_fRX = value; break;
						case 1: m_pJoystick[ i ]->m_fRY = value; break;
						case 2: m_pJoystick[ i ]->m_fRZ = value; break;
					}
					break;
				}
					
				case 2: 
				{
					switch( axis )
					{
						case 0: m_pJoystick[ i ]->m_fZ = value; break;
						case 1: m_pJoystick[ i ]->m_fRZ = value; break;
					}
					break;
				}
			}
			break;
		}
	}
}

void agk::JoystickButton( void* pDevice, int button, int state )
{
	if ( button > 32 ) return;
	if ( button < 0 ) return;
	
	for ( int i = 0; i < AGK_NUM_JOYSTICKS; i++ )
	{
		if ( !m_pJoystick[ i ] ) continue;
		
		if ( m_pJoystick[ i ]->m_pDevice == pDevice )
		{
			if ( state == 0 && m_pJoystick[ i ]->m_iPrevButtons[ button ] == 0 )
			{
				// this means the down an up events have been sent at the same time and down hasn't had enough time to be picked up
				m_pJoystick[ i ]->m_iResetButtons[ button ] = 1;
			}
			else
			{
				m_pJoystick[ i ]->m_iButtons[ button ] = state != 0 ? 1 : 0;
			}
			break;
		}
	}
}

float agk::DeviceToDisplayRatioX()
{
	float VwDw;
	//if ( AGKFrameBuffer::g_pCurrFrameBuffer ) VwDw = (agk::m_iDisplayExtraX*2 + agk::m_iDisplayWidth) / (float)AGKFrameBuffer::g_pCurrFrameBuffer->GetWidth();
	//else VwDw = agk::m_iDisplayWidth / (float)agk::Round(agk::m_fTargetViewportWidth);
	VwDw = agk::m_iDisplayWidth / (float)agk::Round(agk::m_fTargetViewportWidth);

	return VwDw;
}

float agk::DeviceToDisplayRatioY()
{
	float VhDh;
	//if ( AGKFrameBuffer::g_pCurrFrameBuffer ) VhDh = (agk::m_iDisplayExtraY*2 + agk::m_iDisplayHeight) / (float)AGKFrameBuffer::g_pCurrFrameBuffer->GetHeight();
	//else VhDh = agk::m_iDisplayHeight / (float)agk::Round(agk::m_fTargetViewportHeight);
	VhDh = agk::m_iDisplayHeight / (float)agk::Round(agk::m_fTargetViewportHeight);

	return VhDh;
}

int agk::ScreenToDeviceX( float x )
{
	float newX = x / (float) m_iDisplayWidth;
	newX = newX*m_fTargetViewportWidth + m_fTargetViewportX;
	newX = newX * m_iRealDeviceWidth / (float) m_iRenderWidth;
	return agk::Round(newX);
}

int agk::ScreenToDeviceY( float y )
{
	float newY = y / (float) m_iDisplayHeight;
	newY = newY*m_fTargetViewportHeight + m_fTargetViewportY;
	newY = newY * m_iRealDeviceHeight / (float) m_iRenderHeight;
	return agk::Round(newY);
}

float agk::DeviceToScreenX( int x )
{
	float newX = x * m_iRenderWidth / (float) m_iRealDeviceWidth;
	newX = (newX - m_fTargetViewportX) / m_fTargetViewportWidth;
	newX = newX * m_iDisplayWidth;
	return newX;
}

float agk::DeviceToScreenY( int y )
{
	float newY = y * m_iRenderHeight / (float) m_iRealDeviceHeight;
	newY = (newY - m_fTargetViewportY) / m_fTargetViewportHeight;
	newY = newY * m_iDisplayHeight;
	return newY;
}

int agk::ScreenToViewportX( float x )
{
	if ( AGKFrameBuffer::g_pCurrFrameBuffer )
	{
		x += m_iDisplayExtraX;
		x /= (m_iDisplayWidth + m_iDisplayExtraX*2.0f);
		x *= AGKFrameBuffer::g_pCurrFrameBuffer->GetWidth();
		return agk::Round(x);
	}
	else
	{
		float newX = x / (float) m_iDisplayWidth;
		newX = newX*m_fTargetViewportWidth + m_fTargetViewportX;
		return agk::Round(newX);
	}
}

int agk::ScreenToViewportY( float y )
{
	if ( AGKFrameBuffer::g_pCurrFrameBuffer )
	{
		y += m_iDisplayExtraY;
		y /= (m_iDisplayHeight + m_iDisplayExtraY*2.0f);
		y *= AGKFrameBuffer::g_pCurrFrameBuffer->GetHeight();
		return agk::Round(y);
	}
	else
	{
		if ( !g_pRenderer->IsTopLeftOrigin() ) y = m_iDisplayHeight - y;
		float newY = y / (float) m_iDisplayHeight;
		newY = newY*m_fTargetViewportHeight + m_fTargetViewportY;
		return agk::Round(newY);
	}
}

float agk::ViewportToScreenX( int x )
{
	float newX = (x - m_fTargetViewportX) / m_fTargetViewportWidth;
	newX = newX * m_iDisplayWidth;
	return newX;
}

float agk::ViewportToScreenY( int y )
{
	if ( !g_pRenderer->IsTopLeftOrigin() ) y = m_iRenderHeight - y;
	float newY = (y - m_fTargetViewportY) / m_fTargetViewportHeight;
	newY = newY * m_iDisplayHeight;
	return newY;
}

//****f* Core/Display/WorldToScreenX
// FUNCTION
//   Converts a world X coordinate into a screen X coordinate based on the current view offset and zoom.
//   When the <i>SetViewOffset</i> is 0,0 and the <i>SetViewZoom</i> is 1.0 world and screen coordinates are the same.
//   For example when the view is offset by 20 pixels to the right, an object at 0,0 in the world will appear
//   at -20 (off screen) to the left.
// INPUTS
//   x -- The world X coordinate to convert.
// SOURCE
float agk::WorldToScreenX( float x )
//****
{
	if ( m_iViewZoomMode == 1 )
	{
		// centered zooming
		x = x - agk::GetVirtualWidth()/2.0f - agk::GetViewOffsetX();
		x = x*agk::GetViewZoom() + agk::GetVirtualWidth()/2.0f;
	}
	else
	{
		// top left corner zooming
		x -= agk::GetViewOffsetX();
		x *= agk::GetViewZoom();
	}

	return x;
}

//****f* Core/Display/WorldToScreenY
// FUNCTION
//   Converts a world Y coordinate into a screen Y coordinate based on the current view offset and zoom.
//   When the <i>SetViewOffset</i> is 0,0 and the <i>SetViewZoom</i> is 1.0 world and screen coordinates are the same.
//   For example when the view is offset by 20 pixels down, an object at 0,0 in the world will appear
//   at -20 (off screen) above the screen.
// INPUTS
//   y -- The world Y coordinate to convert.
// SOURCE
float agk::WorldToScreenY( float y )
//****
{
	if ( m_iViewZoomMode == 1 )
	{
		// center zooming
		y = y - agk::GetVirtualHeight()/2.0f - agk::GetViewOffsetY();
		y = y*agk::GetViewZoom() + (agk::GetVirtualHeight()/2.0f);
	}
	else
	{
		// top left corner zooming
		y -= agk::GetViewOffsetY();
		y *= agk::GetViewZoom();
	}
	return y;
}

//****f* Core/Display/ScreenToWorldX
// FUNCTION
//   Converts a screen X coordinate into a world X coordinate based on the current view offset and zoom.
//   When the <i>SetViewOffset</i> is 0,0 and the <i>SetViewZoom</i> is 1.0 world and screen coordinates are the same.
//   For example when the view is offset by 20 pixels to the right, input at 0,0 on the screen will appear
//   20,0 in the world.
// INPUTS
//   x -- The screen X coordinate to convert.
// SOURCE
float agk::ScreenToWorldX( float x )
//****
{
	if ( m_iViewZoomMode == 1 )
	{
		// center zooming
		x -= agk::GetVirtualWidth()/2.0f;
		x /= agk::GetViewZoom();
		x += agk::GetVirtualWidth()/2.0f + agk::GetViewOffsetX();
	}
	else
	{
		// top left corner zooming
		x /= agk::GetViewZoom();
		x += agk::GetViewOffsetX();
	}

	return x;
}

//****f* Core/Display/ScreenToWorldY
// FUNCTION
//   Converts a screen Y coordinate into a world Y coordinate based on the current view offset and zoom.
//   When the <i>SetViewOffset</i> is 0,0 and the <i>SetViewZoom</i> is 1.0 world and screen coordinates are the same.
//   For example when the view is offset by 20 pixels down, input at 0,0 on the screen will appear
//   0,20 in the world.
// INPUTS
//   y -- The screen Y coordinate to convert.
// SOURCE
float agk::ScreenToWorldY( float y )
//****
{
	if ( m_iViewZoomMode == 1 )
	{
		// center zooming
		y -= agk::GetVirtualHeight()/2.0f;
		y /= agk::GetViewZoom();
		y += agk::GetVirtualHeight()/2.0f + agk::GetViewOffsetY();
	}
	else
	{
		// top left corner zooming
		y /= agk::GetViewZoom();
		y += agk::GetViewOffsetY();
	}

	return y;
}

// Notifies the AGK of a change in device volume
void agk::DeviceVolume( int vol )
{
	if ( vol > 100 ) vol = 100;
	if ( vol < 0 ) vol = 0;

	m_iDeviceVolume = vol;

	PlatformDeviceVolume();
}

// Notifies the AGK to check music events
void agk::HandleMusicEvents( void* ptr )
{
	cMusicMgr *pMusic = (cMusicMgr*) ptr;
	if ( pMusic ) pMusic->HandleEvent();
	else m_cMusicMgr.HandleEvent();
}

// *****************************
// Public functions
// *****************************

//
// Core functions
//

//****f* Core/Display/SetResolutionMode
// FUNCTION
//   Some platforms have high resolution screens such as the iPad, this function determines how those platforms
//   display their content. You have the choice of mode=1 which will use a full resolution frame buffer
//   that will look better, or mode=0 that will use a smaller resolution frame buffer (usually half sized) 
//   which is then scaled to fit the screen, and will run faster. This does not affect low resolution devices 
//   that will always use a low resolution frame buffer.<br/><br/>
//   This command is deprecated and no longer does anything
// INPUTS
//   mode -- 1 to use a high (native) resolution, 0 to use a low (scaled) resolution
// SOURCE
void agk::SetResolutionMode( int mode )
//****
{
	if ( mode > 1 ) mode = 1;
	if ( mode < 0 ) mode = 0;
	m_iResolutionMode = mode;
}

void agk::SetExtraAGKPlayerAssetsMode( int mode )
{
	// Internal function used only before the Init call
	// 0 = create NO assets in Init
	// 1 = create minimal assets
	// 2 = create extra AGK Player assets
	if ( mode > 2 ) mode = 2;
	if ( mode < 0 ) mode = 0;
	m_iExtraAGKPlayerAssetsMode = mode;
}

void agk::InitGraphicsCommon()
{
	AGKShader::CreateDefaultShaders();

	b2Vec2 gravity;
	gravity.Set(0.0f, 10.0f);
	m_phyWorld = new b2World(gravity);
	if ( !m_DestructionListener ) m_DestructionListener = new MyDestructionListener();
	m_phyWorld->SetDestructionListener( m_DestructionListener );

	// 3D physics setup
	/*m_pBroadphase = new btDbvtBroadphase(); 
	m_pCollisionConfiguration = new btDefaultCollisionConfiguration();
    m_pDispatcher = new btCollisionDispatcher(m_pCollisionConfiguration);
	m_pSolver = new btSequentialImpulseConstraintSolver;
	m_pDynamicsWorld = new btDiscreteDynamicsWorld(m_pDispatcher, m_pBroadphase, m_pSolver, m_pCollisionConfiguration);
	m_pDynamicsWorld->setGravity(btVector3(0, -10, 0));*/

	SetAntialiasMode( 0 );

	// common setup
	RecalculateDisplay();
	
	// dummy ground body
	b2BodyDef groundBodyDef;
	groundBodyDef.type = b2_staticBody;
	m_phyGroundBody = m_phyWorld->CreateBody( &groundBodyDef );

	// bottom wall
	groundBodyDef.type = b2_staticBody;
	groundBodyDef.position.Set( agk::WorldToPhyX(50.0f), agk::WorldToPhyY(101.1f) );
	groundBodyBottom = m_phyWorld->CreateBody(&groundBodyDef);

	b2PolygonShape groundBox;
	groundBox.SetAsBox( agk::WorldToPhyX(50.0f), agk::WorldToPhyY(1.0f) );
	groundBodyBottom->CreateFixture(&groundBox, 0.0f);

	// right wall
	groundBodyDef.position.Set( agk::WorldToPhyX(101.1f), agk::WorldToPhyY(50.0f) );
	groundBodyRight = m_phyWorld->CreateBody(&groundBodyDef);

	groundBox.SetAsBox( agk::WorldToPhyX(1.0f), agk::WorldToPhyY(50.0f) );
	groundBodyRight->CreateFixture(&groundBox, 0.0f);

	// left wall
	groundBodyDef.position.Set( agk::WorldToPhyX(-1.1f), agk::WorldToPhyY(50.0f) );
	groundBodyLeft = m_phyWorld->CreateBody(&groundBodyDef);

	groundBox.SetAsBox( agk::WorldToPhyX(1.0f), agk::WorldToPhyY(50.0f) );
	groundBodyLeft->CreateFixture(&groundBox, 0.0f);

	// top wall
	groundBodyDef.position.Set( agk::WorldToPhyX(50.0f), agk::WorldToPhyY(-1.1f) );
	groundBodyTop = m_phyWorld->CreateBody(&groundBodyDef);

	groundBox.SetAsBox( agk::WorldToPhyX(50.0f), agk::WorldToPhyY(1.0f) );
	groundBodyTop->CreateFixture(&groundBox, 0.0f);

	m_phyWorld->SetDebugDraw( &g_DebugDraw );

	// add a 3D physics ground
	//btCollisionShape* shape = new btStaticPlaneShape(btVector3(0, 1, 0), 1);
	//btDefaultMotionState* motionState = new btDefaultMotionState(btTransform(btQuaternion(0,0,0,1), btVector3(0,-1,0)));
	//btRigidBody::btRigidBodyConstructionInfo rigidBodyCI( 0,                  // mass
	//													  motionState,        // initial position
	//													  shape,              // collision shape of body
	//													  btVector3(0,0,0)    // local inertia
	//													 );

	//btRigidBody *rigidBody = new btRigidBody(rigidBodyCI);
	//m_pDynamicsWorld->addRigidBody(rigidBody);

	// create main camera
	cCamera *mainCamera = new cCamera();
	m_cCameraList.AddItem( mainCamera, 1 );
	mainCamera->SetPosition( 0, 10, -20 );
	mainCamera->LookAt( 0,0,0, 0 );
	m_pCurrentCamera = mainCamera;
	AGKShader::g_varShadowParams.SetVector4( mainCamera->GetFarRange(), m_fShadowBias, 1.0f/m_iShadowMapWidth, 1.0f/m_iShadowMapHeight );

	// DrawLine rendering
	m_pLinesShader = AGKShader::g_pShaderColor;
	m_linesRenderState.SetDepthEnable( 0 );
	m_linesRenderState.SetBlendEnable( 1 );
	m_linesRenderState.SetCullMode( AGK_CULL_NONE );
	m_linesRenderState.SetBlendFunc( AGK_BLEND_SRC_ALPHA, AGK_BLEND_ONE_MINUS_SRC_ALPHA );
	m_linesVertexLayout.m_iPrimitiveType = AGK_PRIMITIVE_LINES;
	m_linesVertexLayout.m_iVertexSize = (3 + 4) * sizeof(float); // position + color

	int numShaderAttribs = m_pLinesShader->GetNumAttributes();
	m_linesVertexLayout.SetNumOffsets( numShaderAttribs );
	for( int i = 0; i < numShaderAttribs; i++ )
	{
		m_linesVertexLayout.m_pOffsets[ i ] = 0;
		AGKShaderAttrib *pShaderAttrib = m_pLinesShader->GetAttribute( i );
		if ( pShaderAttrib->m_iKnownName == AGK_SHADER_ATTRIB_NAME_COLOR) m_linesVertexLayout.m_pOffsets[ i ] = 3 * sizeof(float);
	}
	
	m_iLineArraySize = 128;
	m_pLineVertexData = new float[ m_iLineArraySize * (3 + 4) ]; // 3 floats for position, 4 floats for color
	g_pRenderer->CreateVertices( m_linesVertexLayout.m_iVertexSize, &m_pInternalLinesVertices );

	// physics debug rendering
	g_DebugDraw.SetShader( AGKShader::g_pShaderColor );

	// text object for the legacy PRINT command
	m_pPrintDefaultFont = new cImage();
	m_pPrintDefaultFont->Load( "/ascii.png" );
	m_pPrintDefaultFontExt = new cImage();
	m_pPrintDefaultFontExt->Load( "/asciiExt.png" );
	m_pPrintText = new cText( 100 );
	m_pPrintText->SetDepth(0);
	m_pPrintText->SetFontImage( m_pPrintDefaultFont );
	m_pPrintText->SetExtendedFontImage( m_pPrintDefaultFontExt );

	// freshly initialised app (move ALL reset states from here into this function!)
	ResetAllStates();

	m_cDirectionalLight.Reset();
	m_AmbientColor.Set( 0.3f, 0.3f, 0.3f );

	AGKShader::g_varDirLightDir.SetVector3( m_cDirectionalLight.m_direction.x, m_cDirectionalLight.m_direction.y, m_cDirectionalLight.m_direction.z );
	AGKShader::g_varDirLightColor.SetVector3( m_cDirectionalLight.m_color.x, m_cDirectionalLight.m_color.y, m_cDirectionalLight.m_color.z );
	AGKShader::g_varLightAmbient.SetVector3( m_AmbientColor.x, m_AmbientColor.y, m_AmbientColor.z );

	agk::SetDefaultWrapU( 0 );
	agk::SetDefaultWrapV( 0 );

	PlatformInitGraphicsCommon();
	
	agk::SetVSync( 1 );
}

void agk::InitNonGraphicsCommon()
{
	PlatformInitNonGraphicsCommon();

	uint32_t seed = Random();
	seed <<= 16;
	seed |= Random();
	SetRandomSeed2( seed ); // seed the complex RNG with the output of the simple one

	cSoundMgr::Init();

	PlatformUpdateTime();
	m_fTimeFrameStart = m_fTimeCurr;
	
	agk::SetErrorMode( 1 );
}

void agk::InitExternal( void *ptr, AGKRenderer renderer, int width, int height, void(*swap)(void*), void* swapParam )
{
	if ( !swap ) agk::Warning( "AGK was initialised with InitExternal but no swap function was given" );
	if ( renderer != AGK_RENDERER_OPENGL2 ) 
	{
		agk::Error( "InitExternal is currently only supported by the OpenGL2 renderer" );
		return;
	}

	// default to 100x100 grid, which is later stretched by the display aspect ratio
	m_iDisplayWidth = 100;
	m_iDisplayHeight = 100;

	agk::PlatformResetTime();

	InitFilePaths(); // must be done before PlatformInitExternal

	InitNonGraphicsCommon();

	g_bIsExternal = true;
	SwapExternal = swap;
	g_pSwapParam = swapParam;
	PlatformInitExternal( ptr, width, height, renderer );

	InitGraphicsCommon();
}

void agk::InitGraphics( void *ptr, AGKRendererMode rendererMode, uint32_t flags )
{
	if ( rendererMode == AGK_RENDERER_MODE_NONE )
	{
		InitConsole();
		return;
	}

	// default to 100x100 grid, which is later stretched by the display aspect ratio
	m_iDisplayWidth = 100;
	m_iDisplayHeight = 100;

	agk::PlatformResetTime();

	PlatformSetDevicePtr( ptr );

	InitFilePaths(); // must be done before PlatformInitGraphics

	InitNonGraphicsCommon();

	g_bIsExternal = false;
	PlatformInitGraphics( ptr, rendererMode, flags );

	InitGraphicsCommon();
}

void agk::InitConsole()
{
	agk::PlatformResetTime();

	InitFilePaths(); // must be done before PlatformInitConsole

	PlatformInitConsole();

	InitNonGraphicsCommon();
}

/*
// This has numerous problems with random crashes, assume changing renderer at runtime is not possible
void agk::ChangeRenderer( uint32_t flags, AGKRendererMode rendererMode )
{
	if ( !PlatformNeedsNewRenderer( rendererMode, flags ) ) return;

	if ( m_pPrintDefaultFont ) delete m_pPrintDefaultFont;
	m_pPrintDefaultFont = 0;
	if ( m_pPrintDefaultFontExt ) delete m_pPrintDefaultFontExt;
	m_pPrintDefaultFontExt = 0;
	if ( m_pPrintText ) delete m_pPrintText;
	m_pPrintText = 0;

	//MasterReset();
	AGKFont::DeleteDefaultFont();
	cEditBox::DeleteDefaultFont();
	AGKShader::DeleteDefaultShaders();

	// must delete these incase Android has modified them for video to texture which might no longer be required
	for( uint32_t i = 0; i < m_pVulkanDeviceExtensions.NumItems(); i++ ) delete m_pVulkanDeviceExtensions.GetItem(i);
	m_pVulkanDeviceExtensions.Clear();
	for( uint32_t i = 0; i < m_pVulkanInstanceExtensions.NumItems(); i++ ) delete m_pVulkanInstanceExtensions.GetItem(i);
	m_pVulkanInstanceExtensions.Clear();

	PlatformDeleteRenderer();
	PlatformInitGraphics( 0, rendererMode, flags );

	AGKShader::CreateDefaultShaders();

	m_pLinesShader = AGKShader::g_pShaderColor;

	int numShaderAttribs = m_pLinesShader->GetNumAttributes();
	m_linesVertexLayout.SetNumOffsets( numShaderAttribs );
	for( int i = 0; i < numShaderAttribs; i++ )
	{
		m_linesVertexLayout.m_pOffsets[ i ] = 0;
		AGKShaderAttrib *pShaderAttrib = m_pLinesShader->GetAttribute( i );
		if ( pShaderAttrib->m_iKnownName == AGK_SHADER_ATTRIB_NAME_COLOR) m_linesVertexLayout.m_pOffsets[ i ] = 3 * sizeof(float);
	}
	
	m_iLineArraySize = 128;
	m_pLineVertexData = new float[ m_iLineArraySize * (3 + 4) ]; // 3 floats for position, 4 floats for color
	g_pRenderer->CreateVertices( m_linesVertexLayout.m_iVertexSize, &m_pInternalLinesVertices );

	// physics debug rendering
	g_DebugDraw.SetShader( AGKShader::g_pShaderColor );

	// text object for the legacy PRINT command
	m_pPrintDefaultFont = new cImage();
	m_pPrintDefaultFont->Load( "/ascii.png" );
	m_pPrintDefaultFontExt = new cImage();
	m_pPrintDefaultFontExt->Load( "/asciiExt.png" );
	m_pPrintText = new cText( 100 );
	m_pPrintText->SetDepth(0);
	m_pPrintText->SetFontImage( m_pPrintDefaultFont );
	m_pPrintText->SetExtendedFontImage( m_pPrintDefaultFontExt );

	PlatformInitGraphicsCommon();
}
*/

void agk::InitFilePaths()
{
	PlatformInitFilePaths();
	cFileEntry::InitFileList();
}

void agk::ResetRenderState()
{
	if ( g_pRenderer ) g_pRenderer->ResetInternalState();
}

void agk::ResetAllStates ( void )
{
	// called to bring app to a state resembling that of a freshly initialised app
	if ( m_pPrintText )
	{
		m_pPrintText->SetAlignment( 0 );
		m_pPrintText->SetColor( 255,255,255 );
		m_pPrintText->SetSize( agk::GetVirtualWidth() / 30.0f );
		m_pPrintText->SetSpacing( 0 );
		m_pPrintText->SetPosition( 0,0 );
		m_pPrintText->FixToScreen( 1 );
		m_iPrintSizeChanged = 0;
		
		m_pPrintText->SetFontImage( m_pPrintDefaultFont );
		m_pPrintText->SetExtendedFontImage( m_pPrintDefaultFontExt );
	}

	// input setup
	for ( int i = 0; i < AGK_MAX_KEYS; i++ ) m_iPrevKeyDown[ i ] = 0;
	for ( int i = 0; i < AGK_MAX_KEYS; i++ ) m_iKeyDown[ i ] = 0;
	for ( int i = 0; i < AGK_MAX_KEYS; i++ ) m_iResetKey[ i ] = 0;
}

//****f* Core/Display/SetSyncRate
// FUNCTION
//   Sets the desired rate that frames will be drawn to the screen, in frames per second (fps).
//   Additionally there are two modes to choose from that can limit the CPU, the first (mode=0)
//   sleeps the application between frames to save CPU and battery life where possible. The second 
//   (mode=1) uses a continuous loop to check the time before the next frame, which can be more 
//   accurate but hogs the CPU.<br/><br/>
//   The preferred method of limiting frame rate is SetVSync() which set the refresh rate to the 
//   monitor refresh rate, and will prevent any screen tearing or stuttering. Using SetSyncRate 
//   will automatically turn VSync off since the two commands would fight each other for control 
//   of the frame rate.<br/><br/>
//   Use an fps of 0 to remove all limits and draw frames as quickly as possible. This may be up to 
//   thousands of frames per second on the most powerful graphics cards.<br/><br/>
//   Note that on HTML5 the use of SetSyncRate is highly discouraged as it uses the Javascript SetTimeout
//   function for timing, which can cause inaccurate frame rates and stuttering. On HTML5 the preferred 
//   method of frame rate control is <i>SetVSync</i>.
// INPUTS
//   fps -- The desired frame rate in frames per second, 0 for unlimited.
//   mode -- 1 to use a possibly more accurate but CPU intensive method, 0 (default) to save CPU and battery.
// SOURCE
void agk::SetSyncRate( float fps, int mode )
//****
{
	SetVSync(0);

	if ( mode ) m_iSyncMode = 1;
	else m_iSyncMode = 0;
	
	if ( fps <= 0.5f ) m_fSyncTime = 0;
	else m_fSyncTime = 1.0f / fps;

#ifdef AGK_HTML5
	if ( mode == 0 )
	{
		emscripten_set_main_loop_timing( EM_TIMING_SETTIMEOUT, agk::Round(m_fSyncTime*1000) );
	}
#endif
}

void agk::CreateDefaultImage( const char* filename, uint32_t size, uint32_t* pData )
{
	//if ( cFile::Exists( filename ) ) cFile::DeleteFile( filename );
	if ( !cFile::Exists( filename ) ) 
	{
		cFile oFile;
		oFile.OpenToWrite( filename );
		for ( uint32_t i = 0; i < size; i++ )
		{
			oFile.WriteInteger( pData[ i ] );
		}
		oFile.Close();
	}
}

void agk::CleanUp()
{
	// close any open files
	cFile *pFile = m_cFileList.GetFirst();
	while ( pFile )
	{
		delete pFile;		
		pFile = m_cFileList.GetNext();
	}
	m_cFileList.ClearAll();

	cFolder *pFolder = m_cFolderList.GetFirst();
	while ( pFolder )
	{
		delete pFolder;		
		pFolder = m_cFolderList.GetNext();
	}
	m_cFolderList.ClearAll();

	// close network connections
	cNetwork *pNetwork = m_cNetworkList.GetFirst();
	while ( pNetwork )
	{
		delete pNetwork;		
		pNetwork = m_cNetworkList.GetNext();
	}
	m_cNetworkList.ClearAll();

	BroadcastListener *pListener = m_cBroadcastListenerList.GetFirst();
	while ( pListener )
	{
		delete pListener;		
		pListener = m_cBroadcastListenerList.GetNext();
	}
	m_cBroadcastListenerList.ClearAll();

	AGKSocket *pSocket = m_cSocketList.GetFirst();
	while ( pSocket )
	{
		delete pSocket;		
		pSocket = m_cSocketList.GetNext();
	}
	m_cSocketList.ClearAll();

	cNetworkListener *pSocketListener = m_cSocketListenerList.GetFirst();
	while ( pSocketListener )
	{
		delete pSocketListener;		
		pSocketListener = m_cSocketListenerList.GetNext();
	}
	m_cSocketListenerList.ClearAll();

	UDPManager *pUDPListener = m_cUDPListenerList.GetFirst();
	while ( pUDPListener )
	{
		delete pUDPListener;		
		pUDPListener = m_cUDPListenerList.GetNext();
	}
	m_cUDPListenerList.ClearAll();

	m_cSpriteMgrFront.ClearAll();

	PlatformCleanUp();

	if ( g_pRenderer ) 
	{
		g_pRenderer->CleanUp();
		delete g_pRenderer;
	}
	g_pRenderer = 0;

	for( uint32_t i = 0; i < m_pVulkanDeviceExtensions.NumItems(); i++ ) delete m_pVulkanDeviceExtensions.GetItem(i);
	m_pVulkanDeviceExtensions.Clear();

	for( uint32_t i = 0; i < m_pVulkanInstanceExtensions.NumItems(); i++ ) delete m_pVulkanInstanceExtensions.GetItem(i);
	m_pVulkanInstanceExtensions.Clear();
}

void agk::PNToken( const char* token )
{
	if ( !token ) m_sPNToken.SetStr( "" );
	else m_sPNToken.SetStr( token );
}

void agk::OrientationChanged( int mode )
{
	if ( mode > 4 ) mode = 1;
	if ( mode < 1 ) mode = 1;

	if ( CanOrientationChange(mode) ) m_iOrientation = mode;
}

int agk::CanOrientationChange( int mode )
{
	//if ( !GetDeviceCanRotate() ) return 0;

	if ( mode > 4 ) mode = 1;
	if ( mode < 1 ) mode = 1;

	switch( mode )
	{
		case 1: if ( !(m_bAGKFlags & AGK_FLAG_PORTRAIT) ) return 0; break;
		case 2: if ( !(m_bAGKFlags & AGK_FLAG_PORTRAIT2) ) return 0; break;
		case 3: if ( !(m_bAGKFlags & AGK_FLAG_LANDSCAPE) ) return 0; break;
		case 4: if ( !(m_bAGKFlags & AGK_FLAG_LANDSCAPE2) ) return 0; break;
	}

	return 1;
}

void agk::AppPausing()
{
	wasMusicPlaying = 0;
	if ( agk::GetMusicPlaying() )
	{
		wasMusicPlaying = 1;
		agk::PauseMusic();
	}

	wasVideoPlaying = 0;
	if ( agk::GetVideoPlaying() )
	{
		wasVideoPlaying = 1;
		agk::PauseVideo();
	}

    agk::StopSound(0);
    cSoundMgr::AppPaused();
	AGKMusicOGG::AppPaused();
	StopSpeaking();

	agk::ARPause();

	if ( g_pRenderer ) g_pRenderer->LosingFocus();
}

void agk::AppResuming()
{
	if ( wasMusicPlaying ) agk::ResumeMusic();
	//if ( wasVideoPlaying ) agk::PlayVideo();
	if ( wasVideoPlaying ) agk::VideoResumed();
	AGKMusicOGG::AppResumed();
    cSoundMgr::AppResumed();
	DeviceCameraResumed();

	wasMusicPlaying = 0;
	wasVideoPlaying = 0;

	agk::ARResume();
}

void agk::LosingContext()
{
	//cImage::SaveAllImages();
	if ( !g_pRenderer ) return;
	g_pRenderer->LosingSurface();
}

void agk::VideoResumed()
{
	if( m_iVideoPlayMode == 1 ) PlayVideo();
	else if( m_iVideoPlayMode == 2 )
	{
		if ( m_pVideoTexture ) PlayVideoToImage( m_pVideoTexture->m_iID );
	}
}

void agk::Paused()
{
	m_iPaused = 1;
}

void agk::Resumed( int mode )
{
	// don't count the initial start as a resume
	static int first = 1;
	if ( first == 1 )
	{
		first = 0;
		char* name = agk::GetDeviceBaseName();
		// iOS doesn't send a resume on the initial start so don't ignore it
		if ( strcmp(name,"ios") != 0 ) 
		{
			delete [] name;
			return;
		}
		delete [] name;
	};

	m_iResumed = 1;
	m_iResumed2 = 1;
	agk::PlatformResumed();
}

void agk::ResumedOpenGL( int mode )
{
	// don't count the initial start as a resume
	static int first = 1;
	if ( first == 1 )
	{
		first = 0;
		char* name = agk::GetDeviceBaseName();
		// iOS doesn't send a resume on the initial start so don't ignore it
		if ( strcmp(name,"ios") != 0 ) 
		{
			delete [] name;
			return;
		}
		delete [] name;
	};

	agk::PlatformResumedOpenGL();
}

// Tier 2 only
void agk::AddVulkanDeviceExtensions( const char* szExtensions )
//***2
{
	uString sExtensions = szExtensions;
	int tokens = sExtensions.CountTokens2( ' ' );
	for( int i = 0; i < tokens; i++ )
	{
		uString* token = new uString();
		sExtensions.GetToken2( ' ', i, *token );
		if ( token->CompareTo( "VK_NV_dedicated_allocation" ) == 0 ) { delete token; continue; }
		if ( token->CompareTo( "VK_NV_external_memory" ) == 0 ) token->SetStr( "VK_KHR_external_memory" );
		if ( token->CompareTo( "VK_NV_external_memory_win32" ) == 0 ) token->SetStr( "VK_KHR_external_memory_win32" );
		int found = 0;
		for ( uint32_t j = 0; j < m_pVulkanDeviceExtensions.NumItems(); j++ )
		{
			if ( m_pVulkanDeviceExtensions[j]->CompareTo( *token ) == 0 ) 
			{
				found = 1;
				break;
			}
		}
		if ( !found ) m_pVulkanDeviceExtensions.AddItem( token );
		else delete token;
	}
}

// Tier 2 only
void agk::AddVulkanInstanceExtensions( const char* szExtensions )
//***2
{
	uString sExtensions = szExtensions;
	int tokens = sExtensions.CountTokens2( ' ' );
	for( int i = 0; i < tokens; i++ )
	{
		uString* token = new uString();
		sExtensions.GetToken2( ' ', i, *token );
		int found = 0;
		for ( uint32_t j = 0; j < m_pVulkanInstanceExtensions.NumItems(); j++ )
		{
			if ( m_pVulkanInstanceExtensions[j]->CompareTo( *token ) == 0 ) 
			{
				found = 1;
				break;
			}
		}
		if ( !found ) m_pVulkanInstanceExtensions.AddItem( token );
		else delete token;
	}
}

Renderer* agk::GetRenderer()
{
	return g_pRenderer;
}

//****f* Core/Display/GetRendererName
// FUNCTION
//   Returns the name of the current renderer, e.g. "OpenGL", "OpenGLES", or "Vulkan"
// SOURCE
char* agk::GetRendererName()
//****
{
	if ( g_pRenderer ) 
	{
		const char *name = g_pRenderer->GetName();
		char *str = new char[ strlen(name)+1 ];
		strcpy( str, name );
		return str;
	}
	else
	{
		char *str = new char[ 5 ];
		strcpy( str, "None" );
		return str;
	}
}

//****f* Core/Display/SetOrientationAllowed
// FUNCTION
//   Sets which orientations the AGK will allow the app to rotate to. There are two portrait and
//   two landscape orientations, one for the right way up and the other for upside down.
//   On platforms that can't rotate, like Windows or Mac, this command has no effect and the app
//   will always be drawn right way up.<br><br>
//   A value of 1 for each orientation will determine if the app will rotate when the device is held
//   in that orientation. A value of 0 will keep the app at its last valid orientation.<br><br>
//   Note that if the device is currently in a disallowed orientation then AGK will attempt to
//   rotate the device into an allowed orientation, however this is not guaranteed to happen
//   immediately. So, for example, if you need the device to be in landscape and you call this
//   command with only landscape allowed, you should then wait for <i>GetDeviceWidth</i> to return 
//   greater than <i>GetDeviceHeight</i> which will signal that the device is now in landscape.<br>
// INPUTS
//   portrait -- The default device orientation.
//   portrait2 -- The upside down portrait orientation.
//   landscape -- The landscape orientation when the device is rotated left from its default position.
//   landscape2 -- The landscape orientation when the device is rotated right from its default position.
// SOURCE
void agk::SetOrientationAllowed( int portrait, int portrait2, int landscape, int landscape2 )
//****
{
	if ( portrait != 0 ) m_bAGKFlags |= AGK_FLAG_PORTRAIT;
	else m_bAGKFlags &= ~AGK_FLAG_PORTRAIT;

	if ( portrait2 != 0 ) m_bAGKFlags |= AGK_FLAG_PORTRAIT2;
	else m_bAGKFlags &= ~AGK_FLAG_PORTRAIT2;
	
	if ( landscape != 0 ) m_bAGKFlags |= AGK_FLAG_LANDSCAPE;
	else m_bAGKFlags &= ~AGK_FLAG_LANDSCAPE;
	
	if ( landscape2 != 0 ) m_bAGKFlags |= AGK_FLAG_LANDSCAPE2;
	else m_bAGKFlags &= ~AGK_FLAG_LANDSCAPE2;

	m_bOrientationSet = true;

	bool bAllowed = true;
	switch( m_iOrientation )
	{
		case 1: if ( !(m_bAGKFlags & AGK_FLAG_PORTRAIT) ) bAllowed=false; break;
		case 2: if ( !(m_bAGKFlags & AGK_FLAG_PORTRAIT2) ) bAllowed=false; break;
		case 3: if ( !(m_bAGKFlags & AGK_FLAG_LANDSCAPE) ) bAllowed=false; break;
		case 4: if ( !(m_bAGKFlags & AGK_FLAG_LANDSCAPE2) ) bAllowed=false; break;
	}

	agk::PlatformSetOrientationAllowed( portrait, portrait2, landscape, landscape2 );
	
	if ( !bAllowed )
	{
		if ( portrait != 0 ) agk::OrientationChanged( 1 );
		else if ( portrait2 != 0 ) agk::OrientationChanged( 2 );
		else if ( landscape != 0 ) agk::OrientationChanged( 3 );
		else if ( landscape2 != 0 ) agk::OrientationChanged( 4 );
	}
}

//****f* Core/Display/SetTransitionMode
// FUNCTION
//   This command is deprecated, orientation transitions are now controlled by the device.
// SOURCE
void agk::SetTransitionMode( int mode )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "SetTransitionMode() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* File/Access/SetRawWritePath
// FUNCTION
//   This command is now deprecated. The preferred method of accessing files outside of the usual write
//   folder is to use the <i>OpenRawFolder</i> commands and "raw:" file paths.
// SOURCE
void agk::SetRawWritePath( const char* str )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "SetRawWritePath() has been removed from AppGameKit, please use \"raw:\" file paths instead" );
		warned = 1;
	}
}

char* agk::GetDeviceName()
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "GetDeviceName() has been removed from AppGameKit, please use GetDeviceBaseName() and GetDeviceType() instead" );
		warned = 1;
	}
	char *str = new char[1]; *str = 0;
	return str;
}

// Common function to calculate the viewport and projection matrix values
// Uses device and display width/height values, and the m_fDisplayAspect value set elsewhere in the program 
void agk::RecalculateDisplay()
{
	if ( !g_pRenderer ) return;

	int bufferWidth = m_iRenderWidth;
	int bufferHeight = m_iRenderHeight;
	if ( AGKFrameBuffer::g_pCurrFrameBuffer )
	{
		bufferWidth = AGKFrameBuffer::g_pCurrFrameBuffer->GetWidth();
		bufferHeight = AGKFrameBuffer::g_pCurrFrameBuffer->GetHeight();
	}

	// work out if we need any borders to prevent image stretching
	float y = 0, height = (float) bufferHeight, x = 0, width = (float) bufferWidth;
	float deviceAspect = width / height;
	float aspect = m_fDisplayAspect;
    
    if ( deviceAspect < aspect )
	{
		// top/bottom border needed
		height = bufferWidth / aspect;
		
		// make height a whole number with the same evenness as the render height
		if ( agk::Floor( height ) % 2 == m_iRenderHeight % 2 ) height = (float) agk::Floor( height );
		else height = (float) agk::Ceil( height );
		
		y = (bufferHeight-height) / 2.0f;
	}
	else if ( deviceAspect > aspect )
	{
		// left/right border needed
		width = bufferHeight * aspect;

		// make width a whole number with the same evenness as the render width
		if ( agk::Floor( width ) % 2 == bufferWidth % 2 ) width = (float) agk::Floor( width );
		else width = (float) agk::Ceil( width );

		x = (bufferWidth-width) / 2.0f;
	}

	m_fStretchValue = agk::GetDisplayAspect() / (agk::GetVirtualWidth()/(float)agk::GetVirtualHeight());

	// x, y, width, height are in device coordinates, for the purposes of m_iDisplayExtraX and m_iDisplayExtraY 
	// we should calculate them with whole pixels, so round these first.
	float diffX = m_iDisplayWidth / (float) agk::Round(width);
	m_iDisplayExtraX = agk::Round(x) * diffX;

	float diffY = m_iDisplayHeight / (float) agk::Round(height);
	m_iDisplayExtraY = agk::Round(y) * diffY;

	// these store the floating point versions for more accurate calculations in ScreenToViewport, 
	// but be sure to round m_fTargetViewportWidth and m_fTargetViewportHeight when working with device pixels
	m_fTargetViewportX = (float) agk::Round(x);
	m_fTargetViewportY = (float) agk::Round(y);
	m_fTargetViewportWidth = (float) agk::Round(width);
	m_fTargetViewportHeight = (float) agk::Round(height);
	
	if ( !m_bScissorUser )
	{
		m_iScissorX = agk::Round(m_fTargetViewportX);
		m_iScissorY = agk::Round(m_fTargetViewportY);
		m_iScissorWidth = agk::Round(m_fTargetViewportWidth+m_fTargetViewportX) - m_iScissorX;
		m_iScissorHeight = agk::Round(m_fTargetViewportHeight+m_fTargetViewportY) - m_iScissorY;

		g_pRenderer->SetGlobalScissor( m_iScissorX, m_iScissorY, m_iScissorWidth, m_iScissorHeight );
	}
	else
	{
		agk::SetScissor( m_fScissorUserX, m_fScissorUserY, m_fScissorUserX2, m_fScissorUserY2 );
	}

	g_pRenderer->SetViewport( 0, 0, bufferWidth, bufferHeight );

	// adjust ortho matrix so it matches the viewport exactly
	float rel = m_iDisplayHeight / m_fTargetViewportHeight;
	float fTotalDisplayHeight = bufferHeight * rel;
	fTotalDisplayHeight -= (m_iDisplayHeight+m_iDisplayExtraY);

	rel = m_iDisplayWidth / m_fTargetViewportWidth;
	float fTotalDisplayWidth = bufferWidth * rel;
	fTotalDisplayWidth -= m_iDisplayExtraX;

	m_matOrtho.MakeOrtho( -m_iDisplayExtraX, fTotalDisplayWidth, m_iDisplayHeight+m_iDisplayExtraY, -fTotalDisplayHeight, 0.0f, 1.0f );
	if ( AGKFrameBuffer::g_pCurrFrameBuffer && g_pRenderer->IsFBOFlipped() )
	{
		// flip ortho matrix
		m_matOrtho.mat[1][1] = -m_matOrtho.mat[1][1];
		m_matOrtho.mat[3][1] = -m_matOrtho.mat[3][1];
	}
	AGKShader::g_varOrtho.SetMatrix4( &m_matOrtho.mat[0][0] );
}

//****f* Core/Display/SetDisplayAspect
// FUNCTION
//   This command is used in conjunction with the default percentage based positioning system in AGK. If using this
//   approach you will need to specify a display aspect, so that AGK knows how to correctly display entities on screen.
//   If your artwork was originally designed for a resolution of 1024 x 768, this would result in an aspect ratio
//   of 4:3, which is also the same as saying 1024 / 768 = 1.33, therefore you would call <i>SetDisplayAspect</i> and
//   pass in a 1.33 as your aspect ratio. On platforms where the resolution was different AGK will take care of
//   things internally so that your application still maintains this aspect ratio and looks correct.<br><br>
//   The alternative approach is to call <i>SetVirtualResolution</i> to control the coordinate system and place sprites
//   using screen coordinates instead of using percentages, in which case you should not call this command.<br><br>
//   If sprites already exist when this is called they will become distorted. If the aspect ratio given does not fit
//   exactly on the current device, black borders will be drawn around the rendering area to center it on screen.<br>
//   Use an aspect ratio of 0 to use the current coordinate system as the aspect ratio.<br><br>
//   Use an aspect ratio of -1 to use the device aspect ratio (fills the whole screen without black borders, but 
//   will cause stretching and look different on every device)
//   An alternative method of filling the screen which avoids this problem  is to use <i>SetScissor</i> with the 
//   values 0,0,0,0.
// INPUTS
//   aspect -- the aspect ratio to use from now on, in the form of width/height.
// SOURCE
void agk::SetDisplayAspect( float aspect )
//****
{
	if ( !g_pRenderer ) return;

	m_bUsingDisplayAspect = false;
	m_bUsingDeviceAspect = false;

	// use resolution aspect ratio
	if ( aspect == 0 )
	{
		m_bUsingDisplayAspect = true;
		aspect = m_iDisplayWidth / (float) m_iDisplayHeight;
	}
	else m_bUsingDisplayAspect = false;

	// stretched to fill the whole screen instead
	if ( aspect < 0 )
	{
		m_bUsingDeviceAspect = true;
		aspect = m_iRenderWidth / (float) m_iRenderHeight;
	}

	m_fDisplayAspect = aspect;

	RecalculateDisplay();

	if ( m_pPrintText ) m_pPrintText->ChangedAspect();

	UpdatePhysicsWalls();
}

//****f* Core/Display/SetRenderToImage
// FUNCTION
//   Redirects all future draw calls to an image instead of to the screen. The specified image could then 
//   be applied to an object or sprite. Be careful not to apply the image to an object or sprite at the same time as 
//   it is being drawn to as this could result in an error.
//   You can also choose to render the depth information to an image that you can use later, or render 
//   without a depth buffer if your scene does not need one. You can also use a depth image ID of -1 to
//   render a depth buffer without capturing it in an image. 
//   Note that some devices (particularly Android) do not support rendering depth to an image, in these cases
//   the only valid values for the depth ID are 0 and -1. You can check if the current device supports 
//   depth textures by using <i>IsSupportedDepthTexture</i>.
//   Render images can be any size, and do not need to be a power of 2 in width or height.<br/><br/>
//
//   For a more detailed explanation, when you render to an image it will draw to the image exactly what it would 
//   have drawn to the screen. For example if your virtual resolution is 1024x768 and requires borders then it will 
//   draw borders onto the render image. This means if you were to look at the resulting render image in its native 
//   form, e.g. 1024x1024, it will look like you've taken a 1024x768 window and stretched it vertically into a square. 
//   The result is that if you take this square image and stretch it back into 1024x768, by texturing a sprite or 
//   quad that happens to be 1024x768 in size, then it will look normal again. This means you can render a 1024x768 
//   window to an image of any size, say 64x512, and stretch it to 1024x768 and it should look correct 
//   aspect ratio wise, it will of course be missing some detail. You can then get more advanced by changing the 
//   virtual resolution after setting a render image and changing it back when rendering to the screen, or using 
//   <i>SetCameraAspect</i> to change the 3D aspect ratio if the render image is going to be used for something other 
//   than a 1:1 representation of the screen.<br/><br/>
//   
//   After calling SetRenderToImage the image contents is undefined and can be cleared with <i>ClearScreen</i>, however 
//   if you are going to draw to every pixel on the screen, such as with a full screen shader then this is not necessary. 
//   It is not possible to call SetRenderToImage multiple times with the same image to add more drawn items to the image,
//   the image will always become undefined after the call to SetRenderToImage.
//   If you wish to maintain the contents of a previous render then you should render to a new image and apply the 
//   previously rendered image to a quad to draw it as a background. You can then swap the images in the next frame to 
//   continuously render the previous frame as a background to the current frame.
// INPUTS
//   colorImage -- The ID of the image to use as the color buffer, 0 to not render color
//   depthImage -- The ID of the image to use as the depth buffer, 0 to not render depth, -1 to use a depth buffer without an image
// SOURCE
void agk::SetRenderToImage( int colorImage, int depthImage )
//****
{
	if ( !g_pRenderer ) 
	{
		Error( "Cannot render to image without a renderer" );
		return;
	}

	cImage *pImageColor = 0;
	if ( colorImage ) 
	{
		pImageColor = m_cImageList.GetItem( colorImage );
		if ( !pImageColor )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to render to color image ", 200 );
			errStr.AppendInt( colorImage );
			errStr.Append( " - image does not exist " );
			agk::Error( errStr );
#endif 
			return;
		}

		// the image data is going to change so clear any cached data we have about it
		pImageColor->SetCompressedPixelData( 0,0 );
	}

	cImage *pImageDepth = 0;
	if ( depthImage > 0 )
	{
		pImageDepth = m_cImageList.GetItem( depthImage );
		if ( !pImageDepth )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to render to depth image ", 200 );
			errStr.AppendInt( depthImage );
			errStr.Append( " - image does not exist " );
			agk::Error( errStr );
#endif 
			return;
		}

		// the image data is going to change so clear any cached data we have about it
		pImageDepth->SetCompressedPixelData( 0,0 );
	}

	if ( !pImageColor && !pImageDepth )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set render to image, at least one image must be greater than 0", 200 );
		agk::Error( errStr );
#endif 
		return;
	}

	DrawAllLines();

	bool forceDepth = false;
	if ( depthImage < 0 ) forceDepth = true;

	AGKFrameBuffer* pFBO = AGKFrameBuffer::FindFrameBuffer( pImageColor, pImageDepth, forceDepth );
	if ( !pFBO ) pFBO = new AGKFrameBuffer( pImageColor, true, pImageDepth, true, forceDepth );
	
	AGKFrameBuffer::BindFrameBuffer( pFBO );

	AGKShader::g_varResolution.SetVector2( (float) pFBO->GetWidth(), (float) pFBO->GetHeight() );
	
	//agk::PlatformSetViewport( 0,0, m_iFBOWidth, m_iFBOHeight );
	//agk::UpdateDeviceSize( m_iFBOWidth, m_iFBOHeight );
	//m_iRenderWidth = m_iFBOWidth;
	//m_iRenderHeight = m_iFBOHeight;
	//RecalculateDisplay();
	g_pRenderer->SetViewport( 0,0, pFBO->GetWidth(), pFBO->GetHeight() );

	if ( !m_bScissorUser )
	{
		m_iScissorX = agk::ScreenToViewportX(0);
		m_iScissorY = agk::ScreenToViewportY(0);
		m_iScissorWidth = agk::ScreenToViewportX((float)m_iDisplayWidth) - m_iScissorX;
		m_iScissorHeight = agk::ScreenToViewportY((float)m_iDisplayHeight) - m_iScissorY;

		g_pRenderer->SetGlobalScissor( m_iScissorX, m_iScissorY, m_iScissorWidth, m_iScissorHeight );
	}
	else
	{
		agk::SetScissor( m_fScissorUserX, m_fScissorUserY, m_fScissorUserX2, m_fScissorUserY2 );
	}
}

//****f* Core/Display/SetRenderToScreen
// FUNCTION
//   This command sets the render pipeline to output any future draw calls to the screen. This is the default
//   mode so you only need to call this if you have previously redirected drawing to an image with 
//   <i>SetRenderToImage</i>. After calling this command the backbuffer is immediately cleared, so any previous
//   rendering to the screen will be lost.
// SOURCE
void agk::SetRenderToScreen()
//****
{
	DrawAllLines();

	AGKFrameBuffer::BindFrameBuffer( 0 );

	AGKShader::g_varResolution.SetVector2( (float) m_iRenderWidth, (float) m_iRenderHeight );

	//agk::PlatformSetViewport( 0,0, m_iRenderWidth, m_iRenderHeight );
	//agk::UpdateDeviceSize( 0,0 );
	RecalculateDisplay(); // sets the viewport

	if ( !m_iDefaultFBCleared ) ClearScreen();
	m_iDefaultFBCleared = 0; // if SetRenderToScreen gets called again then we clear again 
}

char* agk::GetCL( )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "GetCL() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
	char *str = new char[1]; *str = 0;
	return str;
}

//****f* Core/Display/SetScissor
// FUNCTION
//   The function sets the area of the screen that will be drawn to in subsequent Sync() or Render() commands. The area is defined by
//   two points representing the top left and bottom right corners of a rectangle which will be the new drawing area. By default this
//   is set to your virtual resolution so anything placed outside this resolution is not be visible.
//   Using SetScissor(0,0,0,0) is a special case that will turn off all clipping and make the full screen useable for displaying things.
//   This can be useful when making an app that works across varying aspect ratios. For example using a virtual resolution of 1024x768 
//   on a device with a 1280x800 screen would fit the 1024x768 area as closely as possible in the center of the screen, with black 
//   borders either side. SetScissor(0,0,0,0) places the 1024x768 area in the same place, but there are no black borders, so placing 
//   something at a negative X position would still be visible for as long as the screen can still fit it in. Whereas placing something 
//   at a negative position on a device with a 1024x768 screen (which fits your virtual resolution perfectly), would make that item 
//   disappear off the edge of the screen. You can use this with the commands <i>GetScreenBoundsLeft</i>, <i>GetScreenBoundsRight</i>,
//   <i>GetScreenBoundsTop</i>, and <i>GetScreenBoundsBottom</i> to find the actual edge of the screen in your chosen resolution. 
//   This allows you to place items at the edge of the screen on all devices regardless of its aspect ratio.
// INPUTS
//   x -- The x component of the first coordinate.
//   y -- The y component of the first coordinate.
//   x2 -- The x component of the second coordinate.
//   y2 -- The y component of the second coordinate.
// SOURCE
void agk::SetScissor( float x, float y, float x2, float y2 )
//****
{
	if ( !g_pRenderer ) return;

	m_bScissorUser = true;
	m_fScissorUserX = x;
	m_fScissorUserY = y;
	m_fScissorUserX2 = x2;
	m_fScissorUserY2 = y2;

	if ( x == 0 && y == 0 && x2 == 0 && y2 == 0 )
	{
		m_iScissorX = 0;
		m_iScissorY = 0;
		m_iScissorWidth = 0;
		m_iScissorHeight = 0;
		g_pRenderer->SetGlobalScissor( 0,0,0,0 );
		return;
	}

	float temp;
	if ( x2 < x ) 
	{
		temp = x2;
		x2 = x;
		x = temp;
	}

	uint32_t flipped = 0;
	if ( !agk::GetRenderer()->IsTopLeftOrigin() ) flipped = 1 - flipped;
	if ( agk::GetRenderer()->IsFBOFlipped() && AGKFrameBuffer::g_pCurrFrameBuffer ) flipped = 1 - flipped;

	if ( flipped )
	{
		if ( y2 > y )
		{
			temp = y2;
			y2 = y;
			y = temp;
		}
	}
	else
	{
		if ( y > y2 )
		{
			temp = y2;
			y2 = y;
			y = temp;
		}
	}

	m_iScissorX = agk::ScreenToViewportX( x );
	m_iScissorY = agk::ScreenToViewportY( y );
	m_iScissorWidth = agk::ScreenToViewportX( x2 ) - m_iScissorX;
	m_iScissorHeight = agk::ScreenToViewportY( y2 ) - m_iScissorY;

	//uString info;
	//info.Format( "Scissor: %d %d %d %d", m_iScissorX, m_iScissorY, m_iScissorWidth, m_iScissorHeight );
	//agk::Warning( info );

	g_pRenderer->SetGlobalScissor( m_iScissorX, m_iScissorY, m_iScissorWidth, m_iScissorHeight );
}

//****f* Core/Display/SetIntendedDeviceSize
// FUNCTION
//   This command has been deprecated and you should use <i>LoadImageResized</i> to adjust image sizes depending 
//   on the device resolution, you can check the device resolution with <i>GetDeviceWidth</i> and 
//   <i>GetDeviceHeight</i>.
void agk::SetIntendedDeviceSize( int width, int height )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		agk::Message( "SetIntendedDeviceSize() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* Text/Properties/UseNewDefaultFonts
// FUNCTION
//   Since version 2.0.20 AGK has a new font system that can display more characters and render characters more smoothly,
//   however to preserve backwards compatibility this is turned off by default. To use the new system set this command to 1.
//   This only affects the default font where you haven't set one yourself.
// INPUTS
//   mode -- 1=use new default fonts, 0=use old default fonts
// SOURCE
void agk::UseNewDefaultFonts( int mode )
//****
{
	if ( m_pPrintText )
	{
		if ( m_iUseNewDefaultFonts == 0 && mode == 1 ) m_pPrintText->SetFont( 0 );
		if ( m_iUseNewDefaultFonts == 1 && mode == 0 ) 
		{
			m_pPrintText->SetFontImage( m_pPrintDefaultFont );
			m_pPrintText->SetExtendedFontImage( m_pPrintDefaultFontExt );
		}
	}

	m_iUseNewDefaultFonts = mode ? 1 : 0;
}

//****f* Core/Display/GetWindowWidth
// FUNCTION
//   Returns the width of the current device's window. This value may differ from the <i>GetDeviceWidth</i> if the
//   window size does not match the pixel size of the backbuffer that is being used to draw the window. For example 
//   on a Mac with a retina display the window size will be half of the pixel size.
// SOURCE
int agk::GetWindowWidth() 
//****
{ 
	return m_iRealDeviceWidth; 
}

//****f* Core/Display/GetWindowHeight
// FUNCTION
//   Returns the height of the current device's window. This value may differ from the <i>GetDeviceHeight</i> if the
//   window size does not match the pixel size of the backbuffer that is being used to draw the window. For example 
//   on a Mac with a retina display the window size will be half of the pixel size.
// SOURCE
int agk::GetWindowHeight() 
//****
{ 
	return m_iRealDeviceHeight; 
} 

//****f* Core/Display/GetDeviceWidth
// FUNCTION
//   Returns the width in pixels of the current device's backbuffer. This value will change if the device orientation
//   changes from portrait to landscape, but only if orientation changes are allowed.
// SOURCE
int agk::GetDeviceWidth() 
//****
{ 
	return m_iRenderWidth; 
}

int agk::GetRealDeviceWidth() 
{ 
	return m_iRenderWidth; 
} 

//****f* Core/Display/GetDeviceHeight
// FUNCTION
//   Returns the height in pixels of the current device's backbuffer. This value will change if the device orientation
//   changes from portrait to landscape, but only if orientation changes are allowed.
// SOURCE
int agk::GetDeviceHeight() 
//****
{ 
	return m_iRenderHeight; 
} 

int agk::GetRealDeviceHeight() 
{ 
	return m_iRenderHeight; 
} 

void agk::UpdatePhysicsWalls()
{
	if ( groundBodyBottom )
	{
		// bottom wall
		groundBodyBottom->SetTransform( b2Vec2(agk::WorldToPhyX(m_iDisplayWidth/2.0f),agk::WorldToPhyY(m_iDisplayHeight+1.0f)), 0 );
		b2Fixture *pFix = groundBodyBottom->GetFixtureList();
		if ( pFix ) groundBodyBottom->DestroyFixture( pFix );

		b2PolygonShape groundBox;
		groundBox.SetAsBox( agk::WorldToPhyX(m_iDisplayWidth/2.0f), agk::WorldToPhyY(1.0f) );
		groundBodyBottom->CreateFixture(&groundBox, 0.0f);
	}

	if ( groundBodyRight )
	{
		// right wall
		groundBodyRight->SetTransform( b2Vec2(agk::WorldToPhyX(m_iDisplayWidth+1.0f),agk::WorldToPhyY(m_iDisplayHeight/2.0f)), 0 );
		b2Fixture *pFix = groundBodyRight->GetFixtureList();
		if ( pFix ) groundBodyRight->DestroyFixture( pFix );

		b2PolygonShape groundBox;
		groundBox.SetAsBox( agk::WorldToPhyX(1.0f), agk::WorldToPhyY(m_iDisplayHeight/2.0f) );
		groundBodyRight->CreateFixture(&groundBox, 0.0f);
	}

	if ( groundBodyLeft )
	{
		// left wall
		groundBodyLeft->SetTransform( b2Vec2(agk::WorldToPhyX(-1.1f),agk::WorldToPhyY(m_iDisplayHeight/2.0f)), 0 );
		b2Fixture *pFix = groundBodyLeft->GetFixtureList();
		if ( pFix ) groundBodyLeft->DestroyFixture( pFix );

		b2PolygonShape groundBox;
		groundBox.SetAsBox( agk::WorldToPhyX(1.0f), agk::WorldToPhyY(m_iDisplayHeight/2.0f) );
		groundBodyLeft->CreateFixture(&groundBox, 0.0f);
	}

	if ( groundBodyTop )
	{
		// top wall
		groundBodyTop->SetTransform( b2Vec2(agk::WorldToPhyX(m_iDisplayWidth/2.0f),agk::WorldToPhyY(-1.1f)), 0 );
		b2Fixture *pFix = groundBodyTop->GetFixtureList();
		if ( pFix ) groundBodyTop->DestroyFixture( pFix );

		b2PolygonShape groundBox;
		groundBox.SetAsBox( agk::WorldToPhyX(m_iDisplayWidth/2.0f), agk::WorldToPhyY(1.0f) );
		groundBodyTop->CreateFixture(&groundBox, 0.0f);
	}
}

//****f* Core/Display/SetVirtualResolution
// FUNCTION
//   The default approach for the coordinate system in AGK is to use a percentage based system where
//   0,0 represents the top left corner and 100,100 the bottom right. The alternative approach is to 
//   treat the platform with a fixed resolution e.g. 320 x 480. Any platforms that don't match this
//   resolution will be scaled to fit as much as possible with black borders where necessary.
// INPUTS
//   iWidth -- the number of units to use across the width of the rendering area
//   iHeight -- the number of units to use across the height of the rendering area
// SOURCE
void agk::SetVirtualResolution( int iWidth, int iHeight )
//****
{
	if ( iWidth < 1 ) iWidth = 1;
	if ( iHeight < 1 ) iHeight = 1;

	m_iDisplayWidth = iWidth;
	m_iDisplayHeight = iHeight;

//	if ( m_bUsingDisplayAspect ) m_fDisplayAspect = m_iDisplayWidth / (float) m_iDisplayHeight;
	m_fDisplayAspect = m_iDisplayWidth / (float) m_iDisplayHeight;
	m_bUsingDisplayAspect = true;

	RecalculateDisplay();
	
	if ( m_pPrintText ) m_pPrintText->ChangedAspect();

	// modify physics objects
	UpdatePhysicsWalls();

	if ( m_pPrintText && !m_iPrintSizeChanged ) m_pPrintText->SetSize( iWidth / 30.0f );
}

//****f* Core/Display/UpdateDeviceSize
// FUNCTION
//   If for any reason the device dimensions may have changed (e.g. a change in orientation rotates the viewspace to a new size)
//   call this function to update the internal values.
// INPUTS
//   w -- The new width
//   h -- The new height
// SOURCE
void agk::UpdateDeviceSize( uint32_t w, uint32_t h )
//****
{
	int iOrigWidth = m_iRenderWidth;
	int iOrigHeight = m_iRenderHeight;

	int iOrigDeviceWidth = m_iRealDeviceWidth;
	int iOrigDeviceHeight = m_iRealDeviceHeight;
	
	// set initial user defined values, will be overridden if the platform has a way of getting the size.
	m_iRenderWidth = w;
	m_iRenderHeight = h;
	
	m_iRealDeviceWidth = w;
	m_iRealDeviceHeight = h;

	// get the new device size from the platform
	if ( w == 0 || h == 0 ) PlatformUpdateDeviceSize();

	if ( m_iRenderWidth == 0 || m_iRenderHeight == 0 )
	{
		m_iRenderWidth = iOrigWidth;
		m_iRenderHeight = iOrigHeight;
	}

	if ( m_iRealDeviceWidth == 0 || m_iRealDeviceHeight == 0 )
	{
		m_iRealDeviceWidth = iOrigDeviceWidth;
		m_iRealDeviceHeight = iOrigDeviceHeight;
	}

	if ( g_pRenderer ) g_pRenderer->UpdateSurfaceSize();

	if ( !AGKFrameBuffer::g_pCurrFrameBuffer ) 
	{
		AGKShader::g_varResolution.SetVector2( (float)m_iRenderWidth, (float)m_iRenderHeight );
	}

	// camera always uses the back buffer aspect ratio
	cCamera::UpdateAllAspectRatio( m_iRenderWidth/(float)m_iRenderHeight );

	if ( m_bUsingDeviceAspect ) m_fDisplayAspect = m_iRenderWidth / (float) m_iRenderHeight;

	// if changed, update viewspace
	if ( iOrigWidth != m_iRenderWidth 
	  || iOrigHeight != m_iRenderHeight )
	{
		RecalculateDisplay();
	}
}

//****f* Core/Display/GetVirtualWidth
// FUNCTION
//   Returns the coordinate for the far right side of the screen. In the default percentage based coordinate
//   system this is 100. If you have set up a virtual resolution using <i>SetVirtualResolution</i> then
//   the width specified here will be returned.
// SOURCE
int agk::GetVirtualWidth() 
//****
{ 
	return m_iDisplayWidth; 
}

//****f* Core/Display/GetVirtualHeight
// FUNCTION
//   Returns the coordinate for the bottom of the screen. In the default percentage based coordinate system
//   this is 100. If you have set up a virtual resolution using <i>SetVirtualResolution</i> then
//   the height specified here will be returned.
// SOURCE
int agk::GetVirtualHeight() 
//****
{ 
	return m_iDisplayHeight; 
} 

//****f* Core/Display/GetScreenBoundsLeft
// FUNCTION
//   Returns the left edge of the visible screen. This includes any black border area so if there are black 
//   borders on the left and right of the display then this value will be negative. This represents the fact that
//   0 is the end of the visible area and the start of the black border, and the left bound is the end of
//   the black border and the edge of the screen. If there is no black border to the left then the left
//   bound will always be 0.
// SOURCE
float agk::GetScreenBoundsLeft() 
//****
{ 
	return -m_iDisplayExtraX;
}

//****f* Core/Display/GetScreenBoundsRight
// FUNCTION
//   Returns the right edge of the visible screen. This includes any black border area so if there are black 
//   borders on the left and right of the display then this value will be greater than GetVirtualWidth. This 
//   represents the fact that the virtual width is the end of the visible area and the start of the black border, 
//   and the right bound is the end of the black border and the edge of the screen. If there is no black border 
//   to the right then the right bound will always be equal to GetVirtualWidth.
// SOURCE
float agk::GetScreenBoundsRight() 
//****
{ 
	return m_iDisplayWidth + m_iDisplayExtraX; 
}

//****f* Core/Display/GetScreenBoundsTop
// FUNCTION
//   Returns the top edge of the visible screen. This includes any black border area so if there are black 
//   borders on the top and bottom of the display then this value will be negative. This represents the fact that
//   0 is the end of the visible area and the start of the black border, and the top bound is the end of
//   the black border and the edge of the screen. If there is no black border to the top then the top
//   bound will always be 0.
// SOURCE
float agk::GetScreenBoundsTop() 
//****
{ 
	return -m_iDisplayExtraY; 
}

//****f* Core/Display/GetScreenBoundsBottom
// FUNCTION
//   Returns the bottom edge of the visible screen. This includes any black border area so if there are black 
//   borders on the top and bottom of the display then this value will be greater than GetVirtualHeight. This 
//   represents the fact that the virtual height is the end of the visible area and the start of the black border, 
//   and the bottom bound is the end of the black border and the edge of the screen. If there is no black border 
//   on the bottom then the bottom bound will always be equal to GetVirtualHeight.
// SOURCE
float agk::GetScreenBoundsBottom() 
//****
{ 
	return m_iDisplayHeight + m_iDisplayExtraY;
}

//****f* Core/Display/GetDisplayAspect
// FUNCTION
//   Returns the current aspect ratio for the screen. This is not the aspect ratio of the coordinate system being used, instead 
//   this value stretches the coordinate system into the desired shape. For an explanation of the coordinate system see
//   <i>SetVirtualResolution</i>.
// SOURCE
float agk::GetDisplayAspect() 
//****
{ 
	return m_fDisplayAspect; 
}

//****f* Core/Display/GetOrientation
// FUNCTION
//   Returns the current orientation of the device. The values returned are: 1 = portrait mode, 2 = portrait mode - 180 degrees rotation,
//   3 = landscape mode - 90 degrees counterclockwise, 4 = landscape mode - 90 degrees clockwise
// SOURCE
int agk::GetOrientation() 
//****
{ 
	return m_iOrientation; 
}

//****f* Core/Display/GetPaused
// FUNCTION
//   Returns 1 if your desktop app loses focus. You can choose to activate a pause screen when this happens or let the app continue as normal. 
//   This only applies to desktop platforms, on mobile platforms you should use <i>GetResumed</i> instead.
// SOURCE
int agk::GetPaused()
//****
{
	int paused = m_iPaused;
	m_iPaused = 0;
	return paused;
}

//****f* Core/Display/GetResumed
// FUNCTION
//   Returns 1 if your app has been passed to the background and has just been reactivated. You should activate a pause screen when this happens.
//   On mobile platforms apps will not run whilst they are in the background so that first chance you app will get to receive this notification 
//   is when it returns from the background and continues running. Since the user may not yet be ready to continue playing you should check this 
//   value and show a pause screen until they are ready.
// SOURCE
int agk::GetResumed()
//****
{
	int resumed = m_iResumed;
	m_iResumed = 0;
	return resumed;
}

// reset by Sync instead of every call
int agk::GetResumed2()
{
	return m_iResumed2;
}

//****f* Core/Misc/SetDefaultMagFilter
// FUNCTION
//   Sets the default magnification filter for textures when the texture is larger than the screen space it is displayed in.
//   You can use a mode of 0 to use the nearest pixel, which will appear blocky, or 1 to use a linear filter
//   which will look blurry. When the image matches the screen space exactly then both filters will look the same
//   when there is a slight difference, nearest tends to be sharper, but may flicker as it changes pixel choice.
//   You can set this value per image using <i>SetImageMagFilter</i>.
// INPUTS
//   filter -- The filter mode to use 0=nearest, 1=linear
// SOURCE
void agk::SetDefaultMagFilter( uint32_t filter )
//****
{
	if ( filter > 1 ) filter = 1;
	m_iDefaultMagFilter = filter;
}

//****f* Core/Misc/SetDefaultMinFilter
// FUNCTION
//   Sets the default minification filter for textures when the texture is smaller than the screen space it is displayed in.
//   You can use a mode of 0 to use the nearest pixel, which will appear blocky, or 1 to use a linear filter
//   which will look blurry. When the image matches the screen space exactly then both filters will look the same
//   when there is a slight difference, nearest tends to be sharper, but may flicker as it changes pixel choice.
//   You can set this value per image using <i>SetImageMinFilter</i>.
// INPUTS
//   filter -- The filter mode to use 0=nearest, 1=linear
// SOURCE
void agk::SetDefaultMinFilter( uint32_t filter )
//****
{
	if ( filter > 1 ) filter = 1;
	m_iDefaultMinFilter = filter;
}

//****f* Core/Misc/SetDefaultWrapU
// FUNCTION
//   Sets the default texture wrapping for images where the UV coordinates go beyond the range 0 to 1 in the U direction.
// INPUTS
//   mode -- The wrapping mode to use 0=clamp, 1=repeat
// SOURCE
void agk::SetDefaultWrapU( uint32_t mode )
//****
{
	if ( mode > 1 ) mode = 1;
	m_iDefaultWrapU = mode;
}

//****f* Core/Misc/SetDefaultWrapV
// FUNCTION
//   Sets the default texture wrapping for images where the UV coordinates go beyond the range 0 to 1 in the V direction.
// INPUTS
//   mode -- The wrapping mode to use 0=clamp, 1=repeat
// SOURCE
void agk::SetDefaultWrapV( uint32_t mode )
//****
{
	if ( mode > 1 ) mode = 1;
	m_iDefaultWrapV = mode;
}

//****f* Core/Display/SetViewOffset
// FUNCTION
//   Offset the screen viewport relative to the world, for example a view offset of 0,20 will move the screen
//   down by 20 pixels showing any sprite that was previously positioned just off the bottom of the screen.
//   This can be useful for scrolling games where you want to move the view across a level.<br><br>
//   Using this command will automatically disable the four physics walls surrounding the screen.<br><br>
//   You can also fix sprites to the screen so that they move along with it by using <i>FixSpriteToScreen</i>.<br><br>
//   The view offset values position the top left corner of the view in the world, while <i>SetViewZoom</i> determines
//   how much of the world the view can see.
// INPUTS
//   x -- The x offset for the view
//   y -- The y offset for the view
// SOURCE
void agk::SetViewOffset( float x, float y )
//****
{
	m_fViewOffsetX = x;
	m_fViewOffsetY = y;

	agk::SetPhysicsWallBottom( 0 );
	agk::SetPhysicsWallTop( 0 );
	agk::SetPhysicsWallLeft( 0 );
	agk::SetPhysicsWallRight( 0 );
}

//****f* Core/Display/SetViewZoom
// FUNCTION
//   Zooms the screen viewport relative to the world, for example a view zoom of 2.0 will double the size of 
//   anything currently in view. A value of 1.0 returns everything to normal size.<br><br>
//   Using this command will automatically disable the four physics walls surrounding the screen.<br><br>
//   You can also fix sprites to the screen so that they do not change size by using <i>FixSpriteToScreen</i>.<br><br>
//   This command can either zoom towards the view's top left corner or towards the view's center, see
//   <i>SetViewZoomMode</i> for details.
// INPUTS
//   zoom -- The zoom level for scrolling sprites
// SOURCE
void agk::SetViewZoom( float zoom )
//****
{
	if ( zoom < 0.001f ) zoom = 0.001f;
	m_fViewZoom = zoom;

	agk::SetPhysicsWallBottom( 0 );
	agk::SetPhysicsWallTop( 0 );
	agk::SetPhysicsWallLeft( 0 );
	agk::SetPhysicsWallRight( 0 );
}

//****f* Core/Display/SetViewZoomMode
// FUNCTION
//   Sets the zoom mode from top left corner or centered. By default the view zooms from its top left corner, maintaining
//   the views offset in world coordinates. For example a view with an offset of 20,20 will maintain its top left corner 
//   at 20,20 in world coordinates no matter what zoom value is given. However, centered zoom keeps the center of the view 
//   stationary whilst scaling everything else around it, making the offset value more difficult to judge. In this mode the
//   top left corner will only be at 20,20 when the zoom value is 1.0, for other zoom values the top left corner will be 
//   scaled away from the offset point. For example, assume a world size of 100,100 units, a zoom level of 1.0, and a view
//   offset of 0,0. The view will be displaying world coordinates 0,0 (its top left corner) to 100,100 (at its bottom right 
//   corner), with a zoom value of 2.0 and top left zooming the view will now show world coordinates 0,0 to 50,50 in the 
//   same space making everything look bigger. In centered zooming the view would instead show 25,25 to 75,75 maintaining 
//   the center of the view over the point 50,50 in world coordinates.
// INPUTS
//   mode -- 0=top left, 1=centered
// SOURCE
void agk::SetViewZoomMode( int mode )
//****
{
	if ( mode != 0 ) mode = 1;
	m_iViewZoomMode = mode;
}

//****f* Core/Display/GetViewOffsetX
// FUNCTION
//   Gets the current view offset in the X direction, set using <i>SetViewOffset</i>.
// SOURCE
float agk::GetViewOffsetX()
//****
{
	return m_fViewOffsetX;
}

//****f* Core/Display/GetViewOffsetY
// FUNCTION
//   Gets the current view offset in the Y direction, set using <i>SetViewOffset</i>.
// SOURCE
float agk::GetViewOffsetY()
//****
{
	return m_fViewOffsetY;
}

//****f* Core/Display/GetViewZoom
// FUNCTION
//   Gets the current scroll zoom level, set using <i>SetViewZoom</i>.
// SOURCE
float agk::GetViewZoom()
//****
{
	return m_fViewZoom;
}

//****f* Core/Display/Sync
// FUNCTION
//   Updates the scene with the latest information, draws all sprites, updates global objects, and swaps the backbuffer into view.
//   Does not draw sprites you have created using pointers in tier 2, you must draw these manually by calling the sprite's <i>Draw</i>
//   function or assigning them to a sprite manager for batch drawing.
// SOURCE
void agk::Sync()
//****
{
	Update();
	Render();
	Swap();
}

//***f* Core/General/Break
// FUNCTION
//   This command is deprecated, breaking is now handled by the IDE
// SOURCE
void agk::Break()
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "Break() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* Core/General/StepPhysics
// FUNCTION
//   Steps the physics simulation by a defined amount of time. This time value is in seconds and may include fractions of seconds.
//   Stepping the physics simulation by a large time value (greater than say 0.1) may result in undefined behaviour and physics 
//   objects moving through each other. It is not required that you call this command in your game loop, if you do not call it, 
//   <i>Sync</i> or <i>Update</i> will call it for you with the last frame time to allow the physics simulation to catch up in real time.
//   If you do call <i>StepPhysics</i> then it will not be called for you by <i>Sync</i> or <i>Update</i> for that frame, this allows you to do
//   your own physics timing if you prefer.<br><br>
//   By using a fixed time step every frame your physics will perform exactly the same across all devices and all frame rates,
//   but a reduction in fps will result in the physics appearing to go slower, as it will always step the same amount
//   of time whether the frame was quick or slow to draw. Using a variable step for each frame will keep physics moving at the same
//   speed regardless of frame rate, but it will no longer be deterministic across devices and different frame rates. For example 
//   if your game depends on a physics entity falling and bouncing to the same height each time it is run then you should use
//   a fixed time step. If the position of physics objects is not important to your game logic then a variable time step may be best.
// INPUTS
//   time -- The step time in seconds
// SOURCE
void agk::StepPhysics( float time )
//****
{
	if ( !g_pRenderer ) return;

	float startTime = agk::Timer();
	
	m_bPhysicsStepped = true;

	// clear the contact iterator
	m_pContactIter = 0;
	m_pLastColCheck = 0;
	m_pLastColCheck2 = 0;

	// apply global forces
	cForce *pForce = (cForce*) m_cForceList.GetFirst();
	while ( pForce )
	{
		float cx = agk::WorldToPhyX(pForce->m_fX);
		float cy = agk::WorldToPhyY(pForce->m_fY);
		float radius = agk::WorldToPhyX(pForce->m_fRadius);
		float radius2 = pForce->m_fRadius * pForce->m_fRadius;
		float power = pForce->m_fPower;
		float limit = pForce->m_fLimit;
		bool fade = pForce->m_bFade;

		b2Body *pBody = m_phyWorld->GetBodyList();
		while ( pBody )
		{
			if ( pBody->GetType() != b2_dynamicBody )
			{
				pBody = pBody->GetNext();
				continue;
			}

			float x = pBody->GetPosition().x;
			float y = pBody->GetPosition().y;

			float vx = cx-x;
			float vy = cy-y;
			float length2 = vx*vx+vy*vy;
			if ( radius>=0 && length2>radius2 )
			{
				pBody = pBody->GetNext();
				continue;
			}

			float length = agk::Sqrt( length2 );
			if ( length < 0.00001f ) 
			{
				vx = 1;
				vy = 0;
			}
			else
			{
				vx /= length;
				vy /= length;
			}

			if ( fade )
			{
				// reduce force power with distance, maximum force = 10*power
				float force = power / length2;
				if ( limit > 0 && force > limit ) force = limit;
				vx *= force;
				vy *= force;
			}
			else
			{
				// constant force at any distance
				vx *= power;
				vy *= power;
			}

			b2Vec2 v( vx, vy );
			pBody->ApplyForce( v, pBody->GetPosition(), true );

			pBody = pBody->GetNext();
		}
		
		pForce = (cForce*)  m_cForceList.GetNext();
	}

	m_phyWorld->Step( time, m_iVelIterations, m_iPosIterations );
//	m_phyWorld->ClearForces();
	
	m_fPhysicsTime = agk::Timer() - startTime;
}

//****f* Core/General/Update
// FUNCTION
//   Updates all 2D and 3D objects based on the given time, animation, physics, etc. If time is 0 it uses the last frame time
//   to step the simulation. If you have already called <i>StepPhysics</i> this frame it will not be called again for this 
//   frame.<br><br>
//   Called automatically by <i>Sync</i>, you may either use <i>Sync</i> or <i>Update(), Render(), Swap()</i> to manually sync.
//   If you wish to have more control  you can break this down further by replacing <i>Update</i> with <i>Update2D, Update3D()</i>
// INPUTS
//   time -- the time in seconds to move everything along. Can be fractions of seconds.
// SOURCE
void agk::Update( float time )
//****
{
	if ( !g_pRenderer ) return;

	float currtime = agk::Timer();
	AGKShader::g_varTime.SetFloat( currtime );
	AGKShader::g_varSinTime.SetFloat( agk::SinRad(currtime) );

	cImage::UpdateGifImages();
	Update2D( time );
	Update3D( time );
}

//****f* Core/General/Update2D
// FUNCTION
//   Called automatically. This is an advanced command to take control of the update process.  
//   Normally <i>Update</i> calls this and <i>Update3D()</i> to update everything in the world.
//   This command only updates the 2D objects such as sprites and text.
// INPUTS
//   time -- the time in seconds to move everything along. Can be fractions of seconds.
// SOURCE
void agk::Update2D( float time )
//****
{
	if ( !g_pRenderer ) return;

	if ( time == 0 ) time = (float) m_fTimeDelta;

	if ( !m_bPhysicsStepped ) StepPhysics( time );
	m_bPhysicsStepped = false;
	//m_phyWorld->ClearForces(); // done automatically
	
	float startTime = agk::Timer();

	// update sprite animation and physics
	//m_cSpriteMgr.UpdateAll( time );s
	m_cSpriteMgrFront.UpdateAll( time );

	// update particles
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetFirst();
	while ( pEmitter )
	{
		pEmitter->Update( time );
		pEmitter = m_cParticleEmitterList.GetNext();
	}

	cText *pText = m_cTextList.GetFirst();
	while ( pText )
	{
		pText->Update( time );
		pText = m_cTextList.GetNext();
	}

	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetFirst();
	while ( pSkeleton )
	{
		pSkeleton->Update( time );
		pSkeleton = m_cSkeleton2DList.GetNext();
	}

	// advert code
	UpdateAd();
	
	m_fUpdateTime = agk::Timer() - startTime;
}

//****f* Core/General/Update3D
// FUNCTION
//   Called automatically. This is an advanced command to take control of the update process.
//   Normally <i>Update</i> calls this and <i>Update2D()</i> to update everything in the world.
//   This command only updates the 3D objects such as 3D models.
// INPUTS
//   time -- the time in seconds to move everything along. Can be fractions of seconds.
// SOURCE
void agk::Update3D( float time )
//****
{
	if ( !g_pRenderer ) return;

	if ( time == 0 ) time = (float) m_fTimeDelta;

	//SITDS:TODO, this should be handeled by the Bullet Motion state.
	// allow the user to call this with a custom or fixed time step similar to StepPhysics() for Box2D
	/*m_pDynamicsWorld->stepSimulation(time, 10);*/

	float startTime = agk::Timer();

	// update all objects
	m_cObjectMgr.UpdateAll( time );

	// update particles
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetFirst();
	while ( pEmitter )
	{
		pEmitter->Update( time );
		pEmitter = m_3DParticleEmitterList.GetNext();
	}

	m_fUpdateTime += (agk::Timer() - startTime);
}

void agk::UpdateInput()
{
	static float fJoystickCheckTime = 0;
	fJoystickCheckTime += agk::GetFrameTime();
	if ( fJoystickCheckTime > 3 )
	{
		fJoystickCheckTime = 0;
		cJoystick::DetectJoysticks();
	}

	// update joysticks
	for ( uint32_t i = 0; i < AGK_NUM_JOYSTICKS; i++ )
	{
		if ( !m_pJoystick[ i ] ) continue;
		m_pJoystick[ i ]->Update();
	}

	for ( uint32_t i = 0; i < 4; i++ )
	{
		if ( !m_pVirtualJoystick[ i ] ) continue;
		m_pVirtualJoystick[ i ]->Update();
	}

	// update virtual buttons
	for ( uint32_t i = 0; i < AGK_MAX_VIRTUAL_BUTTONS; i++ )
	{
		if ( !m_pVirtualButton[ i ] ) continue;
		m_pVirtualButton[ i ]->Update();
	}

	cSoundMgr::UpdateSounds();

	// emulate accelerometer
	if ( GetKeyboardExists() == 1 )
	{
		// gradually increase acceleration, takes 20 frames to reach 1.0
		if ( m_iKeyDown[ AGK_KEY_LEFT ] > 0 ) m_fFakeAccelX -= (1+m_fFakeAccelX)/20.0f; //left
		if ( m_iKeyDown[ AGK_KEY_RIGHT ] > 0 ) m_fFakeAccelX += (1-m_fFakeAccelX)/20.0f; //right
		if ( m_iKeyDown[ AGK_KEY_UP ] > 0 ) m_fFakeAccelY -= (1+m_fFakeAccelY)/20.0f; //up
		if ( m_iKeyDown[ AGK_KEY_DOWN ] > 0 ) m_fFakeAccelY += (1-m_fFakeAccelY)/20.0f; //down

		// reset towards zero
		if ( m_iKeyDown[ AGK_KEY_LEFT ] == 0 && m_iKeyDown[ AGK_KEY_RIGHT ] == 0 )
		{
			if ( m_fFakeAccelX > 0.05f )  m_fFakeAccelX -= 0.05f;
			else if ( m_fFakeAccelX < -0.05f ) m_fFakeAccelX += 0.05f;
			else m_fFakeAccelX = 0;
		}

		if ( m_iKeyDown[ AGK_KEY_UP ] == 0 && m_iKeyDown[ AGK_KEY_DOWN ] == 0 )
		{
			if ( m_fFakeAccelY > 0.05f )  m_fFakeAccelY -= 0.05f;
			else if ( m_fFakeAccelY < -0.05f ) m_fFakeAccelY += 0.05f;
			else m_fFakeAccelY = 0;
		}

		// check bounds
		if ( m_fFakeAccelX > 1.0f ) m_fFakeAccelX = 1.0f;
		if ( m_fFakeAccelX < -1.0f ) m_fFakeAccelX = -1.0f;
		if ( m_fFakeAccelY > 1.0f ) m_fFakeAccelY = 1.0f;
		if ( m_fFakeAccelY < -1.0f ) m_fFakeAccelY = -1.0f;
	}

	// emulated joystick
	if ( GetKeyboardExists() == 1 )
	{
		float speed = 1;
		if ( m_iKeyDown[ AGK_KEY_SHIFT ] > 0 ) speed = 0.5;

		float accel = 3 * agk::GetFrameTime() * speed;

		if ( m_iKeyDown[ AGK_KEY_A ] > 0 ) m_fFakeJoystickX -= accel;//(speed+m_fFakeJoystickX)/20.0f; //left
		if ( m_iKeyDown[ AGK_KEY_D ] > 0 ) m_fFakeJoystickX += accel;//(speed-m_fFakeJoystickX)/20.0f; //right
		if ( m_iKeyDown[ AGK_KEY_W ] > 0 ) m_fFakeJoystickY -= accel;//(speed+m_fFakeJoystickY)/20.0f; //up
		if ( m_iKeyDown[ AGK_KEY_S ] > 0 ) m_fFakeJoystickY += accel;//(speed-m_fFakeJoystickY)/20.0f; //down

		// reset towards zero
		float drag = 0.8f;
		if ( m_iKeyDown[ AGK_KEY_W ] || m_iKeyDown[ AGK_KEY_S ] ) drag = 0.9f;
		if ( m_iKeyDown[ AGK_KEY_A ] == 0 && m_fFakeJoystickX < 0 ) m_fFakeJoystickX *= drag;
		if ( m_iKeyDown[ AGK_KEY_D ] == 0 && m_fFakeJoystickX > 0 ) m_fFakeJoystickX *= drag;
		
		drag = 0.8f;
		if ( m_iKeyDown[ AGK_KEY_A ] || m_iKeyDown[ AGK_KEY_D ] ) drag = 0.9f;
		if ( m_iKeyDown[ AGK_KEY_W ] == 0 && m_fFakeJoystickY < 0 ) m_fFakeJoystickY *= drag;
		if ( m_iKeyDown[ AGK_KEY_S ] == 0 && m_fFakeJoystickY > 0 ) m_fFakeJoystickY *= drag;

		if ( m_fFakeAccelX > speed ) m_fFakeAccelX = speed;
		if ( m_fFakeAccelX < -speed ) m_fFakeAccelX = -speed;
		if ( m_fFakeAccelY > speed ) m_fFakeAccelY = speed;
		if ( m_fFakeAccelY < -speed ) m_fFakeAccelY = -speed;

		float length = m_fFakeJoystickX*m_fFakeJoystickX + m_fFakeJoystickY*m_fFakeJoystickY;
		if ( length > speed*speed )
		{
			length = agk::Sqrt( length );
			m_fFakeJoystickX *= (speed/length);
			m_fFakeJoystickY *= (speed/length);
		}
	}

	// update emulated pointer
	m_iLastPointerDown = m_iPointerDown;
	m_iPointerDown = 0;
	if ( GetMouseExists() == 1 && agk::GetRawMouseLeftState() )
	{
		m_iPointerDown = 1;
	}
	
	if ( GetMultiTouchExists() && cTouch::GetAny() )
	{
		m_iPointerDown = 1;
	}

	// delete old events and detect long hold events
	cTouch::UpdateEvents();

	// mouse
	for ( int i = 0 ; i < 4; i++ )
	{
		if ( m_pMouse[ i ] ) m_pMouse[ i ]->Update();
	}
    
    // reset edit boxes
    cEditBox *pEditBox = m_cEditBoxList.GetFirst();
    while ( pEditBox )
    {
        pEditBox->ResetChangedFlag();
        pEditBox = m_cEditBoxList.GetNext();
    }
    
    // text input
	m_bInputStartedPrev = m_bInputStarted;
	PlatformUpdateTextInput();
    
	// edit boxes
	pEditBox = m_cEditBoxList.GetFirst();
	while ( pEditBox )
	{
		pEditBox->Update();
		pEditBox = m_cEditBoxList.GetNext();
	}
    
	m_iLastChar = m_iCurrChar;
	for ( int i = 0; i < AGK_MAX_KEYS; i++ ) 
	{
		m_iPrevKeyDown[ i ] = m_iKeyDown[ i ];
		// if the key has already been released and we have delayed it, release it now
		if ( m_iResetKey[ i ] )
		{
			m_iKeyDown[ i ] = 0;
			m_iResetKey[ i ] = 0;
		}
	}
}

void agk::DrawAllLines()
{
	if ( !g_pRenderer ) return;

	if ( m_iNumLineVertices == 0 ) return;

	g_pRenderer->SetVertices( m_pInternalLinesVertices, m_pLineVertexData, m_iNumLineVertices );
	g_pRenderer->BindPipeline( 0, m_pLinesShader, &m_linesRenderState, &m_linesVertexLayout, &m_pInternalLinesPipeline );
	g_pRenderer->BindShaderConstants( 0, m_pLinesShader, 0, 0, 0, &m_pInternalLinesConstants );
	g_pRenderer->DrawVertices( 0, m_pInternalLinesVertices, m_iNumLineVertices );

	m_iNumLineVertices = 0;
}

//****f* Core/Display/Render2DBack
// FUNCTION
//   Called automatically. This is an advanced command to take control of the render pipeline. Normally 
//   <i>Render</i> calls RenderShadowMap, Render2DBack, Render3D, Render2DFront to draw
//   everything in the world. This command only draws the 2D sprites and text that are behind the 3D.
// SOURCE
void agk::Render2DBack( )
//****
{
	if ( !g_pRenderer ) return;

	float startTime = agk::Timer();

	cParticleEmitter::m_iQuadParticlesDrawn = 0;
	cSprite::g_iPixelsDrawn = 0;
	
	// draw all sprites
	m_cSpriteMgrFront.DrawSplit( m_i3DDepth, 2 );

	m_fDrawingSetupTime = agk::Timer() - startTime;
}

//****f* Core/Display/Render
// FUNCTION
//   Draws all 2D and 3D created using an ID number to the current frame buffer. It does not
//   swap the backbuffer to the screen. It does not draw sprites or objects you have created using pointers, you will
//   either have to draw them individually or assign them to a sprite manager to batch draw them. In this case
//   <i>Render</i> should still be called as it also draws the print text.
//   Called automatically by <i>Sync</i>, you may either use <i>Sync</i> or <i>Update(), Render(), Swap()</i> to manually sync.
//   If you wish to have more control you can break this down further and replace <i>Render</i> with <i>RenderShadowMap</i>, 
//   <i>Render2DBack</i>, <i>Render3D</i>, <i>Render2DFront</i>.
// SOURCE
void agk::Render()
//****
{
	if ( !g_pRenderer ) return;

	RenderShadowMap();

	m_iDrawingCount = 0;
	Render2DBack(); // draw 2D objects that are behind 3D
	m_iDrawingCount = 0;
	Render3D(); // draw 3D objects
	Render2DFront(); // draw 2D objects that are in front of 3D
}

//****f* Core/Display/Render2DFront
// FUNCTION
//   Called automatically. This is an advanced command to take control of the render pipeline. Normally 
//   <i>Render</i> calls RenderShadowMap, Render2DBack, Render3D, Render2DFront to draw
//   everything in the world. This command only draws the 2D sprites and text that are in front the 3D.
// SOURCE
void agk::Render2DFront( )
//****
{
	if ( !g_pRenderer ) return;

	float startTime = agk::Timer();

	if ( !m_bFirstSync ) 
	{
		if ( m_pSplashSprite )
		{
			delete m_pSplashSprite;
			m_pSplashSprite = 0;
		}
	}
	else m_bFirstSync = false;

	// draw all sprites
	m_cSpriteMgrFront.DrawSplit( m_i3DDepth, 1 );
	
	/*
	static cSprite *pShadowSprite = 0;
	if ( !pShadowSprite && m_pShadowMap4 )
	{
		pShadowSprite = new cSprite( m_pShadowMap4 );
		pShadowSprite->SetSize( 200,200 );
		pShadowSprite->SetPosition( 10,100 );
	}
	if ( pShadowSprite ) 
	{
		pShadowSprite->SetImage( m_pShadowMap4 );
		pShadowSprite->Draw();
	}
	*/
	
 	// draw virtual joysticks
	for ( uint32_t i = 0; i < 4; i++ )
	{
		if ( m_pVirtualJoystick[ i ] ) m_pVirtualJoystick[ i ]->Draw();
	}

	// draw virtual buttons
	for ( uint32_t i = 0; i < AGK_MAX_VIRTUAL_BUTTONS; i++ )
	{
		if ( m_pVirtualButton[ i ] ) m_pVirtualButton[ i ]->Draw();
	}

	// draw any pending lines
	DrawAllLines();

	if ( m_bDrawDebug )
	{
		g_DebugDraw.BeginRender();
		
		//m_cSpriteMgr.DrawDebug();
		m_cSpriteMgrFront.DrawDebug();

		uint32 flags = b2Draw::e_shapeBit | b2Draw::e_jointBit | b2Draw::e_centerOfMassBit;
		g_DebugDraw.SetFlags(flags);

		m_phyWorld->DrawDebugData();

		g_DebugDraw.EndRender();
	}

	// draw print text
	if ( m_pPrintText )
	{
		m_pPrintText->SetString( m_cPrintStr );
		m_pPrintText->Draw();
		m_cPrintStr.ClearTemp();
	}

	DrawAd();
	PlatformDrawTextInput();

#ifdef FREEVERSION
	static cSprite *g_pTrialSprite = 0;
	if ( !g_pTrialSprite )
	{
		cImage *pImage = new cImage();
		pImage->LoadPNGFromMemory( libImageTrialWatermark, 0, 0 );
		g_pTrialSprite = new cSprite( pImage );
		g_pTrialSprite->SetTransparency( 1 );
		g_pTrialSprite->SetAlpha( 128 );
		g_pTrialSprite->FixToScreen(1);
	}
	g_pTrialSprite->SetSize( agk::GetVirtualWidth()/5.0f, -1 );
	float x = agk::GetVirtualWidth() - g_pTrialSprite->GetWidth();
	float y = agk::GetVirtualHeight() - g_pTrialSprite->GetHeight();
	g_pTrialSprite->SetPosition( x, y );
	g_pTrialSprite->Draw();
#endif

	// add to the RenderBack time
	m_fDrawingSetupTime += agk::Timer() - startTime;
}

//****f* Core/Display/RenderShadowMap
// FUNCTION
//   Called automatically. This is an advanced command to take control of the render pipeline. Normally 
//   <i>Render</i> calls RenderShadowMap, Render2DBack, Render3D, Render2DFront to draw
//   everything in the world. This command only calculates the shadow map.
// SOURCE
void agk::RenderShadowMap( )
//****
{
	if ( !g_pRenderer ) return;

	ARControlCamera();

	g_pRenderer->ResetDrawStats();

	if ( m_iShadowMode == 0 ) return;
	if ( m_cDirectionalLight.m_active == 0 ) return;

	if ( !m_pShadowMap ) 
	{
		m_pShadowMap = new cImage();
		m_pShadowMap->CreateBlankImage( m_iShadowMapWidth, m_iShadowMapHeight, 1, 0 );
		m_pShadowMap->SetMagFilter( 1 ); m_pShadowMap->SetMinFilter( 1 );
	}

	if ( !m_pShadowMap2 && m_iShadowMode == 3 ) // cascade
	{
		m_pShadowMap2 = new cImage();
		m_pShadowMap3 = new cImage();
		m_pShadowMap4 = new cImage();
		m_pShadowMap2->CreateBlankImage( m_iShadowMapWidth, m_iShadowMapHeight, 1, 0 );
		m_pShadowMap3->CreateBlankImage( m_iShadowMapWidth, m_iShadowMapHeight, 1, 0 );
		m_pShadowMap4->CreateBlankImage( m_iShadowMapWidth, m_iShadowMapHeight, 1, 0 );
		m_pShadowMap2->SetMagFilter( 1 ); m_pShadowMap2->SetMinFilter( 1 );
		m_pShadowMap3->SetMagFilter( 1 ); m_pShadowMap3->SetMinFilter( 1 );
		m_pShadowMap4->SetMagFilter( 1 ); m_pShadowMap4->SetMinFilter( 1 );
	}

	if ( !m_pShadowMapFBO ) m_pShadowMapFBO = AGKFrameBuffer::FindFrameBuffer( 0, m_pShadowMap, false );
	if ( !m_pShadowMapFBO ) 
	{
		m_pShadowMapFBO = new AGKFrameBuffer( 0, false, m_pShadowMap, true, false );
		m_pShadowMapFBO->SetShadow();
	}

	if ( AGKFrameBuffer::g_pCurrFrameBuffer == 0 && g_pRenderer->GetRenderPassStarted() )
	{
		agk::Error( "RenderShadowMap() must be called before drawing anything to the screen" );
		return;
	}

	AGKFrameBuffer *pOldFBO = AGKFrameBuffer::g_pCurrFrameBuffer;
	AGKFrameBuffer::BindFrameBuffer( m_pShadowMapFBO );

	// must bind before StartShadowFrameBuffer as an in-progress render pass will prevent the image barrier
	
	if ( m_iShadowMode == 3 ) // cascade
	{
		if ( !m_pShadowMapFBO2 ) m_pShadowMapFBO2 = AGKFrameBuffer::FindFrameBuffer( 0, m_pShadowMap2, false );
		if ( !m_pShadowMapFBO2 ) 
		{
			m_pShadowMapFBO2 = new AGKFrameBuffer( 0, false, m_pShadowMap2, true, false );
			m_pShadowMapFBO2->SetShadow();
		}
		if ( !m_pShadowMapFBO3 ) m_pShadowMapFBO3 = AGKFrameBuffer::FindFrameBuffer( 0, m_pShadowMap3, false );
		if ( !m_pShadowMapFBO3 ) 
		{
			m_pShadowMapFBO3 = new AGKFrameBuffer( 0, false, m_pShadowMap3, true, false );
			m_pShadowMapFBO3->SetShadow();
		}
		if ( !m_pShadowMapFBO4 ) m_pShadowMapFBO4 = AGKFrameBuffer::FindFrameBuffer( 0, m_pShadowMap4, false );
		if ( !m_pShadowMapFBO4 ) 
		{
			m_pShadowMapFBO4 = new AGKFrameBuffer( 0, false, m_pShadowMap4, true, false );
			m_pShadowMapFBO4->SetShadow();
		}

		g_pRenderer->StartShadowFrameBuffers( m_pShadowMapFBO->m_pInternalResource, m_pShadowMapFBO2->m_pInternalResource, m_pShadowMapFBO3->m_pInternalResource, m_pShadowMapFBO4->m_pInternalResource );
	}
	else
	{
		g_pRenderer->StartShadowFrameBuffer( m_pShadowMapFBO->m_pInternalResource );
	}
		
	g_pRenderer->SetViewport( 0, 0, m_iShadowMapWidth, m_iShadowMapHeight );
	g_pRenderer->ClearRenderTarget( 0,0,0,0 );
	
	cMesh::g_shadowRenderState.OverrideScissor( 1 );

	int shadowMode = m_iShadowMode;
	
	// get center point of frustum for light space transform
	const AGKQuaternion camRot = agk::m_pCurrentCamera->rotFinal();
	AGKVector camLook(0,0,1);
	camLook.Mult( camRot );

	float dotp = camLook.Dot( m_cDirectionalLight.m_direction );
	if ( agk::Abs(dotp) > 0.9f && shadowMode == 2 ) shadowMode = 1;
	
	float fNear = agk::m_pCurrentCamera->GetNearRange(); 
	float fFar = agk::m_pCurrentCamera->GetFarRange();
	if ( m_fShadowRange > 0 && fFar > m_fShadowRange ) fFar = m_fShadowRange; // far range can be limited to less then the frustum
	AGKVector centerPoint( 0,0,(fNear+fFar)/2.0f );
	centerPoint.Mult( camRot );
	centerPoint += agk::m_pCurrentCamera->posFinal();

	AGKQuaternion lightDir;
	AGKMatrix4 view;
	if ( shadowMode == 1 || shadowMode == 3 )
	{
		// use a non-rotated lightspace transform to avoid shimmering
		lightDir.LookAtDiscrete( m_cDirectionalLight.m_direction.x, m_cDirectionalLight.m_direction.y, m_cDirectionalLight.m_direction.z, 0, m_fShadowLightStep );
		view.MakeInvWorld( lightDir, centerPoint, AGKVector(1,1,1) );
	}
	else
	{
		// create light space transform that keeps the camera frustum horizontal (right to left) in the shadow map
		AGKVector right; 
		AGKVector up; up.Cross( m_cDirectionalLight.m_direction, camLook );
		if ( up.SqrLength() <= 0.00001 ) 
		{
			up.Set( 0,1,0 );
			right.Cross( m_cDirectionalLight.m_direction, up );
			right.Normalize();
			up.Cross( right, m_cDirectionalLight.m_direction );
			up.Normalize();
		}
		else 
		{
			up.Normalize();
			right.Cross( m_cDirectionalLight.m_direction, up );
			right.Normalize();
		}
		AGKMatrix3 lightRot; 
		lightRot.MakeFromAxes( right, up, m_cDirectionalLight.m_direction );
		//lightRot.MakeFromAxes( up, -m_cDirectionalLight.m_direction, -right );

		view.MakeInvWorld( lightRot, centerPoint, AGKVector(1,1,1) );
	}

	if ( shadowMode == 1 ) // Uniform shadow mapping
	{
		// find the best extent for the light space ortho matrix to enclose the camera frustum
		AGKVector points[8];
		agk::m_pCurrentCamera->GetFrustumPoints( fNear, points );
		agk::m_pCurrentCamera->GetFrustumPoints( fFar, points+4 );

		AGKVector min; min.Set(100000000,100000000,100000000); 
		AGKVector max; max.Set(-100000000,-100000000,-100000000);
		for( int i = 0; i < 8; i++ ) 
		{
			points[i].Mult( view ); 
			if ( points[i].x > max.x ) max.x = points[i].x; if ( points[i].x < min.x ) min.x = points[i].x;
			if ( points[i].y > max.y ) max.y = points[i].y; if ( points[i].y < min.y ) min.y = points[i].y;
			if ( points[i].z > max.z ) max.z = points[i].z; if ( points[i].z < min.z ) min.z = points[i].z;
		}

		// adjust the box to the nearest log size so it doesn't change frequently, causing shimmering
		float logDiffX = (float) agk::Ceil( log(max.x-min.x)/log(1.3f) );
		float logDiffY = (float) agk::Ceil( log(max.y-min.y)/log(1.3f) );
		float limitX = pow(1.3f,logDiffX);
		float limitY = pow(1.3f,logDiffY);

		float diffX = limitX / (float)m_iShadowMapWidth;
		float diffY = limitY / (float)m_iShadowMapHeight;
		
		// now shadow volume size is known, modify the light view matrix to the nearest texel
		centerPoint.Mult( -lightDir );
		centerPoint.x = agk::Round(centerPoint.x / diffX) * diffX;
		centerPoint.y = agk::Round(centerPoint.y / diffY) * diffY;
		centerPoint.Mult( lightDir );
		view.MakeInvWorld( lightDir, centerPoint, AGKVector(1,1,1) );
		
		// find new bounding box values
		float avgX = (min.x+max.x) / 2.0f;
		float avgY = (min.y+max.y) / 2.0f;

		avgX = agk::Round(avgX / diffX) * diffX;
		avgY = agk::Round(avgY / diffY) * diffY;

		min.x = avgX - (limitX/2.0f);
		max.x = avgX + (limitX/2.0f);

		min.y = avgY - (limitY/2.0f);
		max.y = avgY + (limitY/2.0f);

		// swap Y values to conteract FBO inversion, although probably doesn't matter
		float minY = min.y;
		float maxY = max.y;
		if ( g_pRenderer->IsFBOFlipped() ) { minY = max.y; maxY = min.y; }

		if ( g_pRenderer->SupportsDepthClamp() )
		{
			float correction1 = (max.z - min.z) / 10.0f;

			cMesh::g_shadowRenderState.SetDepthClampEnable( 1 );
			AGKMatrix4 ortho, proj; 
			
			ortho.MakeOrtho( min.x, max.x, minY, maxY, min.z-correction1, max.z ); // include slightly more than necessary to allow depth based smoothing
			proj.Set( view.GetFloatPtr() );
			proj.Mult( ortho );
			AGKShader::g_varShadowProj.SetMatrix4( proj.GetFloatPtr() );
			
			m_cObjectMgr.DrawShadowMap();
		}
		else
		{
			// directional light uses an orthographic projection, first pass squashes everything outside the camera frustum onto 0 in the depth buffer
			AGKMatrix4 ortho, proj; 
			// values below -100000 have accuracy problems on some Android devices
			ortho.MakeOrtho( min.x, max.x, minY, maxY, min.z-100000, min.z ); // swap Y values to conteract FBO inversion, although probably doesn't matter, -10 to keep the overlap point outside the camera view
			proj.Set( view.GetFloatPtr() );
			proj.Mult( ortho );
			AGKShader::g_varShadowProj.SetMatrix4( proj.GetFloatPtr() );
			cMesh::g_shadowRenderState.SetDepthRange( 0, 0.01f ); // if both values are 0 then Android won't clip on the far plane. Values below 0.01 have accuracy problems on some Android devices

			// draw managed objects outside the camera frustum
			m_cObjectMgr.DrawShadowMap();

			float correction1 = (max.z - min.z) / 10.0f;
	
			// second pass draws everything inside the camera frustum at normal depth values (0 to 1)
			ortho.MakeOrtho( min.x, max.x, minY, maxY, min.z-correction1, max.z ); // overlap slightly with the previous ortho matrix to correct some artifacts
			proj.Set( view.GetFloatPtr() );
			proj.Mult( ortho );
			AGKShader::g_varShadowProj.SetMatrix4( proj.GetFloatPtr() );
			cMesh::g_shadowRenderState.SetDepthRange( 0, 1 );

			// draw managed objects in the camera frustum
			m_cObjectMgr.DrawShadowMap();
		}
	}
	else if ( shadowMode == 2 ) // Light space perspective shadow mapping
	{
		// find the best extent for the light space ortho matrix to enclose the camera frustum
		AGKVector points[8];
		agk::m_pCurrentCamera->GetFrustumPoints( fNear, points );
		agk::m_pCurrentCamera->GetFrustumPoints( fFar, points+4 );

		AGKVector min; min.Set(100000000,100000000,100000000); 
		AGKVector max; max.Set(-100000000,-100000000,-100000000);
		for( int i = 0; i < 8; i++ ) 
		{
			points[i].Mult( view ); 
			if ( points[i].x > max.x ) max.x = points[i].x; if ( points[i].x < min.x ) min.x = points[i].x;
			if ( points[i].y > max.y ) max.y = points[i].y; if ( points[i].y < min.y ) min.y = points[i].y;
			if ( points[i].z > max.z ) max.z = points[i].z; if ( points[i].z < min.z ) min.z = points[i].z;
		}

		float modifier = agk::Sqrt(1.0f - dotp*dotp);

		float zn = 1 / modifier; // should be fNear/modifier but fNear less than 1 reduces quality signifcantly
		float zf = zn + (max.x-min.x)*modifier;
		float n = (zn + sqrt(zf*zn)) / modifier;
		float f = n + (max.x-min.x);
		float shift = n + max.x;
		view.mat[3][0] -= shift;
		n = -n;
		f = -f;
	
		AGKMatrix4 lightProj;
		lightProj.mat[0][0] = ((f + n)/(f - n));
		lightProj.mat[1][1] = 1;
		lightProj.mat[2][2] = 1;
		lightProj.mat[0][3] = -1;
		lightProj.mat[3][0] = -((2.0f * f * n)/(f - n));
		lightProj.mat[3][3] = 0.0f;
		view.Mult( lightProj );

		//uString info; info.Format( "MinZ: %f, MaxZ: %f", min.z, max.z );
		//agk::Print( info );
				
		agk::m_pCurrentCamera->GetFrustumPoints( fNear, points );
		agk::m_pCurrentCamera->GetFrustumPoints( fFar, points+4 );

		AGKVector min2; min2.Set(100000000,100000000,100000000); 
		AGKVector max2; max2.Set(-100000000,-100000000,-100000000);
		for( int i = 0; i < 8; i++ )
		{
			points[i].MultPerspective( view ); 
			if ( points[i].x > max2.x ) max2.x = points[i].x; if ( points[i].x < min2.x ) min2.x = points[i].x;
			if ( points[i].y > max2.y ) max2.y = points[i].y; if ( points[i].y < min2.y ) min2.y = points[i].y;
			if ( points[i].z > max2.z ) max2.z = points[i].z; if ( points[i].z < min2.z ) min2.z = points[i].z;
		}

		//info.Format( "MinZ: %f, MaxZ: %f", min2.z, max2.z );
		//agk::Print( info );

		// swap Y values to conteract FBO inversion, although probably doesn't matter
		float min2Y = min2.y;
		float max2Y = max2.y;
		if ( g_pRenderer->IsFBOFlipped() ) { min2Y = max2.y; max2Y = min2.y; }

		if ( g_pRenderer->SupportsDepthClamp() )
		{
			cMesh::g_shadowRenderState.SetDepthClampEnable( 1 );
			AGKMatrix4 ortho, proj; 
			ortho.MakeOrtho( min2.x, max2.x, min2Y, max2Y, min2.z*2, max2.z ); // include slightly more than necessary to allow depth based smoothing
			proj.Set( view.GetFloatPtr() );
			proj.Mult( ortho );
			AGKShader::g_varShadowProj.SetMatrix4( proj.GetFloatPtr() );
			
			m_cObjectMgr.DrawShadowMap();
		}
		else
		{
			AGKMatrix4 ortho, proj;
			// values below -100000 have accuracy problems on some Android devices
			ortho.MakeOrtho( min2.x, max2.x, min2Y, max2Y, min2.z*100000, min2.z*2 ); 
			proj.Set( view.GetFloatPtr() );
			proj.Mult( ortho );
			AGKShader::g_varShadowProj.SetMatrix4( proj.GetFloatPtr() );
			cMesh::g_shadowRenderState.SetDepthRange( 0, 0.01f ); // if both values are 0 then Android won't clip on the far plane. Values below 0.01 have accuracy problems on some Android devices

			// draw managed objects outside the camera frustum
			m_cObjectMgr.DrawShadowMap();

			// second pass draws everything inside the camera frustum at normal depth values (0 to 1)
			ortho.MakeOrtho( min2.x, max2.x, min2Y, max2Y, min2.z*2.1f, max2.z );
			proj.Set( view.GetFloatPtr() );
			proj.Mult( ortho );
			AGKShader::g_varShadowProj.SetMatrix4( proj.GetFloatPtr() );
			cMesh::g_shadowRenderState.SetDepthRange( 0, 1 );

			// draw managed objects in the camera frustum
			m_cObjectMgr.DrawShadowMap();
		}
	}
	else if ( shadowMode == 3 ) // cascade shadow mapping
	{
		AGKMatrix4 shadowProj[ 4 ];
		// cascades now defined by user
		float cascades[4] = { 1.0f, m_fShadowCascade3, m_fShadowCascade2, m_fShadowCascade1 };
		//float cascades[4] = { 1.0f, 0.5f, 0.25f, 0.125f };
		//float cascades[4] = { 1.0f, 0.367879441f, 0.135335283f, 0.049787068f };

		for( int i = 0; i < 4; i++ )
		{
			if ( i == 1 ) AGKFrameBuffer::BindFrameBuffer( m_pShadowMapFBO2 );
			else if ( i == 2 ) AGKFrameBuffer::BindFrameBuffer( m_pShadowMapFBO3 );
			else if ( i == 3 ) AGKFrameBuffer::BindFrameBuffer( m_pShadowMapFBO4 );
			if ( i > 0 ) g_pRenderer->ClearRenderTarget(0,0,0,0);

			float newFar = fNear + cascades[i]*(fFar-fNear);

			// find the best extent for the light space ortho matrix to enclose the camera frustum
			AGKVector points[8];
			agk::m_pCurrentCamera->GetFrustumPoints( fNear, points );
			agk::m_pCurrentCamera->GetFrustumPoints( newFar, points+4 );

			AGKVector min; min.Set(100000000,100000000,100000000); 
			AGKVector max; max.Set(-100000000,-100000000,-100000000);
			for( int j = 0; j < 8; j++ ) 
			{
				points[j].Mult( view ); 
				if ( points[j].x > max.x ) max.x = points[j].x; if ( points[j].x < min.x ) min.x = points[j].x;
				if ( points[j].y > max.y ) max.y = points[j].y; if ( points[j].y < min.y ) min.y = points[j].y;
				if ( points[j].z > max.z ) max.z = points[j].z; if ( points[j].z < min.z ) min.z = points[j].z;
			}

			// adjust the box to the nearest log size so it doesn't change frequently, causing shimmering
			float logDiffX = (float) agk::Ceil( log(max.x-min.x)/log(1.3f) );
			float logDiffY = (float) agk::Ceil( log(max.y-min.y)/log(1.3f) );
			float limitX = pow(1.3f,logDiffX);
			float limitY = pow(1.3f,logDiffY);

			float diffX = limitX / (float)m_iShadowMapWidth;
			float diffY = limitY / (float)m_iShadowMapHeight;

			// now shadow volume size is known, modify the light view matrix to the nearest texel
			centerPoint.Mult( -lightDir );
			centerPoint.x = agk::Round(centerPoint.x / diffX) * diffX;
			centerPoint.y = agk::Round(centerPoint.y / diffY) * diffY;
			centerPoint.Mult( lightDir );
			view.MakeInvWorld( lightDir, centerPoint, AGKVector(1,1,1) );

			// find new bounding box values
			float avgX = (min.x+max.x) / 2.0f;
			float avgY = (min.y+max.y) / 2.0f;

			avgX = agk::Round(avgX / diffX) * diffX;
			avgY = agk::Round(avgY / diffY) * diffY;

			min.x = avgX - (limitX/2.0f);
			max.x = avgX + (limitX/2.0f);

			min.y = avgY - (limitY/2.0f);
			max.y = avgY + (limitY/2.0f);

			// swap Y values to conteract FBO inversion, although probably doesn't matter
			float minY = min.y;
			float maxY = max.y;
			if ( g_pRenderer->IsFBOFlipped() ) { minY = max.y; maxY = min.y; }

			
			if ( g_pRenderer->SupportsDepthClamp() )
			{
				float correction1 = (max.z - min.z) / 10.0f;

				cMesh::g_shadowRenderState.SetDepthClampEnable( 1 );
				AGKMatrix4 ortho; 
				ortho.MakeOrtho( min.x, max.x, minY, maxY, min.z-correction1, max.z ); // include slightly more than necessary to allow depth based smoothing
				shadowProj[i].Set( view.GetFloatPtr() );
				shadowProj[i].Mult( ortho );
				AGKShader::g_varShadowProj.SetMatrix4( shadowProj[i].GetFloatPtr() );
			
				m_cObjectMgr.DrawShadowMap();
			}
			else
			{
				// directional light uses an orthographic projection, first pass squashes everything outside the camera frustum onto 0 in the depth buffer
				AGKMatrix4 ortho;
				// values below -100000 have accuracy problems on some Android devices
				ortho.MakeOrtho( min.x, max.x, minY, maxY, min.z-100000, min.z );
				shadowProj[i].Set( view.GetFloatPtr() );
				shadowProj[i].Mult( ortho );
				AGKShader::g_varShadowProj.SetMatrix4( shadowProj[i].GetFloatPtr() );
				cMesh::g_shadowRenderState.SetDepthRange( 0, 0.01f ); // if both values are 0 then Android won't clip on the far plane. Values below 0.01 have accuracy problems on some Android devices
		
				// draw managed objects outside the camera frustum
				m_cObjectMgr.DrawShadowMap();

				float correction1 = (max.z - min.z) / 5.0f;
				// second pass draws everything inside the camera frustum at normal depth values (0 to 1)
				ortho.MakeOrtho( min.x, max.x, minY, maxY, min.z-correction1, max.z ); // overlap slightly with the previous ortho matrix to correct some artifacts
				shadowProj[i].Set( view.GetFloatPtr() );
				shadowProj[i].Mult( ortho );
				AGKShader::g_varShadowProj.SetMatrix4( shadowProj[i].GetFloatPtr() );
				cMesh::g_shadowRenderState.SetDepthRange( 0, 1 );

				// draw managed objects in the camera frustum
				m_cObjectMgr.DrawShadowMap();
			}
		}

		AGKShader::g_varShadowProj.SetMatrix4( shadowProj[0].GetFloatPtr() );
		AGKShader::g_varShadowProj2.SetMatrix4( shadowProj[1].GetFloatPtr() );
		AGKShader::g_varShadowProj3.SetMatrix4( shadowProj[2].GetFloatPtr() );
		AGKShader::g_varShadowProj4.SetMatrix4( shadowProj[3].GetFloatPtr() );

		float diff = fFar-fNear;
		AGKShader::g_varShadowParams2.SetVector4( fNear+diff*cascades[0], fNear+diff*cascades[1], fNear+diff*cascades[2], fNear+diff*cascades[3] );
	}
	
	// restore default frame buffer
	AGKFrameBuffer::BindFrameBuffer( pOldFBO );

	if ( m_pShadowMapFBO2 ) 
	{
		g_pRenderer->CompleteShadowFrameBuffers( m_pShadowMapFBO->m_pInternalResource, m_pShadowMapFBO2->m_pInternalResource, m_pShadowMapFBO3->m_pInternalResource, m_pShadowMapFBO4->m_pInternalResource );
	}
	else
	{
		g_pRenderer->CompleteShadowFrameBuffer( m_pShadowMapFBO->m_pInternalResource );
	}
		
	if( pOldFBO ) g_pRenderer->SetViewport( 0, 0, pOldFBO->GetWidth(), pOldFBO->GetHeight() );
	else g_pRenderer->SetViewport( 0, 0, agk::m_iRenderWidth, agk::m_iRenderHeight );

	m_iShadowPolygonsDrawn = g_pRenderer->GetPolygonsDrawn();
}

//****f* Core/Display/Render3D
// FUNCTION
//   Called automatically. This is an advanced command to take control of the render pipeline. Normally 
//   <i>Render</i> calls RenderShadowMap, Render2DBack, Render3D, Render2DFront to draw
//   everything in the world. This command only draws the 3D objects.
// SOURCE
void agk::Render3D( )
//****
{
	if ( !g_pRenderer ) return;

	ARControlCamera();

	float startTime = agk::Timer();
	g_pRenderer->ResetDrawStats();
	
	// draw managed objects
	m_cObjectMgr.DrawAll();
	if ( m_cObjectMgr.GetDrawnCount() > 0 ) m_iDrawingCount++;

	m_iPolygonsDrawn = g_pRenderer->GetPolygonsDrawn();
	m_iVerticesProcessed = g_pRenderer->GetVerticesProcessed();

	AGK3DParticleEmitter::m_iParticlesDrawn = 0;
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetFirst();
	while ( pEmitter )
	{
		pEmitter->DrawAll();
		pEmitter = m_3DParticleEmitterList.GetNext();
	}

	m_f3DDrawingSetupTime = agk::Timer() - startTime;
}

//****f* Core/Display/Swap
// FUNCTION
//   Displays the back buffer to the screen and clears the backbuffer for the next frame, updates global time variables.
//   Called automatically by <i>Sync</i>, you may either use <i>Sync</i> or <i>Update</i>, <i>Render</i>, <i>Swap</i> one after the other to manually
//   sync.
// SOURCE
void agk::Swap()
//****
{
	m_iResumed2 = 0;
    
    // only want to do this once per frame, so Swap seems like a good place to put it
	UpdateInput();
	CheckLocalNotifications();
	AGKMusicOGG::UpdateAll();
	
	float startTime = agk::Timer();
	
	if ( g_pRenderer ) 
	{
		if ( !g_bIsExternal ) g_pRenderer->Swap();
		else 
		{
			if ( SwapExternal ) SwapExternal( g_pSwapParam );
		}

		PlatformSync();

		// HTML5 has a slightly different order of events, the swap isn't done until control is handed back to the browser, so doing a clear here overwrites everything we've done
#ifndef AGK_HTML5
		if ( AGKFrameBuffer::g_pCurrFrameBuffer == 0 ) 
		{
			ClearScreen();
			m_iDefaultFBCleared = 1;
		}
#endif

		VideoUpdate();
		DeviceCameraUpdate();
		ARUpdateInternal();
	}

	m_fDrawingTime = agk::Timer() - startTime;
	
	float waittime = agk::Timer();
	
	if ( m_fSyncTime > 0 && m_iSyncMode < 2 ) // m_iSyncMode=2 is vsync
	{
		PlatformUpdateTime();

		// sleep to save cpu, less accurate, prone to jumping
		if ( m_iSyncMode == 0 )
		{
			double fTimeSoFar = m_fTimeCurr - m_fTimeLimitFrameStart;
			int ms = agk::Floor( (float)(m_fSyncTime - fTimeSoFar) * 1000 );
			if ( ms > 3 ) agk::Sleep( ms-3 );
		}
		
		// busy waiting
		PlatformUpdateTime();
		while ( m_fTimeCurr - m_fTimeLimitFrameStart < m_fSyncTime )
		{
			PlatformUpdateTime();
		}
	}

	waittime = agk::Timer() - waittime;

	// update timer vars
	PlatformUpdateTime();
	m_fTimeLimitFrameStart = m_fTimeCurr;

	m_fTimeDelta = (float) (m_fTimeCurr - m_fTimeFrameStart);
	m_fTimeFrameStart = m_fTimeCurr;
	// end of frame

	float fFps = 60;
	if ( m_fTimeDelta > 0 ) fFps = 1.0f / m_fTimeDelta;
	m_fFps = 0.95f*m_fFps + 0.05f*fFps;

	// do not attempt to interpolate slower than 5 fps, if there was a hiccup in rendering everything would jump.
	if ( m_fTimeDelta > 0.2f ) m_fTimeDelta = 0.2f;
}

//****f* Core/Display/SetPresentMode
// FUNCTION
//   Controls when the <i>Swap</i> and <i>Sync</i> commands present the back buffer to the screen. This can either be delayed 
//   (mode=0) or immediate (mode=1), the default is immediate. Immediate mode has the lowest latency but some implementations 
//   of Vulkan have a performance hit if they try to present immediately after finishing drawing to the back buffer, so delayed 
//   mode should give more consistent performance. In delayed mode the Sync command will first present the previous frame to the 
//   screen and then draw the current frame. The current frame will not be presented until the next call to <i>Sync</i>. This is 
//   particularly apparent during loading screens where if you update the loading bar and then call Sync() the new loading bar 
//   would not immediately appear on screen when using delayed mode.
// INPUTS
//   mode -- 0 for delayed rendering, 1 to immediate rendering
// SOURCE
void agk::SetPresentMode( int mode )
//****
{
	if ( !g_pRenderer ) return;
	g_pRenderer->SetPresentMode( (uint32_t) mode );
}

//****f* Core/Display/ForcePresent
// FUNCTION
//   If the current renderer is using delayed present then you can use this command to force the present to 
//   happen now. You can turn delayed presenting on and off using <i>SetPresentMode</i>.
// SOURCE
void agk::ForcePresent()
//****
{
	if ( !g_pRenderer ) return;
	g_pRenderer->ForcePresent();
}

//****f* Core/Display/ClearScreen
// FUNCTION
//   Clears the screen or the current render target if using <i>SetRenderToImage</i>. If you do not clear then the 
//   contents of the screen or render target are undefined. This is fine as long as you will be drawing to every 
//   single pixel, e.g. when drawing a fullscreen quad.
// SOURCE
void agk::ClearScreen()
//****
{
	if ( !g_pRenderer ) return;

	m_iNumLineVertices = 0;
	
	if ( m_fTargetViewportX == 0 && m_fTargetViewportY == 0 )
	{
		// no borders	
		g_pRenderer->ClearRenderTarget( m_fClearRed, m_fClearGreen, m_fClearBlue, 0 );
	}
	else
	{
		// clear borders then clear main drawing area
		g_pRenderer->ClearRenderTarget( m_fBorderRed, m_fBorderGreen, m_fBorderBlue, 0 );
		
		// check if we need to clear again
		if ( m_fBorderRed != m_fClearRed || m_fBorderGreen != m_fClearGreen || m_fBorderBlue != m_fClearBlue )
		{
			static cSprite* g_pClearSprite = 0;
			if ( !g_pClearSprite ) g_pClearSprite = new cSprite();
			g_pClearSprite->SetSize( (float)agk::GetVirtualWidth(), (float)agk::GetVirtualHeight() );
			g_pClearSprite->SetColorF( m_fClearRed, m_fClearGreen, m_fClearBlue );
			g_pClearSprite->SetTransparency( 0 );
			g_pClearSprite->Draw();
		}
	}
}

//****f* Core/Display/ClearDepthBuffer
// FUNCTION
//   Immediately clears the depth buffer for the current render target. This command is normally not needed as 
//   the depth buffer is cleared automatically at the start of rendering. Using this command may negatively 
//   affect performance.
// SOURCE
void agk::ClearDepthBuffer()
//****
{
	if ( !g_pRenderer ) return;
	g_pRenderer->ClearDepthBuffer();
}

//****f* Core/Misc/SetGenerateMipmaps
// FUNCTION
//   Sets whether loaded images having mipmaps generated and used. Should be called before any images are loaded.
//   May be changed before another image is loaded to make some use mipmaps and others not.
// INPUTS
//   generate -- Set to 1 to generate mipmaps (default is 0)
// SOURCE
void agk::SetGenerateMipmaps( int generate )
//****
{
	m_bGenerateMipmaps = generate > 0;
}

//****f* Core/Misc/Timer
// FUNCTION
//   Get the number of seconds and fractions of seconds since the app was started. Accurate to milliseconds, but due 
//   to floating point inaccuracies the longer the app is running the less accurate this becomes. More specifically 
//   the time value has about 7 significant figures of accuracy, so as the number of seconds gets higher the number 
//   of decimal places decreases. If you only need the time to the nearest second then this value will be fine up to
//   about 16,000,000 seconds.
//   <br><br> 
//   Calling this command will internally make a system call to get the amount of time passed, so it will change every
//   time you call it.
// SOURCE
float agk::Timer()
//****
{
	PlatformUpdateTime();
	return (float) (m_fTimeCurr - m_fTimeStart);
}

//****f* Core/Misc/ResetTimer
// FUNCTION
//   Resets the time returned from <i>Timer</i> to 0. This allows the full accuracy to be regained after your app has been
//   running for some time. This also resets the values returned by <i>GetSeconds</i> and <i>GetMilliseconds</i> to 0.
// SOURCE
void agk::ResetTimer()
//****
{
	m_fTimeLimitFrameStart -= m_fTimeCurr;
	m_fTimeFrameStart -= m_fTimeCurr;
	PlatformResetTime();
}

float agk::GetRunTime()
//****
{
	PlatformUpdateTime();
	return (float) (m_fTimeCurr - m_fTimeStart);
}

//****f* Core/Misc/GetSeconds
// FUNCTION
//   Get the number of whole seconds since the app was started. Accurate to 1 second. <br><br>
//   Calling this command will internally make a system call to get the amount of time passed, 
//   so it may change each time you call it.
// SOURCE
int agk::GetSeconds()
//****
{
	PlatformUpdateTime();
	return Floor((float)(m_fTimeCurr - m_fTimeStart));
}

//****f* Core/Misc/GetFrameTime
// FUNCTION
//   Get the time in seconds spent processing and rendering the last frame. Only updated when <i>Sync</i> or <i>Swap</i> are called.
//   This is limited to a max value of 0.2 seconds to prevent internal timer based code from interpolating large time gaps.
//   To find the true frame time you can use the Timer() command.
// SOURCE
float agk::GetFrameTime()
//****
{
	return m_fTimeDelta;
}

//****f* Core/Misc/GetMilliseconds
// FUNCTION
//   Get the number of milliseconds since the app was started. Calling this command will internally 
//   make a system call to get the amount of time passed, so it may change each time you call it.
// SOURCE
uint32_t agk::GetMilliseconds()
//****
{
	PlatformUpdateTime();
	return m_iTimeMilliseconds;
}

//****f* Core/Misc/SetAntialiasMode
// FUNCTION
//   Sets whether the device should using anti-aliasing when rendering to the back buffer. Currently 
//   this only applies to OpenGL on Windows, Mac, and Linux, and only 4x multi-sampling is available.
//   This does not apply to any objects drawn to an image with <i>SetRenderToImage</i>, only the back buffer 
//   is anti-aliased.
// INPUTS
//   mode -- 0=off, 1=4xMSAA
// SOURCE
void agk::SetAntialiasMode( int mode )
//****
{
	if ( !g_pRenderer ) return;
	g_pRenderer->SetAntialiasMode( mode );
}

//****f* Core/Misc/GetDeviceID
// FUNCTION
//   Returns a string that can be used to identify this device
// SOURCE
char* agk::GetDeviceID()
//****
{
	uString out;
	agk::PlatformGetDeviceID( out );
	char* str = new char[ out.GetLength()+1 ];
	strcpy( str, out.GetStr() );
	return str;
}

void agk::GetDeviceID( uString &out )
{
	agk::PlatformGetDeviceID( out );
}

//****f* Core/Misc/GetNumProcessors
// FUNCTION
//   Returns the number of logical processor cores on the device
// SOURCE
int agk::GetNumProcessors()
//****
{
	if ( m_iNumProcessors == 0 ) m_iNumProcessors = agk::PlatformGetNumProcessors();
	return m_iNumProcessors;
}

//****f* Core/Misc/Sha1
// FUNCTION
//   Hashes a string using the SHA1 algorithm to produce a 40 character hexadecimal string. This is a one way hash function
//   that can be used with salting (appending a secret string) for passwords or tamper detection in parameters passed to a
//   server. If you are calling this function from Tier 2 then you must delete the returned string with agk::DeleteString with DeleteString() when 
//   you are done with it.
// INPUTS
//   str -- The string to hash
// SOURCE
char* agk::Sha1( const char* str )
//****
{
	SHA1 sha;
	sha.Input( str, (uint32_t)strlen(str) );

	uint32_t result[ 5 ];
	sha.Result( &(result[0]) );

	char *strout = new char[ 41 ];
	sprintf( strout, "%08X%08X%08X%08X%08X", result[ 0 ], result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] );

	return strout;
}

void agk::Sha1( const char* str, uString &out )
{
	SHA1 sha;
	sha.Input( str, (uint32_t)strlen(str) );

	uint32_t result[ 5 ];
	sha.Result( &(result[0]) );

	out.Format( "%08X%08X%08X%08X%08X", result[ 0 ], result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] );
}

//****f* Core/Misc/Sha256
// FUNCTION
//   Hashes a string using the SHA256 algorithm to produce a 32 character hexadecimal string. This is a one way hash function
//   that can be used with salting (appending a secret string) for passwords or tamper detection in parameters passed to a
//   server. If you are calling this function from Tier 2 then you must delete the returned string with agk::DeleteString when you are done with it.
// INPUTS
//   str -- The string to hash
// SOURCE
char* agk::Sha256( const char* str )
//****
{
	return sha256(str);
}

//****f* Core/Misc/Sha512
// FUNCTION
//   Hashes a string using the SHA512 algorithm to produce a 64 character hexadecimal string. This is a one way hash function
//   that can be used with salting (appending a secret string) for passwords or tamper detection in parameters passed to a
//   server. If you are calling this function from Tier 2 then you must delete the returned string with agk::DeleteString when you are done with it.
// INPUTS
//   str -- The string to hash
// SOURCE
char* agk::Sha512( const char* str )
//****
{
	return sha512(str);
}

//****f* HTTP/Encoding/HTTPEncode
// FUNCTION
//   Encodes a string so that it can be sent to a server via HTTP without interfering with the HTTP request.
//   For example if you wanted to send a POST variable that contained the characters & or = these would
//   look like additional variables inside the string you want to send. Using HTTPEncode on this string
//   would turn these characters into POST safe values which are then automatically converted back to their
//   original characters once they reach something like a PHP script. This uses standard URL encoding for
//   non-alphanumeric characters leaving alphanumeric characters alone.
// INPUTS
//   str -- The string to encode
// SOURCE
char* agk::HTTPEncode( const char* str )
//****
{
	uString out;
	HTTPEncode( str, out );

	char *strout = new char[ out.GetLength()+1 ];
	strcpy( strout, out.GetStr() );
	return strout;
}

void agk::HTTPEncode( const char* str, uString &out )
{
	out.SetStr("");

	int numBytes;
	while ( *str )
	{
		int c = uString::DecodeUTF8Char( str, &numBytes );

		switch( c )
		{
			case ' ': out.AppendUTF8( "%20" ); break;
			case '!': out.AppendUTF8( "%21" ); break;
			case '"': out.AppendUTF8( "%22" ); break;
			case '#': out.AppendUTF8( "%23" ); break;
			case '$': out.AppendUTF8( "%24" ); break;
			case '%': out.AppendUTF8( "%25" ); break;
			case '&': out.AppendUTF8( "%26" ); break;
			case '\'': out.AppendUTF8( "%27" ); break;
			case '(': out.AppendUTF8( "%28" ); break;
			case ')': out.AppendUTF8( "%29" ); break;
			case '*': out.AppendUTF8( "%2A" ); break;
			case '+': out.AppendUTF8( "%2B" ); break;
			case ',': out.AppendUTF8( "%2C" ); break;
			case '-': out.AppendUTF8( "%2D" ); break;
			case '.': out.AppendUTF8( "%2E" ); break;
			case '/': out.AppendUTF8( "%2F" ); break;
			case ':': out.AppendUTF8( "%3A" ); break;
			case ';': out.AppendUTF8( "%3B" ); break;
			case '<': out.AppendUTF8( "%3C" ); break;
			case '=': out.AppendUTF8( "%3D" ); break;
			case '>': out.AppendUTF8( "%3E" ); break;
			case '?': out.AppendUTF8( "%3F" ); break;
			case '@': out.AppendUTF8( "%40" ); break;
			case '\n': out.AppendUTF8( "%0A" ); break;
			case '\r': out.AppendUTF8( "%0D" ); break;
			case '\t': out.AppendUTF8( "%09" ); break;
			case '[': out.AppendUTF8( "%5B" ); break;
			case '\\': out.AppendUTF8( "%5C" ); break;
			case ']': out.AppendUTF8( "%5D" ); break;
			case '^': out.AppendUTF8( "%5E" ); break;
			case '_': out.AppendUTF8( "%5F" ); break;
			case '`': out.AppendUTF8( "%60" ); break;
			case '{': out.AppendUTF8( "%7B" ); break;
			case '|': out.AppendUTF8( "%7C" ); break;
			case '}': out.AppendUTF8( "%7D" ); break;
			case '~': out.AppendUTF8( "%7E" ); break;
			default: out.AppendUnicode( c ); break;
		}

		str += numBytes;
	}
}

//****f* HTTP/Encoding/HTTPDecode
// FUNCTION
//   Decodes a URL encoded string. It can decode all alphanumeric characters and most non-alphanumeric characters.
// INPUTS
//   str -- The string to decode
// SOURCE
char* agk::HTTPDecode( const char* str )
//****
{
	uString out;
	HTTPDecode( str, out );

	char *strout = new char[ out.GetLength()+1 ];
	strcpy( strout, out.GetStr() );
	return strout;
}

void agk::HTTPDecode( const char* str, uString &out )
{
	out.SetStr("");

	int length = (int)strlen( str );
	for( int i = 0; i < length; i++ )
	{
		if ( i < length-2 && str[i] == '%' )
		{
			switch( str[i+1] )
			{
				case '0': 
				{
					switch( str[i+2] )
					{
						case 'A': out.AppendAscii( '\n' ); break;
						case 'D': out.AppendAscii( '\r' ); break;
						case '9': out.AppendAscii( '\t' ); break;
					}
					break;
				}

				case '2': 
				{
					switch( str[i+2] )
					{
						case '0': out.AppendAscii( ' ' ); break;
						case '1': out.AppendAscii( '!' ); break;
						case '2': out.AppendAscii( '"' ); break;
						case '3': out.AppendAscii( '#' ); break;
						case '4': out.AppendAscii( '$' ); break;
						case '5': out.AppendAscii( '%' ); break;
						case '6': out.AppendAscii( '&' ); break;
						case '7': out.AppendAscii( '\'' ); break;
						case '8': out.AppendAscii( '(' ); break;
						case '9': out.AppendAscii( ')' ); break;
						case 'A': out.AppendAscii( '*' ); break;
						case 'B': out.AppendAscii( '+' ); break;
						case 'C': out.AppendAscii( ',' ); break;
						case 'D': out.AppendAscii( '-' ); break;
						case 'E': out.AppendAscii( '.' ); break;
						case 'F': out.AppendAscii( '/' ); break;
					}
					break;
				}

				case '3': 
				{
					switch( str[i+2] )
					{
						case '0': out.AppendAscii( '0' ); break;
						case '1': out.AppendAscii( '1' ); break;
						case '2': out.AppendAscii( '2' ); break;
						case '3': out.AppendAscii( '3' ); break;
						case '4': out.AppendAscii( '4' ); break;
						case '5': out.AppendAscii( '5' ); break;
						case '6': out.AppendAscii( '6' ); break;
						case '7': out.AppendAscii( '7' ); break;
						case '8': out.AppendAscii( '8' ); break;
						case '9': out.AppendAscii( '9' ); break;
						case 'A': out.AppendAscii( ':' ); break;
						case 'B': out.AppendAscii( ';' ); break;
						case 'C': out.AppendAscii( '<' ); break;
						case 'D': out.AppendAscii( '=' ); break;
						case 'E': out.AppendAscii( '>' ); break;
						case 'F': out.AppendAscii( '?' ); break;
					}
					break;
				}

				case '4': 
				{
					switch( str[i+2] )
					{
						case '0': out.AppendAscii( '@' ); break;
						case '1': out.AppendAscii( 'A' ); break;
						case '2': out.AppendAscii( 'B' ); break;
						case '3': out.AppendAscii( 'C' ); break;
						case '4': out.AppendAscii( 'D' ); break;
						case '5': out.AppendAscii( 'E' ); break;
						case '6': out.AppendAscii( 'F' ); break;
						case '7': out.AppendAscii( 'G' ); break;
						case '8': out.AppendAscii( 'H' ); break;
						case '9': out.AppendAscii( 'I' ); break;
						case 'A': out.AppendAscii( 'J' ); break;
						case 'B': out.AppendAscii( 'K' ); break;
						case 'C': out.AppendAscii( 'L' ); break;
						case 'D': out.AppendAscii( 'M' ); break;
						case 'E': out.AppendAscii( 'N' ); break;
						case 'F': out.AppendAscii( 'O' ); break;
					}
					break;
				}

				case '5': 
				{
					switch( str[i+2] )
					{
						case '0': out.AppendAscii( 'P' ); break;
						case '1': out.AppendAscii( 'Q' ); break;
						case '2': out.AppendAscii( 'R' ); break;
						case '3': out.AppendAscii( 'S' ); break;
						case '4': out.AppendAscii( 'T' ); break;
						case '5': out.AppendAscii( 'U' ); break;
						case '6': out.AppendAscii( 'V' ); break;
						case '7': out.AppendAscii( 'W' ); break;
						case '8': out.AppendAscii( 'X' ); break;
						case '9': out.AppendAscii( 'Y' ); break;
						case 'A': out.AppendAscii( 'Z' ); break;
						case 'B': out.AppendAscii( '[' ); break;
						case 'C': out.AppendAscii( '\\' ); break;
						case 'D': out.AppendAscii( ']' ); break;
						case 'E': out.AppendAscii( '^' ); break;
						case 'F': out.AppendAscii( '_' ); break;
					}
					break;
				}

				case '6': 
				{
					switch( str[i+2] )
					{
						case '0': out.AppendAscii( '`' ); break;
						case '1': out.AppendAscii( 'a' ); break;
						case '2': out.AppendAscii( 'b' ); break;
						case '3': out.AppendAscii( 'c' ); break;
						case '4': out.AppendAscii( 'd' ); break;
						case '5': out.AppendAscii( 'e' ); break;
						case '6': out.AppendAscii( 'f' ); break;
						case '7': out.AppendAscii( 'g' ); break;
						case '8': out.AppendAscii( 'h' ); break;
						case '9': out.AppendAscii( 'i' ); break;
						case 'A': out.AppendAscii( 'j' ); break;
						case 'B': out.AppendAscii( 'k' ); break;
						case 'C': out.AppendAscii( 'l' ); break;
						case 'D': out.AppendAscii( 'm' ); break;
						case 'E': out.AppendAscii( 'n' ); break;
						case 'F': out.AppendAscii( 'o' ); break;
					}
					break;
				}

				case '7': 
				{
					switch( str[i+2] )
					{
						case '0': out.AppendAscii( 'p' ); break;
						case '1': out.AppendAscii( 'q' ); break;
						case '2': out.AppendAscii( 'r' ); break;
						case '3': out.AppendAscii( 's' ); break;
						case '4': out.AppendAscii( 't' ); break;
						case '5': out.AppendAscii( 'u' ); break;
						case '6': out.AppendAscii( 'v' ); break;
						case '7': out.AppendAscii( 'w' ); break;
						case '8': out.AppendAscii( 'x' ); break;
						case '9': out.AppendAscii( 'y' ); break;
						case 'A': out.AppendAscii( 'z' ); break;
						case 'B': out.AppendAscii( '{' ); break;
						case 'C': out.AppendAscii( '|' ); break;
						case 'D': out.AppendAscii( '}' ); break;
						case 'E': out.AppendAscii( '~' ); break;
					}
					break;
				}
			}

			i+=2;
		}
		else
		{
			out.AppendByte( str[i] );
		}
	}
}

int agk::SortArray( AGKSortValue* pArray, uint32_t size )
{
	if ( !pArray ) return 0;
	if ( size < 1 ) return 0;

	uint32_t iCount1[ 257 ];
	uint32_t iCount2[ 257 ];
	uint32_t iCount3[ 257 ];
	uint32_t iCount4[ 257 ];

	for ( int i = 0; i < 257; i++ ) 
	{
		iCount1[ i ] = 0;
		iCount2[ i ] = 0;
		iCount3[ i ] = 0;
		iCount4[ i ] = 0;
	}

	uint32_t value1, value2, value3, value4;
	bool bSort = false;

	for ( uint32_t i = 0; i < size-1; i++ )
	{
		value1 = pArray[ i ].iValue & 0xff;
		value2 = (pArray[ i ].iValue >> 8) & 0xff;
		value3 = (pArray[ i ].iValue >> 16) & 0xff;
		value4 = (pArray[ i ].iValue >> 24);

		++iCount1[ value1+1 ];
		++iCount2[ value2+1 ];
		++iCount3[ value3+1 ];
		++iCount4[ value4+1 ];

		if ( bSort || pArray[i].iValue > pArray[i+1].iValue ) bSort = true;
	}

	
	value1 = pArray[ size-1 ].iValue & 0xff;
	value2 = (pArray[ size-1 ].iValue >> 8) & 0xff;
	value3 = (pArray[ size-1 ].iValue >> 16) & 0xff;
	value4 = (pArray[ size-1 ].iValue >> 24);

	++iCount1[ value1+1 ];
	++iCount2[ value2+1 ];
	++iCount3[ value3+1 ];
	++iCount4[ value4+1 ];

	// if array is already in order we can skip
	if ( !bSort ) return 1;


	for ( int i = 1; i < 256; i++ ) 
	{
		iCount1[ i ] += iCount1[ i-1 ];
		iCount2[ i ] += iCount2[ i-1 ];
		iCount3[ i ] += iCount3[ i-1 ];
		iCount4[ i ] += iCount4[ i-1 ];
	}

	AGKSortValue *pTemp = new AGKSortValue[ size ];

	// first pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = pArray[ i ].iValue & 0xff;
		uint32_t index = iCount1[ value ];
		pTemp[ index ] = pArray[ i ];
		++iCount1[ value ];
	}

	// second pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pTemp[ i ].iValue >> 8) & 0xff;
		uint32_t index = iCount2[ value ];
		pArray[ index ] = pTemp[ i ];
		++iCount2[ value ];
	}

	// third pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pArray[ i ].iValue >> 16) & 0xff;
		uint32_t index = iCount3[ value ];
		pTemp[ index ] = pArray[ i ];
		++iCount3[ value ];
	}

	// fourth pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pTemp[ i ].iValue >> 24);
		uint32_t index = iCount4[ value ];
		pArray[ index ] = pTemp[ i ];
		++iCount4[ value ];
	}

	delete [] pTemp;

	return 1;
}

int agk::SortArray64( AGKSortValue64* pArray, uint32_t size )
{
	if ( !pArray ) return 0;
	if ( size < 1 ) return 0;

	uint32_t iCount1[ 257 ];
	uint32_t iCount2[ 257 ];
	uint32_t iCount3[ 257 ];
	uint32_t iCount4[ 257 ];
	uint32_t iCount5[ 257 ];
	uint32_t iCount6[ 257 ];
	uint32_t iCount7[ 257 ];
	uint32_t iCount8[ 257 ];

	for ( int i = 0; i < 257; i++ ) 
	{
		iCount1[ i ] = 0;
		iCount2[ i ] = 0;
		iCount3[ i ] = 0;
		iCount4[ i ] = 0;
		iCount5[ i ] = 0;
		iCount6[ i ] = 0;
		iCount7[ i ] = 0;
		iCount8[ i ] = 0;
	}

	uint32_t value1, value2, value3, value4, value5, value6, value7, value8;

	for ( uint32_t i = 0; i < size; i++ )
	{
		value1 = pArray[ i ].iValue & 0xff;
		value2 = (pArray[ i ].iValue >> 8) & 0xff;
		value3 = (pArray[ i ].iValue >> 16) & 0xff;
		value4 = (pArray[ i ].iValue >> 24) & 0xff;
		value5 = (pArray[ i ].iValue >> 32) & 0xff;
		value6 = (pArray[ i ].iValue >> 40) & 0xff;
		value7 = (pArray[ i ].iValue >> 48) & 0xff;
		value8 = (pArray[ i ].iValue >> 56) & 0xff;

		++iCount1[ value1+1 ];
		++iCount2[ value2+1 ];
		++iCount3[ value3+1 ];
		++iCount4[ value4+1 ];
		++iCount5[ value5+1 ];
		++iCount6[ value6+1 ];
		++iCount7[ value7+1 ];
		++iCount8[ value8+1 ];
	}

	for ( int i = 1; i < 256; i++ ) 
	{
		iCount1[ i ] += iCount1[ i-1 ];
		iCount2[ i ] += iCount2[ i-1 ];
		iCount3[ i ] += iCount3[ i-1 ];
		iCount4[ i ] += iCount4[ i-1 ];
		iCount5[ i ] += iCount5[ i-1 ];
		iCount6[ i ] += iCount6[ i-1 ];
		iCount7[ i ] += iCount7[ i-1 ];
		iCount8[ i ] += iCount8[ i-1 ];
	}

	AGKSortValue64 *pTemp = new AGKSortValue64[ size ];

	// first pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = pArray[ i ].iValue & 0xff;
		uint32_t index = iCount1[ value ];
		pTemp[ index ] = pArray[ i ];
		++iCount1[ value ];
	}

	// second pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pTemp[ i ].iValue >> 8) & 0xff;
		uint32_t index = iCount2[ value ];
		pArray[ index ] = pTemp[ i ];
		++iCount2[ value ];
	}

	// third pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pArray[ i ].iValue >> 16) & 0xff;
		uint32_t index = iCount3[ value ];
		pTemp[ index ] = pArray[ i ];
		++iCount3[ value ];
	}

	// fourth pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pTemp[ i ].iValue >> 24) & 0xff;
		uint32_t index = iCount4[ value ];
		pArray[ index ] = pTemp[ i ];
		++iCount4[ value ];
	}

	// fifth pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pArray[ i ].iValue >> 32) & 0xff;
		uint32_t index = iCount5[ value ];
		pTemp[ index ] = pArray[ i ];
		++iCount5[ value ];
	}

	// sixth pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pTemp[ i ].iValue >> 40) & 0xff;
		uint32_t index = iCount6[ value ];
		pArray[ index ] = pTemp[ i ];
		++iCount6[ value ];
	}

	// seventh pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pArray[ i ].iValue >> 48) & 0xff;
		uint32_t index = iCount7[ value ];
		pTemp[ index ] = pArray[ i ];
		++iCount7[ value ];
	}

	// eigth pass
	for ( uint32_t i = 0; i < size; i++ )
	{
		uint32_t value = (pTemp[ i ].iValue >> 56) & 0xff;
		uint32_t index = iCount8[ value ];
		pArray[ index ] = pTemp[ i ];
		++iCount8[ value ];
	}

	delete [] pTemp;

	return 1;
}


//****f* Core/Maths/SetRandomSeed
// FUNCTION
//   Sets the seed for the random number generator. Two AGK applications using the same seed value will generate the same
//   sequence of random numbers. By default the seed is set to the current time on startup so that each run of the application
//   will generate a different sequence of numbers.
// INPUTS
//   seed -- The seed value, between 1 and 2^32
// SOURCE
void agk::SetRandomSeed( uint32_t seed )
//****
{
	m_iRandSeed = seed;
	//srand( seed );
}

//****f* Core/Maths/Random
// FUNCTION
//   Generates a random number based on the current seed value. The random number generator is built into AGK
//   so a particular seed value will produce the same sequence of numbers on every platform.
//   Produces a random number between 0 and 65535
// SOURCE
uint32_t agk::Random( )
//****
{
	// Uses integer overflow to generate pseudo random numbers.
	m_iRandSeed = (214013*m_iRandSeed + 2531011);
	// only use the top 16 bits as the lower 16 bits produce very short repeat cycles.
	return (m_iRandSeed >> 16) & 0xffff;
}

//****f* Core/Maths/Random
// FUNCTION
//   Generates a random number between two given values. The result may be equal to either of the given values.
//   The total range of values is limited to 0-65535. The random number generator is built into AGK
//   so a particular seed value will produce the same sequence of numbers on every platform.
// INPUTS
//   from -- The lowest value to return
//   to -- The highest value to return
// SOURCE
uint32_t agk::Random( uint32_t from, uint32_t to )
//****
{
	if ( to > 65535 ) to = 65535;
	if ( from > to ) from = 0;
	int diff = (to-from)+1;
	return (Random() % diff) + from;
}

//****f* Core/Maths/RandomSign
// FUNCTION
//   Will randomly negate the value given and return it. Has a 50-50 chance of negating the value.
//   The initial value can be negative, in which case it will randomly become positive.
// INPUTS
//   value -- The value to change.
// SOURCE
int agk::RandomSign( int value )
//****
{
	int change = (Random() % 2);
	if ( change == 1 ) return -value;
	else return value;
}

//****f* Core/Maths/SetRandomSeed2
// FUNCTION
//   Sets the seed for the random number generator. Two AGK applications using the same seed value will generate the same
//   sequence of random numbers. By default the seed is set to the current time on startup so that each run of the application
//   will generate a different sequence of numbers.
// INPUTS
//   seed -- The seed value, between 1 and 2^32
// SOURCE
void agk::SetRandomSeed2( uint32_t seed )
//****
{
	m_iRandMTIndex = 0;
	m_iRandMTArray[0] = seed;
	for ( int i = 1; i < 623; i++ )
	{
		m_iRandMTArray[i] = (1812433253 * (m_iRandMTArray[i-1] ^ (m_iRandMTArray[i-1] >> 30)) + i);
	}
}

//****f* Core/Maths/Random2
// FUNCTION
//   Generates a random number based on the current seed value. The random number generator is built into AGK
//   so a particular seed value will produce the same sequence of numbers on every platform.
//   Produces a random number between -2,147,483,648 and 2,147,483,647.
//   This generator is slower than <i>Random</i> but produces better quality randomness over a larger range of values.
// SOURCE
int agk::Random2( )
//****
{
	if ( m_iRandMTIndex == 0 ) 
	{
		for ( int i = 0; i < 624; i++ ) 
		{
			uint32_t y = (m_iRandMTArray[i] & 0x80000000) + (m_iRandMTArray[(i+1) % 624] & 0x7fffffff);
			m_iRandMTArray[i] = m_iRandMTArray[(i + 397) % 624] ^ (y>>1);
			if ( (y % 2) != 0 ) m_iRandMTArray[i] = m_iRandMTArray[i] ^ 0x9908b0df;
		}
	}

	uint32_t y = m_iRandMTArray[m_iRandMTIndex];
	y = y ^ (y >> 11);
	y = y ^ ((y << 7) & 0x9d2c5680);
	y = y ^ ((y << 15) & 0xefc60000);
	y = y ^ (y >> 18);

	m_iRandMTIndex = (m_iRandMTIndex + 1) % 624;
	return (int)y;
}

//****f* Core/Maths/Random2
// FUNCTION
//   Generates a random number between two given values. The result may be equal to either of the given values.
//   The total range of values is -2,147,483,648 and 2,147,483,647. The random number generator is built into AGK
//   so a particular seed value will produce the same sequence of numbers on every platform.
// INPUTS
//   from -- The lowest value to return
//   to -- The highest value to return
// SOURCE
int agk::Random2( int from, int to )
//****
{
	if ( from == to ) return from;

	if ( from > to ) 
	{
		int temp = from;
		from = to;
		to = temp;
	}

	uint32_t diff = (to-from)+1;
	return (Random2() % diff) + from;
}

//****f* Core/Maths/ATanFull
// FUNCTION
//   Returns the angle in degrees between x=0 y=-1 (up) and the given vector in a clockwise direction. Returns 
//   a value from 0 to 360. This command is proprietary to AGK and is useful in 2D situations. If you are looking for 
//   an equivalent to atan2 in C++ use the AGK command ATan2 instead.
// INPUTS
//   x -- The x component of the vector to check
//   y -- The y component of the vector to check
// SOURCE
float agk::ATanFull( float x, float y )
//****
{
	if ( x == 0 ) return y <= 0 ? 0.0f : 180.0f;
	if ( y == 0 ) return x >= 0 ? 90.0f : 270.0f;

	if ( x > 0 )
	{
		if ( y < 0 ) return agk::ATan( x / (-y) );
		else return agk::ATan( y / x ) + 90.0f;
	}
	else
	{
		if ( y > 0 ) return agk::ATan( (-x) / y ) + 180.0f;
		else return agk::ATan( y / x ) + 270.0f;
	}
}

//****f* Core/Maths/ATanFullRad
// FUNCTION
//   Returns the angle in radians between x=0 y=-1 (up) and the given vector in a clockwise direction. Returns 
//   a value from 0 to 2*PI. This command is proprietary to AGK and is useful in 2D situations. If you are looking for 
//   an equivalent to atan2 in C++ use the AGK command ATan2Rad instead.
// INPUTS
//   x -- The x component of the vector to check
//   y -- The y component of the vector to check
// SOURCE
float agk::ATanFullRad( float x, float y )
//****
{
	if ( x == 0 ) return y <= 0 ? 0 : PI;
	if ( y == 0 ) return x >= 0 ? PI/2 : PI*3/2;

	if ( x > 0 )
	{
		if ( y < 0 ) return ATanRad( x / (-y) );
		else return ATanRad( y / x ) + PI/2;
	}
	else
	{
		if ( y > 0 ) return ATanRad( (-x) / y ) + PI;
		else return ATanRad( y / x ) + PI*3/2;
	}
}

//****f* Core/Maths/Sin
// FUNCTION
//   Returns the sine of a value in degrees.
// INPUTS
//   a -- The value to pass into the sine function.
// SOURCE
float agk::Sin( float a )
//****
{
	return sin( a * PI / 180 );
}

//****f* Core/Maths/Cos
// FUNCTION
//   Returns the cosine of a value in degrees.
// INPUTS
//   a -- The value to pass into the cosine function.
// SOURCE
float agk::Cos( float a )
//****
{
	return cos( a * PI / 180 );
}

//****f* Core/Maths/Tan
// FUNCTION
//   Returns the tangent of a value in degrees.
// INPUTS
//   a -- The value to pass into the tangent function.
// SOURCE
float agk::Tan( float a )
//****
{
	return tan( a * PI / 180 );
}

//****f* Core/Maths/SinRad
// FUNCTION
//   Returns the sine of a value in radians.
// INPUTS
//   a -- The value to pass into the sine function.
// SOURCE
float agk::SinRad( float a )
//****
{
	return sin( a );
}

//****f* Core/Maths/CosRad
// FUNCTION
//   Returns the cosine of a value in radians.
// INPUTS
//   a -- The value to pass into the cosine function.
// SOURCE
float agk::CosRad( float a )
//****
{
	return cos( a );
}

//****f* Core/Maths/TanRad
// FUNCTION
//   Returns the tangent of a value in radians.
// INPUTS
//   a -- The value to pass into the tangent function.
// SOURCE
float agk::TanRad( float a )
//****
{
	return tan( a );
}

//****f* Core/Maths/ASin
// FUNCTION
//   Returns the arcsine of a value in degrees.
// INPUTS
//   a -- The value to pass into the arcsine function.
// SOURCE
float agk::ASin( float a )
//****
{
	return asin( a ) * 180 / PI;
}

//****f* Core/Maths/ACos
// FUNCTION
//   Returns the arccosine of a value in degrees.
// INPUTS
//   a -- The value to pass into the arccosine function.
// SOURCE
float agk::ACos( float a )
//****
{
	return acos( a ) * 180 / PI;
}

//****f* Core/Maths/ATan
// FUNCTION
//   Returns the arctangent of a value in degrees in the range -90 to 90.
// INPUTS
//   a -- The value to pass into the arctangent function.
// SOURCE
float agk::ATan( float a )
//****
{
	return atan( a ) * 180 / PI;
}

//****f* Core/Maths/ATan2
// FUNCTION
//   Returns the angle of an x,y vector in degrees in the range -180 to 180.
//   This exactly matches the C++ atan2 function with degrees.
// INPUTS
//   y -- The y value to pass to atan2
//   x -- The x value to pass to atan2
// SOURCE
float agk::ATan2( float y, float x )
//****
{
	return atan2( y, x ) * 180 / PI;
}

//****f* Core/Maths/ASinRad
// FUNCTION
//   Returns the arcsine of a value in radians.
// INPUTS
//   a -- The value to pass into the arcsine function.
// SOURCE
float agk::ASinRad( float a )
//****
{
	return asin( a );
}

//****f* Core/Maths/ACosRad
// FUNCTION
//   Returns the arccosine of a value in radians.
// INPUTS
//   a -- The value to pass into the arccosine function.
// SOURCE
float agk::ACosRad( float a )
//****
{
	return acos( a );
}

//****f* Core/Maths/ATanRad
// FUNCTION
//   Returns the arctangent of a value in radians in the range -pi/2 to pi/2.
// INPUTS
//   a -- The value to pass into the arctangent function.
// SOURCE
float agk::ATanRad( float a )
//****
{
	return atan( a );
}

//****f* Core/Maths/ATan2Rad
// FUNCTION
//   Returns the angle of an x,y vector in radians in the range -pi to pi.
//   This exactly matches the C++ atan2 function.
// INPUTS
//   y -- The y value to pass to atan2
//   x -- The x value to pass to atan2
// SOURCE
float agk::ATan2Rad( float y, float x )
//****
{
	return atan2( y, x );
}


//****f* Core/Maths/Trunc
// FUNCTION
//   Returns the integer part of a float value with no rounding either way.
// INPUTS
//   a -- The value to truncate.
// SOURCE
int agk::Trunc( float a )
//****
{
	return (int) a; // no longer need to worry about slow x86 conversions
}

//****f* Core/Maths/Floor
// FUNCTION
//   Rounds a float to the next lowest integer. This differs from Trunc when using negative numbers,
//   Trunc( -1.6 ) is -1 but Floor( -1.6 ) is -2.
// INPUTS
//   a -- The value to floor.
// SOURCE
int agk::Floor( float a )
//****
{
	int i = (int) a;
	return (a < i) ? i - 1 : i;
}

//****f* Core/Maths/Ceil
// FUNCTION
//   Rounds a float to the next highest integer. This differs from Trunc when using positive numbers,
//   Trunc( 1.6 ) is 1 but Ceil( 1.6 ) is 2.
// INPUTS
//   a -- The value to round up.
// SOURCE
int agk::Ceil( float a )
//****
{
	int i = (int) a;
	return (a > i) ? i + 1 : i;
}

//****f* Core/Maths/Round
// FUNCTION
//   Rounds a float to the nearest integer (positive or negative). 
// INPUTS
//   a -- The value to round.
// SOURCE
int agk::Round( float a )
//****
{
	return agkfloattoint( a );
}

//****f* Core/Maths/Sqrt
// FUNCTION
//   Returns the square root of a float value.
// INPUTS
//   a -- The value to square root.
// SOURCE
float agk::Sqrt( float a )
//****
{
	if ( a > 0 ) return sqrt( a );
	else return 0;
}

//****f* Core/Maths/Abs
// FUNCTION
//   Returns absolute of a value, that is the positive version of the number.
// INPUTS
//   a -- The value to convert.
// SOURCE
float agk::Abs( float a )
//****
{
	if ( a < 0 ) a = -a;
	return a;
}

//****f* Core/Maths/Mod
// FUNCTION
//   Returns the remainder of the integer division a/b.
// INPUTS
//   a -- The numerator.
//   b -- The denominator.
// SOURCE
int agk::Mod( int a, int b )
//****
{
	if ( b == 0 ) return 0;
	return a % b;
}

//****f* Core/Maths/FMod
// FUNCTION
//   Returns the remainder of the float division a/b.
// INPUTS
//   a -- The numerator.
//   b -- The denominator.
// SOURCE
float agk::FMod( float a, float b )
//****
{
	if ( b == 0 ) return 0;
	return fmod( a, b );
}

//****f* Core/Maths/Pow
// FUNCTION
//   Returns a raised to the power of b.
// INPUTS
//   a -- The base.
//   b -- The power.
// SOURCE
float agk::Pow( float a, float b )
//****
{
	return pow( a, b );
}

//****f* Core/Maths/Lerp
// FUNCTION
//   Linearly interpolates between b and c by the fraction a.
// INPUTS
//   a -- The interpolation factor (typically between 0 and 1).
//   b -- The starting value.
//   c -- The ending value.
// SOURCE
float agk::Lerp(float a, float b, float c)
//****
{
	return b + a * (c - b);
}

//****f* Core/Maths/InverseLerp
// FUNCTION
//   Calculates the interpolation factor (a) given the values b and c, and a value a.
// INPUTS
//   a -- The value to be normalized between b and c.
//   b -- The starting value.
//   c -- The ending value.
// SOURCE
float agk::InverseLerp(float a, float b, float c)
//****
{
	return (a - b) / (c - b);
}

//****f* Core/Maths/Map
// FUNCTION
//   Maps a value from one range to another.
// INPUTS
//   a -- The value to be mapped.
//   b -- The minimum value of the input range.
//   c -- The maximum value of the input range.
//   d -- The minimum value of the output range.
//   e -- The maximum value of the output range.
// SOURCE
float agk::Map(float a, float b, float c, float d, float e)
//****
{
	float time = agk::InverseLerp(a, b, c);
	return agk::Lerp(time, d, e);
}

//****f* Core/Maths/Clamp
// FUNCTION
//   Clamps a value between a minimum and maximum range.
// INPUTS
//   a -- The value to be clamped.
//   b -- The minimum value of the range.
//   c -- The maximum value of the range.
// SOURCE
float agk::Clamp(float a, float b, float c)
//****
{
	if (a < b) return b;
	if (a > c) return c;
	return a;
}


//****f* Core/Maths/Min
// FUNCTION
//   Returns the minimum of two values.
// INPUTS
//   a -- The first value.
//   b -- The second value.
// SOURCE
float agk::Min(float a, float b)
//****
{
	return fmin(a, b);
}

//****f* Core/Maths/Max
// FUNCTION
//   Returns the maximum of two values.
// INPUTS
//   a -- The first value.
//   b -- The second value.
// SOURCE
float agk::Max(float a, float b)
//****
{
	return fmax(a, b);
}

//****f* Core/Maths/Wrap
// FUNCTION
//   Wraps a value within a specified range [min, max).
// INPUTS
//   a -- The value to be wrapped.
//   b -- The minimum value of the range.
//   c -- The maximum value of the range (exclusive).
// SOURCE
float agk::Wrap(float a, float b, float c)
//****
{
	if (b == c) return b; // If the range is zero, return the minimum value.
	float range = c - b;
	return b + fmod(fmod(a - b, range) + range, range);
}

//****f* Core/Maths/WrapAngle
// FUNCTION
//   Wraps an angle value within the range of 0 to 360 degrees.
// INPUTS
//   a -- The angle value to be wrapped.
// SOURCE
float agk::WrapAngle(float a)
//****
{
	float remainder = fmod(a, 360.0f);
	if (remainder < 0.0f) remainder += 360.0f;
	return remainder;
}

//****f* Core/Maths/Sign
// FUNCTION
//   Returns the sign of the value.
// INPUTS
//   a -- The value whose sign is to be determined.
// SOURCE
int agk::Sign(float a)
//****
{
	if (a > 0) return 1;
	if (a < 0) return -1;
	return 0;
}

//****f* Core/Maths/CurveValue
// FUNCTION
//   Moves a current value towards a destination value at a specified speed.
// INPUTS
//   a -- The current value.
//   b -- The destination value.
//   c -- The speed of movement (number of iterations to reach destination).
// SOURCE
float agk::CurveValue(float a, float b, float c)
//****
{
	if (c < 1.0f) c = 1.0f;
	return a + ((b - a) / c);
}

//****f* Core/Maths/CurveAngle
// FUNCTION
//   Moves a current angle towards a destination angle at a specified angular speed.
// INPUTS
//   a -- The current angle (in degrees).
//   b -- The destination angle (in degrees).
//   c -- The angular speed (number of iterations to reach destination).
// SOURCE
float agk::CurveAngle(float a, float b, float c)
//****
{
	if (c < 1.0f) c = 1.0f;
	float delta = agk::WrapAngle(b - a);
	if (delta > 180.0f) {
		delta -= 360.0f;
	}
	float angleToMove = delta / c;
	a += angleToMove;
	return agk::WrapAngle(a);
}

//****f* Core/Maths/Log
// FUNCTION
//   Returns the natural logarithm of the given value.
// INPUTS
//   a -- The input value
// SOURCE
float agk::Log(float a)
//****
{
	return log(a);
}

//****f* Core/Misc/SetSortTextures
// FUNCTION
//   This command is deprecated, sorting is now handled automatically.
// SOURCE
void agk::SetSortTextures( int sort )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "SetSortTextures() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* Core/Misc/SetSortDepth
// FUNCTION
//   This command is deprecated, sorting is now handled automatically.
// SOURCE
void agk::SetSortDepth( int sort )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "SetSortDepth() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* Core/Misc/SetSortTransparentDepth
// FUNCTION
//   This command is deprecated, sorting is now handled automatically.
// SOURCE
void agk::SetSortTransparentDepth( int sort )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "SetSortTransparentDepth() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* Core/Misc/SetSortCreated
// FUNCTION
//   This command is deprecated, sorting is now handled automatically.
// SOURCE
void agk::SetSortCreated( int sort )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "SetSortCreated() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* Core/Display/ScreenFPS
// FUNCTION
//   Returns an average frames per second based on the rendering time of the last few frames. To get the exact 
//   time spent on the last frame you can call <i>GetFrameTime</i>.
// SOURCE
float agk::ScreenFPS()
//****
{
	return m_fFps;
}

//****f* Core/Display/GetPolygonsDrawn
// FUNCTION
//   Returns the number of polygons drawn by the GPU last frame for 3D objects.
// SOURCE
uint32_t agk::GetPolygonsDrawn()
//****
{
	return m_iPolygonsDrawn;
}

//****f* Core/Display/GetShadowPolygonsDrawn
// FUNCTION
//   Returns the number of polygons drawn by the GPU last frame when constructing shadow maps.
// SOURCE
uint32_t agk::GetShadowPolygonsDrawn()
//****
{
	return m_iShadowPolygonsDrawn;
}

//****f* Core/Display/GetVerticesProcessed
// FUNCTION
//   Returns the number of vertices processed by the GPU last frame for 3D objects.
// SOURCE
uint32_t agk::GetVerticesProcessed()
//****
{
	return m_iVerticesProcessed;
}

//****f* Core/Display/EnableClearDepth
// FUNCTION
//   This command is deprecated, clearing the depth buffer is not optional
// SOURCE
void agk::EnableClearDepth( uint32_t clear )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "EnableClearDepth() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* Core/Display/EnableClearColor
// FUNCTION
//   This command is deprecated, you can choose to clear by using <i>ClearScreen</i> or not.<br/><br/>
//   If you wish to maintain the contents of a previous rendered image then you should render to a new image and apply the previously rendered 
//   image to a quad to draw it as a background. You can then swap the images in the next frame to continuously render
//   the previous frame as a background to the current frame.
// SOURCE
void agk::EnableClearColor( uint32_t clear )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "EnableClearColor() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* Core/Display/SetBorderColor
// FUNCTION
//   Sets the color or any borders used when the display does not fit the aspect ratio exactly.
//   If this color is different from the clear color than an additional clear operation is performed and
//   may affect performance if fill rate is an issue.
// INPUTS
//   red -- The red component of the border color
//   green -- The green component of the border color
//   blue -- The blue component of the border color
// SOURCE
void agk::SetBorderColor( uint32_t red, uint32_t green, uint32_t blue )
//****
{
	m_fBorderRed = red / 255.0f;
	m_fBorderGreen = green / 255.0f;
	m_fBorderBlue = blue / 255.0f;
}

//****f* Core/Display/SetClearColor
// FUNCTION
//   Sets the clear color to use when clearing the back buffer.
// INPUTS
//   red -- The red component of the clear color
//   green -- The green component of the clear color
//   blue -- The blue component of the clear color
// SOURCE
void agk::SetClearColor( uint32_t red, uint32_t green, uint32_t blue )
//****
{
	if ( m_fClearRed == m_fBorderRed && m_fClearGreen == m_fBorderGreen && m_fClearBlue == m_fBorderBlue )
	{
		m_fClearRed = red / 255.0f;
		m_fClearGreen = green / 255.0f;
		m_fClearBlue = blue / 255.0f;

		m_fBorderRed = m_fClearRed;
		m_fBorderGreen = m_fClearGreen;
		m_fBorderBlue = m_fClearBlue;
	}
	else
	{
		m_fClearRed = red / 255.0f;
		m_fClearGreen = green / 255.0f;
		m_fClearBlue = blue / 255.0f;
	}
}


//
// Image functions
//

// for Tier 2 use only
cImage* agk::GetImagePtr( uint32_t iImageIndex )
//***2
{
	cImage *pImage = m_cImageList.GetItem( iImageIndex );
	return pImage;
}

// for Tier 2 use only
uint32_t agk::GetImageTextureID ( uint32_t iImageIndex )
//***2
{
	return 0; // this is no longer supported as the renderer is not guaranteed to be OpenGL
}

// for Tier 2 use only
uint32_t agk::GetOpenGLImageID( uint32_t iImageIndex )
//***2
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( !pImage ) 
	{
		uString errStr; errStr.Format( "Failed to get OpenGL image %d, image does not exist", iImageIndex );
		agk::Error( errStr );
		return 0;
	}

	uint32_t texID = g_pRenderer->GetImageInternalID( pImage->GetInternalResource() );
    return texID;		
}

// for Tier 2 use only
void* agk::GetVulkanVRImageData( uint32_t iImageIndex )
//***2
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( !pImage ) 
	{
		uString errStr; errStr.Format( "Failed to get Vulkan VR image %d, image does not exist", iImageIndex );
		agk::Error( errStr );
		return 0;
	}

	if ( g_pRenderer->GetIdentifier() != AGK_RENDERER_VULKAN ) 
	{
		uString errStr; errStr.Format( "Failed to get Vulkan VR image %d, the current renderer is not Vulkan", iImageIndex );
		agk::Error( errStr );
		return 0;
	}
	else
	{
#ifndef DISABLE_VULKAN
		VulkanRenderer *pVulkanRenderer = (VulkanRenderer*)g_pRenderer;
		return pVulkanRenderer->GetVRImage( pImage->GetInternalResource() );
#endif
	}
}

// for Tier 2 use only
void agk::SetVRImage( uint32_t iImageIndex, int mode )
//***2
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( !pImage ) 
	{
		uString errStr; errStr.Format( "Failed to set VR image %s, image does not exist", iImageIndex );
		agk::Error( errStr );
		return;
	}

	if ( g_pRenderer->GetIdentifier() != AGK_RENDERER_VULKAN ) 
	{
		uString errStr; errStr.Format( "Failed to set VR image %d, the current renderer is not Vulkan", iImageIndex );
		agk::Warning( errStr );
		return;
	}
	else
	{
#ifndef DISABLE_VULKAN
		VulkanRenderer *pVulkanRenderer = (VulkanRenderer*)g_pRenderer;
		pVulkanRenderer->SetVRImage( pImage->GetInternalResource(), mode );
#endif
	}
}

// for Tier 2 use only
void agk::ResetVRImages()
//***2
{
	if ( g_pRenderer->GetIdentifier() != AGK_RENDERER_VULKAN ) 
	{
		agk::Warning( "Failed to reset VR images, the current renderer is not Vulkan" );
		return;
	}
	else
	{
#ifndef DISABLE_VULKAN
		VulkanRenderer *pVulkanRenderer = (VulkanRenderer*)g_pRenderer;
		pVulkanRenderer->ResetVRImages();
#endif
	}
}

//****f* Image/General/GetImageSizeFromFile
// FUNCTION
//   Opens the image file to extract the width and height values and then immediately closes the file. This is much 
//   faster than loading the entire image. This can be useful when using <i>LoadImageResized</i> to know how much to 
//   scale the image before loading it. Both the width and height will be returned in a single integer value, the top
//   16bits will be the width and the lower 16bits will be the height. You can extract these values in Tier 1 by doing <br/>
//   width = result >> 16<br/>
//   height = result && 0xFFFF
// INPUTS
//   filename -- The filename of the image to check
// SOURCE
uint32_t agk::GetImageSizeFromFile( const char* filename )
//****
{
	return cImage::GetImageSizeFromFile( filename );
}

//****f* Image/General/LoadImage
// FUNCTION
//   Loads an image from a file into a specified image ID, can also be used to load an atlas texture that will be used by sub images.
//   If loading an atlas texture a subimages.txt file must exist detailing all the images contained on it.<br><br>
//   Image width and height must be between 1 and 2048 pixels, some devices may support larger sizes but this is not guaranteed. Images
//   do not need to be a power of 2 in size (2,4,8,16,32,etc).<br><br>
//   If you have lots of small images you could combine them into an atlas texture to improve performance.<br><br>
// INPUTS
//   ID -- The ID to use to reference this image later.
//   sImageFilename -- The filename of the image to load.
//   bBlackToAlpha -- Set to 1 to override the image's alpha channel to be transparent where there are black pixels and opaque otherwise (default 0)
// SOURCE
void agk::LoadImage( uint32_t ID, const char *sImageFilename, int bBlackToAlpha )
//****
{
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add image ", 200 );
		errStr.Append( sImageFilename );
		errStr.Append( " - image ID must be greater than 0" );
		agk::Error( errStr );
#endif
		return;
	}

	// check if this image has already been loaded
	cImage* pFound = (cImage*) m_cImageList.GetItem( ID );
	if ( pFound != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add image ", 200 );
		errStr.Append( sImageFilename );
		errStr.Append( " into image id " );
		errStr.AppendUInt(  ID );
		errStr.Append( " - image already added with " );
		errStr.Append( pFound->GetPath() );
		agk::Error( errStr );
#endif
		return;
	}
	
	cImage *pImage = new cImage( );
	pImage->m_iID = ID;
	if ( !pImage->Load( sImageFilename, bBlackToAlpha>0 ) )
	{
		delete pImage;
		return;
	}
	
	m_cImageList.AddItem( pImage, ID );
}

//****f* Image/General/LoadImage
// FUNCTION
//   Loads an image from a file into a specified image ID, can also be used to load an atlas texture that will be used by sub images.
//   If loading an atlas texture a subimages.txt file must exist detailing all the images contained on it.<br><br>
//   Image width and height must be between 1 and 2048 pixels, some devices may support larger sizes but this is not guaranteed. Images
//   do not need to be a power of 2 in size (2,4,8,16,32,etc).<br><br>
//   If you have lots of small images you could combine them into an atlas texture to improve performance.<br><br>
// INPUTS
//   ID -- ID number for the image
//   sImageFilename -- The filename of the image to load
// SOURCE
void agk::LoadImage( uint32_t ID, const char* sImageFilename )
//****
{
	LoadImage( ID, sImageFilename, 0 );
}


//****f* Image/General/LoadImage
// FUNCTION
//   Loads an image from a file into a specified image ID, can also be used to load an atlas texture that will be used by sub images.
//   If loading an atlas texture a subimages.txt file must exist detailing all the images contained on it.<br><br>
//   Image width and height must be between 1 and 2048 pixels, some devices may support larger sizes but this is not guaranteed. Images
//   do not need to be a power of 2 in size (2,4,8,16,32,etc).<br><br>
//   If you have lots of small images you could combine them into an atlas texture to improve performance.<br><br>
// INPUTS
//   sImageFilename -- The filename of the image to load
//   bBlackToAlpha -- Set to 1 to override the image's alpha channel to be transparent where there are black pixels and opaque otherwise (default 0)
// SOURCE
uint32_t agk::LoadImage( const char* sImageFilename, int bBlackToAlpha )
//****
{
	uint32_t iID = m_cImageList.GetFreeID( MAX_IMAGES );
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add image ", 200 );
		errStr.Append( sImageFilename );
		errStr.Append( " - no free image IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	cImage *pImage = new cImage( );
	pImage->m_iID = iID;
	if ( !pImage->Load( sImageFilename, bBlackToAlpha>0 ) )
	{
		delete pImage;
		return 0;
	}

	m_cImageList.AddItem( pImage, iID );
	return iID;
}

//****f* Image/General/LoadImage
// FUNCTION
//   Loads an image from a file into a specified image ID, can also be used to load an atlas texture that will be used by sub images.
//   If loading an atlas texture a subimages.txt file must exist detailing all the images contained on it.<br><br>
//   Image width and height must be between 1 and 2048 pixels, some devices may support larger sizes but this is not guaranteed. Images
//   do not need to be a power of 2 in size (2,4,8,16,32,etc).<br><br>
//   If you have lots of small images you could combine them into an atlas texture to improve performance.<br><br>
// INPUTS
//   sImageFilename -- The filename of the image to load
// SOURCE
uint32_t agk::LoadImage( const char* sImageFilename )
//****
{
	return LoadImage( sImageFilename, 0 );
}

//****f* Image/General/LoadSubImage
// FUNCTION
//   Loads a sub image from an atlas texture for use as a standalone image into a specified image ID.
//   The subimages.txt file should start with the same name as the image file, for example an atlas image MyImage.png
//   would have a subimages file named "MyImage subimages.txt". The subimages file contains a series of rows
//   each describing an image that exists within the atlas image. Each line must have the format Name:X:Y:Width:Height
//   with the delimiter : used between the fields. The Name field is the name you want to used to reference the sub 
//   image when loading, this should match the sImageFilename parameter of this LoadSubImage command. The X:Y fields
//   are the X and Y pixel coordinates that represent the top left corner of the subimage, and the Width:Height fields
//   are the size in pixels of the sub image. These values are then used to extract your named image from the atlas
//   and load it into its own image ID to be used as if it were a normal image. The atlas image must remain loaded
//   for the entire time you are using the loaded sub image.
//   Note that when loading a sub image AGK will modify the UV coordinates slightly so that the image does not
//   steal pixels from neighboring images during filtering, by default it shifts the UV inwards by 0.5 pixels. You
//   can override this by setting <i>SetSpriteUVBorder</i> to 0 for sprites where you need pixel perfect results, but
//   you will have to watch out for pixel bleeding around the edges, and may need to give your sub images a 1 pixel 
//   border of an appropriate color that it can safely steal from when filtering.
// INPUTS
//   iImageIndex -- The image ID to use to reference this image later.
//   iParentIndex -- The image ID that holds the atlas texture, loaded previously with LoadImage.
//   sImageFilename -- The filename of the sub image as stored in subimages.txt. Do not use a path before the filename.
// SOURCE
void agk::LoadSubImage ( uint32_t iImageIndex, uint32_t iParentIndex, const char *sImageFilename )
//****
{
	if ( iParentIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr("Error loading sub image "); errStr.AppendInt((int)iImageIndex); errStr.Append(" - Parent image ID must be greater than 0");
		agk::Error( errStr );
#endif
		return;
	}

	if ( iImageIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add image ", 200 );
		errStr.Append( sImageFilename );
		errStr.Append( " - image ID must be greater than 0" );
		agk::Error( errStr );
#endif
		return;
	}

	// check if this image has already been loaded
	cImage* pFound = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( pFound != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load sub image ", 200 );
		errStr.Append( sImageFilename );
		errStr.Append( " into image id " );
		errStr.AppendUInt(  iImageIndex );
		errStr.Append( " - image already added with " );
		errStr.Append( pFound->GetPath() );
		agk::Error( errStr );
#endif
		return;
	}

	cImage* pParent = (cImage*) m_cImageList.GetItem( iParentIndex );
	if ( pParent == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load sub image ", 200 );
		errStr.Append( sImageFilename );
		errStr.Append( " from parent image " );
		errStr.AppendUInt(  iParentIndex );
		errStr.Append( " - parent image does not exist " );
		agk::Error( errStr );
#endif
		return;
	}

	cImage *pImage = new cImage();
	pImage->m_iID = iImageIndex;
	if ( !pImage->LoadSubImage( pParent, sImageFilename ) )
	{
		delete pImage;
		return;
	}

	m_cImageList.AddItem( pImage, iImageIndex );
}

//****f* Image/General/LoadSubImage
// FUNCTION
//   Loads a sub image from an atlas texture for use as a standalone image into a specified image ID.
//   The subimages.txt file should start with the same name as the image file, for example an atlas image MyImage.png
//   would have a subimages file named "MyImage subimages.txt". The subimages file contains a series of rows
//   each describing an image that exists within the atlas image. Each line must have the format Name:X:Y:Width:Height
//   with the delimiter : used between the fields. The Name field is the name you want to used to reference the sub 
//   image when loading, this should match the sImageFilename parameter of this LoadSubImage command. The X:Y fields
//   are the X and Y pixel coordinates that represent the top left corner of the subimage, and the Width:Height fields
//   are the size in pixels of the sub image. These values are then used to extract your named image from the atlas
//   and load it into its own image ID to be used as if it were a normal image. The atlas image must remain loaded
//   for the entire time you are using the loaded sub image.
//   Note that when loading a sub image AGK will modify the UV coordinates slightly so that the image does not
//   steal pixels from neighboring images during filtering, by default it shifts the UV inwards by 0.5 pixels. You
//   can override this by setting <i>SetSpriteUVBorder</i> to 0 for sprites where you need pixel perfect results, but
//   you will have to watch out for pixel bleeding around the edges, and may need to give your sub images a 1 pixel 
//   border of an appropriate color that it can safely steal from when filtering.
// INPUTS
//   iParentIndex -- The image ID that holds the atlas texture, loaded previously.
//   sImageFilename -- The filename of the sub image as stored in subimages.txt. Do not use a path before the filename.
// SOURCE
uint32_t agk::LoadSubImage ( uint32_t iParentIndex, const char *sImageFilename )
//****
{
	uint32_t iID = m_cImageList.GetFreeID( MAX_IMAGES );
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load sub image ", 200 );
		errStr.Append( sImageFilename );
		errStr.Append( " from parent image " );
		errStr.AppendUInt(  iParentIndex );
		errStr.Append( " - no free ID found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	LoadSubImage( iID, iParentIndex, sImageFilename ); 
	return iID;
}

//****f* Image/General/LoadImageResized
// FUNCTION
//   Loads an image, resizing it in the process. This allows you to have one high quality image and then 
//   resize it based on the device resolution at runtime, instead of having multiple levels of quality.
//   Reducing the image size is preferred to increasing the image size as increasing the image size doesn't
//   improve the quality, but both are supported.
//   A value of 1.0 does not change the image size, a value less than 1 will make the image smaller, a value
//   greater than 1 will make the image bigger.
//   Scaling values must be greater than 0, but can be any fraction, i.e. a scale of 0.6742 would be valid.
//   A scale of 0.5 would halve the image size, 2.0 would double to image size, and so on.
//   The image can be resized differently in the X and Y directions, although this will cause stretching.
//   If you load an atlas texture using this command then the subimages.txt file will also have its values 
//   resized so that <i>LoadSubImage</i> will still work correctly.
//   The cache parameter is no longer used as the image scaling is now done by the GPU so has almost no 
//   impact on performance
// INPUTS
//   iImageID -- The ID to use to reference this image in future
//   szFilename -- The name of the file to load
//   scaleX -- The amount to scale in the X direction, 1.0 is the original size
//   scaleY -- The amount to scale in the Y direction, 1.0 is the original size
//   cache -- No longer used, must be 0
// SOURCE
void agk::LoadImageResized( uint32_t iImageID, const char* szFilename, float scaleX, float scaleY, int cache )
//****
{
	if ( iImageID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load resized image ", 200 );
		errStr.Append( szFilename );
		errStr.Append( " - image ID must be greater than 0" );
		agk::Error( errStr );
#endif
		return;
	}

	// check if this image has already been loaded
	cImage* pFound = (cImage*) m_cImageList.GetItem( iImageID );
	if ( pFound != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load resized image ", 200 );
		errStr.Append( szFilename );
		errStr.Append( " into image id " );
		errStr.AppendUInt(  iImageID );
		errStr.Append( " - image already loaded with " );
		errStr.Append( pFound->GetPath() );
		agk::Error( errStr );
#endif
		return;
	}
	
	cImage *pImage = new cImage( );
	pImage->m_iID = iImageID;
	if ( !pImage->LoadResized( szFilename, scaleX, scaleY, cache ) )
	{
		delete pImage;
		return;
	}
	
	m_cImageList.AddItem( pImage, iImageID );
}

//****f* Image/General/LoadImageResized
// FUNCTION
//   Loads an image, resizing it in the process. This allows you to have one high quality image and then 
//   resize it based on the device resolution at runtime, instead of having multiple levels of quality.
//   Reducing the image size is preferred to increasing the image size as increasing the image size doesn't
//   improve the quality, but both are supported.
//   A value of 1.0 does not change the image size, a value less than 1 will make the image smaller, a value
//   greater than 1 will make the image bigger.
//   Scaling values must be greater than 0, but can be any fraction, i.e. a scale of 0.6742 would be valid.
//   A scale of 0.5 would halve the image size, 2.0 would double to image size, and so on.
//   The image can be resized differently in the X and Y directions, although this will cause stretching.
//   If you load an atlas texture using this command then the subimages.txt file will also have its values 
//   resized so that <i>LoadSubImage</i> will still work correctly.
//   The cache parameter is no longer used as the image scaling is now done by the GPU so has almost no 
//   impact on performance
// INPUTS
//   szFilename -- The name of the file to load
//   scaleX -- The amount to scale in the X direction, 1.0 is the original size
//   scaleY -- The amount to scale in the Y direction, 1.0 is the original size
//   cache -- No longer used, must be 0
// SOURCE
uint32_t agk::LoadImageResized( const char* szFilename, float scaleX, float scaleY, int cache )
//****
{
	uint32_t iID = m_cImageList.GetFreeID( MAX_IMAGES );
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load resized image ", 200 );
		errStr.Append( szFilename );
		errStr.Append( " - no free ID found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	LoadImageResized( iID, szFilename, scaleX, scaleY, cache ); 
	if ( m_cImageList.GetItem( iID ) == 0 ) return 0;
	return iID;
}

void agk::PreCacheImage( const char* szFilename, float scaleX, float scaleY )
{
	cImage::PreCache( szFilename, scaleX, scaleY );
}

int agk::GetCachingFinished()
{
	return cImage::GetCachingFinished();
}

//****f* Image/General/CreateImageColor
// FUNCTION
//   Creates a 1x1 pixel image of a specified color. This can be used to texture any object or sprite with a solid color.
// INPUTS
//   imageID -- The image ID to use for this image.
//   red -- The red component of the image (0 to 255)
//   green -- The green component of the image (0 to 255)
//   blue -- The blue component of the image (0 to 255)
//   alpha -- The alpha component of the image (0 to 255), 0 is completely transparent
// SOURCE
void agk::CreateImageColor( uint32_t imageID, uint32_t red, uint32_t green, uint32_t blue, uint32_t alpha )
//****
{
	if ( imageID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create color image - image ID must be greater than 0" );
		agk::Error( errStr );
#endif
		return;
	}

	// check if this image has already been loaded
	cImage* pFound = (cImage*) m_cImageList.GetItem( imageID );
	if ( pFound != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create color image ", 200 );
		errStr.AppendUInt(  imageID );
		errStr.Append( " - image already exists" );
		agk::Error( errStr );
#endif
		return;
	}
	
	cImage *pImage = new cImage( );
	pImage->m_iID = imageID;
	pImage->CreateColorImage( red, green, blue, alpha );
		
	m_cImageList.AddItem( pImage, imageID );
}

//****f* Image/General/CreateImageColor
// FUNCTION
//   Creates a 1x1 pixel image of a specified color and returns an ID to use to reference it. 
//   This can be used to texture any object or sprite with a solid color.
// INPUTS
//   red -- The red component of the image (0 to 255)
//   green -- The green component of the image (0 to 255)
//   blue -- The blue component of the image (0 to 255)
//   alpha -- The alpha component of the image (0 to 255), 0 is completely transparent
// SOURCE
uint32_t agk::CreateImageColor( uint32_t red, uint32_t green, uint32_t blue, uint32_t alpha )
//****
{
	uint32_t imageID = m_cImageList.GetFreeID();
	if ( imageID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create color image - no free image IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	cImage *pImage = new cImage( );
	pImage->m_iID = imageID;
	pImage->CreateColorImage( red, green, blue, alpha );
		
	m_cImageList.AddItem( pImage, imageID );
		
	return imageID;
}

//****f* Image/General/CreateRenderImage
// FUNCTION
//   Creates a blank image suitable for rendering, this can be used with <i>SetRenderToImage</i> to draw things to images. 
//   You can create RGBA images for normal rendering or depth images for capturing the depth buffer on devices that 
//   support it. Use <i>IsSupportedDepthTexture</i> to check if the current device supports depth textures.
//   You can also choose to use mipmapping on this image or not, this overrides the global SetGenerateMipmaps() command
//   for this image only, this is because mipmaps on rendered images can be a performance hit so it should not be used
//   unless necessary. Mipmaps should only be necessary if you intend to use this image to texture objects in your scene,
//   if you are only using this image for full screen shaders you should not use mipmapping on it.
// INPUTS
//   imageID -- The image ID to use for this image
//   width -- The width of the image to create
//   height -- The height of the image to create
//   format -- 0=RGBA (32bit), 1=Depth
//   mipmap -- 1 to use mipmapping on this image, 0 to turn it off
// SOURCE
void agk::CreateRenderImage( uint32_t imageID, uint32_t width, uint32_t height, uint32_t format, uint32_t mipmap )
//****
{
	if ( imageID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create render image - image ID must be greater than 0" );
		agk::Error( errStr );
#endif
		return;
	}

	// check if this image has already been loaded
	cImage* pFound = (cImage*) m_cImageList.GetItem( imageID );
	if ( pFound != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create render image ", 200 );
		errStr.AppendUInt(  imageID );
		errStr.Append( " - image already exists" );
		agk::Error( errStr );
#endif
		return;
	}
	
	cImage *pImage = new cImage( );
	pImage->m_iID = imageID;
	pImage->CreateBlankImage( width, height, format, mipmap );
		
	m_cImageList.AddItem( pImage, imageID );
}

//****f* Image/General/CreateRenderImage
// FUNCTION
//   Creates a blank image suitable for rendering and returns an ID to reference it. This can be used with 
//   <i>SetRenderToImage</i> to draw things to images. You can create RGBA images for normal rendering or 
//   depth images for capturing the depth buffer on devices that support it.
//   You can also choose to use mipmapping on this image or not, this overrides the global SetGenerateMipmaps() command
//   for this image only, this is because mipmaps on rendered images can be a performance hit so it should not be used
//   unless necessary. Mipmaps should only be necessary if you intend to use this image to texture objects in your scene,
//   if you are only using this image for full screen shaders you should not use mipmapping on it.
// INPUTS
//   width -- The width of the image to create
//   height -- The height of the image to create
//   format -- 0=RGBA (32bit), 1=Depth
//   mipmap -- 1 to use mipmapping on this image, 0 to turn it off
// SOURCE
uint32_t agk::CreateRenderImage( uint32_t width, uint32_t height, uint32_t format, uint32_t mipmap )
//****
{
	uint32_t imageID = m_cImageList.GetFreeID();
	if ( imageID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create render image - no free image IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	cImage *pImage = new cImage( );
	pImage->m_iID = imageID;
	pImage->CreateBlankImage( width, height, format, mipmap );
		
	m_cImageList.AddItem( pImage, imageID );
		
	return imageID;
}

//****f* Image/General/GetImageExists
// FUNCTION
//   Returns 1 if the image exists, 0 if not.
// INPUTS
//   iImageIndex -- The ID of the image to check
// SOURCE
uint32_t agk::GetImageExists( uint32_t iImageIndex )
//****
{
	if ( m_cImageList.GetItem( iImageIndex ) ) return 1;
	return 0;
}

//****f* Image/General/DeleteImage
// FUNCTION
//   Delete an image from the global store using its ID.
// INPUTS
//   iImageIndex -- The ID of the image to delete
// SOURCE
void agk::DeleteImage( uint32_t iImageIndex )
//****
{
	cImage *pImage = (cImage*) m_cImageList.RemoveItem( iImageIndex );
	if ( pImage ) delete pImage;
}

//****f* Image/General/DeleteAllImages
// FUNCTION
//   Deletes all images loaded by LoadImage or LoadSubImage. This also resets the auto image ID to 10000.
// SOURCE
void agk::DeleteAllImages()
//****
{
	cImage *pImage = m_cImageList.GetFirst();
	while ( pImage )
	{
		delete pImage;		
		pImage = m_cImageList.GetNext();
	}
	m_cImageList.ClearAll();
}

//****f* Image/General/SetImageSubImages
// FUNCTION
//   Sets the sub image data for an atlas image, which is the layout of where each sub image is located
//   within the atlas image. Normally this is loaded automatically from the subimages.txt file when the
//   image is loaded, but if this is not possible then this command can be used to set that data.
//   The file must be a valid subimages.txt file in the same format as that specified in <i>LoadSubImage</i>
//   Unlike the normal load image command the file does not need to be named subimages.txt, it can have any 
//   name and path
// INPUTS
//   iImageIndex -- The ID of the image to change
//   sSubImageFile -- The path to the sub images file
// SOURCE
void agk::SetImageSubImages( uint32_t iImageIndex, const char* sSubImageFile )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( !pImage ) 
	{
		uString err; err.Format( "Failed to set sub images, image ID %d does not exist", iImageIndex );
		Error( err );
		return;
	}

	pImage->SetSubImages( sSubImageFile );
}

//****f* Image/Properties/GetImageWidth
// FUNCTION
//   Returns the width of the image in pixels. Even though this command returns a float the value is 
//   guaranteed to be a whole number.
// INPUTS
//   iImageIndex -- The ID of the image to retrieve.
// SOURCE
float agk::GetImageWidth( uint32_t iImageIndex )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( pImage ) return (float) pImage->GetWidth();
	return 0;
}

//****f* Image/Properties/GetImageHeight
// FUNCTION
//   Returns the height of the image in pixels. Even though this command returns a float the value is
//   guaranteed to be a whole number.
// INPUTS
//   iImageIndex -- The ID of the image to retrieve.
// SOURCE
float agk::GetImageHeight( uint32_t iImageIndex )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( pImage ) return (float) pImage->GetHeight();
	return 0;
}

//****f* Image/Properties/SetImageMinFilter
// FUNCTION
//   Sets the filter for textures when the texture is smaller than the screen space it is displayed in.
//   You can use a mode of 0 to use the nearest pixel, which will appear blocky, or 1 to use a linear filter
//   which will look blurry. When the image matches the screen space exactly then both filters will look the same
//   when there is a slight difference, nearest tends to be sharper, but may flicker as it changes pixel choice.
// INPUTS
//   iImageIndex -- The ID of the image to change.
//   mode -- The filter mode to use, 0=nearest, 1=linear
// SOURCE
void agk::SetImageMinFilter( uint32_t iImageIndex, uint32_t mode )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( pImage ) pImage->SetMinFilter( mode );
}

//****f* Image/Properties/SetImageMagFilter
// FUNCTION
//   Sets the filter for textures when the texture is larger than the screen space it is displayed in.
//   You can use a mode of 0 to use the nearest pixel, which will appear blocky, or 1 to use a linear filter
//   which will look blurry. When the image matches the screen space exactly then both filters will look the same
//   when there is a slight difference, nearest tends to be sharper, but may flicker as it changes pixel choice.
// INPUTS
//   iImageIndex -- The ID of the image to change.
//   mode -- The filter mode to use, 0=nearest, 1=linear
// SOURCE
void agk::SetImageMagFilter( uint32_t iImageIndex, uint32_t mode )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( pImage ) pImage->SetMagFilter( mode );
}

//****f* Image/Properties/SetImageWrapU
// FUNCTION
//   Sets the UV wrap mode of the image when the U coordinate goes outside the range 0-1. The default is 
//   mode 0 which clamps the pixel value to the last valid pixel, mode 1 repeats the texture starting from
//   the opposite side.<br><br>
//   To use UV values outside 0-1 successfully on all platforms the image in question must be a power of 2
//   in width and height, and not be part of an atlas texture. This applies to both clamp and repeat.
// INPUTS
//   iImageIndex -- The ID of the image to change.
//   mode -- The wrap mode to use, 0=clamp, 1=repeat
// SOURCE
void agk::SetImageWrapU( uint32_t iImageIndex, uint32_t mode )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( pImage ) pImage->SetWrapU( mode );
}

//****f* Image/Properties/SetImageWrapV
// FUNCTION
//   Sets the UV wrap mode of the image when the V coordinate goes outside the range 0-1. The default is 
//   mode 0 which clamps the pixel value to the last valid pixel, mode 1 repeats the texture starting from
//   the opposite side.<br><br>
//   To use UV values outside 0-1 successfully on all platforms the image in question must be a power of 2
//   in width and height, and not be part of an atlas texture. This applies to both clamp and repeat.
// INPUTS
//   iImageIndex -- The ID of the image to change.
//   mode -- The wrap mode to use, 0=clamp, 1=repeat
// SOURCE
void agk::SetImageWrapV( uint32_t iImageIndex, uint32_t mode )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( pImage ) pImage->SetWrapV( mode );
}

//****f* Image/Modify/SetImageMask
// FUNCTION
//   Copies a color channel from one image to another. You can specify the source and destination channels using the values
//   1,2,3,4 to represent red, green, blue, and alpha respectively.<br><br>
//   This is a slow command and should not be called every frame.<br><br>
//   The x,y offset values allow you to offset the source image on te destination image so a small source image can be used
//   to mask any part of a large image. Any part of the large image outside the size of the small image will be left unchanged.
//   negative offset values are supported to shift the source image off the top left of the destination image.
//   If you add some transparent pixels to an image that currently has none, and you use the image on a sprite, then be sure 
//   to use <i>SetSpriteTransparency</i> to make the sprite transparent.
// INPUTS
//   iDstImage -- The ID of the image to change.
//   iSrcImage -- The ID of the image to use as a source.
//   dst -- The ID of the color channel to use as the destination, 1-4 for RGBA,
//   src -- The ID of the color channel to use as the source, 1-4 for RGBA,
//   x -- The x offset for the source image on the destination image,
//   y -- The y offset for the source image on the destination image.
// SOURCE
void agk::SetImageMask( uint32_t iDstImage, uint32_t iSrcImage, int dst, int src, int x, int y )
//****
{
	if ( dst < 1 || dst > 4 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set mask for image ", 200 );
		errStr.AppendInt( iDstImage );
		errStr.Append( " - destination channel must be between 1 and 4" );
		agk::Error( errStr );
#endif 
		return;
	}

	if ( src < 1 || src > 4 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set mask for image ", 200 );
		errStr.AppendInt( iDstImage );
		errStr.Append( " - source channel must be between 1 and 4" );
		agk::Error( errStr );
#endif 
		return;
	}

	cImage *pImage = (cImage*) m_cImageList.GetItem( iDstImage );
	if ( !pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set mask for image ", 200 );
		errStr.AppendInt( iDstImage );
		errStr.Append( " - image does not exist " );
		agk::Error( errStr );
#endif 
		return;
	}

	cImage *pImage2 = (cImage*) m_cImageList.GetItem( iSrcImage );
	if ( !pImage2 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set mask for image ", 200 );
		errStr.AppendInt( iDstImage );
		errStr.Append( " - source image does not exist " );
		agk::Error( errStr );
#endif 
		return;
	}

	pImage->SetMask( pImage2, dst, src, x, y );
}

//****f* Image/Modify/SetImageTransparentColor
// FUNCTION
//   Turns a particular color completely transparent in the chosen image.
//   This is a slow command and should not be called every frame.
// INPUTS
//   iImage -- The ID of the image to change.
//   r -- The red component of the color to set as transparent
//   g -- The red component of the color to set as transparent
//   b -- The red component of the color to set as transparent
// SOURCE
void agk::SetImageTransparentColor( uint32_t iImage, int r, int g, int b )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( iImage );
	if ( !pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set image transparent color", 200 );
		errStr.AppendInt( iImage );
		errStr.Append( " - image does not exist " );
		agk::Error( errStr );
#endif 
		return;
	}

	pImage->SetTransparentColor( r,g,b );
}

//****f* Image/General/SaveImage
// FUNCTION
//   Saves the image at the given ID to the file name specified. The file will be placed in the app's write
//   folder at the location currently specified by <i>SetFolder</i>. Alternatively you can specify 
//   a path beginning with a forward slash to choose a location from the root of the write folder, ignoring
//   any <i>SetFolder</i> folder.<br><br>
//   It is recommended that you use the extension ".png" at the end of the filename to save in PNG format.
//   Some platforms may support additional extensions such as ".jpg" but this is not guaranteed to work
//   on all platforms.
// INPUTS
//   iImageIndex -- The ID of the image to change.
//   filename -- The filename of the saved image
// SOURCE
void agk::SaveImage( uint32_t iImageIndex, const char* filename )
//****
{
	if ( !filename )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to save image, the string has not been assigned a value" );
#endif 
		return;		
	}

	cImage *pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
	if ( !pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to save image ", 200 );
		errStr.AppendInt( iImageIndex );
		errStr.Append( " - image does not exist " );
		agk::Error( errStr );
#endif 
		return;
	}

	pImage->Save( filename );
}

//****f* Image/General/GetImage
// FUNCTION
//   Before using this command consider using <i>SetRenderToImage</i> instead as it will be faster if you just want to
//   draw some things to an image for use later as a texture.<br/><br/>
//   GetImage grabs a portion of the backbuffer and creates a new image from it. The position and size values must be in screen
//   coordinates. Returns the ID of the new image, this must be deleted when you are done with it.
//   To use this command effectively you must know how AGK draws to the back buffer. When <i>Sync</i> is called AGK updates
//   the positions of all objects with <i>Update</i>, then draws them all to the back buffer with <i>Render</i>, without clearing it,
//   then displays the back buffer to the screen with <i>Swap</i>. It then clears the back buffer and returns to your code, 
//   so if you were to call <i>GetImage</i> immediately after <i>Sync</i> you would get a blank image filled with the current clear color. 
//   Therefore if you want to grab an image of the current scene fully drawn you must call <i>Render</i> then <i>GetImage</i>. The backbuffer
//   will then be cleared automatically ready for the next rendering.<br/><br/>
//   If you are using <i>Update</i>, <i>Render</i>, and <i>Swap</i> yourself instead of <i>Sync</i>, then call <i>GetImage</i> after 
//   <i>Render</i>, you will then need to call <i>Render</i> and <i>Swap</i> to draw to the screen.<br><br>
//   This also allows you to do things such as drawing lines to the back buffer, getting an image of the result and then 
//   clearing it so it doesn't effect what is displayed to the screen.<br><br>
//   Calling <i>GetImage</i> is a slow command and it is not recommended that it be called every frame. A better method would be to use 
//   <i>SetRenderToImage</i> to draw directly to the image on the GPU without transferring it back to the CPU.<br><br>
//   Note that the image produced by this command is not guaranteed to have the same width and height as those given to the 
//   command, this is because the image is created from a portion of the screen which has a different size on different 
//   devices. For example, with a virtual resolution of 480x320, you would get an image of the full screen by calling this 
//   command with a width of 480 and a height of 320, but on an iPhone this would produce an image of 480x320 pixels, whilst 
//   on an iPad it would be around 1024x768 pixels. This should not effect how you use the image as applying it to a sprite 
//   and setting the sprite size to the same 480x320 will make the sprite fill the screen in both cases. It simply means that 
//   on the iPad you have a higher quality image to play with.<br><br>
//   This also applies to the line drawing commands, drawing a line from 0,0 to 100,100 and then getting an image from 0,0
//   to 100,100 will produce a diagonal line image on all devices, but high resolution screen devices will produce an image
//   of higher quality containing more pixels. Use <i>GetImageWidth</i> and <i>GetImageHeight</i> if you need to know the 
//   actual size of the image produced in pixels. <br><br>
//   When drawing transparent sprites and using GetImage on them AGK has to undo the blending of the sprite with the background
//   color to retrieve an image that can be used again in future transparent sprites.
// INPUTS
//   x -- The x coordinate of the top left corner of the box to copy
//   y -- The y coordinate of the top left corner of the box to copy
//   width -- The width of the box to copy
//   height -- The height of the box to copy
// SOURCE
uint32_t agk::GetImage( float x, float y, float width, float height )
//****
{
	uint32_t iID = m_cImageList.GetFreeID( MAX_IMAGES );
	
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get image - no free image IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	agk::GetImage( iID, x, y, width, height );
	return iID;
}

//****f* Image/General/GetImage
// FUNCTION
//   Before using this command consider using <i>SetRenderToImage</i> instead as it will be faster if you just want to
//   draw some things to an image for use later as a texture.<br/><br/>
//   GetImage grabs a portion of the backbuffer and creates a new image from it. The position and size values must be in screen
//   coordinates. Returns the ID of the new image, this must be deleted when you are done with it.
//   To use this command effectively you must know how AGK draws to the back buffer. When <i>Sync</i> is called AGK updates
//   the positions of all objects with <i>Update</i>, then draws them all to the back buffer with <i>Render</i>, without clearing it,
//   then displays the back buffer to the screen with <i>Swap</i>. It then clears the back buffer and returns to your code, 
//   so if you were to call <i>GetImage</i> immediately after <i>Sync</i> you would get a blank image filled with the current clear color. 
//   Therefore if you want to grab an image of the current scene fully drawn you must call <i>Render</i> then <i>GetImage</i>. The backbuffer
//   will then be cleared automatically ready for the next rendering.<br/><br/>
//   If you are using <i>Update</i>, <i>Render</i>, and <i>Swap</i> yourself instead of <i>Sync</i>, then call <i>GetImage</i> after 
//   <i>Render</i>, you will then need to call <i>Render</i> and <i>Swap</i> to draw to the screen.<br><br>
//   This also allows you to do things such as drawing lines to the back buffer, getting an image of the result and then 
//   clearing it so it doesn't effect what is displayed to the screen.<br><br>
//   Calling <i>GetImage</i> is a slow command and it is not recommended that it be called every frame. A better method would be to use 
//   <i>SetRenderToImage</i> to draw directly to the image on the GPU without transferring it back to the CPU.<br><br>
//   Note that the image produced by this command is not guaranteed to have the same width and height as those given to the 
//   command, this is because the image is created from a portion of the screen which has a different size on different 
//   devices. For example, with a virtual resolution of 480x320, you would get an image of the full screen by calling this 
//   command with a width of 480 and a height of 320, but on an iPhone this would produce an image of 480x320 pixels, whilst 
//   on an iPad it would be around 1024x768 pixels. This should not effect how you use the image as applying it to a sprite 
//   and setting the sprite size to the same 480x320 will make the sprite fill the screen in both cases. It simply means that 
//   on the iPad you have a higher quality image to play with.<br><br>
//   This also applies to the line drawing commands, drawing a line from 0,0 to 100,100 and then getting an image from 0,0
//   to 100,100 will produce a diagonal line image on all devices, but high resolution screen devices will produce an image
//   of higher quality containing more pixels. Use <i>GetImageWidth</i> and <i>GetImageHeight</i> if you need to know the 
//   actual size of the image produced in pixels. <br><br>
//   When drawing transparent sprites and using GetImage on them AGK has to undo the blending of the sprite with the background
//   color to retrieve an image that can be used again in future transparent sprites.
// INPUTS
//   imageID -- The image number that will contain the image captured
//   x -- The x coordinate of the top left corner of the box to copy
//   y -- The y coordinate of the top left corner of the box to copy
//   width -- The width of the box to copy
//   height -- The height of the box to copy
// SOURCE
void agk::GetImage( uint32_t imageID, float x, float y, float width, float height )
//****
{
	if ( imageID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get image - image ID must be greater than 0" );
		agk::Error( errStr );
#endif
		return;
	}

	// check if this image has already been loaded
	cImage* pFound = (cImage*) m_cImageList.GetItem( imageID );
	if ( pFound != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get image into image id ", 200 );
		errStr.AppendUInt(  imageID );
		errStr.Append( " - image already added with " );
		errStr.Append( pFound->GetPath() );
		agk::Error( errStr );
#endif
		return;
	}

	// draw any pending lines
	DrawAllLines();
	
	cImage *pImage = new cImage();
	pImage->m_iID = imageID;
	pImage->m_szFile.SetStr( "GetImage" );

	float x2 = x + width;
	float y2 = y + height;

	float temp;
	if ( x2 < x ) 
	{
		temp = x2;
		x2 = x;
		x = temp;
	}

	uint32_t flipped = 0;
	if ( !agk::GetRenderer()->IsTopLeftOrigin() ) flipped = 1 - flipped;
	
	if ( flipped )
	{
		if ( y2 > y )
		{
			temp = y2;
			y2 = y;
			y = temp;
		}
	}
	else
	{
		if ( y2 < y )
		{
			temp = y2;
			y2 = y;
			y = temp;
		}
	}

	int iX = agk::ScreenToViewportX( x );
	int iY = agk::ScreenToViewportY( y );
	int iWidth = agk::ScreenToViewportX( x2 ) - iX;
	int iHeight = agk::ScreenToViewportY( y2 ) - iY;

	pImage->CreateFromScreen( iX, iY, iWidth, iHeight );
	m_cImageList.AddItem( pImage, imageID );
}

//****f* Image/Properties/GetImageFilename
// FUNCTION
//   Returns the file name used to load this image. In tier 2 the returned string must be deleted when 
//   you are done with it.
// INPUTS
//   imageID -- The ID of the image to check.
// SOURCE
char* agk::GetImageFilename( uint32_t imageID )
//****
{
	char *str = new char[ 1 ];
	*str = 0;

	cImage *pImage = (cImage*) m_cImageList.GetItem( imageID );
	if ( !pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get file name for image ", 200 );
		errStr.AppendInt( imageID );
		errStr.Append( " - image does not exist " );
		agk::Error( errStr );
#endif 
		return str;
	}

	const char* path = pImage->GetPath();
	delete [] str;
	str = new char[ strlen(path) + 1 ];
	strcpy( str, path );
	return str;
}

//****f* Image/General/CopyImage
// FUNCTION
//   Copies a portion of the given image into a new image. The x,y,width,height values are in pixels
//   and represent the portion of the image you would like to copy into a new image. The new image
//   with have the same size as the width and height values given.<br><br>
//   This is a slow command and should not be called every frame.
// INPUTS
//   fromImage -- The ID of the image to copy
//   x -- The x coordinate of the top left corner of the box to copy
//   y -- The y coordinate of the top left corner of the box to copy
//   width -- The width of the box to copy
//   height -- The height of the box to copy
// SOURCE
uint32_t agk::CopyImage( uint32_t fromImage, int x, int y, int width, int height )
//****
{
	uint32_t iID = m_cImageList.GetFreeID( MAX_IMAGES );
	
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to copy image - no free image IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	agk::CopyImage( iID, fromImage, x, y, width, height );
	return iID;
}

//****f* Image/General/CopyImage
// FUNCTION
//   Copies a portion of the given image into a new image. The x, y, width, height values are in pixels
//   and represent the portion of the image you would like to copy into a new image. The new image
//   with have the same size as the width and height values given. If an image already exists with 
//   the new ID given it must be deleted before calling this command. This is a slow command
//   and should not be called every frame.
// INPUTS
//   newImage -- The ID of the new image to create, this image must not exist
//   fromImage -- The ID of the image to copy
//   x -- The x coordinate of the top left corner of the box to copy
//   y -- The y coordinate of the top left corner of the box to copy
//   width -- The width of the box to copy
//   height -- The height of the box to copy
// SOURCE
void agk::CopyImage( uint32_t newImage, uint32_t fromImage, int x, int y, int width, int height )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( newImage );
	if ( pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to copy to image ", 200 );
		errStr.AppendInt( newImage );
		errStr.Append( " - image already exists " );
		agk::Error( errStr );
#endif 
		return;
	}

	cImage *pFromImage = (cImage*) m_cImageList.GetItem( fromImage );
	if ( !pFromImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to copy from image ", 200 );
		errStr.AppendInt( fromImage );
		errStr.Append( " - image does not exist " );
		agk::Error( errStr );
#endif 
		return;
	}

	if ( x < 0 || x > pFromImage->GetWidth() || y < 0 || y > pFromImage->GetHeight() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to copy from image ", 200 );
		errStr.AppendInt( fromImage );
		errStr.Append( " - x,y values must be within the image bounds" );
		agk::Error( errStr );
#endif 
		return;
	}

	if ( x + width > pFromImage->GetWidth() || y + height > pFromImage->GetHeight() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to copy from image ", 200 );
		errStr.AppendInt( fromImage );
		errStr.Append( " - width,height values must be within the image bounds" );
		agk::Error( errStr );
#endif 
		return;
	}

	pImage = new cImage();
	pImage->m_iID = newImage;
	pImage->CopyFrom( pFromImage, x,y, width, height );
	m_cImageList.AddItem( pImage, newImage );
}

//****f* Image/Modify/ResizeImage
// FUNCTION
//   Resizes an image to new width and height. If the image is an atlas image then its subimages.txt values
//   will also be resized so that <i>LoadSubImage</i> will still work. Note that if you have previously used
//   <i>LoadSubImage</i> on this image then resizing it will make those sub images display incorrectly.
//   This command will not work on sub images themselves.
// INPUTS
//   imageID -- The ID of the image to resize
//   width -- The new width of the image
//   height -- The new height of the image
// SOURCE
void agk::ResizeImage( uint32_t imageID, int width, int height )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( imageID );
	if ( !pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to resize image ", 200 );
		errStr.AppendInt( imageID );
		errStr.Append( " - image does not exist " );
		agk::Error( errStr );
#endif 
		return;
	}

	if ( width <= 0 || height <= 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to resize image ", 200 );
		errStr.AppendInt( imageID );
		errStr.Append( " - width and height values must be greater than 0" );
		agk::Error( errStr );
#endif 
		return;
	}

	pImage->Resize( width, height );
}
    
//****f* Image/Choose/ShowChooseImageScreen
// FUNCTION
//   Presents the user with an option to choose an image stored on their current platform, for example
//   a photo on a phone or an image saved on a PC. This does not immediately capture the image, depending 
//   on the platform your app may continue running in the background whilst the user is choosing an image, 
//   or it may pause execution whilst the image is chosen. In any case you must assume your app continues 
//   running but is no longer visible, use <i>IsChoosingImage</i> to check when the user returns from the image 
//   choosing process, and <i>GetChosenImage</i> to discover the result of the process.<br><br>
//   This function returns 1 if it was successful in displaying the choose screen, 0 otherwise.
// SOURCE
uint32_t agk::ShowChooseImageScreen()
//****
{
    if ( m_bIsChoosing ) return 1;
    
    if ( m_pUncollectedChosenImage ) delete m_pUncollectedChosenImage;
	m_pUncollectedChosenImage = 0;
    
    agk::m_bIsChoosing = true;
    agk::PlatformShowChooseScreen();
    return 1;
}
    
void agk::ChooseInternal(int value)
{
    if ( value == 0 )
    {
        if ( m_pUncollectedChosenImage ) delete m_pUncollectedChosenImage;
        m_pUncollectedChosenImage = 0;
    }
    
    m_bIsChoosing = false;
}
    
//****f* Image/Choose/IsChoosingImage
// FUNCTION
//   Returns 1 if AGK is currently displaying a choose image screen and waiting for the user to pick an image.
//   When this returns 0 the user has either cancelled or chosen an image, check <i>GetChosenImage</i>
//   to see what the result was.
// SOURCE
uint32_t agk::IsChoosingImage()
//****
{
    return m_bIsChoosing;
}

//****f* Image/Choose/GetChosenImage
// FUNCTION
//   Returns the ID of a newly chosen image picked using <i>ShowChooseImageScreen</i>. If this returns
//   0 then the user cancelled the process or you have not yet started it with <i>ShowChooseImageScreen</i>.
//   Once you have called this command to retrieve the image ID it will return 0 until <i>ShowChooseImageScreen</i>
//   is called again.
// SOURCE
uint32_t agk::GetChosenImage()
//****
{
    if ( m_bIsChoosing ) return 0;
    if ( !m_pUncollectedChosenImage ) return 0;
    
    uint32_t iID = m_cImageList.GetFreeID( MAX_IMAGES );
	
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to choose image - no free image IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}
    
    m_pUncollectedChosenImage->m_iID = iID;
    m_cImageList.AddItem( m_pUncollectedChosenImage, iID );
    m_pUncollectedChosenImage = 0;
    return iID;
}

//****f* Image/Capture/ShowImageCaptureScreen
// FUNCTION
//   <b>This function has been deprecated, use <i>SetDeviceCameraToImage</i> instead.</b><br/><br/>
//   Presents the user with an option to take a photo with the device camera, if available. If the device
//   does not have a camera, or otherwise cannot be used, this will return 0 and your app will continue as
//   normal. This does not immediately capture the image, depending on the platform your app may continue
//   running in the background whilst the user is taking a photo, or it may pause execution whilst the 
//   photo is taken. In any case you must assume your app continues running but is no longer visible, use 
//   <i>IsCapturingImage</i> to check when the user returns from the image capture process, and <i>GetCapturedImage</i>
//   to discover the result of the process.
//   This does not currently work on Mac.
// SOURCE
uint32_t agk::ShowImageCaptureScreen()
//****
{
	if ( m_bIsCapturing ) return 1;

	bool result = agk::PlatformShowCaptureScreen();
	if ( result ) agk::m_bIsCapturing = true;
	return result ? 1 : 0;
}

void agk::CaptureImage()
{
	if ( !m_bIsCapturing ) return;

	if ( m_iUncollectedCaptureImage ) agk::DeleteImage( m_iUncollectedCaptureImage );
	m_iUncollectedCaptureImage = 0;

	uint32_t iID = m_cImageList.GetFreeID( MAX_IMAGES );
	
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to capture image - no free image IDs found" );
		agk::Error( errStr );
#endif
		return;
	}

	cImage *pImage = new cImage();
	pImage->m_iID = iID;
	if ( !pImage->CaptureFromCamera() )
	{
		delete pImage;
		return;
	}

	m_cImageList.AddItem( pImage, iID );
	m_iUncollectedCaptureImage = iID;
}
    
void agk::CaptureInternal(int value)
{
    if ( value == 0 )
    {
        if ( m_iUncollectedCaptureImage ) agk::DeleteImage( m_iUncollectedCaptureImage );
        m_iUncollectedCaptureImage = 0;
    }
    
    m_bIsCapturing = false;
}

void agk::CancelCapture()
{
	agk::PlatformHideCaptureScreen();
	agk::m_bIsCapturing = false;
}

//****f* Image/Capture/IsCapturingImage
// FUNCTION
//   <b>This function has been deprecated, use <i>SetDeviceCameraToImage</i> instead.</b><br/><br/>
//   Returns 1 if AGK is currently displaying a camera feed and waiting for the user to capture an image.
//   When this returns 0 the user has either cancelled or captured an image, check <i>GetCapturedImage</i>
//   to see what the result was.
// SOURCE
uint32_t agk::IsCapturingImage()
//****
{
	return m_bIsCapturing;
}

//****f* Image/Capture/GetCapturedImage
// FUNCTION
//   <b>This function has been deprecated, use <i>SetDeviceCameraToImage</i> instead.</b><br/><br/>
//   Returns the ID of a newly captured image created using <i>ShowImageCaptureScreen</i>. If this returns
//   0 then the user cancelled the process or you have not yet started it with <i>ShowImageCaptureScreen</i>.
//   Once you have called this command to retrieve the image ID it will return 0 until <i>ShowImageCaptureScreen</i>
//   is called again.
// SOURCE
uint32_t agk::GetCapturedImage()
//****
{
    if ( m_bIsCapturing ) return 0;
    
	uint32_t iID = m_iUncollectedCaptureImage;
	m_iUncollectedCaptureImage = 0;
	return iID;
}

//****f* Image/QR/DecodeQRCode
// FUNCTION
//   Attempts to decode a QR code and return the string encoded within it.
//   Returns an empty string if it could not find a QR code in the image or failed to decode it.
//   Multiple QR codes in the image are likely to cause the decode to fail.
// INPUTS
//   image -- The ID of the image to decode, can be an image captured from the camera
// SOURCE
char* agk::DecodeQRCode( uint32_t image )
//****
{
	char* str = new char[1];
	str[0] = 0;

	cImage *pFromImage = (cImage*) m_cImageList.GetItem( image );
	if ( !pFromImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to decode QR image ", 200 );
		errStr.AppendInt( image );
		errStr.Append( " - image does not exist " );
		agk::Error( errStr );
#endif 
		return str;
	}

	uString out("");
	int length = pFromImage->DecodeQR( out );
	if ( length > 0 ) 
	{
		delete [] str;
		str = new char[ length+1 ];
		strcpy( str, out.GetStr() );
	}

	return str;
}

//****f* Image/QR/EncodeQRCode
// FUNCTION
//   Encodes the given text into a QR code and returns a new image ID containing that code.
//   You can select the amount of error correction included in the code to allow part of the QR code
//   to become damaged but still be readable. The higher the error correction mode the more likely
//   it is that a damaged or obscured QR code will be read correctly, but higher error correction 
//   modes may produce a larger QR code.<br><br>
//   Level 0 still provides a minimal level of error correction rather than none.
// INPUTS
//   text -- The text to encode.
//   errormode -- The level of error correction to include in the code from 0 (lowest) to 3 (highest)
// SOURCE
uint32_t agk::EncodeQRCode( const char* text, int errormode )
//****
{
	if ( !text ) return 0;
	
	uint32_t iID = m_cImageList.GetFreeID( MAX_IMAGES );
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to encode QR code - no free image IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	cImage *pImage = new cImage();
	pImage->m_iID = iID;
	if ( !pImage->EncodeQR(text,errormode) )
	{
		delete pImage;
		return 0;
	}

	m_cImageList.AddItem( pImage, iID );
	return iID;
}

//****f* Image/General/PrintImage
// FUNCTION
//   Prints an image to a connected printer. This command is not guaranteed to work on all platforms.
//   The size parameter determines how large the image is on the page, a value of 100 makes it use
//   as much of the page as possible, 50 makes it use half this amount, 25 a quarter and so on.
// INPUTS
//   image -- the ID of the image to print
//   size -- the amount of space to use on the page, between 0 and 100.
// SOURCE
void agk::PrintImage( uint32_t image, float size )
//****
{
	cImage *pImage = (cImage*) m_cImageList.GetItem( image );
	if ( !pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to print image ", 200 );
		errStr.AppendInt( image );
		errStr.Append( " - image does not exist " );
		agk::Error( errStr );
#endif 
		return;
	}

	if ( size < 0 ) size = 0;
	if ( size > 100 ) size = 100;

	pImage->Print( size );
}

void agk::SetImageSavePixels( int mode )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "SetImageSavePixels() has been removed from AppGameKit and no longer does anything, it should be removed from your code" );
		warned = 1;
	}
}

//****f* Core/Display/IsSupportedDepthTexture
// FUNCTION
//   This command returns 1 if the current device supports using depth images with <i>SetRenderToImage</i>. If this
//   returns 0 then the only valid depth image IDs to SetRenderToImage are 0 for no depth, or -1 for an internal depth 
//   buffer.
// SOURCE
uint32_t agk::IsSupportedDepthTexture()
//****
{
	if ( !g_pRenderer ) return 0;
	return g_pRenderer->SupportsDepthTexture();
}

//****f* Core/Display/IsInvertedDepth
// FUNCTION
//   Returns 1 if the current renderer is using an inverted depth buffer, 0 if not. Inverted depth buffers are useful
//   when the renderer is using a floating point depth buffer as it solves almost all depth fighting issues involved
//   with drawing large depth ranges. If an inverted depth buffer is being used then depth values of 1.0 are near the 
//   camera and depth values of 0.0 are far away. AGK automatically adjusts the depth buffer function (less or greater)
//   depending on whether the depth buffer is inverted or not, so you can assume that values around 0.0 are close to 
//   the camera most of the time. But if you draw to a depth buffer for your own use then you will need to take this
//   into account if you use those depth values in a shader, e.g. when doing your own shadows.
// SOURCE
int agk::IsInvertedDepth()
//****
{
	if ( !g_pRenderer ) return 0;
	return g_pRenderer->IsInvertedDepth();
}

//****f* Core/Display/GetClipSpaceMode
// FUNCTION
//   Returns 0 if the Z clip space range is -1 to 1 and returns 1 if the Z clip space range is 0 to 1. This depends
//   on the renderer curently being used, for example OpenGL uses a clip space range from -1 to 1 whereas Vulkan uses 
//   a clip space range from 0 to 1. This only applies to the Z coordinate, both X and Y will always be in the range 
//   -1 to 1 in clip space.
// SOURCE
int agk::GetClipSpaceMode()
//****
{
	if ( !g_pRenderer ) return 0;
	return g_pRenderer->IsClipSpaceZeroOne();
}

//****f* Core/Display/IsTopLeftOrigin
// FUNCTION
//   Returns 1 if the framebuffer origin is in the top left corner (such as in Vulkan) or 0 if the origin
//   is in the bottom left corner (such as OpenGL).
// SOURCE
int agk::IsTopLeftOrigin()
//****
{
	if ( !g_pRenderer ) return 0;
	return g_pRenderer->IsTopLeftOrigin();
}

//****f* 3D/Shaders/GetSupportedShaderVaryings
// FUNCTION
//   Returns the number of varying values that can be used in shaders on the current device. Varyings are
//   the variables that pass data between the vertex and pixel shaders. This value is guaranteed to be at 
//   least 32, but most devices support more. A single vec4 varying holds 4 varying values, so 32 varyings 
//   values means you can have a maximum of 8 vec4 varyings. Note that a vec3 varying may take up 4 value 
//   spaces if it cannot be packed with any other varying. Varyings may be packed together if they can 
//   fill a vec4 without being split, for example a vec3 and a float can be packed together,
//   as can two vec2 varyings. However two vec3 varyings cannot be packed together without being split up
//   so they will each use up 4 values with the extra space being wasted. Packing is determined by the driver
//   and cannot be guaranteed.
// SOURCE
int agk::GetSupportedShaderVaryings()
//****
{
	if ( !g_pRenderer ) return 0;
	return g_pRenderer->GetMaxVaryings();
}

//
// Sprite functions
//

cSprite* agk::GetSpritePtr( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite;
}

//****f* Sprite/Properties/GetSpriteImageID
// FUNCTION
//   Gets the ID of the image currently assigned to the sprite. This only works if the image was loaded
//   with an ID (or assigned one by AGK).
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
uint32_t agk::GetSpriteImageID( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	cImage* pImage = pSprite->GetImagePtr();
	if ( !pImage ) return 0;
	return pImage->GetID();
}

//****f* Sprite/Creation/CreateSprite
// FUNCTION
//   Creates a sprite from a specified image ID to use when rendering.<br><br>
//   By default sprites are created with a depth of 10, are sized using the 
//   given image as a guide, and positioned at 0,0 using their top left corner.<br><br>
//   You may use an image ID of 0 to create a blank sprite drawn with color only.
//   If the assigned image has alpha pixels the sprite is create with a transparency mode 
//   of 1, otherwise it uses a transparency mode of 0 (opaque)
// INPUTS
//   iSpriteIndex -- The sprite ID to use to reference this sprite later (separate from image IDs, so there can be both a sprite 1 and an image 1)
//   iImageIndex -- The ID of the image to use when drawing this sprite
// SOURCE
void agk::CreateSprite( uint32_t iSpriteIndex, uint32_t iImageIndex )
//****
{
	cImage *pImage = 0;
	if ( iImageIndex > 0 )
	{
		pImage = m_cImageList.GetItem( iImageIndex );
		if ( pImage == 0 ) 
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "", 100 );
			errStr.Format( "Failed to create sprite %d, Image %d does not exist", iSpriteIndex, iImageIndex );
			Error( errStr );
#endif
			return;
		}
	}

	if ( iSpriteIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create sprite %d, ID must be greater than 0", iSpriteIndex );
		Error( errStr );
#endif
		return;
	}

	if ( m_cSpriteList.GetItem( iSpriteIndex ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create sprite %d, ID already exists", iSpriteIndex );
		Error( errStr );
#endif
		return;
	}

	cSprite *pSprite = new cSprite( pImage );
	m_cSpriteList.AddItem( pSprite, iSpriteIndex );
	m_cSpriteMgrFront.AddSprite( pSprite );
	pSprite->SetID( iSpriteIndex );
}

//****f* Sprite/Creation/CreateSprite
// FUNCTION
//   Creates a sprite in a blank sprite ID with an image to use when rendering, it returns the sprite ID used.<br><br>
//   By default sprites are created with a depth of 10, are sized using the 
//   given image as a guide, and positioned at 0,0 using their top left corner.<br><br>
//   You may use an image ID of 0 to create a blank sprite drawn with color only.
//   If the assigned image has alpha pixels the sprite is create with a transparency mode 
//   of 1, otherwise it uses a transparency mode of 0 (opaque)
// INPUTS
//   iImageIndex -- The ID of the image to use when drawing this sprite
// SOURCE
uint32_t agk::CreateSprite( uint32_t iImageIndex )
//****
{
	uint32_t iID = m_cSpriteList.GetFreeID( MAX_SPRITES );
	
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create sprite - no free sprite IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	cImage *pImage = 0;
	if ( iImageIndex > 0 )
	{
		pImage = m_cImageList.GetItem( iImageIndex );
		if ( pImage == 0 ) 
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "", 100 );
			errStr.Format( "Failed to create sprite, Image %d does not exist", iImageIndex );
			Error( errStr );
#endif
			return 0;
		}
	}

	cSprite *pSprite = new cSprite( pImage );
	m_cSpriteList.AddItem( pSprite, iID );
	m_cSpriteMgrFront.AddSprite( pSprite );
	pSprite->SetID( iID );
	return iID;
}

//****f* Sprite/Creation/LoadSprite
// FUNCTION
//   Creates a sprite in a blank sprite ID with an explicit image to use when rendering, it returns the sprite ID used.<br><br>
//   By default sprites are created with a depth of 10, are sized using the 
//   given image as a guide, and positioned at 0,0 using their top left corner.<br><br>
//   If the assigned image has alpha pixels the sprite is create with a transparency mode 
//   of 1, otherwise it uses a transparency mode of 0 (opaque)
//   This command takes an image file name and loads it specifically for this sprite, this image will be deleted when the 
//   sprite is deleted. If lots of sprites are going to use the same image you should load the image separately and pass its
//   ID to the <i>CreateSprite</i> command to save memory.
// INPUTS
//   imagefile -- The file name of the image to use when drawing this sprite
// SOURCE
uint32_t agk::LoadSprite( const char* imagefile )
//****
{
	uint32_t iID = m_cSpriteList.GetFreeID( MAX_SPRITES );
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create sprite - no free sprite IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	cSprite *pSprite = new cSprite( imagefile );
	m_cSpriteList.AddItem( pSprite, iID );
	m_cSpriteMgrFront.AddSprite( pSprite );
	pSprite->SetID( iID );
	return iID;
}

//****f* Sprite/Creation/LoadSprite
// FUNCTION
//   Creates a sprite from a specified image file to use when rendering.<br><br>
//   By default sprites are created with a depth of 10, are sized using the 
//   given image as a guide, and positioned at 0,0 using their top left corner.<br><br>
//   If the assigned image has alpha pixels the sprite is create with a transparency mode 
//   of 1, otherwise it uses a transparency mode of 0 (opaque)
//   This command takes an image file name and loads it specifically for this sprite, this image will be deleted when the 
//   sprite is deleted. If lots of sprites are going to use the same image you should load the image separately and pass its
//   ID to the <i>CreateSprite</i> command to save memory.
// INPUTS
//   iSpriteIndex -- The sprite ID to use to reference this sprite later (separate from image IDs, so there can be both a sprite 1 and an image 1)
//   imagefile -- The file name of the image to use when drawing this sprite
// SOURCE
void agk::LoadSprite( uint32_t iSpriteIndex, const char* imagefile )
//****
{
	if ( iSpriteIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create sprite %d, ID must be greater than 0", iSpriteIndex );
		Error( errStr );
#endif
		return;
	}

	if ( m_cSpriteList.GetItem( iSpriteIndex ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create sprite %d, ID already exists", iSpriteIndex );
		Error( errStr );
#endif
		return;
	}

	cSprite *pSprite = new cSprite( imagefile );
	m_cSpriteList.AddItem( pSprite, iSpriteIndex );
	m_cSpriteMgrFront.AddSprite( pSprite );
	pSprite->SetID( iSpriteIndex );
}

//****f* Sprite/Creation/CloneSprite
// FUNCTION
//   Clones a sprite into a given sprite ID. The new sprite will be in in exactly the same position as the original.<br><br>
//   Any physics values or shapes assigned to the sprite will not be copied. The new sprite will not be setup for
//   physics.
// INPUTS
//   iSpriteIndex -- The ID to use for the new sprite.
//   iOtherSprite -- The ID of the sprite to copy.
// SOURCE
void agk::CloneSprite( uint32_t iSpriteIndex, uint32_t iOtherSprite )
//****
{
	cSprite* pOtherSprite = m_cSpriteList.GetItem( iOtherSprite );
	if ( !pOtherSprite )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to clone sprite, Sprite %d does not exist", iOtherSprite );
		Error( errStr );
#endif
		return;
	}

	cSprite* pSprite = m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to clone sprite, Sprite %d already exists", iSpriteIndex );
		Error( errStr );
#endif
		return;
	}

	pSprite = new cSprite( pOtherSprite );
	pSprite->SetID( iSpriteIndex );
	m_cSpriteList.AddItem( pSprite, iSpriteIndex );
	m_cSpriteMgrFront.AddSprite( pSprite );
}

//****f* Sprite/Creation/CloneSprite
// FUNCTION
//   Clones a sprite into a free ID and returns it. The new sprite will be in in exactly the same position as the original.<br><br>
//   Any physics values or shapes assigned to the sprite will not be copied. The new sprite will not be setup for
//   physics.
// INPUTS
//   iOtherSprite -- The ID of the sprite to copy.
// SOURCE
uint32_t agk::CloneSprite( uint32_t iOtherSprite )
//****
{
	cSprite* pOtherSprite = m_cSpriteList.GetItem( iOtherSprite );
	if ( !pOtherSprite )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to clone sprite, Sprite %d does not exist", iOtherSprite );
		Error( errStr );
#endif
		return 0;
	}

	uint32_t iID = m_cSpriteList.GetFreeID();

	cSprite *pSprite = new cSprite( pOtherSprite );
	pSprite->SetID( iID );
	m_cSpriteList.AddItem( pSprite, iID );
	m_cSpriteMgrFront.AddSprite( pSprite );
	return iID;
}

//****f* Sprite/Creation/CreateDummySprite
// FUNCTION
//   Creates a sprite in the given sprite ID, it returns the sprite ID used. Dummy sprites behave as normal 
//   sprites but have no image or other visual aspect to them. They will not be drawn even if an image is 
//   assigned to them. They are useful for adding physics objects to a scene without needing visuals to 
//   accompany the physics shape. You can use the physics contact and feedback commands to work out what
//   has hit these hidden physics shapes if desired. If you do not need to know what has hit your hidden
//   shapes then you can add them all to a single dummy sprite using the <i>AddSpriteShape</i> commands for best
//   performance.<br><br>
//   <i>SetSpriteShape</i> will not work on dummy sprites as they have no image to calculate a shape, shapes must
//   be defined manually using <i>SetSpriteShapeBox</i>, <i>SetSpriteShapeCircle</i>, or <i>SetSpriteShapePolygon</i>.<br><br>
//   Dummy sprites will not update their stored angle and position with the latest physics versions, so calls
//   to <i>GetSpriteX</i>, <i>GetSpriteY</i>, or <i>GetSpriteAngle</i> will return the last value you set. Setting the sprite's
//   position will update the physics body to the position you set.
// INPUTS
//   iSpriteIndex -- The ID to use for this sprite.
// SOURCE
void agk::CreateDummySprite( uint32_t iSpriteIndex )
//****
{
	if ( iSpriteIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create sprite %d, ID must be greater than 0", iSpriteIndex );
		Error( errStr );
#endif
		return;
	}

	if ( m_cSpriteList.GetItem( iSpriteIndex ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create sprite %d, ID already exists", iSpriteIndex );
		Error( errStr );
#endif
		return;
	}

	cSprite *pSprite = new cSprite( );
	m_cSpriteList.AddItem( pSprite, iSpriteIndex );
	pSprite->SetID( iSpriteIndex );
}

//****f* Sprite/Creation/CreateDummySprite
// FUNCTION
//   Creates a sprite in a blank sprite ID, it returns the sprite ID used. Dummy sprites behave as normal 
//   sprites but have no image or other visual aspect to them. They will not be drawn even if an image is 
//   assigned to them. They are useful for adding physics objects to a scene without needing visuals to 
//   accompany the physics shape. You can use the physics contact and feedback commands to work out what
//   has hit these hidden physics shapes if desired. If you do not need to know what has hit your hidden
//   shapes then you can add them all to a single dummy sprite using the <i>AddSpriteShape</i> commands for best
//   performance.<br><br>
//   <i>SetSpriteShape</i> will not work on dummy sprites as they have no image to calculate a shape, shapes must
//   be defined manually using <i>SetSpriteShapeBox</i>, <i>SetSpriteShapeCircle</i>, or <i>SetSpriteShapePolygon</i>.<br><br>
//   Dummy sprites will not update their stored angle and position with the latest physics versions, so calls
//   to <i>GetSpriteX</i>, <i>GetSpriteY</i>, or <i>GetSpriteAngle</i> will return the last value you set. Setting the sprite's
//   position will update the physics body to the position you set.
// SOURCE
uint32_t agk::CreateDummySprite( )
//****
{
	uint32_t iID = m_cSpriteList.GetFreeID( MAX_SPRITES );
	
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create dummy sprite - no free sprite IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	cSprite *pSprite = new cSprite( );
	m_cSpriteList.AddItem( pSprite, iID );
	pSprite->SetID( iID );
	return iID;
}

//****f* Sprite/Properties/GetSpriteExists
// FUNCTION
//   Returns 1 if the sprite exists, 0 if not.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check
// SOURCE
uint32_t agk::GetSpriteExists( uint32_t iSpriteIndex )
//****
{
	if ( m_cSpriteList.GetItem( iSpriteIndex ) ) return 1;
	return 0;
}

//****f* Sprite/Creation/DeleteSprite
// FUNCTION
//   Deletes the sprite at the given ID.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to delete
// SOURCE
void agk::DeleteSprite( uint32_t iSpriteIndex )
//****
{
	cSprite* pSprite = (cSprite*) m_cSpriteList.RemoveItem( iSpriteIndex );
	if ( pSprite ) 
	{
		if ( m_pSpriteContactIter == pSprite ) m_pSpriteContactIter = 0;
		m_cSpriteMgrFront.RemoveSprite( pSprite );
		delete pSprite;
	}
}

//****f* Sprite/Creation/DeleteAllSprites
// FUNCTION
//   Deletes all sprites created with CreateSprite, CreateDummySprite, or LoadSprite. This also resets the 
//   auto sprite ID to 10000.
// SOURCE
void agk::DeleteAllSprites()
//****
{
	cSprite *pSprite = m_cSpriteList.GetFirst();
	while ( pSprite )
	{
		delete pSprite;		
		pSprite = m_cSpriteList.GetNext();
	}
	m_cSpriteList.ClearAll();
	m_cSpriteMgrFront.ClearSprites();
}

//****f* Sprite/Properties/SetSpriteImage
// FUNCTION
//   Change the sprite image to a new loaded image. If the new image has a different size or shape from the old image
//   the sprite may look distorted as a result, you can fix this by resetting the sprite dimensions using <i>SetSpriteSize</i>.
//   If the sprite is animated you may also need to call <i>SetSpriteAnimation</i> again.<br><br>
//   By default the collision shape is not modified, you can pass an additional parameter to update the collision shape
//   although this is an expensive process.
//   Using this command will clear any animation frames you have set with any of the sprite animation commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iImageIndex -- The ID of the image to use for this sprite.
// SOURCE
void agk::SetSpriteImage ( uint32_t iSpriteIndex, uint32_t iImageIndex )
//****
{
	SetSpriteImage( iSpriteIndex, iImageIndex, 0 );
}

//****f* Sprite/Properties/SetSpriteImage
// FUNCTION
//   Change the sprite image to a new loaded image. If the new image has a different size or shape from the old image
//   the sprite may look distorted as a result, you can fix this by resetting the sprite dimensions using <i>SetSpriteSize</i>.
//   If the sprite is animated you may also need to call <i>SetSpriteAnimation</i> again.<br><br>
//   In the case of circle and polygon sprites you may set whether the sprite uses this new image to change its collision
//   shape. Box shapes are not affected by image changes.
//   Using this command will clear any animation frames you have set with any of the sprite animation commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iImageIndex -- The ID of the image to use for this sprite.
//   bUpdateShape -- Sets whether the collision shape of this sprite should be changed to match the new image. ( 1 or 0 )
// SOURCE
void agk::SetSpriteImage ( uint32_t iSpriteIndex, uint32_t iImageIndex, int bUpdateShape )
//****
{
	cImage *pImage = 0;
	if ( iImageIndex > 0 )
	{
		pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
		if ( pImage == 0 ) 
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Image ", 50 );
			errStr.AppendUInt( iImageIndex );
			errStr.Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}
	else bUpdateShape = false;

	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetImage( pImage, bUpdateShape>0 );
}

//****f* Sprite/Properties/SetSpriteAdditionalImage
// FUNCTION
//   Adds additional images to the sprite that can be used with shaders. The image set with <i>SetSpriteImage</i>
//   is used as texture stage 0, and this command will let you set stages 1 to 7. These additional images do not
//   play any part in animation or shape calculations.
//   Note that the sprite will have the same UV coordinates for each texture so it is recommended that the images
//   have the same dimensions, or use power of 2 images to avoid UV conversions on mobile devices where images
//   might be scaled.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iImageIndex -- The ID of the image to use for this sprite.
//   iStage -- The index of the texture stage to use, in the range 1 to 7.
// SOURCE
void agk::SetSpriteAdditionalImage ( uint32_t iSpriteIndex, uint32_t iImageIndex, int iStage )
//****
{
	if ( iStage < 1 || iStage > 7 )
	{
		Error( "SetSpriteAdditionalImage using invalid stage index, must be in the range 1 to 7" );
		return;
	}

	cImage *pImage = 0;
	if ( iImageIndex > 0 )
	{
		pImage = (cImage*) m_cImageList.GetItem( iImageIndex );
		if ( pImage == 0 ) 
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Image ", 50 );
			errStr.AppendUInt( iImageIndex );
			errStr.Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}

	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetAdditionalImage( pImage, iStage );
}

//****f* Sprite/Properties/SetSpriteUV
// FUNCTION
//   This command overrides the normal UV calculations of the sprites and allows you to set them directly
//   for each vertex. Note that animation using sprite sheets or atlas textures will not function when
//   using this command, and the UV offset and zoom functions will have no effect. You have complete
//   control over the UV coordinates. To undo this use <i>ResetSpriteUV</i> to return to calculated UV coordinates.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   u1 -- The U coordinate of the top left vertex.
//   v1 -- The V coordinate of the top left vertex.
//   u2 -- The U coordinate of the bottom left vertex.
//   v2 -- The V coordinate of the bottom left vertex.
//   u3 -- The U coordinate of the top right vertex.
//   v3 -- The V coordinate of the top right vertex.
//   u4 -- The U coordinate of the bottom right vertex.
//   v4 -- The V coordinate of the bottom right vertex.
// SOURCE
void agk::SetSpriteUV ( uint32_t iSpriteIndex, float u1, float v1, float u2, float v2, float u3, float v3, float u4, float v4 )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetUV( u1, v1, u2, v2, u3, v3, u4, v4 );
}

//****f* Sprite/Properties/ResetSpriteUV
// FUNCTION
//   This command reinstates the normal functionality of UV coordinates after a call to <i>SetSpriteUV</i>.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
// SOURCE
void agk::ResetSpriteUV( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->ResetUV();
}

//****f* Sprite/Properties/SetSpritePosition
// FUNCTION
//   Immediately positions the specified sprite to the given X,Y world coordinates. The default world coordinate system has 0,0 as 
//   the top left corner, and 100,100 as the bottom right hand corner of the screen (this can be changed using <i>SetVirtualResolution</i>). 
//   This function always positions the sprite using its top left corner, regardless of the current sprite offset. The top left 
//   corner used to position the sprite does not rotate with the sprite, for example as the sprite rotates around its center the 
//   imaginary top left corner remains fixed and the sprite's position value does not change.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to position
//   fX -- The X coordinate to position the sprite, can use decimal values.
//   fY -- the Y coordinate to position the sprite, can use decimal values.
// SOURCE
void agk::SetSpritePosition( uint32_t iSpriteIndex, float fX, float fY )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPosition( fX, fY );
}

//****f* Sprite/Properties/SetSpritePositionByOffset
// FUNCTION
//   Immediately positions the specified sprite to the given X,Y world coordinates. The default world coordinate system has 0,0 as 
//   the top left corner, and 100,100 as the bottom right hand corner of the screen (this can be changed using <i>SetVirtualResolution</i>). 
//   <br><br>This function always positions the sprite using its current offset. For example if the current offset is the center of the sprite 
//   this command will place the center of the sprite at the given coordinates.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to position
//   fX -- The X coordinate to position the sprite, can use decimal values.
//   fY -- the Y coordinate to position the sprite, can use decimal values.
// SOURCE
void agk::SetSpritePositionByOffset( uint32_t iSpriteIndex, float fX, float fY )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPositionByOffset( fX, fY );
}

//****f* Sprite/Properties/SetSpriteX
// FUNCTION
//   Immediately positions the specified sprite to the given X world coordinates. The default world coordinate system has 0,0 as 
//   the top left corner, and 100,100 as the bottom right hand corner of the screen (this can be changed using <i>SetVirtualResolution</i>).<br><br>
//   This command positions the sprite by its top left corner.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to position
//   fX -- The X coordinate to position the sprite, can use decimal values.
// SOURCE
void agk::SetSpriteX ( uint32_t iSpriteIndex, float fX )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetX( fX );
}

//****f* Sprite/Properties/SetSpriteY
// FUNCTION
//   Immediately positions the specified sprite to the given Y world coordinates. The default world coordinate system has 0,0 as 
//   the top left corner, and 100,100 as the bottom right hand corner of the screen (this can be changed using <i>SetVirtualResolution</i>).
//   <br><br>This command positions the sprite by its top left corner.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to position
//   fY -- The Y coordinate to position the sprite, can use decimal values.
// SOURCE
void agk::SetSpriteY ( uint32_t iSpriteIndex, float fY )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetY( fY );
}

//****f* Sprite/Properties/SetSpriteAngle
// FUNCTION
//   Immediately rotates the specified sprite to the given angle in degrees. By default sprites rotate around 
//   their center, see <i>SetSpriteOffset</i> to change this.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to rotate.
//   fAng -- The angle to set the sprite in degrees.
// SOURCE
void agk::SetSpriteAngle( uint32_t iSpriteIndex, float fAng )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetAngle( fAng );
}

//****f* Sprite/Properties/SetSpriteAngleRad
// FUNCTION
//   Immediately rotates the specified sprite to the given angle in radians. By default sprites rotate around 
//   their center, see <i>SetSpriteOffset</i> to change this.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to rotate.
//   fAng -- The angle to set the sprite in radians.
// SOURCE
void agk::SetSpriteAngleRad( uint32_t iSpriteIndex, float fAng )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetAngleRad( fAng );
}

//****f* Sprite/Properties/SetSpriteDepth
// FUNCTION
//   Sets the draw order for the sprite between 0-10000, 0 being the front of the screen, 10000 being the back.
//   Anything above 10000 will result in the sprite being clipped from view. By default sprites are at depth 10.
//   If two sprites occupy the same depth then the order they are drawn is undefined unless <i>SetSortCreated</i>
//   is used to true, in which case sprites at the same depth will be drawn in the order they were created.
//   For maximum performance it is recommended that every sprite has its own depth value unless the order
//   they are drawn is not important, for example physics sprites that won't normally overlap.
//   Note that if you are not using any 3D objects and you are using sprite depths greater then 5000 you should 
//   use SetGlobal3DDepth to 10000 to improve performance (essentially bringing all sprites to the front of the 
//   3D renderer).
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iDepth -- The depth this sprite should be drawn at.
// SOURCE
void agk::SetSpriteDepth ( uint32_t iSpriteIndex, int iDepth )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetDepth( iDepth );
}

//****f* Sprite/Properties/SetSpriteFlip
// FUNCTION
//   Flips the sprite either horizontally or vertically, (or both). This merely modifies the UV coordinates
//   so that the sprite appears flipped, it does not adjust position or angle values. Note that flipping in
//   both horizontal and vertical directions at the same time gives the appearance of rotation by 180 degrees.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   horz -- 1 to flip to sprite horizontally left to right, 0 to keep the sprite normal.
//   vert -- 1 to flip to sprite vertically top to bottom, 0 to keep the sprite normal.
// SOURCE
void agk::SetSpriteFlip ( uint32_t iSpriteIndex, int horz, int vert )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetFlip( horz, vert );
}

//****f* Sprite/Properties/SetSpriteSnap
// FUNCTION
//   Turns on a special render mode that keeps the sprite on whole pixels only so it does not draw itself
//   across pixel boundaries which may cause flickering as the sprite moves across the screen.
//   As a consequence this may make the sprite appear to jump from the one pixel to the next as it moves
//   instead of smoothly moving across the screen. If the sprite has alpha blended pixels along its edge 
//   then snapping is not required and can be turned off. By default this is turned off.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   snap -- 1 to turn snapping on, 0 to turn it off
// SOURCE
void agk::SetSpriteSnap ( uint32_t iSpriteIndex, int snap )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetSnap( snap );
}


//****f* Sprite/Properties/SetSpriteVisible
// FUNCTION
//   Sets whether this sprite is visible during drawing. It may still update its animation and physics,
//   which are controlled by <i>SetSpriteActive</i>.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   bVisible -- The visibility of this sprite, 1 for visible, 0 for not visible.
// SOURCE
void agk::SetSpriteVisible ( uint32_t iSpriteIndex, int bVisible )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetVisible( bVisible>0 );
}

//****f* Sprite/Properties/SetSpriteActive
// FUNCTION
//   Sets whether this sprite updates its animation and physics every frame, the sprite may be visible
//   or not, which is controlled by <i>SetSpriteVisible</i>.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   bActive -- Set to 1 if this sprite should be updated, 0 if not.
// SOURCE
void agk::SetSpriteActive ( uint32_t iSpriteIndex, int bActive )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );
		errStr.AppendUInt( iSpriteIndex );
		errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetActive( bActive>0 );
}

//****f* Sprite/Properties/GetSpriteX
// FUNCTION
//   Returns the current X coordinate of the sprite's top left corner as a floating point value.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteX( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetX();
}

//****f* Sprite/Properties/GetSpriteY
// FUNCTION
//   Returns the current Y coordinate of the sprite's top left corner as a floating point value.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteY( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
	
	return pSprite->GetY();
}

//****f* Sprite/Properties/GetSpriteXByOffset
// FUNCTION
//   Returns the current X coordinate of the sprite's current offset point in the world.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteXByOffset( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetXByOffset();
}

//****f* Sprite/Properties/GetSpriteYByOffset
// FUNCTION
//   Returns the current Y coordinate of the sprite's current offset point in the world.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteYByOffset( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
	
	return pSprite->GetYByOffset();
}

//****f* Sprite/Properties/GetSpriteOffsetX
// FUNCTION
//   Returns the X component of the sprite's current offset point.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteOffsetX( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetOffsetX();
}

//****f* Sprite/Properties/GetSpriteOffsetY
// FUNCTION
//   Returns the Y component of the sprite's current offset point.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteOffsetY( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
	
	return pSprite->GetOffsetY();
}

//****f* Sprite/Properties/GetSpriteWidth
// FUNCTION
//   Returns the current width of the sprite as a floating point value.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteWidth( uint32_t iSpriteIndex )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetWidth();
}

//****f* Sprite/Properties/GetSpriteAngle
// FUNCTION
//   Returns the current angle of the sprite in degrees, 0 degrees being the direction x=0 y=-1 and proceeding clockwise.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve.
// SOURCE
float agk::GetSpriteAngle( uint32_t iSpriteIndex )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetAngle();
}

//****f* Sprite/Properties/GetSpriteAngleRad
// FUNCTION
//   Returns the current angle of the sprite in radians, 0 radians being the direction x=0 y=-1 and proceeding clockwise.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve.
// SOURCE
float agk::GetSpriteAngleRad( uint32_t iSpriteIndex )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetAngleRad();
}

//****f* Sprite/Properties/GetSpriteHeight
// FUNCTION
//   Returns the current height of the sprite as a floating point value.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteHeight( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetHeight();
}

//****f* Sprite/Properties/GetSpriteScaleX
// FUNCTION
//   Returns the current scaling of the sprite in the X direction as set with SetSpriteScale or SetSpriteScaleByOffset
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteScaleX( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetScaleX();
}

//****f* Sprite/Properties/GetSpriteScaleY
// FUNCTION
//   Returns the current scaling of the sprite in the Y direction as set with SetSpriteScale or SetSpriteScaleByOffset
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve
// SOURCE
float agk::GetSpriteScaleY( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetScaleY();
}


//****f* Sprite/Properties/GetSpriteHitTest
// FUNCTION
//   Returns 1 if the point x,y in world coordinates lies within the sprite, 0 if not. 
//   Takes into account the rotation and scale values of the sprite.<br><br>
//   Uses the shape assigned to it from <i>SetSpriteShape</i>, if no shape is set it uses 
//   the sprite width and height as a box shape.<br><br>
//   If you are testing a mouse or touch coordinate, remember to convert it to world 
//   coordinates using <i>ScreenToWorldX</i> and <i>ScreenToWorldY</i>.
// INPUTS
//   iSpriteIndex -- The sprite to test.
//   x -- The x position in world coordinates to check.
//   y -- The y position in world coordinates to check.
// SOURCE
int agk::GetSpriteHitTest ( uint32_t iSpriteIndex, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetHitTest( x, y ) ? 1 : 0;
}

//****f* Sprite/Properties/GetSpriteHit
// FUNCTION
//   Returns the ID of the first sprite found under the point x,y in world coordinates, 0 if none. 
//   Sprites are ordered by depth so a sprite appearing above another in the draw order will be
//   returned instead of the sprite behind it.<br><br>
//   Takes into account the rotation and scale values of the sprite. It does not take into account 
//   the transparency of the sprite, only its collision shape. Uses the shape assigned to it from 
//   <i>SetSpriteShape</i>, if no shape is set it uses the sprite width and height as a box shape.
//   If you are testing a mouse or touch coordinate, remember to convert it to world 
//   coordinates using <i>ScreenToWorldX</i> and <i>ScreenToWorldY</i>.
// INPUTS
//   x -- The x position in world coordinates to check.
//   y -- The y position in world coordinates to check.
// SOURCE
int agk::GetSpriteHit( float x, float y )
//****
{
	cSprite *pSprite = m_cSpriteList.GetFirst();
	float depth = 100000;
	uint32_t iID = 0;

	while ( pSprite )
	{
		if ( pSprite->GetZ() <= depth )
		{
			if ( pSprite->GetHitTest( x, y ) )
			{
				depth = pSprite->GetZ();
				iID = pSprite->GetID();
			}
		}

		pSprite = m_cSpriteList.GetNext();
	}
	
	return iID;
}

//****f* Sprite/Properties/GetSpriteHitGroup
// FUNCTION
//   Returns the ID of the first sprite found under the point x,y in world coordinates, 0 if none. 
//   Sprites are ordered by depth so a sprite appearing above another in the draw order will be
//   returned instead of the sprite behind it.<br><br>
//   Filters results to only those sprites in the specified group. By default sprites are created in group 0,
//   you can change this with <i>SetSpriteGroup</i>.<br><br>
//   Takes into account the rotation and scale values of the sprite. It does not take into account 
//   the transparency of the sprite, only its collision shape. Uses the shape assigned to it from 
//   <i>SetSpriteShape</i>, if no shape is set it uses the sprite width and height as a box shape.
//   If you are testing a mouse or touch coordinate, remember to convert it to world 
//   coordinates using <i>ScreenToWorldX</i> and <i>ScreenToWorldY</i>.
// INPUTS
//   group -- The group ID to check.
//   x -- The x position in world coordinates to check.
//   y -- The y position in world coordinates to check.
// SOURCE
int agk::GetSpriteHitGroup( int group, float x, float y )
//****
{
	cSprite *pSprite = m_cSpriteList.GetFirst();
	float depth = 100000;
	uint32_t iID = 0;

	while ( pSprite )
	{
		if ( pSprite->m_iGroup == group && pSprite->GetZ() <= depth )
		{
			if ( pSprite->GetHitTest( x, y ) )
			{
				depth = pSprite->GetZ();
				iID = pSprite->GetID();
			}
		}

		pSprite = m_cSpriteList.GetNext();
	}
	
	return iID;
}

//****f* Sprite/Properties/GetSpriteHitCategory
// FUNCTION
//   Returns the ID of the first sprite found under the point x,y in world coordinates, 0 if none. 
//   Sprites are ordered by depth so a sprite appearing above another in the draw order will be
//   returned instead of the sprite behind it.<br><br>
//   This function filters the results so only sprites of certain categories are checked. The 
//   category parameter is a bitwise field that uses the lower 16 bits to represent each of the possible 16
//   categories used when setting up a sprite. The default value of all 1s means all categories will be included,
//   whereas a value of all 0s means no categories will be included. You can set individual bits to set which ones 
//   should be checked. You can set which categories a sprite belongs to with <i>SetSpriteCategoryBits</i>.
//   Takes into account the rotation and scale values of the sprite. It does not take into account 
//   the transparency of the sprite, only its collision shape. Uses the shape assigned to it from 
//   <i>SetSpriteShape</i>, if no shape is set it uses the sprite width and height as a box shape.
//   If you are testing a mouse or touch coordinate, remember to convert it to world 
//   coordinates using <i>ScreenToWorldX</i> and <i>ScreenToWorldY</i>.
// INPUTS
//   categories -- The categories to check.
//   x -- The x position in world coordinates to check.
//   y -- The y position in world coordinates to check.
// SOURCE
int agk::GetSpriteHitCategory( uint32_t categories, float x, float y )
//****
{
	cSprite *pSprite = m_cSpriteList.GetFirst();
	float depth = 100000;
	uint32_t iID = 0;

	while ( pSprite )
	{
		if ( (pSprite->m_iCategories & categories) > 0 && pSprite->GetZ() <= depth )
		{
			if ( pSprite->GetHitTest( x, y ) )
			{
				depth = pSprite->GetZ();
				iID = pSprite->GetID();
			}
		}

		pSprite = m_cSpriteList.GetNext();
	}
	
	return iID;
}

//****f* Sprite/Properties/GetSpriteDepth
// FUNCTION
//   Returns the current depth of the sprite in the range 0-10000, with 0 being the front of the 
//   screen and 10000 being the back.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
int agk::GetSpriteDepth( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetDepth( );
}

//****f* Sprite/Properties/GetSpriteColorRed
// FUNCTION
//   Returns the current red component of a sprite in the range 0-255.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
uint32_t agk::GetSpriteColorRed( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetColorRed( );
}

//****f* Sprite/Properties/GetSpriteColorGreen
// FUNCTION
//   Returns the current green component of a sprite in the range 0-255.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
uint32_t agk::GetSpriteColorGreen( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetColorGreen( );
}

//****f* Sprite/Properties/GetSpriteColorBlue
// FUNCTION
//   Returns the current blue component of a sprite in the range 0-255.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
uint32_t agk::GetSpriteColorBlue( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetColorBlue( );
}

//****f* Sprite/Properties/GetSpriteColorAlpha
// FUNCTION
//   Returns the current alpha value of a sprite in the range 0-255.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
uint32_t agk::GetSpriteColorAlpha( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetColorAlpha( );
}

//****f* Sprite/Animation/GetSpritePlaying
// FUNCTION
//   Returns 1 if the sprite is currently playing an animation, 0 if not.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
int agk::GetSpritePlaying( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetPlaying( );
}

//****f* Sprite/Properties/GetSpriteVisible
// FUNCTION
//   Returns 0 if the sprite has been set as invisible using <i>SetSpriteVisible</i>, otherwise returns 1.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
int agk::GetSpriteVisible( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetVisible();
}

//****f* Sprite/Properties/GetSpriteActive
// FUNCTION
//   Returns 0 if the sprite has been set as inactive using <i>SetSpriteActive</i>, otherwise returns 1.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
int agk::GetSpriteActive( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetActive();
}

//****f* Sprite/Properties/GetSpriteGroup
// FUNCTION
//   Returns the value of the group set using <i>SetSpriteGroup</i>. If you have not set the group this will be 0.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
int agk::GetSpriteGroup( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetGroup();
}

//****f* Sprite/Properties/GetSpriteTransparency
// FUNCTION
//   Returns the current transparency mode of the sprite, 0=no transparency, 1=alpha channel transparency, 2=additive blending.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
int agk::GetSpriteTransparency( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetTransparencyMode();
}

//****f* Sprite/Properties/GetSpriteFlippedH
// FUNCTION
//   Returns 1 if the sprite has been flipped horizontally with <i>SetSpriteFlip</i>, otherwise returns 0.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
int agk::GetSpriteFlippedH( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetFlippedHorizontally();
}

//****f* Sprite/Properties/GetSpriteInScreen
// FUNCTION
//   Returns 1 if the sprite is currently within the visible area of the screen, 0 if it is outside the visible area.
//   Note that if the sprite is very close to the edge where it may be difficult to determine if all the pixels in the 
//   sprite are outside the visible area then this command will return 1 and assume it is visible. In other words if 
//   this command returns 0 then the sprite is definitely off screen, if it returns 1 then the sprite is most likely
//   on screen but could actually be off screen and very close to an edge.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
int agk::GetSpriteInScreen( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetInScreen();
}

//****f* Sprite/Properties/GetSpriteFlippedV
// FUNCTION
//   Returns 1 if the sprite has been flipped vertically with <i>SetSpriteFlip</i>, otherwise returns 0.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
int agk::GetSpriteFlippedV( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetFlippedVertically();
}

//****f* Sprite/Properties/GetSpriteXFromPixel
// FUNCTION
//   Converts a pixel point on the sprite's image to the point on the sprite's surface that represents where that pixel is.
//   For example if a 200x100 pixel image was assigned to a sprite of size 10x10, then calling this command with a pixel value
//   of 100 (center of the image) would return 5 (center of the sprite). The sprite must have an image assigned for this to work
//   or it will always return 0. The command is not limited by the size of the image or sprite, so in the above example a pixel 
//   value of 300 or -10 would both be valid.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
//   x -- The x coordinate of the pixel to check.
// SOURCE
float agk::GetSpriteXFromPixel( uint32_t iSpriteIndex, int x )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetXFromPixel( x );
}

//****f* Sprite/Properties/GetSpriteYFromPixel
// FUNCTION
//   Converts a pixel point on the sprite's image to the point on the sprite's surface that represents where that pixel is.
//   For example if a 200x100 pixel image was assigned to a sprite of size 10x10, then calling this command with a pixel value
//   of 50 (center of the image) would return 5 (center of the sprite). The sprite must have an image assigned for this to work
//   or it will always return 0. The command is not limited by the size of the image or sprite, so in the above example a pixel 
//   value of 300 or -10 would both be valid.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
//   y -- The y coordinate of the pixel to check.
// SOURCE
float agk::GetSpriteYFromPixel( uint32_t iSpriteIndex, int y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetYFromPixel( y );
}

//****f* Sprite/Properties/GetSpritePixelFromX
// FUNCTION
//   Converts a point on the sprite's image to the pixel on the sprite's image that is underneath that point.
//   For example if a 200x100 pixel image was assigned to a sprite of size 10x10, then calling this command with a pixel value
//   of 5 (center of the sprite) would return 100 (center of the image). The sprite must have an image assigned for this to work
//   or it will always return 0. The command is not limited by the size of the image or sprite, so in the above example a pixel 
//   value of 20 or -1 would both be valid.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
//   x -- The x coordinate of the sprite point to check.
// SOURCE
int agk::GetSpritePixelFromX( uint32_t iSpriteIndex, float x )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetPixelFromX( x );
}

//****f* Sprite/Properties/GetSpritePixelFromY
// FUNCTION
//   Converts a point on the sprite's image to the pixel on the sprite's image that is underneath that point.
//   For example if a 200x100 pixel image was assigned to a sprite of size 10x10, then calling this command with a pixel value
//   of 5 (center of the sprite) would return 50 (center of the image). The sprite must have an image assigned for this to work
//   or it will always return 0. The command is not limited by the size of the image or sprite, so in the above example a pixel 
//   value of 20 or -1 would both be valid.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
//   y -- The y coordinate of the sprite point to check.
// SOURCE
int agk::GetSpritePixelFromY( uint32_t iSpriteIndex, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetPixelFromY( y );
}

//****f* Sprite/Properties/GetWorldXFromSprite
// FUNCTION
//   Converts a point on the sprite to world coordinates. For example if a 10x10 sprite was rotated by 45 
//   degrees around its center point (at 5x5) then to find the position in the world of the sprite's top left
//   corner you would call this command with the values -5,-5, since the values are relative to the sprite's
//   center point (defined by SetSpriteOffset).
//   The command is not limited by the size of the sprite, so in the above example values of 20 or -15 would 
//   both be valid.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
//   x -- The X component of the point on the sprite.
//   y -- The Y component of the point on the sprite.
// SOURCE
float agk::GetWorldXFromSprite( uint32_t iSpriteIndex, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetWorldXFromPoint( x, y );
}

//****f* Sprite/Properties/GetWorldYFromSprite
// FUNCTION
//   Converts a point on the sprite to world coordinates. For example if a 10x10 sprite was rotated by 45 
//   degrees around its center point (at 5x5) then to find the position in the world of the sprite's top left
//   corner you would call this command with the values -5,-5, since the values are relative to the sprite's
//   center point (defined by SetSpriteOffset).
//   The command is not limited by the size of the sprite, so in the above example values of 20 or -15 would 
//   both be valid.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
//   x -- The X component of the point on the sprite.
//   y -- The Y component of the point on the sprite.
// SOURCE
float agk::GetWorldYFromSprite( uint32_t iSpriteIndex, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetWorldYFromPoint( x, y );
}

//****f* Sprite/Properties/GetSpriteXFromWorld
// FUNCTION
//   Converts a point in world coordinates to a point on the sprite. This is the opposite of GetWorldXFromSprite
//   and will return values relative to the sprite's center point defined with SetSpriteOffset. By default this
//   is the center of the sprite.
//   The command is not limited by the size of the sprite, it may return values larger than the sprite bounds.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
//   x -- The X component of the point to convert into sprite coordinates.
//   y -- The Y component of the point to convert into sprite coordinates.
// SOURCE
float agk::GetSpriteXFromWorld( uint32_t iSpriteIndex, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetXFromWorld( x, y );
}

//****f* Sprite/Properties/GetSpriteYFromWorld
// FUNCTION
//   Converts a point in world coordinates to a point on the sprite. This is the opposite of GetWorldYFromSprite
//   and will return values relative to the sprite's center point defined with SetSpriteOffset. By default this
//   is the center of the sprite.
//   The command is not limited by the size of the sprite, it may return values larger than the sprite bounds.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
//   x -- The X component of the point to convert into sprite coordinates.
//   y -- The Y component of the point to convert into sprite coordinates.
// SOURCE
float agk::GetSpriteYFromWorld( uint32_t iSpriteIndex, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetYFromWorld( x, y );
}


//****f* Sprite/Properties/SetSpriteSize
// FUNCTION
//   Sets the sprite to a new width and height. In the default coordinate system a width and height of 100,100 
//   would fill the entire drawable screen (this can be changed using <i>SetVirtualResolution</i>). If either width 
//   or height is set, with the other set to -1, the -1 value will be recalculated to maintain the image's 
//   aspect ratio so it doesn't look stretched. If both width AND height are set to -1, then the sprite will 
//   take on the width of the assigned image and calculate its height so it isn't stretched. This function 
//   recalculates the sprite's collision shape, which can be a costly process for circle and polygon shapes. 
//   A more efficient way to change the size of a sprite is to scale it using the <i>SetSpriteScale</i> function. 
//   This function resets the scale of the sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve.
//   width -- the width to use for the sprite, use minus 1 to have this value calculated.
//   height -- the height to use for the sprite, use minus 1 to have this value calculated.
// SOURCE
void agk::SetSpriteSize( uint32_t iSpriteIndex, float width, float height )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetSize( width, height );
}

//****f* Sprite/Animation/SetSpriteAnimation
// FUNCTION
//   Initialises the sprite animation with frames from its assigned image, based on a frame width and frame height.
//   The sprite will use the frame width and frame height to extract images of that size from its assigned image beginning
//   in the top left corner and moving from left to right. When it reaches the right hand side of the image it will begin 
//   again one row down, moving from left to right again until the frame count is reached or it runs out of space on the 
//   image to look for frames. Storing an animation image on an atlas texture is supported.<br><br>
//   This function is the preferred method of assigning an animation to a sprite as it avoids expensive image changes
//   during rendering. However if all your animation frames are separate images you can use the <i>AddSpriteAnimationFrame</i>
//   to add frames from images individually.
//   Using SetSpriteImage will clear all animation frames you have set here.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to set for animation.
//   iFrameWidth -- The width of the frames in pixels on the image.
//   iFrameHeight -- The height of the frames in pixels on the image.
//   iFrameCount -- The number of frames the sprite should attempt to retrieve from the image.
// SOURCE
void agk::SetSpriteAnimation( uint32_t iSpriteIndex, int iFrameWidth, int iFrameHeight, int iFrameCount )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetAnimation( iFrameWidth, iFrameHeight, iFrameCount );
}

//****f* Sprite/Animation/AddSpriteAnimationFrame
// FUNCTION
//   Adds an image to the sprite as a new animation frame. Frame indices start at 1 and increase incrementally.
//   This image may be shared by multiple sprites either as single images or as animation frames, the image may also be 
//   a part of an atlas texture.<br><br>
//   Alternatively if you have all your animation frames on a single image you can use the faster <i>SetSpriteAnimation</i>
//   that avoids image changes during rendering by modifying the UV coordinates to change frame instead.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to set for animation.
//   iImageIndex -- The ID of the image to add.
// SOURCE
void agk::AddSpriteAnimationFrame( uint32_t iSpriteIndex, uint32_t iImageIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = m_cImageList.GetItem( iImageIndex );
	if ( pImage == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Image ", 50 );  errStr.AppendUInt( iImageIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->AddAnimationFrame( pImage );
}

//****f* Sprite/Animation/ClearSpriteAnimationFrames
// FUNCTION
//   Removes all animation frames from a sprite returning it to a single image sprite. If you added images 
//   individually to the sprite using <i>AddSpriteAnimationFrame</i> then the sprite's image will be undefined
//   and it is recommended that you assign it a new image.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to clear.
// SOURCE
void agk::ClearSpriteAnimationFrames( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->ClearAnimationFrames();
}

//****f* Sprite/Animation/SetSpriteSpeed
// FUNCTION
//   Sets the sprite animation to a specified speed, can be used whilst the animation is running. Can be set to 0 to temporarily pause the animation.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   fFps -- the rate at which the sprite should update, sprite frames will be skipped if the sprite frame rate is too high compared to the game frame rate.
// SOURCE
void agk::SetSpriteSpeed( uint32_t iSpriteIndex, float fFps )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetSpeed( fFps );
}

//****f* Sprite/Animation/PlaySprite
// FUNCTION
//   Begins the animation of a sprite based on the given values. Animation speed is based on animation frames per second
//   and is not affected by the drawing frame rate.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to animate.
// SOURCE
void agk::PlaySprite( uint32_t iSpriteIndex )
//****
{
	PlaySprite( iSpriteIndex, 10, 1, -1, -1 );
}

//****f* Sprite/Animation/PlaySprite
// FUNCTION
//   Begins the animation of a sprite based on the given values. Animation speed is based on animation frames per second
//   and is not affected by the drawing frame rate.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to animate.
//   fFps -- Frames per second. The number of frames the sprite should attempt to cycle through every second (optional, default 10).
// SOURCE
void agk::PlaySprite( uint32_t iSpriteIndex, float fFps )
//****
{
	PlaySprite( iSpriteIndex, fFps, 1, -1, -1 );
}

//****f* Sprite/Animation/PlaySprite
// FUNCTION
//   Begins the animation of a sprite based on the given values. Animation speed is based on animation frames per second
//   and is not affected by the drawing frame rate.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to animate.
//   fFps -- Frames per second. The number of frames the sprite should attempt to cycle through every second (optional, default 10).
//   iLoop -- The looping mode of the sprite, 0 equals do not loop, 1 equals loop forever (optional, default 1).
// SOURCE
void agk::PlaySprite( uint32_t iSpriteIndex, float fFps, int iLoop )
//****
{
	PlaySprite( iSpriteIndex, fFps, iLoop, -1, -1 );
}

//****f* Sprite/Animation/PlaySprite
// FUNCTION
//   Begins the animation of a sprite based on the given values. Animation speed is based on animation frames per second
//   and is not affected by the drawing frame rate.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to animate.
//   fFps -- Frames per second. The number of frames the sprite should attempt to cycle through every second (optional, default 10).
//   iLoop -- The looping mode of the sprite, 0 equals do not loop, 1 equals loop forever (optional, default 1).
//   iFromFrame -- The frame to begin at, frames start at 1 (optional, default minus 1).
//   iToFrame -- The frame to end at, frames end at <i>GetSpriteFrameCount</i> (optional, default minus 1).
// SOURCE
void agk::PlaySprite( uint32_t iSpriteIndex, float fFps, int iLoop, int iFromFrame, int iToFrame )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->Play( fFps, iLoop>0, iFromFrame, iToFrame );
}

//****f* Sprite/Animation/StopSprite
// FUNCTION
//   Stops the animation of a sprite, maintaining the values used to set it up.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to stop animating.
// SOURCE
void agk::StopSprite( uint32_t iSpriteIndex )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->Stop( );
}

//****f* Sprite/Animation/ResumeSprite
// FUNCTION
//   Continues the animation of the sprite using the values used to set it up. 
//   Continues from the current frame rather than starting again at the first frame.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to resume animating.
// SOURCE
void agk::ResumeSprite( uint32_t iSpriteIndex )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->Resume( );
}

//****f* Sprite/Animation/SetSpriteFrame
// FUNCTION
//   Sets the sprite to a specific frame, frames start at 1 and end at <i>GetSpriteFrameCount</i>
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iFrame -- The ID of the frame this sprite should change to, has an immediate effect.
// SOURCE
void agk::SetSpriteFrame( uint32_t iSpriteIndex, int iFrame )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetFrame( iFrame );
}

//****f* Sprite/Animation/GetSpriteCurrentFrame
// FUNCTION
//   Gets the sprite's current frame ID.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve.
// SOURCE
int agk::GetSpriteCurrentFrame( uint32_t iSpriteIndex )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetCurrentFrame();
}

//****f* Sprite/Animation/GetSpriteFrameCount
// FUNCTION
//   Returns the total number of frames the sprite managed to get from its image. May be less
//   than the number of frames requested during setup.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to retrieve.
// SOURCE
int agk::GetSpriteFrameCount( uint32_t iSpriteIndex )
//****
{
	//cSprite *pSprite = cSprite::GetSprite( iSpriteIndex );
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetFrameCount();
}

//****f* Sprite/Properties/SetSpriteTransparency
// FUNCTION
//   Set the sprite transparency to a particular setting, with a choice of no transparency, alpha transparency,
//   additive blending, and custom blending. By default sprites are created with alpha transparency, but if you 
//   do not need this it is recommended that you turn transparency off to improve performance. With custom 
//   blending you can specify the source and destination blend modes with the <i>SetSpriteBlendModes</i> command.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   mode -- The transparency mode for this sprite, 0=off, 1=alpha transparency, 2=additive blending, 3=custom blending
// SOURCE
void agk::SetSpriteTransparency( uint32_t iSpriteIndex, int mode )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetTransparency( mode );
}

//****f* Sprite/Properties/SetSpriteBlendModes
// FUNCTION
//   When <i>SetSpriteTransparency<i/> is set to 3 then the source and destination blend values can be
//   specified manually using this command. The blend modes available are as follows:<br/>
//    0 = 0<br/>
//    1 = 1<br/>
//    2 = Source Pixel Alpha<br/>
//    3 = 1 - Source Pixel Alpha<br/>
//    4 = Destination Pixel Alpha<br/>
//    5 = 1 - Destination Pixel Alpha<br/>
//    6 = Source Pixel Color (valid for destination mode only)<br/>
//    7 = 1 - Source Pixel Color (valid for destination mode only)<br/>
//    8 = Destination Pixel Color (valid for source mode only)<br/>
//    9 = 1 - Destination Pixel Color (valid for source mode only)<br/>
//    10 = Alpha Saturate (valid for source mode only)<br/>
//   The source pixel will be multiplied by the source mode, and the destination pixel will be multiplied
//   by the destination mode. The two will then be added together to make the final pixel color. The source
//   pixel is the pixel belonging to the object being drawn, whilst the destination pixel is the color of 
//   the pixel already on screen, which the current sprite is being drawn over.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   src -- The blend mode to use for the source of the blend.
//   dst -- The blend mode to use for the destination of the blend.
// SOURCE
void agk::SetSpriteBlendModes( uint32_t iSpriteIndex, int src, int dst )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetBlendFunction( src, dst );
}

//****f* Sprite/Properties/SetSpriteOffset
// FUNCTION
//   The offset point is the point that the sprite will rotate around, with (0,0) being the top left corner and (width,height)
//   being the bottom right corner. The offset can also be used to position the sprite using <i>SetSpritePositionByOffset</i>, whilst
//   <i>SetSpritePosition</i> will always position the sprite using its top left corner. If the sprite is scaled remember to take 
//   the scale into account, a sprite created as 10 by 10 units wide scaled by 0.5 will have a bottom right corner at 5,5 so 
//   to position the offset in the center would mean placing it at 2.5,2.5, when the sprite is scale back up the offset point 
//   will scale with it to maintain its relative position.<br><br>
//   This command forces the recalculation of the sprite's shape due to a new center point, additional shapes are not 
//   recalculated so will become distorted from their original definition. It is not recommended calling this command on a 
//   sprite already setup for physics. Change the offset before applying physics or additional shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The X distance from the top left corner to offset the rotation point.
//   y -- The Y distance from the top left corner to offset the rotation point.
// SOURCE
void agk::SetSpriteOffset( uint32_t iSpriteIndex, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetOffset( x,y );
}

//****f* Sprite/Properties/SetSpriteColor
// FUNCTION
//   Set the color of a sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iRed -- The red component of the color.
//   iGreen -- The green component of the color.
//   iBlue -- The blue component of the color.
//   iAlpha -- The alpha component of the color. The acceptable range is from 0 to 255. When a value of 0 is used the sprite will be invisible. When a value of 255 is used the sprite will be fully opaque.
// SOURCE
void agk::SetSpriteColor( uint32_t iSpriteIndex, int iRed, int iGreen, int iBlue, int iAlpha )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetColor( iRed, iGreen, iBlue, iAlpha );
}

//****f* Sprite/Properties/SetSpriteColorRed
// FUNCTION
//   Set the red component of a sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iRed -- The red component of the color. The acceptable range is from 0 to 255.
// SOURCE
void agk::SetSpriteColorRed( uint32_t iSpriteIndex, int iRed )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetRed( iRed );
}

//****f* Sprite/Properties/SetSpriteColorGreen
// FUNCTION
//   Set the green component of a sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iGreen -- The green component of the color. The acceptable range is from 0 to 255.
// SOURCE
void agk::SetSpriteColorGreen( uint32_t iSpriteIndex, int iGreen )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetGreen( iGreen );
}

//****f* Sprite/Properties/SetSpriteColorBlue
// FUNCTION
//   Set the blue component of a sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iBlue -- The blue component of the color. The acceptable range is from 0 to 255.
// SOURCE
void agk::SetSpriteColorBlue( uint32_t iSpriteIndex, int iBlue )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetBlue( iBlue );
}

//****f* Sprite/Properties/SetSpriteColorAlpha
// FUNCTION
//   Set the alpha component of a sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   iAlpha -- The alpha component of the color. The acceptable range is from 0 to 255. When a value of 0 is used the sprite will be invisible. When a value of 255 is used the sprite will be fully opaque.
// SOURCE
void agk::SetSpriteColorAlpha( uint32_t iSpriteIndex, int iAlpha )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetAlpha( iAlpha );
}

//****f* Sprite/Properties/SetSpriteUVBorder
// FUNCTION
//   Adjusts the UV coordinates of the sprite to create a border that moves the edge of the sprite inwards,
//   away from the edge of the image applied to it. This can be useful for sub images loaded from an atlas texture 
//   where images might be packed very closely together. Using a border makes sure that the sprite doesn't 
//   accidentally sample from a neighbouring image, you could also fix this by adding space between the images on an 
//   atlas texture. By default a sprite uses a border of 0.5 pixels when its image is a sub image, and a border of 
//   0 pixels when its has a normal image.
//   If you have compensated for this yourself by adding spacing to the atlas image then setting the border to 0 
//   removes the default offset and creates a pixel perfect reproduction of the sub image. You may also increase 
//   this border by setting the border greater than 0.5 pixels.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   border -- 0=no border, 0.5=half pixel offset, 1=one pixel offset, etc
// SOURCE
void agk::SetSpriteUVBorder( uint32_t iSpriteIndex, float border )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetUVBorder( border );
}

//****f* Sprite/Properties/SetSpriteUVOffset
// FUNCTION
//   Offsets the sprites UV coordinates by the given amount. For example, offsetting by 0.5 in the U direction will 
//   make the sprite begin sampling the texture halfway across the top of the texture instead of the top left corner
//   as normal. UV values outside the range of 0,0 (top left) and 1,1 (bottom right) can either wrap around or clamp
//   the texture, which is decided by the image assigned to the sprite using <i>SetImageWrapU</i> and <i>SetImageWrapV</i>.
//   Clamping or wrapping cannot be set on a per-sprite basis.<br><br>
//   By default a sprite is set to use the UV coordinates 0,0 to 1,1 using the full image available to it. However 
//   there are several cases where this is changed by the AGK to hide certain limitations. If the texture assigned 
//   to the sprite is not a power of 2 width or height the image is increased in size until it is a power of 2 size 
//   and the UV coordinates for the sprite reduced so that the sprite only uses the portion of the texture 
//   containing the original image. This is because most mobile platforms do not support textures that are not a 
//   power of 2 width or height. Therefore offsetting the sprite's UV coordinates in this case will shift the sprite's 
//   usage of the texture into the undefined portion which is being used as padding.<br><br>
//   Additionally if the sprite is using an image that belongs to an atlas texture the sprite's UV coordinates will
//   be set so that it only uses the portion of the texture containing its assigned image. Offsetting the UV
//   coordinates in this case will shift the sprite's usage of the texture into other images that are part of the 
//   atlas texture. The same can be said of sprites using an animation contained within a single texture using 
//   <i>SetSpriteAnimation</i>.<br><br>
//   Due to these possibilities it is recommended that UV coordinates only be modified on sprites that are using whole 
//   images (not atlas textures) and which are a power of 2 size in both width and height. With these constraints 
//   it is possible to use UV values outside 0-1 to clamp or repeat the texture successfully.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify
//   u -- The amount to offset the UV coordinates in the U direction.
//   v -- The amount to offset the UV coordinates in the V direction.
// SOURCE
void agk::SetSpriteUVOffset( uint32_t iSpriteIndex, float u, float v )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetUVOffset( u, v );
}

//****f* Sprite/Properties/SetSpriteUVScale
// FUNCTION
//   Scales the sprites UV coordinates by the given amount. A sprite with UV scaled by 2 will make its texture look 
//   twice as big as normal. The UV scale does not affect the UV offset chosen using <i>SetSpriteUVOffset</i>, so that an
//   offset of 0.5 in the U direction will always begin sampling halfway across the texture, the scale defines how
//   far the sprite continues sampling. So with an offset of 0.5, a scale of 2 will make the sprite sample from 0.5 
//   to 1 instead of 0.5 to 1.5.<br><br>
//   By default a sprite is set to use the UV coordinates 0,0 to 1,1 using the full image available to it. However 
//   there are several cases where this is changed by the AGK to hide certain limitations. If the texture assigned 
//   to the sprite is not a power of 2 width or height the image is increased in size until it is a power of 2 size 
//   and the UV coordinates for the sprite reduced so that the sprite only uses the portion of the texture 
//   containing the original image. This is because most mobile platforms do not support textures that are not a 
//   power of 2 width or height. Therefore offsetting the sprite's UV coordinates in this case will shift the sprite's 
//   usage of the texture into the undefined portion which is being used as padding.<br><br>
//   Additionally if the sprite is using an image that belongs to an atlas texture the sprite's UV coordinates will
//   be set so that it only uses the portion of the texture containing its assigned image. Offsetting the UV
//   coordinates in this case will shift the sprite's usage of the texture into other images that are part of the 
//   atlas texture. The same can be said of sprites using an animation contained within a single texture using 
//   <i>SetSpriteAnimation</i>.<br><br>
//   Due to these possibilities it is recommended that UV coordinates only be modified on sprites that are using whole 
//   images (not atlas textures) and which are a power of 2 size in both width and height. With these constraints 
//   it is possible to use UV values outside 0-1 to clamp or repeat the texture successfully.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify
//   scaleU -- The amount to scale in the U direction.
//   scaleV -- The amount to scale in the V direction.
// SOURCE
void agk::SetSpriteUVScale( uint32_t iSpriteIndex, float scaleU, float scaleV )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetUVScale( scaleU, scaleV );
}

//****f* Sprite/Properties/FixSpriteToScreen
// FUNCTION
//   By default sprites are created in world coordinates and <i>SetViewOffset</i> can be used to move around the world.
//   Use this command to instead fix the sprite to the screen so it will move with the viewport when the viewport 
//   is moved around. You can still reposition a sprite that is fixed to the screen, it only affects what happens 
//   when the viewport is moved. You should not use physics or collision commands on sprites fixed to the screen 
//   as their debug shapes will not line up and they will interfere with physics sprites not fixed to the screen.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to change.
//   mode -- 1=screen sprite, 0=world sprite
// SOURCE
void agk::FixSpriteToScreen( uint32_t iSpriteIndex, int mode )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->FixToScreen( mode );
}

//****f* Sprite/Properties/SetSpriteScale
// FUNCTION
//   Sets the sprite scale as an absolute multiple of its original size. For example a scale value of 2 would double
//   the sprite's size whilst a value of 1 will return it to its original size. This function scales from the top left 
//   corner so any increase in size will keep the top and left sides stationary whilst the bottom and right sides move.
//   The sprites center of rotation (its current offset point) will scale with the sprite. To scale from the offset
//   point use <i>SetSpriteScaleByOffset</i>.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The value to scale the sprite in the X direction.
//   y -- The value to scale the sprite in the Y direction.
// SOURCE
void agk::SetSpriteScale( uint32_t iSpriteIndex, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetScale( x,y );
}

//****f* Sprite/Properties/SetSpriteScaleByOffset
// FUNCTION
//   Sets the sprite scale as an absolute multiple of its original size. For example a scale value of 2 would double
//   the sprite's size whilst a value of 1 will return it to its original size. This function scales from the sprite's 
//   center of rotation (its current offset point) so any increase in size will keep the offset point stationary whilst 
//   all four sides expand away from it. To scale from the top left corner use <i>SetSpriteScale</i>.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The value to scale the sprite in the X direction.
//   y -- The value to scale the sprite in the Y direction.
// SOURCE
void agk::SetSpriteScaleByOffset( uint32_t iSpriteIndex, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetScaleByOffset( x,y );
}

//****f* Sprite/Properties/SetSpriteScissor
// FUNCTION
//   Clips the sprite to the specified world coordinates when drawn. Use the values 0,0,0,0 to turn off
//   the sprite scissor
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The x coordinate of the top left corner of the box to use as a clip boundary.
//   y -- The y coordinate of the top left corner of the box to use as a clip boundary.
//   x2 -- The x coordinate of the bottom right corner of the box to use as a clip boundary.
//   y2 -- The y coordinate of the bottom right corner of the box to use as a clip boundary.
// SOURCE
void agk::SetSpriteScissor( uint32_t iSpriteIndex, float x, float y, float x2, float y2 )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetScissor( x,y, x2,y2 );
}

//****f* Sprite/Properties/SetSpriteShader
// FUNCTION
//   Sets the shader used to draw this sprite, loaded with <i>LoadSpriteShader</i> or <i>LoadShader</i>.
//   By default sprites are assigned an internal shader that can handle 1 texture and a color.
//   If you use a shader ID of 0 the sprite is assigned the internal shader.
// INPUTS
//   spriteID -- The ID of the sprite to modify.
//   shaderID -- The ID of the shader to use.
// SOURCE
void agk::SetSpriteShader( uint32_t spriteID, uint32_t shaderID )
//****
{
	cSprite *pSprite = m_cSpriteList.GetItem( spriteID );
	if ( !pSprite )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shader for sprite " );
		errStr.AppendUInt( spriteID ).Append( " - sprite does not exist" );
		Error( errStr );
#endif
		return;
	}

	AGKShader *pShader = 0;
	if ( shaderID > 0 )
	{
		pShader = m_cShaderList.GetItem( shaderID );
		if ( !pSprite )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set shader for sprite " );
			errStr.AppendUInt( spriteID ).Append( " - shader ");
			errStr.AppendUInt( shaderID ).Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}

	pSprite->SetShader( pShader );
}

//****f* Sprite/Properties/DrawSprite
// FUNCTION
//   Immediately draws the sprite to the backbuffer at its current position, size, and rotation. This is 
//   useful if you want to take control of the order that things are drawn. If you do this then be sure 
//   to make the sprite invisible before calling <i>Render</i> or <i>Sync</i> otherwise your sprite will 
//   be drawn twice
// INPUTS
//   iSpriteIndex -- The ID of the sprite to draw.
// SOURCE
void agk::DrawSprite( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->Draw();
}

//
// Physics commands
//

//****f* 2DPhysics/General/SetPhysicsScale
// FUNCTION
//   Sets the scale used by the physics system compared with world coordinates.<br><br>
//   By design the physics system is set to use 1 unit as equalling 1 meter, which in the case of default world coordinates (100,100)
//   would mean that the screen is 100 meters by 100 meters in the physics simulation. However by design the physics system is designed to 
//   work best with dynamic objects ranging from 0.1 meters to 10 meters in size, and with static objects up to 50 meters, so the screen is 
//   scaled down when sent to the physics system, by default the scale is 0.2, so in the physics world the screen is 20 meters by 20 meters.
//   This is purely to allow the physics system to work at its designed scale whilst allowing world coordinates to be used as parameters
//   with the AGK doing all the necessary scaling behind the scenes. This function allows you to change the scale factor if your virtual 
//   resolution is going to be different from 100,100.<br><br>
//   This function must be called before any other physics functions, and must not be called once the physics system is running.
// INPUTS
//   scale -- The new scale value to use for all screen to physics values and vice versa.
// SOURCE
void agk::SetPhysicsScale( float scale )
//****
{
	if ( scale <= 0.0001f ) scale = 0.0001f;
	m_phyScale = scale;

	UpdatePhysicsWalls();
}

//****f* 2DPhysics/General/SetPhysicsGravity
// FUNCTION
//   Sets the gravity vector for all sprites using physics. The x and y values will be scaled into physics space so will
//   only represent meters per second squared when scale = 1.0, in world space the values represent pixels per second
//   squared. For example in the default scale of 0.2, a <i>SetPhysicsGravity</i> value of 0,50 would represent 10 meters per second 
//   squared. Gravity is a constant acceleration applied to all physics objects equally, regardless of mass. Whereas a force
//   applies an acceleration proportional to the objects mass. To counteract gravity with a force will require accounting for 
//   mass.
// INPUTS
//   x -- The X component of the gravity vector.
//   y -- The Y component of the gravity vector.
// SOURCE
void agk::SetPhysicsGravity( float x, float y )
//****
{
	x = agk::WorldToPhyX( x );
	y = agk::WorldToPhyY( y );

	if ( m_phyWorld ) 
	{
		m_phyWorld->SetGravity( b2Vec2(x,y) );
		b2Body *pBody = m_phyWorld->GetBodyList();
		while ( pBody )
		{
			pBody->SetAwake( true );
			pBody = pBody->GetNext();
		}
	}
}

//****f* 2DPhysics/Debug/SetPhysicsDebugOn
// FUNCTION
//   Enables the drawing of internal physics shapes on screen. If you <i>SetViewOffset</i> to something other than
//   0,0 make sure none of your physics sprites are fixed to the screen using <i>FixSpriteToScreen</i> otherwise the 
//   debug shapes will not line up. Debug outlines are drawn as world sprites.<br><br>
//   The debug output will draw the shape of every physics sprite set using <i>SetSpritePhysicsOn</i> and all non
//   physics sprites that have a shape assigned for non-physics collision commands. The shapes will be drawn 
//   in the following colors: Cream=Dynamic physics object, Green=Static physics object, Dark Blue=Kinematic physics 
//   object, Light Blue=Non-physics object. Grey=Sleeping dynamic physics object. Additionally physics objects will 
//   be drawn as shaded with an outline, non-physics objects will be an outline only.
// SOURCE
void agk::SetPhysicsDebugOn() 
//****
{
	m_bDrawDebug = true;
}

//****f* 2DPhysics/Debug/SetPhysicsDebugOff
// FUNCTION
//   Disables the drawing of internal physics shapes on screen.
// SOURCE
void agk::SetPhysicsDebugOff()
//****
{
	m_bDrawDebug = false;
}

//****f* 2DPhysics/Debug/SetPhysicsThreading
// FUNCTION
//   Sets the number of threads to use during physics. A value of 0 or 1 turns off multi-threading, a value
//   of minus 1 chooses a value matching the number of processors in the device for best performance.
//   Using a value higher than the number of processors in the device is likely to hurt performance.
//   Default is minus 1.
// INPUTS
//   threads -- The number of threads to use, minus 1 to automatically choose a number appropriate for the device
// SOURCE
void agk::SetPhysicsThreading( int threads )
//****
{
	m_phyWorld->SetNumThreads( threads );
}

//****f* 2DPhysics/Debug/SetPhysicsCCD
// FUNCTION
//   Turns Continuous Collision Detection on and off. This prevents fast moving objects from tunnelling through
//   static bodies. To prevent fast moving objects passing through each other use SetSpritePhysicsIsBullet
//   When you have a large number of dynamic bodies CCD can be the bottleneck in the physics engine, especially
//   when threading is turned on as this part is not currently threaded. Default is off.
// INPUTS
//   mode -- 0 to disable CCD, 1 to turn it on
// SOURCE
void agk::SetPhysicsCCD( int mode )
//****
{
	m_phyWorld->SetContinuousPhysics( mode>0 );
}

//****f* 2DPhysics/Debug/SetPhysicsSleeping
// FUNCTION
//   Sets the ability of dynamic bodies to sleep when they are not moving, this dramatically improves performance
//   when dynamic bodies have settled into their final positions. Turning it off is only useful for benchmarking
//   when you want to keep the CPU active processing all bodies all the time. Default is on.
// INPUTS
//   mode -- 0 to disable sleeping, 1 to turn it on
// SOURCE
void agk::SetPhysicsSleeping( int mode )
//****
{
	m_phyWorld->SetAllowSleeping( mode>0 );
}

//****f* 2DPhysics/Debug/GetPhysicsSolveTime
// FUNCTION
//   Returns the number of milliseconds spent in the solver
// SOURCE
float agk::GetPhysicsSolveTime()
//****
{
	return m_phyWorld->GetProfile().solve;
}

//****f* 2DPhysics/Debug/GetPhysicsIslandCount
// FUNCTION
//   Returns the number of islands the solver processed last step
// SOURCE
int agk::GetPhysicsIslandCount()
//****
{
	return m_phyWorld->GetIslandCount();
}

//****f* 2DPhysics/General/SetPhysicsMaxPolygonPoints
// FUNCTION
//   Sets the maximum number of points that will be generated in future polygon physics shapes, does not
//   affect already generated shapes, may be called multiple times. Only affects shapes generated by the 
//   AGK through <i>SetSpriteShape</i>. Must be between 2 and 12. The default setting is 8.
// INPUTS
//   points -- The maximum number of points allowed in new polygon shapes.
// SOURCE
void agk::SetPhysicsMaxPolygonPoints( int points )
//****
{
	if ( points < 2 ) points = 2;
	if ( points > b2_maxPolygonVertices ) points = b2_maxPolygonVertices;
	m_iMaxPolygonPoints = points;
}

b2World* agk::GetPhysicsWorld()
{
	return m_phyWorld;
}

//****f* 2DPhysics/General/SetPhysicsWallTop
// FUNCTION
//   Toggles the existence of a physics wall at the top of the screen to prevent physics objects leaving 
//   the screen in that direction. If you have physics objects beyond the edge of the screen, e.g. in a 
//   platform game, you should turn this off.<br><br>
//   If you change the view offset using <i>SetViewOffset</i> the walls will not move with it, they are fixed 
//   to the world, so they will be disabled automatically.
// INPUTS
//   mode -- 0=off, 1=on
// SOURCE
void agk::SetPhysicsWallTop( int mode )
//****
{
	if ( mode == 0 )
	{
		if ( groundBodyTop )
		{
			m_phyWorld->DestroyBody( groundBodyTop );
			groundBodyTop = 0;
		}
	}
	else
	{
		if ( !groundBodyTop )
		{
			b2BodyDef groundBodyDef;
			groundBodyDef.type = b2_staticBody;
			groundBodyDef.position.Set( agk::WorldToPhyX(m_iDisplayWidth/2.0f),agk::WorldToPhyY(-1.1f) );
			groundBodyTop = m_phyWorld->CreateBody(&groundBodyDef);

			b2PolygonShape groundBox;
			groundBox.SetAsBox( agk::WorldToPhyX(m_iDisplayWidth/2.0f), agk::WorldToPhyY(1.0f) );
			groundBodyTop->CreateFixture(&groundBox, 0.0f);
		}
	}
}

//****f* 2DPhysics/General/SetPhysicsWallLeft
// FUNCTION
//   Toggles the existence of a physics wall on the left of the screen to prevent physics objects leaving 
//   the screen in that direction. If you have physics objects beyond the edge of the screen, e.g. in a 
//   platform game, you should turn this off.<br><br>
//   If you change the view offset using <i>SetViewOffset</i> the walls will not move with it, they are fixed 
//   to the world, so they will be disabled automatically.
// INPUTS
//   mode -- 0=off, 1=on
// SOURCE
void agk::SetPhysicsWallLeft( int mode )
//****
{
	if ( mode == 0 )
	{
		if ( groundBodyLeft ) 
		{
			m_phyWorld->DestroyBody( groundBodyLeft );
			groundBodyLeft = 0;
		}
	}
	else
	{
		if ( !groundBodyLeft )
		{
			b2BodyDef groundBodyDef;
			groundBodyDef.type = b2_staticBody;
			groundBodyDef.position.Set( agk::WorldToPhyX(-1.1f),agk::WorldToPhyY(m_iDisplayHeight/2.0f) );
			groundBodyLeft = m_phyWorld->CreateBody(&groundBodyDef);

			b2PolygonShape groundBox;
			groundBox.SetAsBox( agk::WorldToPhyX(1.0f), agk::WorldToPhyY(m_iDisplayHeight/2.0f) );
			groundBodyLeft->CreateFixture(&groundBox, 0.0f);
		}
	}
}

//****f* 2DPhysics/General/SetPhysicsWallRight
// FUNCTION
//   Toggles the existence of a physics wall on the right of the screen to prevent physics objects leaving 
//   the screen in that direction. If you have physics objects beyond the edge of the screen, e.g. in a 
//   platform game, you should turn this off.<br><br>
//   If you change the view offset using <i>SetViewOffset</i> the walls will not move with it, they are fixed 
//   to the world, so they will be disabled automatically.
// INPUTS
//   mode -- 0=off, 1=on
// SOURCE
void agk::SetPhysicsWallRight( int mode )
//****
{
	if ( mode == 0 )
	{
		if ( groundBodyRight ) 
		{
			m_phyWorld->DestroyBody( groundBodyRight );
			groundBodyRight = 0;
		}
	}
	else
	{
		if ( !groundBodyRight ) 
		{
			b2BodyDef groundBodyDef;
			groundBodyDef.type = b2_staticBody;
			groundBodyDef.position.Set( agk::WorldToPhyX(m_iDisplayWidth+1.0f),agk::WorldToPhyY(m_iDisplayHeight/2.0f) );
			groundBodyRight = m_phyWorld->CreateBody(&groundBodyDef);

			b2PolygonShape groundBox;
			groundBox.SetAsBox( agk::WorldToPhyX(1.0f), agk::WorldToPhyY(m_iDisplayHeight/2.0f) );
			groundBodyRight->CreateFixture(&groundBox, 0.0f);
		}
	}
}

//****f* 2DPhysics/General/SetPhysicsWallBottom
// FUNCTION
//   Toggles the existence of a physics wall at the bottom of the screen to prevent physics objects leaving 
//   the screen in that direction. If you have physics objects beyond the edge of the screen, e.g. in a 
//   platform game, you should turn this off.<br><br>
//   If you change the view offset using <i>SetViewOffset</i> the walls will not move with it, they are fixed 
//   to the world, so they will be disabled automatically.
// INPUTS
//   mode -- 0=off, 1=on
// SOURCE
void agk::SetPhysicsWallBottom( int mode )
//****
{
	if ( mode == 0 )
	{
		if ( groundBodyBottom ) 
		{
			m_phyWorld->DestroyBody( groundBodyBottom );
			groundBodyBottom = 0;
		}
	}
	else
	{
		if ( !groundBodyBottom ) 
		{
			b2BodyDef groundBodyDef;
			groundBodyDef.type = b2_staticBody;
			groundBodyDef.position.Set( agk::WorldToPhyX(m_iDisplayWidth/2.0f), agk::WorldToPhyY(m_iDisplayHeight+1.0f) );
			groundBodyBottom = m_phyWorld->CreateBody(&groundBodyDef);

			b2PolygonShape groundBox;
			groundBox.SetAsBox( agk::WorldToPhyX(m_iDisplayWidth/2.0f), agk::WorldToPhyY(1.0f) );
			groundBodyBottom->CreateFixture(&groundBox, 0.0f);
		}
	}
}


//****f* 2DPhysics/Forces/CreatePhysicsForce
// FUNCTION
//   Creates a global force that affects all physics sprites. Can be set to either attract to or repel 
//   sprites from a specific location. It returns a force ID that can be used to modify or delete the 
//   force later. Forces continue to act until they are deleted.
// INPUTS
//   x -- The x position of the force location in world coordinates.
//   y -- The y position of the force location in world coordinates.
//   power -- The strength of the force at 1 unit from the force point for fading forces, or the strength at all times for non fading.
//   limit -- Applies to fading forces only, the maximum force that will be applied to a sprite, used when the sprite is closer than 1 unit.
//   range -- The range that this force can act, sprites greater than this distance from the force point feel no effects. less than 0 means infinite range.
//   fade -- Set to 1 if the force should be weaker when sprites are further from the force point, 0 if the force is equal at all distances.
// SOURCE
uint32_t agk::CreatePhysicsForce( float x, float y, float power, float limit, float range, int fade )
//****
{
	uint32_t iID = m_cForceList.GetFreeID( MAX_FORCES );
	
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add force - no free force IDs found" );
		agk::Error( errStr );
#endif
		return 0;
	}

	cForce *pForce = new cForce( x,y, power, limit, range, fade>0 );
	m_cForceList.AddItem( pForce, iID );
	return iID;
}

//****f* 2DPhysics/Forces/DeletePhysicsForce
// FUNCTION
//   Deletes the specified global force.
// INPUTS
//   iForceIndex -- The ID of the force to delete.
// SOURCE
void agk::DeletePhysicsForce( uint32_t iForceIndex )
//****
{
	cForce *pForce = (cForce*) m_cForceList.RemoveItem( iForceIndex );
	if ( pForce ) delete pForce;
}

//****f* 2DPhysics/Forces/SetPhysicsForcePosition
// FUNCTION
//   Changes the position of the global force in world coordinates.
// INPUTS
//   iForceIndex -- The ID of the force to modify.
//   x -- The x component of the new position.
//   y -- The y component of the new position.
// SOURCE
void agk::SetPhysicsForcePosition( uint32_t iForceIndex, float x, float y )
//****
{
	cForce *pForce = (cForce*) m_cForceList.GetItem( iForceIndex );
	if ( !pForce )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set force position, force %d does not exist", iForceIndex );
		agk::Error( err );
#endif
		return;
	}

	pForce->m_fX = x;
	pForce->m_fY = y;
}

//****f* 2DPhysics/Forces/SetPhysicsForcePower
// FUNCTION
//   Changes the strength of the global force. For forces that fade this will be the strength at 1 unit 
//   from the force position.<br><br>
//	 The force is in Newtons, and is similar in size to gravity except that it is affected by the mass of
//   the object. For example, for an object of mass of 1 kg and a force of 10 newtons will affect the object
//   in the same way as gravity set at 10 m/s^2. For a mass of 2 kg it is harder to move, so a force of 10 
//   Newtons would be half as effective at moving the object as gravity at 10m/s^2.
// INPUTS
//   iForceIndex -- The ID of the force to modify.
//   power -- The new strength of the force.
// SOURCE
void agk::SetPhysicsForcePower( uint32_t iForceIndex, float power )
//****
{
	cForce *pForce = (cForce*) m_cForceList.GetItem( iForceIndex );
	if ( !pForce )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set force position, force %d does not exist", iForceIndex );
		agk::Error( err );
#endif
		return;
	}

	pForce->m_fPower = power;
}

//****f* 2DPhysics/Forces/SetPhysicsForceRange
// FUNCTION
//   Changes the range of the global force. Sprites greater than this distance from the force position will
//   not feel its effects. A range less than zero equals an infinite range.
// INPUTS
//   iForceIndex -- The ID of the force to modify.
//   range -- The new range of the force.
// SOURCE
void agk::SetPhysicsForceRange( uint32_t iForceIndex, float range )
//****
{
	cForce *pForce = (cForce*) m_cForceList.GetItem( iForceIndex );
	if ( !pForce )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set force position, force %d does not exist", iForceIndex );
		agk::Error( err );
	#endif
		return;
	}

	pForce->m_fRadius = range;
}

//****f* Sprite/Physics/SetSpriteShape
// FUNCTION
//   Sets the current shape for use in collision detection, hit testing, and physics. A shape can be set without turning physics
//   on, and by default all sprites are set to use the box shape, which is the fastest to setup. If you select no shape (0) then
//   any existing shape will be deleted, and hit testing will use the sprite dimensions instead. Commands that require a shape 
//   such as <i>GetSpriteCollision</i> will generate a box shape for the sprite if none exists.
//   The shape parameter lets you define what type of bounding box the system should use to detect collisions. Circle will create 
//   a perfect circle centered on the sprite's rotation point and big enough to enclose the sprite's visible pixels. Box will 
//   create a box around the edges of the sprite, without regard to whether pixels are visible or not. Polygon will create a close 
//   fitting convex polygon around the visible pixels of a sprite, with a visible pixel being defined as one with an alpha value 
//   greater than 128.<br><br>
//   This function will not work on dummy sprites as there is no image to use when calculating a shape, in these cases shapes
//   must be specified manually using <i>SetSpriteShapeBox</i>, <i>SetSpriteShapeCircle</i>, or <i>SetSpriteShapePolygon</i>.<br><br>
//   By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can set shapes 
//   individually by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0 meaning delete all 
//   existing shapes before creating a new one at ID 1. This command only changes existing shapes, you can add additional shapes 
//   by using the AddSpriteShape commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   shape -- The shape to use for this sprite, 0=no shape, 1=circle, 2=box, 3=polygon
// SOURCE
void agk::SetSpriteShape( uint32_t iSpriteIndex, int shape )
//****
{
	SetSpriteShape( iSpriteIndex, shape, 0 );
}

//****f* Sprite/Physics/SetSpriteShapeBox
// FUNCTION
//   Overrides the current auto generated shape for use in collision detection, hit testing, and physics. A shape can be set 
//   without turning physics on, and by default all sprites are set to use the box shape, which is the fastest to setup. 
//   The box is defined by specifying its top left and bottom right coordinates in sprite space, relative to the offset of the sprite,
//   by default this is the center of the sprite.
//   For example if the current sprite offset was 0,0 the top left box corner would be 0,0, but if the sprite offset was the 
//   middle of the sprite (default) the top left corner would be -width/2,-height/2. You may also specify an angle to offset the box
//   relative to the current sprite rotation.<br><br>
//   By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can set shapes 
//   individually by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0 meaning delete all 
//   existing shapes before creating a new one at ID 1. This command only changes existing shapes, you can add additional shapes 
//   by using the AddSpriteShape commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The X coordinate of the top left corner of the new box in sprite space.
//   y -- The Y coordinate of the top left corner of the new box in sprite space.
//   x2 -- The X coordinate of the bottom right corner of the new box in sprite space.
//   y2 -- The Y coordinate of the bottom right corner of the new box in sprite space.
//   angle -- The angle of the box in radians.
// SOURCE
void agk::SetSpriteShapeBox( uint32_t iSpriteIndex, float x, float y, float x2, float y2, float angle )
//****
{
	SetSpriteShapeBox( iSpriteIndex, x, y, x2, y2, angle, 0 );
}

//****f* Sprite/Physics/SetSpriteShapeCircle
// FUNCTION
//   Overrides the current auto generated shape for use in collision detection, hit testing, and physics. A shape can be set 
//   without turning physics on, and by default all sprites are set to use the box shape, which is the fastest to setup. 
//   The circle is defined by specifying its center point relative to the sprite's current offset and a radius. For example,
//   if the circle was to be centered on the sprite's offset point it would be specified at position 0,0. Any other value will
//   offset the circle from the sprite. The radius is defined in x coordinates, due to world coordinates not necessarily 
//   representing the size of items on screen (e.g. 10 units in X may not be the same apparent size as 10 units in Y).<br><br>
//   By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can set shapes 
//   individually by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0 meaning delete all 
//   existing shapes before creating a new one at ID 1. This command only changes existing shapes, you can add additional shapes 
//   by using the AddSpriteShape commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The X coordinate of the center of the circle in sprite space.
//   y -- The Y coordinate of the center of the circle in sprite space.
//   radius -- The radius of the circle.
// SOURCE
void agk::SetSpriteShapeCircle( uint32_t iSpriteIndex, float x, float y, float radius )
//****
{
	SetSpriteShapeCircle( iSpriteIndex, x, y, radius, 0 );
}

//****f* Sprite/Physics/SetSpriteShapePolygon
// FUNCTION
//   Overrides the current auto generated shape for use in collision detection, hit testing, and physics. A shape can be set 
//   without turning physics on, and by default all sprites are set to use the box shape, which is the fastest to setup. 
//   The polygon is defined by a set of points (between 2 and 12) relative to the current sprite's offset. For example,
//   a point of 0,0 would be centered on the sprite's offset point, any other value will be offset from this point.
//   Points are defined one at a time by calling this command multiple times, with index starting at 0. Once the index equals
//   numPoints-1 then the shape will be created using the previously defined points. Once you start defining points you
//   must complete the process by reaching index=numPoints-1 before defining points for any other shape.<br><br>
//   By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can set shapes 
//   individually by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0 meaning delete all 
//   existing shapes before creating a new one at ID 1. This command only changes existing shapes, by default all sprites have 
//   a base shape at ID 1. You can add additional shapes by using the AddSpriteShape commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   numPoints -- The number of points to use in the polygon, min 2, max 12.
//   index -- The index of the point to set, if this equals numPoints-1 then the shape will be created
//   x -- X coordinate of the polygon to be added
//   y -- Y coordinate of the polygon to be added
// SOURCE
void agk::SetSpriteShapePolygon( uint32_t iSpriteIndex, uint32_t numPoints, uint32_t index, float x, float y )
//****
{
	SetSpriteShapePolygon( iSpriteIndex, numPoints, index, x, y, 0 );
}

//****f* Sprite/Physics/SetSpriteShape
// FUNCTION
//   Sets the current shape for use in collision detection, hit testing, and physics. A shape can be set without turning physics
//   on, and by default all sprites are set to use the box shape, which is the fastest to setup. If you select no shape (0) then
//   any existing shape will be deleted, and hit testing will use the sprite dimensions instead. Commands that require a shape 
//   such as <i>GetspriteCollision</i> will generate a box shape for the sprite if none exists.
//   The shape parameter lets you define what type of bounding box the system should use to detect collisions. Circle will create 
//   a perfect circle centered on the sprite's rotation point and big enough to enclose the sprite's visible pixels. Box will 
//   create a box around the edges of the sprite, without regard to whether pixels are visible or not. Polygon will create a close 
//   fitting convex polygon around the visible pixels of a sprite, with a visible pixel being defined as one with an alpha value 
//   greater than 128.<br><br>
//   This function will not work on dummy sprites as there is no image to use when calculating a shape, in these cases shapes
//   must be specified manually using <i>SetSpriteShapeBox</i>, <i>SetSpriteShapeCircle</i>, or <i>SetSpriteShapePolygon</i>.<br><br>
//   By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can set shapes 
//   individually by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0 meaning delete all 
//   existing shapes before creating a new one at ID 1. This command only changes existing shapes, by default all sprites have 
//   a base shape at ID 1. You can add additional shapes by using the AddSpriteShape commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   shape -- The shape to use for this sprite, 0=no shape, 1=circle, 2=box, 3=polygon
//   shapeID -- The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and replace them with this new one
// SOURCE
void agk::SetSpriteShape( uint32_t iSpriteIndex, int shape, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
	#endif
		return;
	}

	cSprite::ePhysicsShape eShape = cSprite::ePolygon;
	switch(shape)
	{
		case 0: eShape = cSprite::eNone; break;
		case 1: eShape = cSprite::eCircle; break;
		case 2: eShape = cSprite::eBox; break;
		case 3: eShape = cSprite::ePolygon; break;
		default:
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Unrecognised physics shape for sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );
			Error( errStr );
#endif
			return;
		}
	}

	pSprite->SetShape( eShape, shapeID-1 );
}

//****f* Sprite/Physics/SetSpriteShapeBox
// FUNCTION
//   Overrides the current auto generated shape for use in collision detection, hit testing, and physics. A shape can be set 
//   without turning physics on, and by default all sprites are set to use the box shape, which is the fastest to setup. 
//   The box is defined by specifying its top left and bottom right coordinates in sprite space, relative to the offset of the sprite,
//   by default this is the center of the sprite.
//   For example if the current sprite offset was 0,0 the top left box corner would be 0,0, but if the sprite offset was the 
//   middle of the sprite (default) the top left corner would be -width/2,-height/2. You may also specify an angle to offset the box
//   relative to the current sprite rotation.<br><br>
//   By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can set shapes 
//   individually by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0 meaning delete all 
//   existing shapes before creating a new one at ID 1. This command only changes existing shapes, by default all sprites have 
//   a base shape at ID 1. You can add additional shapes by using the AddSpriteShape commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The X coordinate of the top left corner of the new box in sprite space.
//   y -- The Y coordinate of the top left corner of the new box in sprite space.
//   x2 -- The X coordinate of the bottom right corner of the new box in sprite space.
//   y2 -- The Y coordinate of the bottom right corner of the new box in sprite space.
//   angle -- The angle of the box in radians.
//   shapeID -- The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and replace them with this new one
// SOURCE
void agk::SetSpriteShapeBox( uint32_t iSpriteIndex, float x, float y, float x2, float y2, float angle, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetShapeBox( x,y, x2,y2, angle, shapeID-1 );
}

//****f* Sprite/Physics/SetSpriteShapeCircle
// FUNCTION
//   Overrides the current auto generated shape for use in collision detection, hit testing, and physics. A shape can be set 
//   without turning physics on, and by default all sprites are set to use the box shape, which is the fastest to setup. 
//   The circle is defined by specifying its center point relative to the sprite's current offset and a radius. For example,
//   if the circle was to be centered on the sprite's offset point it would be specified at position 0,0. Any other value will
//   offset the circle from the sprite. The radius is defined in x coordinates, due to world coordinates not necessarily 
//   representing the size of items on screen (e.g. 10 units in X may not be the same apparent size as 10 units in Y).<br><br>
//   By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can set shapes 
//   individually by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0 meaning delete all 
//   existing shapes before creating a new one at ID 1. This command only changes existing shapes, by default all sprites have 
//   a base shape at ID 1. You can add additional shapes by using the AddSpriteShape commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The X coordinate of the center of the circle in sprite space.
//   y -- The Y coordinate of the center of the circle in sprite space.
//   radius -- The radius of the circle.
//   shapeID -- The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and replace them with this new one
// SOURCE
void agk::SetSpriteShapeCircle( uint32_t iSpriteIndex, float x, float y, float radius, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetShapeCircle( x,y, radius, shapeID );
}

//****f* Sprite/Physics/SetSpriteShapePolygon
// FUNCTION
//   Overrides the current auto generated shape for use in collision detection, hit testing, and physics. A shape can be set 
//   without turning physics on, and by default all sprites are set to use the box shape, which is the fastest to setup. 
//   The polygon is defined by a set of points (between 2 and 12) relative to the current sprite's offset. For example,
//   a point of 0,0 would be centered on the sprite's offset point, any other value will be offset from this point.
//   Points are defined one at a time by calling this command multiple times, with index starting at 0. Once the index equals
//   numPoints-1 then the shape will be created using the previously defined points. Once you start defining points you
//   must complete the process by reaching index=numPoints-1 before defining points for any other shape.<br><br>
//   By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can set shapes 
//   individually by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0 meaning delete all 
//   existing shapes before creating a new one at ID 1. This command only changes existing shapes, by default all sprites have 
//   a base shape at ID 1. You can add additional shapes by using the AddSpriteShape commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   numPoints -- The number of points to use in the polygon, min 2, max 12.
//   index -- The index of the point to set, if it equals numPoints-1 then the shape will be created
//   x -- X coordinate of the polygon to be added
//   y -- Y coordinate of the polygon to be added
//   shapeID -- The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and replace them with this new one
// SOURCE
void agk::SetSpriteShapePolygon( uint32_t iSpriteIndex, uint32_t numPoints, uint32_t index, float x, float y, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetShapePolygon( numPoints, index, x, y, shapeID-1 );
}

//****f* Sprite/Physics/SetSpriteShapeChain
// FUNCTION
//   Overrides the current auto generated shape for use in physics. Normal sprite collision and hit testing does not work with 
//   the chain shape, it is only for physics. 
//   A shape can be set without turning physics on, and by default all sprites are set to use the box shape, which is the fastest to setup. 
//   The chain is defined by a set of points (at least 2) relative to the current sprite's offset. For example,
//   a point of 0,0 would be centered on the sprite's offset point, any other value will be offset from this point.
//   Chains are rigid and can be used to create hollow concave polygons, or 2D terrains. Set the loop parameter to 1 to join 
//   to two ends of the chain together creating a hollow polygon.
//   Points are defined one at a time by calling this command multiple times, with index starting at 0. Once the index equals
//   numPoints-1 then the shape will be created using the previously defined points. Once you start defining points you
//   must complete the process by reaching index=numPoints-1 before defining points for any other shape.<br><br>
//   Using a shapeID of 0 removes all other shapes assigned to the sprite and replaces it with this one. You can set shapes 
//   individually by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape. This command only changes 
//   existing shapes, by default all sprites have a base shape at ID 1. You can add additional shapes by using the 
//   AddSpriteShape commands.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   numPoints -- The number of points to use in the chain, min 2, no maximum.
//   index -- The index of the point to set, if it equals numPoints-1 then the shape will be created
//   loop -- 1 to join the two ends of the chain together, 0 to leave them unconnected
//   x -- X coordinate of the polygon to be added
//   y -- Y coordinate of the polygon to be added
//   shapeID -- The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and replace them with this new one
// SOURCE
void agk::SetSpriteShapeChain( uint32_t iSpriteIndex, uint32_t numPoints, uint32_t index, int loop, float x, float y, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetShapeChain( numPoints, index, loop, x, y, shapeID-1 );
}

//****f* Sprite/Physics/AddSpriteShapeBox
// FUNCTION
//   Adds a new shape to the sprite, in addition to any it already has. These additional shapes only apply to physics 
//   sprites and must be added after a sprite has been set to use physics.<br><br>
//   The box is defined by specifying its top left and bottom right coordinates in sprite space, relative to its current 
//   offset. For example if the current sprite offset was 0,0 the top left box corner would be 0,0, but if the sprite 
//   offset was the middle of the sprite (default) the top left corner would be -width/2,-height/2. You may also specify 
//   an angle to offset the box relative to the current sprite rotation.<br><br>
//   This will recalculate the sprite's mass and center of mass values.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The X coordinate of the top left corner of the new box in sprite space.
//   y -- The Y coordinate of the top left corner of the new box in sprite space.
//   x2 -- The X coordinate of the bottom right corner of the new box in sprite space.
//   y2 -- The Y coordinate of the bottom right corner of the new box in sprite space.
//   angle -- The angle of the box in radians.
// SOURCE
void agk::AddSpriteShapeBox( uint32_t iSpriteIndex, float x, float y, float x2, float y2, float angle )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->AddShapeBox( x,y, x2,y2, angle );
}

//****f* Sprite/Physics/AddSpriteShapeCircle
// FUNCTION
//   Adds a new shape to the sprite, in addition to any it already has. These additional shapes only apply to physics 
//   sprites and must be added after a sprite has been set to use physics.<br><br>
//   The circle is defined by specifying its center point relative to the sprite's current offset and a radius. For example,
//   if the circle was to be centered on the sprite's offset point it would be specified at position 0,0. Any other value will
//   offset the circle from the sprite. The radius is defined in x coordinates, due to world coordinates not necessarily 
//   representing the size of items on screen (e.g. 10 units in X may not be the same apparent size as 10 units in Y).<br><br>
//   This will recalculate the sprite's mass and center of mass values.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The X coordinate of the center of the circle in sprite space.
//   y -- The Y coordinate of the center of the circle in sprite space.
//   radius -- The radius of the circle.
// SOURCE
void agk::AddSpriteShapeCircle( uint32_t iSpriteIndex, float x, float y, float radius )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->AddShapeCircle( x,y, radius );
}

//****f* Sprite/Physics/AddSpriteShapePolygon
// FUNCTION
//   Adds a new shape to the sprite, in addition to any it already has. These additional shapes only apply to physics 
//   sprites and must be added after a sprite has been set to use physics.<br><br>
//   The polygon is defined by a set of points (between 2 and 12) relative to the current sprite's offset. For example,
//   a point of 0,0 would be centered on the sprite's offset point, any other value will be offset from this point.
//   Points are defined one at a time by calling this command multiple times, with index starting at 0. Once the index equals
//   numPoints-1 then the shape will be created using the previously defined points. Once you start defining points you
//   must complete the process by reaching index=numPoints-1 before defining points for any other shape.<br><br>
//   This will recalculate the sprite's mass and center of mass values.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   numPoints -- The number of points to use in the polygon, min 2, max 12.
//   index -- Index for points, so you can specify index 0, 1, 2 etc.
//   x -- X position for the specified point.
//   y -- Y position for the specified point.
// SOURCE
void agk::AddSpriteShapePolygon( uint32_t iSpriteIndex, uint32_t numPoints, uint32_t index, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->AddShapePolygon( numPoints, index, x, y );
}

//****f* Sprite/Physics/AddSpriteShapeChain
// FUNCTION
//   Adds a new shape to the sprite, in addition to any it already has. Shapes can be added even if the sprite is not
//   setup for physics.<br><br>
//   The chain is defined by a set of points (at least 2) relative to the current sprite's offset. For example,
//   a point of 0,0 would be centered on the sprite's offset point, any other value will be offset from this point.
//   Chains are rigid and can be used to create hollow concave polygons, or 2D terrains. Set the loop parameter to 1 to join 
//   to two ends of the chain together creating a hollow polygon.
//   Points are defined one at a time by calling this command multiple times, with index starting at 0. Once the index equals
//   numPoints-1 then the shape will be created using the previously defined points. Once you start defining points you
//   must complete the process by reaching index=numPoints-1 before defining points for any other shape.<br><br>
//   This will recalculate the sprite's mass and center of mass values.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   numPoints -- The number of points to use in the chain, minimum of 2, no maximum.
//   index -- The index of the point to set, if it equals numPoints-1 then the shape will be created
//   loop -- 1=connect this back to the first point creating a loop, 0=leave this point hanging on the end (default)
//   x -- X position for the specified point.
//   y -- Y position for the specified point.
// SOURCE
void agk::AddSpriteShapeChain( uint32_t iSpriteIndex, uint32_t numPoints, uint32_t index, int loop, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->AddShapeChain( numPoints, index, loop, x, y );
}

//****f* Sprite/Physics/ClearSpriteShapes
// FUNCTION
//   Removes all additional shapes applied to the sprite and keeps only the base shape at shapeID 1.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
// SOURCE
void agk::ClearSpriteShapes( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->ClearAdditionalShapes( );
}

//****f* Sprite/Physics/GetSpriteNumShapes
// FUNCTION
//   Returns the current number of shapes assigned to this sprite. Shape IDs are valid from 1 up to and
//   including the value returned by this command.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check
// SOURCE
int agk::GetSpriteNumShapes( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetNumShapes();
}

//****f* Sprite/Physics/GetSpriteShapeNumVertices
// FUNCTION
//   Returns the number of vertices in the specified shape. This only applies to polygon and chain shapes.
//   Shape IDs start at 1 for the first shape up to and including the value returned by <i>GetSpriteNumShapes</i>.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check
//   shapeID -- The ID of the shape to check
// SOURCE
int agk::GetSpriteShapeNumVertices( uint32_t iSpriteIndex, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetShapeNumVertices( shapeID-1 );
}

//****f* Sprite/Physics/GetSpriteShapeVertexX
// FUNCTION
//   Returns the X value of given vertex in the specified shape. This only applies to polygon and chain shapes.
//   Shape IDs start at 1 for the first shape up to and including the value returned by <i>GetSpriteNumShapes</i>.
//   Vertex IDs start at 1 for the first vertex up to and including the value returned by <i>GetSpriteShapeNumVertices</i>
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check
//   shapeID -- The ID of the shape to check
//   vertex -- the ID of the vertex to check, vertices start at ID 1.
// SOURCE
float agk::GetSpriteShapeVertexX( uint32_t iSpriteIndex, int shapeID, int vertex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetShapeVertexX( shapeID-1, vertex-1 );
}

//****f* Sprite/Physics/GetSpriteShapeVertexY
// FUNCTION
//   Returns the Y value of given vertex in the specified shape. This only applies to polygon and chain shapes.
//   Shape IDs start at 1 for the first shape up to and including the value returned by <i>GetSpriteNumShapes</i>.
//   Vertex IDs start at 1 for the first vertex up to and including the value returned by <i>GetSpriteShapeNumVertices</i>
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check
//   shapeID -- The ID of the shape to check
//   vertex -- the ID of the vertex to check, vertices start at ID 1.
// SOURCE
float agk::GetSpriteShapeVertexY( uint32_t iSpriteIndex, int shapeID, int vertex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetShapeVertexY( shapeID-1, vertex-1 );
}

//****f* Sprite/Physics/SetSpritePhysicsCOM
// FUNCTION
//   Sets the center of mass (COM) relative to the sprite's offset. By default the AGK calculates the best location
//   for the COM based on the size and location of all shapes attached to the sprite. Setting it to 0,0 will 
//   put the COM on the sprite's offset point (and center of rotation). If the COM is very different from the 
//   offset point the sprite may seem unstable as it will behave like an unbalanced spinning top.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The x coordinate of the center of mass.
//   y -- The y coordinate of the center of mass.
// SOURCE
void agk::SetSpritePhysicsCOM( uint32_t iSpriteIndex, float x, float y )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsCOM( x, y );
}

//****f* Sprite/Physics/CalculateSpritePhysicsCOM
// FUNCTION
//   Recalculates the COM based on the shapes attached to the sprite, if you have overridden the COM this will
//   set it back to a location decided by the AGK. If the COM is very different from the offset point the sprite
//   may seem unstable as it will behave like an unbalanced spinning top.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
// SOURCE
void agk::CalculateSpritePhysicsCOM( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->CalculatePhysicsCOM( );
}

//****f* Sprite/Physics/GetSpritePhysicsCOMX
// FUNCTION
//   Returns the X value of current Center Of Mass for the given sprite's physics body. All shapes currently 
//   added to this sprite contribute to this value. If you have set the center of mass manually then it will 
//   return that value. Physics must be turned on for this sprite for the command to work, otherwise it will 
//   return 0.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check
// SOURCE
float agk::GetSpritePhysicsCOMX( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetPhysicsCOMX();
}

//****f* Sprite/Physics/GetSpritePhysicsCOMY
// FUNCTION
//   Returns the Y value of current Center Of Mass for the given sprite's physics body. All shapes currently 
//   added to this sprite contribute to this value. If you have set the center of mass manually then it will 
//   return that value. Physics must be turned on for this sprite for the command to work, otherwise it will 
//   return 0. 
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check
// SOURCE
float agk::GetSpritePhysicsCOMY( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetPhysicsCOMY();
}

//****f* Sprite/Physics/SetSpritePhysicsOn
// FUNCTION
//   Sets the sprite up for automatic collision using the built physics system. Once you have set a sprite to be controlled by physics
//   you should use <i>SetSpritePosition</i> and <i>SetSpriteAngle</i> sparingly as these will interrupt the physics motion of the sprite.
//   You can also use the <i>SetSpritePhysicsVelocity</i> and <i>SetSpritePhysicsAngularVelocity</i> to change the speed and direction of a sprite,
//   but again these will interfere with the physics motion of the sprite. If you wish to influence the position or rotation of a physics
//   sprite you should use the force and torque (rotational force) functions where possible, these will maintain smooth physics motion.<br><br>
//   
//   The mode parameter lets you choose how the sprite should behave in the physics world. Static means it will never move or rotate, 
//   dynamic means it will respond to all collisions and forces it encounters, including gravity and collisions with static objects.
//   Kinematic is a special case which can be thought of as a moving static body, it will not respond to collisions or forces and will 
//   continue at its specified velocity forever, but dynamic items will respond to it and effectively be pushed out of the way.<br><br>
//   
//   The physics shape used is determined by the <i>SetSpriteShape</i> command, which must be called before this command and is expensive to 
//   change for circle and polygon shapes as they rebuild a shape from the pixels of the sprite's image.<br><br>
//
//   Once you have called this command to determine the mode of the sprite, further calls will ignore the mode values and it will only 
//   reactivate a sprite that has been turned off, as the mode cannot be changed whilst the sprite is in the physics system. 
//   If you wish to change the mode of a sprite call <i>SetSpritePhysicsDelete</i>, which will delete all its physics settings, then call 
//   <i>SetSpritePhysicsOn</i> with the new mode. But doing this too often will slow the system down.<br><br>
//
//   All physics sprites should be world sprites (not fixed to the screen), unless <i>SetViewOffset</i> is set to 0,0 in which case this doesn't 
//   matter. Otherwise debug shapes will not line up and sprites from different view spaces will not interact properly.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   mode -- The physics mode to use for this sprite, 1=static, 2=dynamic, 3=kinematic
// SOURCE
void agk::SetSpritePhysicsOn( uint32_t iSpriteIndex, int mode )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	cSprite::ePhysicsMode eMode = cSprite::eStatic;
	switch(mode)
	{
		case 1: eMode = cSprite::eStatic; break;
		case 2: eMode = cSprite::eDynamic; break;
		case 3: eMode = cSprite::eKinematic; break;
		default:
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Unrecognised physics mode for sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );
			Error( errStr );
#endif
			return;
		}

	}

	pSprite->SetPhysicsOn( eMode );
}

void agk::PrepareToDeleteSpriteContacts( cSprite *pSprite )
{
	while( m_pContactIter )
	{
		b2Body *body1 = m_pContactIter->GetFixtureA()->GetBody();
		b2Body *body2 = m_pContactIter->GetFixtureB()->GetBody();
		if ( pSprite == (cSprite*) body1->GetUserData() || pSprite == (cSprite*) body2->GetUserData() ) m_pContactIter = m_pContactIter->GetNext();
		else break;
	}
}

//****f* Sprite/Physics/SetSpritePhysicsOff
// FUNCTION
//   Temporarily turns off physics for this sprite, it will no longer move or react to collisions or forces.
//   Use <i>SetSpritePhysicsOn</i> to reactivate the sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
// SOURCE
void agk::SetSpritePhysicsOff( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsOff();
}

//****f* Sprite/Physics/SetSpritePhysicsGravityScale
// FUNCTION
//   Sets the gravity scale for the sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//	 scale -- scaling value for the gravity.
// SOURCE
void agk::SetSpritePhysicsGravityScale ( UINT iSpriteIndex, float scale )
//****
{
	cSprite *pSprite = ( cSprite* ) m_cSpriteList.GetItem ( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr ( "Sprite ", 50 );  errStr.AppendUInt ( iSpriteIndex );  errStr.Append ( " does not exist" );
		Error ( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsGravityScale ( scale );
}

//****f* Sprite/Physics/GetSpritePhysicsGravityScale
// FUNCTION
//   Returns the gravity scale for the sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
// SOURCE
float agk::GetSpritePhysicsGravityScale ( UINT iSpriteIndex )
//****
{
	cSprite *pSprite = ( cSprite* ) m_cSpriteList.GetItem ( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr ( "Sprite ", 50 );  errStr.AppendUInt ( iSpriteIndex );  errStr.Append ( " does not exist" );
		Error ( errStr );
#endif
		return 0.0f;
	}

	return pSprite->GetPhysicsGravityScale ( );
}

//****f* Sprite/Physics/SetSpritePhysicsInitiallyAwake
// FUNCTION
//   Sets whether the sprite is awake upon creation.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//	 awake -- 0 for sleep, 1 for awake.
// SOURCE
void agk::SetSpritePhysicsInitiallyAwake ( UINT iSpriteIndex, int awake )
//****
{
	cSprite *pSprite = ( cSprite* ) m_cSpriteList.GetItem ( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr ( "Sprite ", 50 );  errStr.AppendUInt ( iSpriteIndex );  errStr.Append ( " does not exist" );
		Error ( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsInitiallyAwake ( awake != 0 );
}

//****f* Sprite/Physics/SetSpritePhysicsAllowSleep
// FUNCTION
//   Sets whether the sprite is allowed to sleep.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//	 sleep -- 0 to disable sleeping, 1 to allow it.
// SOURCE
void agk::SetSpritePhysicsAllowSleep ( UINT iSpriteIndex, int sleep )
//****
{
	cSprite *pSprite = ( cSprite* ) m_cSpriteList.GetItem ( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr ( "Sprite ", 50 );  errStr.AppendUInt ( iSpriteIndex );  errStr.Append ( " does not exist" );
		Error ( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsAllowSleep ( sleep != 0 );
}

//****f* Sprite/Physics/GetSpritePhysicsInertia
// FUNCTION
//   Returns the current inertia of the sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite.
// SOURCE
float agk::GetSpritePhysicsInertia ( UINT iSpriteIndex )
//****
{
	cSprite *pSprite = ( cSprite* ) m_cSpriteList.GetItem ( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr ( "Sprite ", 50 );  errStr.AppendUInt ( iSpriteIndex );  errStr.Append ( " does not exist" );
		Error ( errStr );
#endif
		return 0.0f;
	}

	return pSprite->GetInertia ( );
}

//****f* Sprite/Physics/GetSpritePhysicsIsBullet
// FUNCTION
//   Returns whether the sprite is set to be a bullet or not.
// INPUTS
//   iSpriteIndex -- The ID of the sprite.
// SOURCE
int agk::GetSpritePhysicsIsBullet ( UINT iSpriteIndex )
//****
{
	cSprite *pSprite = ( cSprite* ) m_cSpriteList.GetItem ( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr ( "Sprite ", 50 );  errStr.AppendUInt ( iSpriteIndex );  errStr.Append ( " does not exist" );
		Error ( errStr );
#endif
		return 0;
	}

	return pSprite->GetIsBullet ( );
}

//****f* Sprite/Physics/GetSpritePhysicsIsAwake
// FUNCTION
//   Returns whether the sprite is awake or not.
// INPUTS
//   iSpriteIndex -- The ID of the sprite.
// SOURCE
int agk::GetSpritePhysicsIsAwake ( UINT iSpriteIndex )
//****
{
	cSprite *pSprite = ( cSprite* ) m_cSpriteList.GetItem ( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr ( "Sprite ", 50 );  errStr.AppendUInt ( iSpriteIndex );  errStr.Append ( " does not exist" );
		Error ( errStr );
#endif
		return 0;
	}

	return pSprite->GetIsAwake ( );
}

//****f* Sprite/Physics/SetSpritePhysicsDelete
// FUNCTION
//   Turns off physics for this sprite and deletes all associated physics settings for this sprite. You can use this to
//   change the mode or shape of a sprite but doing so regularly can affect the performance of the application.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
// SOURCE
void agk::SetSpritePhysicsDelete( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsDelete();
}

//****f* Sprite/Physics/SetSpritePhysicsFriction
// FUNCTION
//   Sets the friction value to use for this sprite during physics calculations. Should be in the range 0 to 1.
//   By default this sets all the shapes assigned to this sprite to the same value, you can instead set it on a 
//   per shape basis by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0
//   meaning apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   friction -- The new friction value.
// SOURCE
void agk::SetSpritePhysicsFriction( uint32_t iSpriteIndex, float friction )
//****
{
	SetSpritePhysicsFriction( iSpriteIndex, friction, 0 );
}

//****f* Sprite/Physics/SetSpritePhysicsRestitution
// FUNCTION
//   Sets the restitution (bounciness) value to use for this sprite during physics calculations. Should be in the range 0 to 1.
//   Values greater than 1 will result in the sprite gaining energy from collisions which can cause an unstable result.
//   By default this sets all the shapes assigned to this sprite to the same value, you can instead set it on a 
//   per shape basis by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0
//   meaning apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   restitution -- The new restitution value.
// SOURCE
void agk::SetSpritePhysicsRestitution( uint32_t iSpriteIndex, float restitution )
//****
{
	SetSpritePhysicsRestitution( iSpriteIndex, restitution, 0 );
}

//****f* Sprite/Physics/SetSpritePhysicsFriction
// FUNCTION
//   Sets the friction value to use for this sprite during physics calculations. Should be in the range 0 to 1.
//   By default this sets all the shapes assigned to this sprite to the same value, you can instead set it on a 
//   per shape basis by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0
//   meaning apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   friction -- The new friction value.
//   shapeID -- The ID of the shape to change, 0 to apply the value to all shapes
// SOURCE
void agk::SetSpritePhysicsFriction( uint32_t iSpriteIndex, float friction, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsFriction( friction, shapeID-1 );
}

//****f* Sprite/Physics/SetSpritePhysicsRestitution
// FUNCTION
//   Sets the restitution (bounciness) value to use for this sprite during physics calculations. Should be in the range 0 to 1.
//   Values greater than 1 will result in the sprite gaining energy from collisions which can cause an unstable result.
//   By default this sets all the shapes assigned to this sprite to the same value, you can instead set it on a 
//   per shape basis by specifying a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0
//   meaning apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   restitution -- The new restitution value.
//   shapeID -- The ID of the shape to change, 0 to apply the value to all shapes
// SOURCE
void agk::SetSpritePhysicsRestitution( uint32_t iSpriteIndex, float restitution, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsRestitution( restitution, shapeID-1 );
}

//****f* Sprite/Physics/SetSpritePhysicsDensity
// FUNCTION
//   Sets the density value to use for the given sprite shape during physics calculations. Default value is 1.0.
//   This affects the mass calculation for the given size of the sprite. This command will recalculate the mass 
//   and center of mass for this sprite.
//   Use a shapeID of 0 to apply this density to all shapes or specify a shape ID greater than 0 to apply it only 
//   to that shape. Shape IDs start at 1 for the first shape.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify
//   density -- The new density value, default is 1.0
//   shapeID -- The ID of the shape to change, 0 to apply the value to all shapes
// SOURCE
void agk::SetSpritePhysicsDensity( uint32_t iSpriteIndex, float density, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsDensity( density, shapeID-1 );
}

//****f* Sprite/Physics/SetSpritePhysicsCanRotate
// FUNCTION
//   Sets whether the physics simulation is allowed to rotate the sprite.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   rotate -- 1 to allow rotation, 0 to prevent it.
// SOURCE
void agk::SetSpritePhysicsCanRotate( uint32_t iSpriteIndex, int rotate )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsCanRotate( rotate>0 );
}

//****f* Sprite/Physics/SetSpritePhysicsVelocity
// FUNCTION
//   Immediately sets the sprite's velocity to the given direction. This is an abrupt change that might not look
//   right during the physics simulation, forces and impulses are the preferred approach to influencing velocity.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   vx -- The x component of the new velocity.
//   vy -- The y component of the new velocity.
// SOURCE
void agk::SetSpritePhysicsVelocity( uint32_t iSpriteIndex, float vx, float vy )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsVelocity( vx, vy );
}

//****f* Sprite/Physics/SetSpritePhysicsAngularVelocity
// FUNCTION
//   Immediately sets the sprite's rotational velocity to the given direction. This is an abrupt change that might not look
//   right during the physics simulation, torque and angular impulses are the preferred approach to influencing angular velocity.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   va -- The new angular velocity.
// SOURCE
void agk::SetSpritePhysicsAngularVelocity( uint32_t iSpriteIndex, float va )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsAngularVelocity( va );
}

//****f* Sprite/Physics/SetSpritePhysicsDamping
// FUNCTION
//   Sets some damping on the sprite's linear movement which may simulate something like wind resistance.<br><br>
//   A value of 0 represents no damping, a value of 0.75 would reduce the velocity vector by half every second 
//   when running at 60 frames per second. Higher values will reduce the speed more quickly.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   damp -- The new damping value.
// SOURCE
void agk::SetSpritePhysicsDamping( uint32_t iSpriteIndex, float damp )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsDamping( damp );
}

//****f* Sprite/Physics/SetSpritePhysicsAngularDamping
// FUNCTION
//   Sets some damping on the sprite's angular movement which may simulate something like wind resistance.<br><br>
//   A value of 0 represents no damping, a value of 0.75 would reduce the angular velocity vector by half every 
//   second when running at 60 frames per second. Higher values will reduce the spin more quickly.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   damp -- The new damping value.
// SOURCE
void agk::SetSpritePhysicsAngularDamping( uint32_t iSpriteIndex, float damp )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsAngularDamping( damp );
}

//****f* Sprite/Physics/SetSpritePhysicsIsBullet
// FUNCTION
//   Set this to true if the sprite is likely to be moving very fast, like a bullet, as it will then be checked
//   more thoroughly for collision with other dynamic sprites, using this unnecessarily will affect performance.
//   This is called Continuous Collision Detection (CCD) and applies automatically to collision checks between 
//   this sprite and static objects. This command turns CCD on for collision checks between this sprite and dynamic 
//   objects. This will not work if global CCD is turned off with SetPhysicsCCD.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   bullet -- 1 to set this sprite as a bullet, 0 to turn it off.
// SOURCE
void agk::SetSpritePhysicsIsBullet( uint32_t iSpriteIndex, int bullet )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsIsBullet( bullet>0 );
}

//****f* Sprite/Physics/SetSpritePhysicsMass
// FUNCTION
//   This command overrides the calculated mass for this sprite and sets it to a value of your choice, in kilograms.
//   Setting this too low or too high can cause an unstable simulation, especially if a very light object meets a 
//   very heavy object. The value range you should use depends on your chosen physics scale.<br><br>
//	 Internally a default mass per object is calculated based on its size. A 1m x 1m box would weigh 1 kg, so because
//   of the default physics scale of 5, a 5 x 5 box in virtual units weighs 1 kg.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   mass -- The new mass value.
// SOURCE
void agk::SetSpritePhysicsMass( uint32_t iSpriteIndex, float mass )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsMass( mass );
}

//****f* Sprite/Physics/SetSpritePhysicsIsSensor
// FUNCTION
//   Set this to 1 to make the sprite a sensor object. Physics sensors detect collisions and contacts but do
//   not respond to them, they also do not affect anything that hits them. Their only purpose is to detect 
//   collisions. If you apply this to a dynamic body it will not collide with anything and most likely fall 
//   through the floor and continue falling forever, it is still affected by forces.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   sensor -- 1 to set this sprite as a sensor, 0 to make it a normal physics object.
// SOURCE
void agk::SetSpritePhysicsIsSensor( uint32_t iSpriteIndex, int sensor )
//****
{
	SetSpritePhysicsIsSensor( iSpriteIndex, sensor, 0 );
}

//****f* Sprite/Physics/SetSpriteGroup
// FUNCTION
//   Assigns this sprite to a group for filtering collisions (physics or non physics). In physics, sprites of the same positive 
//   group ID will always collide, whilst those that share the same negative group ID will never collide. Those with a group ID 
//   of zero (default), or differing group IDs move on to the category filter check.<br/><br/>
//   When the sprite is not setup for physics this test will only apply to the base shape at shapeID 1.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   group -- The group ID to assign to this sprite.
// SOURCE
void agk::SetSpriteGroup( uint32_t iSpriteIndex, int group )
//****
{
	SetSpriteGroup( iSpriteIndex, group, 0 );
}

//****f* Sprite/Physics/SetSpriteCategoryBits
// FUNCTION
//   Assigns the sprite to zero or more categories for collision filtering (physics and non physics). There are 16 categories, 
//   each represented by a single bit in the "categories" parameter, a value of 1 for a bit represents that this sprite is a 
//   part of that category and 0 that it does not belong to that category. Sprites can then be set to collide with certain
//   categories using <i>SetSpriteCollideBits</i> regardless of which categories they themselves belong to.<Br><br>
//   By default all sprites belong to category 1 (0x0001 the rightmost bit) and collide with all categories (0xffff).<br/><br/>
//   When the sprite is not setup for physics this test will only apply to the base shape at shapeID 1.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   categories -- The bitwise field of categories to assign to this sprite.
// SOURCE
void agk::SetSpriteCategoryBits( uint32_t iSpriteIndex, uint32_t categories )
//****
{
	SetSpriteCategoryBits( iSpriteIndex, categories, 0 );
}

//****f* Sprite/Physics/SetSpriteCategoryBit
// FUNCTION
//   Assigns or removes a sprite from a particular category. There are 16 categories that a sprite can belong to, and a 
//   sprite can belong to any number at once. This command is similar to <i>SetSpriteCategoryBits</i> except this command sets 
//   one category at a time whilst that command sets them all at once using a bit mask.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   category -- The category to change, must be between 1 and 16 inclusive.
//   flag -- 1 to make the sprite a part of this category, 0 to remove it.
// SOURCE
void agk::SetSpriteCategoryBit( uint32_t iSpriteIndex, uint32_t category, int flag )
//****
{
	SetSpriteCategoryBit( iSpriteIndex, category, flag, 0 );
}

//****f* Sprite/Physics/SetSpriteCollideBits
// FUNCTION
//   Uses a bitwise mask to determine which sprite categories this sprite can collide with. Sprites are 
//   assigned categories using <i>SetSpriteCategoryBits</i>. There are 16 categories, each represented by a single 
//   bit in the "mask" parameter, a value of 1 for a bit represents that this sprite will collide with sprites from 
//   that category and 0 that it will not collide with that category, regardless of which category this sprite itself 
//   belongs to. By default all sprites belong to category 1 (0x0001 the rightmost bit) and collide with all 
//   categories (0xffff).<br/><br/>
//   When the sprite is not setup for physics this test will only apply to the base shape at shapeID 1.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   mask -- The bitwise mask of categories this sprite can collide with during physics calculations.
// SOURCE
void agk::SetSpriteCollideBits( uint32_t iSpriteIndex, uint32_t mask )
//****
{
	SetSpriteCollideBits( iSpriteIndex, mask, 0 );
}

//****f* Sprite/Physics/SetSpriteCollideBit
// FUNCTION
//   Sets or removes a category that this sprite can collide with. Sprites are assigned categories using 
//   <i>SetSpriteCategoryBit</i>. There are 16 categories, a value of 1 for that category represents that this sprite 
//   will collide with sprites from that category and 0 that it will not collide with that category, regardless of 
//   which category this sprite itself belongs to. By default all sprites belong to category 1 and collide with all 
//   categories. This command is similar to <i>SetSpriteCategoryBits</i> except this command sets one category at a time 
//   whilst that command sets them all at once using a bit mask.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   category -- The category to set collision on or off for this sprite, must be between 1 and 16 inclusive.
//   flag -- 1 to set collision on, 0 to turn it off for this sprite.
// SOURCE
void agk::SetSpriteCollideBit( uint32_t iSpriteIndex, uint32_t category, int flag )
//****
{
	SetSpriteCollideBit( iSpriteIndex, category, flag, 0 );
}

//****f* Sprite/Physics/SetSpritePhysicsIsSensor
// FUNCTION
//   Set this to 1 to make the sprite a sensor object. Physics sensors detect collisions and contacts but do
//   not respond to them, they also do not affect anything that hits them. Their only purpose is to detect 
//   collisions. If you apply this to a dynamic body it will not collide with anything and most likely fall 
//   through the floor and continue falling forever, it is still affected by forces.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   sensor -- 1 to set this sprite as a sensor, 0 to make it a normal physics object.
//   shapeID -- the ID of the shape to change, 0 to set all the sprite's shapes to this value
// SOURCE
void agk::SetSpritePhysicsIsSensor( uint32_t iSpriteIndex, int sensor, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsIsSensor( sensor>0, shapeID-1 );
}

//****f* Sprite/Physics/SetSpriteGroup
// FUNCTION
//   Assigns this sprite to a group for filtering collisions (physics or non physics). In physics, sprites of the same positive 
//   group ID will always collide, whilst those that share the same negative group ID will never collide. Those with a group ID 
//   of zero (default), or differing group IDs move on to the category filter check.<br/><br/>
//   When the sprite is not setup for physics this test will only apply to the base shape at shapeID 1.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   group -- The group ID to assign to this sprite.
//   shapeID -- the ID of the shape to change, 0 to set all the sprite's shapes to this value
// SOURCE
void agk::SetSpriteGroup( uint32_t iSpriteIndex, int group, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}
	
	pSprite->SetGroup( group, shapeID-1 );
}

//****f* Sprite/Physics/SetSpriteCategoryBits
// FUNCTION
//   Assigns the sprite to zero or more categories for collision filtering (physics and non physics). There are 16 categories, 
//   each represented by a single bit in the "categories" parameter, a value of 1 for a bit represents that this sprite is a 
//   part of that category and 0 that it does not belong to that category. Sprites can then be set to collide with certain
//   categories using <i>SetSpriteCollideBits</i> regardless of which categories they themselves belong to.<Br><br>
//   By default all sprites belong to category 1 (0x0001 the rightmost bit) and collide with all categories (0xffff).<br/><br/>
//   When the sprite is not setup for physics this test will only apply to the base shape at shapeID 1.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   categories -- The bitwise field of categories to assign to this sprite.
//   shapeID -- the ID of the shape to change, 0 to set all the sprite's shapes to this value
// SOURCE
void agk::SetSpriteCategoryBits( uint32_t iSpriteIndex, uint32_t categories, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetCategoryBits( categories, shapeID-1 );
}

//****f* Sprite/Physics/SetSpriteCategoryBit
// FUNCTION
//   Assigns or removes a sprite from a particular category. There are 16 categories that a sprite can belong to, and a 
//   sprite can belong to any number at once. This command is similar to <i>SetSpriteCategoryBits</i> except this command sets 
//   one category at a time whilst that command sets them all at once using a bit mask.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   category -- The category to change, must be between 1 and 16 inclusive.
//   flag -- 1 to make the sprite a part of this category, 0 to remove it.
//   shapeID -- the ID of the shape to change, 0 to set all the sprite's shapes to this value
// SOURCE
void agk::SetSpriteCategoryBit( uint32_t iSpriteIndex, uint32_t category, int flag, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetCategoryBit( category, flag, shapeID-1 );
}

//****f* Sprite/Physics/SetSpriteCollideBits
// FUNCTION
//   Uses a bitwise mask to determine which sprite categories this sprite can collide with. Sprites are 
//   assigned categories using <i>SetSpriteCategoryBits</i>. There are 16 categories, each represented by a single 
//   bit in the "mask" parameter, a value of 1 for a bit represents that this sprite will collide with sprites from 
//   that category and 0 that it will not collide with that category, regardless of which category this sprite itself 
//   belongs to. By default all sprites belong to category 1 (0x0001 the rightmost bit) and collide with all 
//   categories (0xffff).<br/><br/>
//   When the sprite is not setup for physics this test will only apply to the base shape at shapeID 1.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   mask -- The bitwise mask of categories this sprite can collide with during physics calculations.
//   shapeID -- the ID of the shape to change, 0 to set all the sprite's shapes to this value
// SOURCE
void agk::SetSpriteCollideBits( uint32_t iSpriteIndex, uint32_t mask, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}
	
	pSprite->SetCollideBits( mask, shapeID-1 );
}

//****f* Sprite/Physics/SetSpriteCollideBit
// FUNCTION
//   Sets or removes a category that this sprite can collide with. Sprites are assigned categories using 
//   <i>SetSpriteCategoryBit</i>. There are 16 categories, a value of 1 for that category represents that this sprite 
//   will collide with sprites from that category and 0 that it will not collide with that category, regardless of 
//   which category this sprite itself belongs to. By default all sprites belong to category 1 and collide with all 
//   categories. This command is similar to <i>SetSpriteCategoryBits</i> except this command sets one category at a time 
//   whilst that command sets them all at once using a bit mask.<br/><br/>
//   By default this sets all shapes to the same value, you can set this value on a per shape basis by
//   specifying a shapeID value greater than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
//   apply it to all shapes.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   category -- The category to set collision on or off for this sprite, must be between 1 and 16 inclusive.
//   flag -- 1 to set collision on, 0 to turn it off for this sprite.
//   shapeID -- the ID of the shape to change, 0 to set all the sprite's shapes to this value
// SOURCE
void agk::SetSpriteCollideBit( uint32_t iSpriteIndex, uint32_t category, int flag, int shapeID )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetCollideBit( category, flag, shapeID-1 );
}

//****f* Sprite/Physics/SetSpritePhysicsForce
// FUNCTION
//   Applies a force to the sprite that will last for this frame only, to continue applying this force you must 
//   keep calling this function. The force consists of a point in world coordinates and a direction, if the point 
//   and direction are not in line with the sprite's offset point then it will result in a rotation of the sprite 
//   as it is moved by the force. The length of the force vector determines its strength. If the sprite is constrained 
//   by surrounding objects it may not move unless the force is large enough to move those objects as well.<br><br>
//   Forces apply acceleration to an object relative to its mass, heavy objects will move less than light objects
//   with the same force applied to them.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The X coordinate of the force position in world coordinates.
//   y -- The Y coordinate of the force position in world coordinates.
//   vx -- The X component of the force direction.
//   vy -- The Y component of the force direction.
// SOURCE
void agk::SetSpritePhysicsForce( uint32_t iSpriteIndex, float x, float y, float vx, float vy )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsForce( x,y, vx,vy );
}

//****f* Sprite/Physics/SetSpritePhysicsTorque
// FUNCTION
//   Applies a torque to the rotation of the sprite, similar to applying a force to its movement. If the sprite 
//   is constrained by surrounding objects it may not rotate unless the torque is large enough to move those 
//   objects as well. The torque will last for this frame only, to continue applying this torque you must keep
//   calling this function.<br><br>
//   The reaction to a torque force is relative to the object's size, large objects will rotate slower than small
//   objects given the same torque.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   torque -- The size of the force to apply to the sprite's rotation. may be negative.
// SOURCE
void agk::SetSpritePhysicsTorque( uint32_t iSpriteIndex, float torque )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsTorque( torque );
}

//****f* Sprite/Physics/SetSpritePhysicsImpulse
// FUNCTION
//   Similar to a force but applied only once. Whilst forces are applied continuously over time gradually influencing
//   a sprite's velocity, an impulse simulates the sprite being hit suddenly and immediately changes the velocity with
//   the equivalent power of a similar force applied for 1 second.<br><Br>
//   The impulse consists of a point in world coordinates and a direction, if the point and direction are not in line 
//   with the sprite's offset point then it will result in a rotation of the sprite as it is moved by the impulse. The 
//   length of the impulse vector determines it strength. If the sprite is constrained by surrounding objects it will 
//   impart the impulse onto those objects and may not move itself.<br><br>
//   Impulses apply acceleration to an object relative to its mass, heavy objects will move less than light objects
//   with the same impulse applied to them.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   x -- The X coordinate of the impulse position in world coordinates.
//   y -- The Y coordinate of the impulse position in world coordinates.
//   vx -- The X component of the impulse direction.
//   vy -- The Y component of the impulse direction.
// SOURCE
void agk::SetSpritePhysicsImpulse( uint32_t iSpriteIndex, float x, float y, float vx, float vy )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsLinearImpulse( x,y, vx,vy );
}

//****f* Sprite/Physics/SetSpritePhysicsAngularImpulse
// FUNCTION
//   Similar to a torque force, but applied only once. Whilst forces are applied continuously over time gradually influencing
//   a sprite's velocity, an impulse simulates the sprite being hit suddenly and immediately changes the angular velocity with
//   the equivalent power of a similar torque force applied for 1 second.<br><br>
//   If the sprite is constrained by surrounding objects it may not rotate unless the impulse is large enough to move those 
//   objects as well. <br><br>
//   The reaction to an impulse is relative to the object's size, large objects will rotate slower than small objects given 
//   the same impulse.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to modify.
//   impulse -- The size of the force to apply to the sprite's rotation. may be negative.
// SOURCE
void agk::SetSpritePhysicsAngularImpulse( uint32_t iSpriteIndex, float impulse )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return;
	}

	pSprite->SetPhysicsAngularImpulse( impulse );
}

//****f* Sprite/Physics/GetSpritePhysicsVelocityX
// FUNCTION
//   Returns the linear velocity of the sprite in the X direction. This is the number of units per second that the sprite
//   is currently moving in your chosen resolution.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
float agk::GetSpritePhysicsVelocityX( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetPhysicsVelocityX( );
}

//****f* Sprite/Physics/GetSpritePhysicsVelocityY
// FUNCTION
//   Returns the linear velocity of the sprite in the Y direction. This is the number of units per second that the sprite
//   is currently moving in your chosen resolution.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
float agk::GetSpritePhysicsVelocityY( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetPhysicsVelocityY( );
}

//****f* Sprite/Physics/GetSpritePhysicsAngularVelocity
// FUNCTION
//   Returns the angular velocity of the sprite in radians per second. This is the speed at which the sprite is currently 
//   rotating.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
float agk::GetSpritePhysicsAngularVelocity( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetPhysicsAngularVelocity( );
}

//****f* Sprite/Physics/GetSpritePhysicsMass
// FUNCTION
//   Returns the mass of the sprite in kilograms currently being used. This was either generated automatically when its 
//   shape was created or a shape was added, or was set manually.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to check.
// SOURCE
float agk::GetSpritePhysicsMass( uint32_t iSpriteIndex )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( pSprite->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 ); errStr.AppendUInt( iSpriteIndex );  errStr.Append( " is not setup for physics" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->GetPhysicsMass( );
}

//
// Joints
//

// this command gets called be AGK when a joint is about to be deleted by Box2D
void agk::ClearJoint( b2Joint *pDelJoint )
{
	int ID = (int)reinterpret_cast<long long>(pDelJoint->GetUserData());
	m_cJointList.RemoveItem( ID );
	// Box2D will handle the actual deletion of the pointer
}

/*
void agk::CreateJoint( uint32_t iSpriteIndex1, uint32_t iSpriteIndex2 )
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	b2RevoluteJointDef jointDef1;
	jointDef1.Initialize( pSprite2->m_phyBody, pSprite1->m_phyBody, b2Vec2( agk::WorldToPhyX(50),agk::WorldToPhyY(50) ) );
	jointDef1.enableMotor = true;
	jointDef1.motorSpeed = 1;
	jointDef1.maxMotorTorque = 100;
	b2Joint *pJoint1 = m_phyWorld->CreateJoint(&jointDef1);

	b2PrismaticJointDef jointDef2;
	jointDef2.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2( agk::WorldToPhyX(60),agk::WorldToPhyY(50) ), b2Vec2( 0,1 ) );
	b2Joint *pJoint2 = m_phyWorld->CreateJoint(&jointDef2);
		
	b2GearJointDef jointDef3;
	jointDef3.bodyA = pSprite1->m_phyBody;
	jointDef3.bodyB = pSprite2->m_phyBody;
	jointDef3.joint1 = pJoint1;
	jointDef3.joint2 = pJoint2;
	jointDef3.ratio = 2.0f;
		
	m_phyWorld->CreateJoint(&jointDef3);
}
*/

//****f* 2DPhysics/Joints/DeleteJoint
// FUNCTION
//   Deletes a joint and allows the connected sprites to move freely again. Joints should be deleted before sprites.
//   Gear joints should be deleted before the joints it depends on. Deleting a joint that does not exist will not cause
//   an error.
// INPUTS
//   iJointIndex -- The ID of the joint to delete.
// SOURCE
void agk::DeleteJoint( uint32_t iJointIndex )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.RemoveItem( iJointIndex );
	if ( pJoint )
	{
		m_phyWorld->DestroyJoint( pJoint );
	}
}

//****f* 2DPhysics/Joints/GetJointExists
// FUNCTION
//   Returns 1 if the specified joint still exists, 0 otherwise. Joints can be deleted by the system.
// INPUTS
//   iJointIndex -- The ID of the joint to check.
// SOURCE
int agk::GetJointExists( uint32_t iJointIndex )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint )
	{
		return 1;
	}

	return 0;
}


void agk::CreateDistanceJoint( uint32_t iJointIndex, cSprite *pSprite1, cSprite *pSprite2, float x, float y, float x2, float y2, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return;

	if ( iJointIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joint ID, must be greater than 0" );
#endif
		return;
	}

	b2Joint *pJoint = m_cJointList.GetItem( iJointIndex );
	if ( pJoint != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " already exists" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create distance joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create distance joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	b2DistanceJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)), b2Vec2(agk::WorldToPhyX(x2),agk::WorldToPhyY(y2)) );
	jointDef.collideConnected = colConnected>0;
	pJoint = m_phyWorld->CreateJoint( &jointDef );

	m_cJointList.AddItem( pJoint, iJointIndex );
	UINT_PTR index = iJointIndex;
	pJoint->SetUserData( (void*) index );
}

void agk::CreateRevoluteJoint( uint32_t iJointIndex, cSprite *pSprite1, cSprite *pSprite2, float x, float y, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return;

	if ( iJointIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joint ID, must be greater than 0" );
#endif
		return;
	}

	b2Joint *pJoint = m_cJointList.GetItem( iJointIndex );
	if ( pJoint != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " already exists" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create revolute joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create revolute joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	b2RevoluteJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)) );
	jointDef.collideConnected = colConnected>0;
	pJoint = m_phyWorld->CreateJoint( &jointDef );

	m_cJointList.AddItem( pJoint, iJointIndex );
    UINT_PTR index = iJointIndex;
	pJoint->SetUserData( (void*) index );
}

void agk::CreatePrismaticJoint( uint32_t iJointIndex, cSprite *pSprite1, cSprite *pSprite2, float x, float y, float vx, float vy, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return;

	if ( iJointIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joint ID, must be greater than 0" );
#endif
		return;
	}

	b2Joint *pJoint = m_cJointList.GetItem( iJointIndex );
	if ( pJoint != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " already exists" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create prismatic joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create prismatic joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	b2PrismaticJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)), b2Vec2(agk::WorldToPhyX(vx),agk::WorldToPhyY(vy)) );
	jointDef.collideConnected = colConnected>0;
	pJoint = m_phyWorld->CreateJoint( &jointDef );

	m_cJointList.AddItem( pJoint, iJointIndex );
	UINT_PTR index = iJointIndex;
	pJoint->SetUserData( (void*) index );
}

void agk::CreatePulleyJoint( uint32_t iJointIndex, cSprite *pSprite1, cSprite *pSprite2, float gnd1x, float gnd1y, float gnd2x, float gnd2y, float a1x, float a1y, float a2x, float a2y, float ratio, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return;

	if ( iJointIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joint ID, must be greater than 0" );
#endif
		return;
	}

	b2Joint *pJoint = m_cJointList.GetItem( iJointIndex );
	if ( pJoint != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " already exists" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create pulley joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create pulley joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	b2PulleyJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(gnd1x),agk::WorldToPhyY(gnd1y)), b2Vec2(agk::WorldToPhyX(gnd2x),agk::WorldToPhyY(gnd2y)), 
							b2Vec2(agk::WorldToPhyX(a1x),agk::WorldToPhyY(a1y)), b2Vec2(agk::WorldToPhyX(a2x),agk::WorldToPhyY(a2y)), ratio );
	jointDef.collideConnected = colConnected>0;
	pJoint = m_phyWorld->CreateJoint( &jointDef );

	m_cJointList.AddItem( pJoint, iJointIndex );
	UINT_PTR index = iJointIndex;
	pJoint->SetUserData( (void*) index );
}

void agk::CreateMouseJoint( uint32_t iJointIndex, cSprite *pSprite, float x, float y, float maxForce )
{
	if ( !pSprite ) return;

	if ( iJointIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joint ID, must be greater than 0" );
#endif
		return;
	}

	b2Joint *pJoint = m_cJointList.GetItem( iJointIndex );
	if ( pJoint != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " already exists" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create mouse joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	b2MouseJointDef jointDef;
	jointDef.bodyA = m_phyGroundBody;
	jointDef.bodyB = pSprite->m_phyBody;
	jointDef.maxForce = maxForce;
	jointDef.target.Set( agk::WorldToPhyX(x), agk::WorldToPhyY(y) );
	pJoint = m_phyWorld->CreateJoint( &jointDef );

	m_cJointList.AddItem( pJoint, iJointIndex );
	UINT_PTR index = iJointIndex;
	pJoint->SetUserData( (void*) index );
}

void agk::CreateLineJoint( uint32_t iJointIndex, cSprite *pSprite1, cSprite *pSprite2, float x, float y, float vx, float vy, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return;
		
	if ( iJointIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joint ID, must be greater than 0" );
#endif
		return;
	}

	b2Joint *pJoint = m_cJointList.GetItem( iJointIndex );
	if ( pJoint != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " already exists" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	b2WheelJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)), b2Vec2(agk::WorldToPhyX(vx),agk::WorldToPhyY(vy)) );
	jointDef.collideConnected = colConnected>0;
	pJoint = m_phyWorld->CreateJoint( &jointDef );

	m_cJointList.AddItem( pJoint, iJointIndex );
	UINT_PTR index = iJointIndex;
	pJoint->SetUserData( (void*) index );
}

void agk::CreateWeldJoint( uint32_t iJointIndex, cSprite *pSprite1, cSprite *pSprite2, float x, float y, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return;
		
	if ( iJointIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joint ID, must be greater than 0" );
#endif
		return;
	}

	b2Joint *pJoint = m_cJointList.GetItem( iJointIndex );
	if ( pJoint != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " already exists" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	b2WeldJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)) );
	jointDef.collideConnected = colConnected>0;
	pJoint = m_phyWorld->CreateJoint( &jointDef );

	m_cJointList.AddItem( pJoint, iJointIndex );
	UINT_PTR index = iJointIndex;
	pJoint->SetUserData( (void*) index );
}

void agk::CreateRopeJoint( uint32_t iJointIndex, cSprite *pSprite1, cSprite *pSprite2, float x, float y, float x2, float y2, float maxLength, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return;

	if ( iJointIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joint ID, must be greater than 0" );
#endif
		return;
	}

	b2Joint *pJoint = m_cJointList.GetItem( iJointIndex );
	if ( pJoint != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " already exists" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create rope joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create rope joint on sprite - sprite not set up for physics" ); agk::Error( errStr );
#endif
		return;
	}

	b2RopeJointDef jointDef;
	jointDef.bodyA = pSprite1->m_phyBody;
	jointDef.bodyB = pSprite2->m_phyBody;
	jointDef.localAnchorA = pSprite1->m_phyBody->GetLocalPoint(b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)));
	jointDef.localAnchorB = pSprite2->m_phyBody->GetLocalPoint(b2Vec2(agk::WorldToPhyX(x2),agk::WorldToPhyY(y2)));
	jointDef.collideConnected = colConnected>0;
	jointDef.maxLength = agk::WorldToPhyX( maxLength );
	pJoint = m_phyWorld->CreateJoint( &jointDef );

	m_cJointList.AddItem( pJoint, iJointIndex );
	UINT_PTR index = iJointIndex;
	pJoint->SetUserData( (void*) index );
}



uint32_t agk::CreateDistanceJoint( cSprite *pSprite1, cSprite *pSprite2, float x, float y, float x2, float y2, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return 0;

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create distance joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create distance joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	b2DistanceJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)), b2Vec2(agk::WorldToPhyX(x2),agk::WorldToPhyY(y2)) );
	jointDef.collideConnected = colConnected>0;
	b2Joint* pJoint = m_phyWorld->CreateJoint( &jointDef );

	uint32_t iID = m_cJointList.GetFreeID();
	m_cJointList.AddItem( pJoint, iID );
	UINT_PTR index = iID;
	pJoint->SetUserData( (void*) index );
	return iID;
}

uint32_t agk::CreateRevoluteJoint( cSprite *pSprite1, cSprite *pSprite2, float x, float y, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return 0;

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create revolute joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create revolute joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	b2RevoluteJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)) );
	jointDef.collideConnected = colConnected>0;
	b2Joint* pJoint = m_phyWorld->CreateJoint( &jointDef );

	uint32_t iID = m_cJointList.GetFreeID();
	m_cJointList.AddItem( pJoint, iID );
	UINT_PTR index = iID;
	pJoint->SetUserData( (void*) index );
	return iID;
}

uint32_t agk::CreatePrismaticJoint( cSprite *pSprite1, cSprite *pSprite2, float x, float y, float vx, float vy, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return 0;

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create prismatic joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create prismatic joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	b2PrismaticJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)), b2Vec2(agk::WorldToPhyX(vx),agk::WorldToPhyY(vy)) );
	jointDef.collideConnected = colConnected>0;
	b2Joint* pJoint = m_phyWorld->CreateJoint( &jointDef );

	uint32_t iID = m_cJointList.GetFreeID();
	m_cJointList.AddItem( pJoint, iID );
	UINT_PTR index = iID;
	pJoint->SetUserData( (void*) index );
	return iID;
}

uint32_t agk::CreatePulleyJoint( cSprite *pSprite1, cSprite *pSprite2, float gnd1x, float gnd1y, float gnd2x, float gnd2y, float a1x, float a1y, float a2x, float a2y, float ratio, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return 0;

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create pulley joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create pulley joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	b2PulleyJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(gnd1x),agk::WorldToPhyY(gnd1y)), b2Vec2(agk::WorldToPhyX(gnd2x),agk::WorldToPhyY(gnd2y)), 
							b2Vec2(agk::WorldToPhyX(a1x),agk::WorldToPhyY(a1y)), b2Vec2(agk::WorldToPhyX(a2x),agk::WorldToPhyY(a2y)), ratio );
	jointDef.collideConnected = colConnected>0;
	b2Joint* pJoint = m_phyWorld->CreateJoint( &jointDef );

	uint32_t iID = m_cJointList.GetFreeID();
	m_cJointList.AddItem( pJoint, iID );
	UINT_PTR index = iID;
	pJoint->SetUserData( (void*) index );
	return iID;
}

uint32_t agk::CreateMouseJoint( cSprite *pSprite, float x, float y, float maxForce )
{
	if ( !pSprite ) return 0;

	if ( !pSprite->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create mouse joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	b2MouseJointDef jointDef;
	jointDef.bodyA = m_phyGroundBody;
	jointDef.bodyB = pSprite->m_phyBody;
	jointDef.maxForce = maxForce;
	jointDef.target.Set( agk::WorldToPhyX(x), agk::WorldToPhyY(y) );
	b2Joint* pJoint = m_phyWorld->CreateJoint( &jointDef );

	uint32_t iID = m_cJointList.GetFreeID();
	m_cJointList.AddItem( pJoint, iID );
	UINT_PTR index = iID;
	pJoint->SetUserData( (void*) index );
	return iID;
}

uint32_t agk::CreateLineJoint( cSprite *pSprite1, cSprite *pSprite2, float x, float y, float vx, float vy, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return 0;
		
	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	b2WheelJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)), b2Vec2(agk::WorldToPhyX(vx),agk::WorldToPhyY(vy)) );
	jointDef.collideConnected = colConnected>0;
	b2Joint* pJoint = m_phyWorld->CreateJoint( &jointDef );

	uint32_t iID = m_cJointList.GetFreeID();
	m_cJointList.AddItem( pJoint, iID );
	UINT_PTR index = iID;
	pJoint->SetUserData( (void*) index );
	return iID;
}

uint32_t agk::CreateWeldJoint( cSprite *pSprite1, cSprite *pSprite2, float x, float y, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return 0;
		
	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	b2WeldJointDef jointDef;
	jointDef.Initialize( pSprite1->m_phyBody, pSprite2->m_phyBody, b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)) );
	jointDef.collideConnected = colConnected>0;
	b2Joint* pJoint = m_phyWorld->CreateJoint( &jointDef );

	uint32_t iID = m_cJointList.GetFreeID();
	m_cJointList.AddItem( pJoint, iID );
	UINT_PTR index = iID;
	pJoint->SetUserData( (void*) index );
	return iID;
}

uint32_t agk::CreateRopeJoint( cSprite *pSprite1, cSprite *pSprite2, float x, float y, float x2, float y2, float maxLength, int colConnected )
{
	if ( !pSprite1 || !pSprite2 ) return 0;

	if ( !pSprite1->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create rope joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pSprite2->m_phyBody ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create rope joint on sprite - sprite not set up for physics" );
		Error( errStr );
#endif
		return 0;
	}

	b2RopeJointDef jointDef;
	jointDef.bodyA = pSprite1->m_phyBody;
	jointDef.bodyB = pSprite2->m_phyBody;
	jointDef.localAnchorA = pSprite1->m_phyBody->GetLocalPoint(b2Vec2(agk::WorldToPhyX(x),agk::WorldToPhyY(y)));
	jointDef.localAnchorB = pSprite2->m_phyBody->GetLocalPoint(b2Vec2(agk::WorldToPhyX(x2),agk::WorldToPhyY(y2)));
	jointDef.collideConnected = colConnected>0;
	jointDef.maxLength = agk::WorldToPhyX( maxLength );
	b2Joint* pJoint = m_phyWorld->CreateJoint( &jointDef );

	uint32_t iID = m_cJointList.GetFreeID();
	m_cJointList.AddItem( pJoint, iID );
	UINT_PTR index = iID;
	pJoint->SetUserData( (void*) index );
	return iID;
}
	
//****f* 2DPhysics/Joints/CreateDistanceJoint
// FUNCTION
//   Creates a distance joint between two sprites. The distance joint keeps the sprites a certain distance apart whilst
//   being allowed to rotate freely around the anchor points. Specify two anchor points in world coordinates with the 
//   sprites already at the desired distance apart. The anchor points can be offset from the sprite positions.
//   A joint may be deleted by the system if any of the sprites it connects are deleted.
// INPUTS
//   iJointIndex -- The ID to use for this joint.
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the sprite 1 anchor point.
//   y -- The y coordinate of the sprite 1 anchor point.
//   x2 -- The x coordinate of the sprite 2 anchor point.
//   y2 -- The y coordinate of the sprite 2 anchor point.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
void agk::CreateDistanceJoint( uint32_t iJointIndex, uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, float x2, float y2, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
		
	CreateDistanceJoint( iJointIndex, pSprite1, pSprite2, x,y, x2,y2, colConnected );
}

//****f* 2DPhysics/Joints/CreateRevoluteJoint
// FUNCTION
//   Creates a revolute joint between two sprites. The revolute joint allows the sprites to only rotate around the given point. 
//   Specify a single anchor point in world coordinates with the sprites already at the desired relative position. 
//   The anchor point can be offset from the sprite center positions.<br><br>
//   A joint may be deleted by the system if any of the sprites it connects are deleted.<br><br>
//   This joint supports motors and limits.
// INPUTS
//   iJointIndex -- The ID to use for this joint.
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the anchor point.
//   y -- The y coordinate of the anchor point.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
void agk::CreateRevoluteJoint( uint32_t iJointIndex, uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
		
	CreateRevoluteJoint( iJointIndex, pSprite1, pSprite2, x, y, colConnected>0 );
}
	
//****f* 2DPhysics/Joints/CreatePrismaticJoint
// FUNCTION
//   Creates a prismatic joint between two sprites. The prismatic joint allows the sprites to only move along a given axis relative to each other. 
//   It can be thought of as a piston with the sprites unable to rotate at each end. It is similar to a line joint except that relative rotation
//   is prevented. Specify a single anchor point in world coordinates with the sprites already at the desired relative position, at the piston's 
//   minimal extent. From this point the sprites will be allowed to separate along the given axis and rotate as a whole, but not rotate relative 
//   to each other. The anchor point can be offset from the sprite center positions.<br><br>
//   A joint may be deleted by the system if any of the sprites it connects are deleted.<br><br>
//   This joint supports motors and limits.
// INPUTS
//   iJointIndex -- The ID to use for this joint.
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the anchor point.
//   y -- The y coordinate of the anchor point.
//   vx -- The x component of the axis.
//   vy -- The y component of the axis.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
void agk::CreatePrismaticJoint( uint32_t iJointIndex, uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, float vx, float vy, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}

	CreatePrismaticJoint( iJointIndex, pSprite1, pSprite2, x,y, vx,vy, colConnected );
}
	
//****f* 2DPhysics/Joints/CreatePulleyJoint
// FUNCTION
//   Creates a pulley joint between two sprites. The anchor points are world space coordinates that attach the joint to the sprite,
//   the anchor points do not have to be on the sprite's center, or anywhere near the sprite, but this point will become the new
//   center of rotation for the time the sprite is attached to the pulley. The ground points are where the pulley rope will attach
//   to the imaginary pulleys, and will remain fixed for the life of the joint, they need not be in the same location. The ratio
//   value determines the gear ratio between the two sides of the pulley, for example a value of 2 would mean that sprite 1 moves
//   at twice the speed of sprite 2, but will experience half the force applied to sprite 2.
// INPUTS
//   iJointIndex -- The ID to use for this joint.
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   gnd1x -- The x coordinate of the ground point for sprite 1.
//   gnd1y -- The y coordinate of the ground point for sprite 1.
//   gnd2x -- The x coordinate of the ground point for sprite 2.
//   gnd2y -- The y coordinate of the ground point for sprite 2.
//   a1x -- The x coordinate of the anchor point for sprite 1.
//   a1y -- The y coordinate of the anchor point for sprite 1.
//   a2x -- The x coordinate of the anchor point for sprite 2.
//   a2y -- The y coordinate of the anchor point for sprite 2.
//   ratio -- The ratio between the two sides of the pulley.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
void agk::CreatePulleyJoint( uint32_t iJointIndex, uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float gnd1x, float gnd1y, float gnd2x, float gnd2y, float a1x, float a1y, float a2x, float a2y, float ratio, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}

	CreatePulleyJoint( iJointIndex, pSprite1, pSprite2, gnd1x, gnd1y, gnd2x, gnd2y, a1x, a1y, a2x, a2y, ratio, colConnected );
}
	
//****f* 2DPhysics/Joints/CreateMouseJoint
// FUNCTION
//   Creates a mouse joint between a point and a sprite. This is typically used when dragging a shape with the mouse pointer,
//   and attempts to move the sprite towards the given point using a force up to the maximum given. Specify an anchor point in 
//   world coordinates that will act as the initial hold point on the sprite. Any further change in the target position will 
//   attempt to move that point of the sprite to the new location. Use <i>SetJointMouseTarget</i> to change the location of the target 
//   position.
// INPUTS
//   iJointIndex -- The ID to use for this joint.
//   iSpriteIndex -- The ID of the sprite to move.
//   x -- The x coordinate of the initial anchor point on the sprite.
//   y -- The y coordinate of the initial anchor point on the sprite.
//   maxForce -- The maximum force the joint can use to move the sprite.
// SOURCE
void agk::CreateMouseJoint( uint32_t iJointIndex, uint32_t iSpriteIndex, float x, float y, float maxForce )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}

	CreateMouseJoint( iJointIndex, pSprite, x, y, maxForce );
}
	
//****f* 2DPhysics/Joints/CreateLineJoint
// FUNCTION
//   Creates a line joint between two sprites. The line joint allows the sprites to only move along a given axis relative to each other 
//   whilst rotating freely at either end. It is similar to a prismatic joint except that relative rotation is allowed.
//   Specify a single anchor point in world coordinates with the sprites already at the desired relative position, at the piston's minimal extent.
//   From this point the sprites will be allowed to separate along the given axis relative to one another.<br>
//   The anchor point can be offset from the sprite center positions.
//   A joint may be deleted by the system if any of the sprites it connects are deleted.
//   This joint supports motors but not limits.
//   Box2D has renamed this joint the Wheel Joint and it now contains a spring component to simulate a vehicle wheel. The AGK command name
//   will remain the same for backwards compatibility, however the functionality may have changed.
// INPUTS
//   iJointIndex -- The ID to use for this joint.
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the anchor point.
//   y -- The y coordinate of the anchor point.
//   vx -- The x component of the axis.
//   vy -- The y component of the axis.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
void agk::CreateLineJoint( uint32_t iJointIndex, uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, float vx, float vy, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}

	CreateLineJoint( iJointIndex, pSprite1, pSprite2, x, y, vx, vy, colConnected );
}
	
//****f* 2DPhysics/Joints/CreateWeldJoint
// FUNCTION
//   Creates a weld joint between two sprites. The weld joint attempts to limit all relative movement and rotation between
//   the two sprites. Specify a single anchor point in world coordinates with the sprites already in the desired positions.
//   The joint is not a perfect fixture and given a large enough force the sprites may shift out of position. 
//   The anchor point can be offset from the sprite center positions.<br><br>
//   A joint may be deleted by the system if any of the sprites it connects are deleted.
// INPUTS
//   iJointIndex -- The ID to use for this joint.
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the anchor point.
//   y -- The y coordinate of the anchor point.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
void agk::CreateWeldJoint( uint32_t iJointIndex, uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" );	agk::Error( errStr );
#endif
		return;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" );	agk::Error( errStr );
#endif
		return;
	}

	CreateWeldJoint( iJointIndex, pSprite1, pSprite2, x, y, colConnected );
}

//****f* 2DPhysics/Joints/CreateRopeJoint
// FUNCTION
//   Creates a rope joint between two sprites. The rope joint enforces a maximum distance between the sprites 
//   without any other restrictions. It does not stop them getting closer together.
//   Specify two anchor points in world coordinates with the maximum length you want to allow, the current position
//   of the sprites does not affect the initialisation of the joint.  
//   The anchor points can be offset from the sprite positions.
//   A joint may be deleted by the system if any of the sprites it connects are deleted.
// INPUTS
//   iJointIndex -- The ID to use for this joint.
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the sprite 1 anchor point.
//   y -- The y coordinate of the sprite 1 anchor point.
//   x2 -- The x coordinate of the sprite 2 anchor point.
//   y2 -- The y coordinate of the sprite 2 anchor point.
//   maxLength -- The maximum length allowed between the sprite anchor points.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
void agk::CreateRopeJoint( uint32_t iJointIndex, uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, float x2, float y2, float maxLength, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
		
	CreateRopeJoint( iJointIndex, pSprite1, pSprite2, x,y, x2,y2, maxLength, colConnected );
}

//****f* 2DPhysics/Joints/CreateGearJoint
// FUNCTION
//   Creates a gear joint between two existing joints. The gear joint allows appearance of two existing joints to be locked together in
//   perfect friction. The sprites that will be joined will be sprite 2 on both joints, sprite 1 on both joints must be a static sprite.
//   A joint may be deleted by the system if any of the sprites it connects are deleted. This joint should be deleted before any of the 
//   joints it depends on are deleted.
// INPUTS
//   iJointIndex -- The ID for the gear joint.
//   iJoint1 -- The ID of the first joint to join.
//   iJoint2 -- The ID of the second joint to join.
//   ratio -- The gear ratio to use in moving one joint from the other.
// SOURCE
void agk::CreateGearJoint( uint32_t iJointIndex, uint32_t iJoint1, uint32_t iJoint2, float ratio )
//****
{
	if ( iJointIndex == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joint ID, must be greater than 0" );
#endif
		return;
	}

	b2Joint *pJoint = m_cJointList.GetItem( iJointIndex );
	if ( pJoint != 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " already exists" );	agk::Error( errStr );
#endif
		return;
	}

	b2Joint *pJoint1 = (b2Joint*)m_cJointList.GetItem( iJoint1 );
	if ( pJoint1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJoint1 );  errStr.Append( " does not exist" );	agk::Error( errStr );
#endif
		return;
	}
	if ( !pJoint1->GetBodyB() ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create gear joint, could not get body for joint ", 50 ); errStr.AppendInt( iJoint1 ); agk::Error( errStr );
#endif
		return;
	}

	b2Joint *pJoint2 = (b2Joint*)m_cJointList.GetItem( iJoint2 );
	if ( pJoint2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJoint2 );  errStr.Append( " does not exist" ); agk::Error( errStr );
#endif
		return;
	}
	if ( !pJoint2->GetBodyB() ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create gear joint, could not get body for joint ", 50 ); errStr.AppendInt( iJoint2 ); agk::Error( errStr );
#endif
		return;
	}

	b2GearJointDef jointDef;
	jointDef.bodyA = pJoint1->GetBodyB();
	jointDef.bodyB = pJoint2->GetBodyB();
	jointDef.joint1 = pJoint1;
	jointDef.joint2 = pJoint2;
	jointDef.ratio = ratio;
	pJoint = m_phyWorld->CreateJoint( &jointDef );

	m_cJointList.AddItem( pJoint, iJointIndex );
	UINT_PTR index = iJointIndex;
	pJoint->SetUserData( (void*) index );
}









//****f* 2DPhysics/Joints/CreateDistanceJoint
// FUNCTION
//   Creates a distance joint between two sprites. The distance joint keeps the sprites a certain distance apart whilst
//   being allowed to rotate freely around the anchor points. Specify two anchor points in world coordinates with the 
//   sprites already at the desired distance apart. The anchor points can be offset from the sprite positions.
//   A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the sprites
//   it connects are deleted.
// INPUTS
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the sprite 1 anchor point.
//   y -- The y coordinate of the sprite 1 anchor point.
//   x2 -- The x coordinate of the sprite 2 anchor point.
//   y2 -- The y coordinate of the sprite 2 anchor point.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
uint32_t agk::CreateDistanceJoint( uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, float x2, float y2, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return CreateDistanceJoint( pSprite1, pSprite2, x,y, x2,y2, colConnected );
}

//****f* 2DPhysics/Joints/CreateRevoluteJoint
// FUNCTION
//   Creates a revolute joint between two sprites. The revolute joint allows the sprites to only rotate around the given point. 
//   Specify a single anchor point in world coordinates with the sprites already at the desired relative position. 
//   The anchor point can be offset from the sprite center positions.<br><br>
//   A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the sprites
//   it connects are deleted.<br><br>
//   This joint supports motors and limits.
// INPUTS
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the anchor point.
//   y -- The y coordinate of the anchor point.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
uint32_t agk::CreateRevoluteJoint( uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return CreateRevoluteJoint( pSprite1, pSprite2, x, y, colConnected>0 );
}
	
//****f* 2DPhysics/Joints/CreatePrismaticJoint
// FUNCTION
//   Creates a prismatic joint between two sprites. The prismatic joint allows the sprites to only move along a given axis relative to each other. 
//   It can be thought of as a piston with the sprites unable to rotate at each end. It is similar to a line joint except that relative rotation
//   is prevented. Specify a single anchor point in world coordinates with the sprites already at the desired relative position, at the piston's 
//   minimal extent. From this point the sprites will be allowed to separate along the given axis and rotate as a whole, but not rotate relative 
//   to each other. The anchor point can be offset from the sprite center positions.<br><br>
//   A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the sprites
//   it connects are deleted.<br><br>
//   This joint supports motors and limits.
// INPUTS
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the anchor point.
//   y -- The y coordinate of the anchor point.
//   vx -- The x component of the axis.
//   vy -- The y component of the axis.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
uint32_t agk::CreatePrismaticJoint( uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, float vx, float vy, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return CreatePrismaticJoint( pSprite1, pSprite2, x,y, vx,vy, colConnected );
}
	
	
uint32_t agk::CreatePulleyJoint( uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float gnd1x, float gnd1y, float gnd2x, float gnd2y, float a1x, float a1y, float a2x, float a2y, float ratio, int colConnected )
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return CreatePulleyJoint( pSprite1, pSprite2, gnd1x, gnd1y, gnd2x, gnd2y, a1x, a1y, a2x, a2y, ratio, colConnected );
}

//****f* 2DPhysics/Joints/CreatePulleyJoint2
// FUNCTION
//   Creates a pulley joint between two sprites. This the first half of a two command setup. Due to the number of parameters required
//   you must call <i>FinishPulleyJoint</i> with the rest of the parameters to create the joint. This command returns nothing,
//   the joint ID is returned by <i>FinishPulleyJoint</i>.
// INPUTS
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   ratio -- The ratio between the two sides of the pulley.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
void agk::CreatePulleyJoint2( uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float ratio, int colConnected )
//****
{
	m_iPulleySprite1 = iSpriteIndex1;
	m_iPulleySprite2 = iSpriteIndex2;
	m_iPulleyRatio = ratio;
	m_iPulleyColConnected = colConnected;
}

//****f* 2DPhysics/Joints/FinishPulleyJoint
// FUNCTION
//   Creates a pulley joint between two sprites. This the second half of a two command setup. Due to the number of parameters required
//   you must call <i>CreatePulleyJoint2</i> first with the initial set of parameters to create the joint. This command returns the 
//   ID of the new joint.
// INPUTS
//   gnd1x -- The x coordinate of the first ground point
//   gnd1y -- The y coordinate of the first ground point
//   gnd2x -- The x coordinate of the second ground point
//   gnd2y -- The y coordinate of the second ground point
//   a1x -- The x coordinate of the first anchor point
//   a1y -- The y coordinate of the first anchor point
//   a2x -- The x coordinate of the second anchor point
//   a2y -- The y coordinate of the second anchor point
// SOURCE
uint32_t agk::FinishPulleyJoint( float gnd1x, float gnd1y, float gnd2x, float gnd2y, float a1x, float a1y, float a2x, float a2y )
//****
{
	if ( m_iPulleySprite1 == 0 && m_iPulleySprite2 == 0 && m_iPulleyRatio == 0 && m_iPulleyColConnected == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "You must call CreatePulleyJoint2 before calling FinishPulleyJoint" );
		Error( errStr );
#endif
		return 0;
	}

	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( m_iPulleySprite1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( m_iPulleySprite1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( m_iPulleySprite2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( m_iPulleySprite2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	uint32_t jointID = CreatePulleyJoint( pSprite1, pSprite2, gnd1x, gnd1y, gnd2x, gnd2y, a1x, a1y, a2x, a2y, m_iPulleyRatio, m_iPulleyColConnected );
	m_iPulleySprite1 = 0;
	m_iPulleySprite2 = 0;
	m_iPulleyRatio = 0;
	m_iPulleyColConnected = 0;

	return jointID;
}
	
//****f* 2DPhysics/Joints/CreateMouseJoint
// FUNCTION
//   Creates a mouse joint between a point and a sprite. This is typically used when dragging a shape with the mouse pointer,
//   and attempts to move the sprite towards the given point using a force up to the maximum given. Specify an anchor point in 
//   world coordinates that will act as the initial hold point on the sprite. Any further change in the target position will 
//   attempt to move that point of the sprite to the new location. Use <i>SetJointMouseTarget</i> to change the location of the target 
//   position.
// INPUTS
//   iSpriteIndex -- The ID of the sprite to move.
//   x -- The x coordinate of the initial anchor point on the sprite.
//   y -- The y coordinate of the initial anchor point on the sprite.
//   maxForce -- The maximum force the joint can use to move the sprite.
// SOURCE
uint32_t agk::CreateMouseJoint( uint32_t iSpriteIndex, float x, float y, float maxForce )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return CreateMouseJoint( pSprite, x, y, maxForce );
}
	
//****f* 2DPhysics/Joints/CreateLineJoint
// FUNCTION
//   Creates a line joint between two sprites. The line joint allows the sprites to only move along a given axis relative to each other 
//   whilst rotating freely at either end. It is similar to a prismatic joint except that relative rotation is allowed.<br><br>
//   Specify a single anchor point in world coordinates with the sprites already at the desired relative position, at the piston's minimal extent.
//   From this point the sprites will be allowed to separate along the given axis relative to one another.
//   The anchor point can be offset from the sprite center positions.
//   A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the sprites
//   it connects are deleted.
//   This joint supports motors and limits.
//   Box2D has renamed this joint the Wheel Joint and it now contains a spring component to simulate a vehicle wheel. The AGK command name
//   will remain the same for backwards compatibility, however the functionality may have changed
// INPUTS
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the anchor point.
//   y -- The y coordinate of the anchor point.
//   vx -- The x component of the axis.
//   vy -- The y component of the axis.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
uint32_t agk::CreateLineJoint( uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, float vx, float vy, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return CreateLineJoint( pSprite1, pSprite2, x, y, vx, vy, colConnected );
}
	
//****f* 2DPhysics/Joints/CreateWeldJoint
// FUNCTION
//   Creates a weld joint between two sprites. The weld joint attempts to limit all relative movement and rotation between
//   the two sprites. Specify a single anchor point in world coordinates with the sprites already in the desired positions.
//   The joint is not a perfect fixture and given a large enough force the sprites may shift out of position. <br><br>
//   The anchor point can be offset from the sprite center positions.<br><br>
//   A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the sprites
//   it connects are deleted.
// INPUTS
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the anchor point.
//   y -- The y coordinate of the anchor point.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
uint32_t agk::CreateWeldJoint( uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return CreateWeldJoint( pSprite1, pSprite2, x, y, colConnected );
}

//****f* 2DPhysics/Joints/CreateRopeJoint
// FUNCTION
//   Creates a rope joint between two sprites. The rope joint enforces a maximum distance between the sprites 
//   without any other restrictions. It does not stop them getting closer together.
//   Specify two anchor points in world coordinates with the maximum length you want to allow, the current position
//   of the sprites does not affect the initialisation of the joint. 
//   The anchor points can be offset from the sprite positions.
//   A joint may be deleted by the system if any of the sprites it connects are deleted.
// INPUTS
//   iSpriteIndex1 -- The ID of the first sprite to join.
//   iSpriteIndex2 -- The ID of the second sprite to join.
//   x -- The x coordinate of the sprite 1 anchor point.
//   y -- The y coordinate of the sprite 1 anchor point.
//   x2 -- The x coordinate of the sprite 2 anchor point.
//   y2 -- The y coordinate of the sprite 2 anchor point.
//   maxLength -- The maximum length allowed between the sprite anchor points.
//   colConnected -- Set whether the two sprites connected by the joint can collide with one another, 0=no, 1=yes.
// SOURCE
uint32_t agk::CreateRopeJoint( uint32_t iSpriteIndex1, uint32_t iSpriteIndex2, float x, float y, float x2, float y2, float maxLength, int colConnected )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
		
	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSpriteIndex2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( iSpriteIndex2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return CreateRopeJoint( pSprite1, pSprite2, x,y, x2,y2, maxLength, colConnected );
}

//****f* 2DPhysics/Joints/CreateGearJoint
// FUNCTION
//   Creates a gear joint between two existing joints. The gear joint allows appearance of two existing joints to be locked together in
//   perfect friction. The sprites that will be joined will be sprite 2 on both joints, sprite 1 on both joints must be a static sprite.
//   A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the sprites
//   it connects are deleted. This joint should be deleted before any of the joints it depends on are deleted.
// INPUTS
//   iJoint1 -- The ID of the first joint to join.
//   iJoint2 -- The ID of the second joint to join.
//   ratio -- The gear ratio to use in moving one joint from the other.
// SOURCE
uint32_t agk::CreateGearJoint( uint32_t iJoint1, uint32_t iJoint2, float ratio )
//****
{
	b2Joint *pJoint1 = (b2Joint*)m_cJointList.GetItem( iJoint1 );
	if ( pJoint1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJoint1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
	if ( !pJoint1->GetBodyB() ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create gear joint, could not get body for joint ", 50 ); errStr.AppendInt( iJoint1 );
		Error( errStr );
#endif
		return 0;
	}

	b2Joint *pJoint2 = (b2Joint*)m_cJointList.GetItem( iJoint2 );
	if ( pJoint2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJoint2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
	if ( !pJoint2->GetBodyB() ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create gear joint, could not get body for joint ", 50 ); errStr.AppendInt( iJoint2 );
		Error( errStr );
#endif
		return 0;
	}

	b2GearJointDef jointDef;
	jointDef.bodyA = pJoint1->GetBodyB();
	jointDef.bodyB = pJoint2->GetBodyB();
	jointDef.joint1 = pJoint1;
	jointDef.joint2 = pJoint2;
	jointDef.ratio = ratio;
	b2Joint* pJoint = m_phyWorld->CreateJoint( &jointDef );

	uint32_t iID = m_cJointList.GetFreeID();
	m_cJointList.AddItem( pJoint, iID );
	UINT_PTR index = iID;
	pJoint->SetUserData( (void*) index );
	return iID;
}
	
//****f* 2DPhysics/Joints/SetJointLimitOn
// FUNCTION
//   Works on Prismatic joints and Revolute joints. Sets the limit that this joint can reach before stopping,
//   for revolute joints this is based on angles, for the others it is on length.<br><br>
//   By default a joint does not have limits.
// INPUTS
//   iJointIndex -- The ID of the joint to modify.
//   lowerLimit -- The smallest extent that the joint can reach.
//   upperLimit -- The greatest extent that the joint can reach.
// SOURCE
void agk::SetJointLimitOn( uint32_t iJointIndex, float lowerLimit, float upperLimit )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	switch( pJoint->GetType() )
	{
		/*
		case e_wheelJoint:
		{
			b2WheelJoint *pLineJoint = (b2WheelJoint*)pJoint;
			pLineJoint->EnableLimit( true );
			pLineJoint->SetLimits( lowerLimit, upperLimit );
			break;
		}
		*/
		case e_prismaticJoint:
		{
			b2PrismaticJoint *pPrismaticJoint = (b2PrismaticJoint*)pJoint;
			pPrismaticJoint->EnableLimit( true );
			pPrismaticJoint->SetLimits( lowerLimit, upperLimit );
			break;
		}
		case e_revoluteJoint:
		{
			b2RevoluteJoint *pRevoluteJoint = (b2RevoluteJoint*)pJoint;
			pRevoluteJoint->EnableLimit( true );
			pRevoluteJoint->SetLimits( lowerLimit, upperLimit );
			break;
		}
		default:
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Attempted to set joint limit on a joint that doesn't support limits ID:", 50 );  errStr.AppendInt( iJointIndex );
			Error( errStr );
#endif
			return;
		}
	}
}

//****f* 2DPhysics/Joints/SetJointLimitOff
// FUNCTION
//   Turns off limits for joints that support them. Works on Prismatic joints and Revolute joints.
// INPUTS
//   iJointIndex -- The ID of the joint to modify.
// SOURCE
void agk::SetJointLimitOff( uint32_t iJointIndex )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	switch( pJoint->GetType() )
	{
		/*
		case e_wheelJoint:
		{
			b2WheelJoint *pLineJoint = (b2WheelJoint*)pJoint;
			pLineJoint->EnableLimit( false );
			break;
		}
		*/
		case e_prismaticJoint:
		{
			b2PrismaticJoint *pPrismaticJoint = (b2PrismaticJoint*)pJoint;
			pPrismaticJoint->EnableLimit( false );
			break;
		}
		case e_revoluteJoint:
		{
			b2RevoluteJoint *pRevoluteJoint = (b2RevoluteJoint*)pJoint;
			pRevoluteJoint->EnableLimit( false );
		}
		default:
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Attempted to remove joint limit on a joint that doesn't support limits ID:", 50 );  errStr.AppendInt( iJointIndex );
			Error( errStr );
#endif
			return;
		}
	}
}

//****f* 2DPhysics/Joints/SetJointMotorOn
// FUNCTION
//   Turns on a motor for the joint so that it moves continuously until prevented by a collision. Works on Line/Wheel 
//   joints, Prismatic joints, and Revolute joints. Motors work by applying a force to achieve a set speed, if
//   they meet resistance they increase the force until either the motor is moving at the desired speed or 
//   the maximum force specified is reached, at which point the motor will stop, continuing to apply the maximum
//   force. In the case of linear joints the motor applies in one direction and either pushes the attached sprites
//   together or apart.
// INPUTS
//   iJointIndex -- The ID of the joint to modify.
//   speed -- The desired speed of the motor.
//   maxForce -- The max force it can use to achieve the speed.
// SOURCE
void agk::SetJointMotorOn( uint32_t iJointIndex, float speed, float maxForce )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	switch( pJoint->GetType() )
	{
		case e_wheelJoint:
		{
			b2WheelJoint *pLineJoint = (b2WheelJoint*)pJoint;
			pLineJoint->EnableMotor( true );
			pLineJoint->SetMaxMotorTorque( maxForce );
			pLineJoint->SetMotorSpeed( speed );
			break;
		}
		case e_prismaticJoint:
		{
			b2PrismaticJoint *pPrismaticJoint = (b2PrismaticJoint*)pJoint;
			pPrismaticJoint->EnableMotor( true );
			pPrismaticJoint->SetMaxMotorForce( maxForce );
			pPrismaticJoint->SetMotorSpeed( speed );
			break;
		}
		case e_revoluteJoint:
		{
			b2RevoluteJoint *pRevoluteJoint = (b2RevoluteJoint*)pJoint;
			pRevoluteJoint->EnableMotor( true );
			pRevoluteJoint->SetMaxMotorTorque( maxForce );
			pRevoluteJoint->SetMotorSpeed( speed );
			break;
		}
		default:
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Attempted to set joint motor on a joint that doesn't support motors, ID:", 50 );  errStr.AppendInt( iJointIndex );
			Error( errStr );
#endif
			return;
		}
	}
}

//****f* 2DPhysics/Joints/SetJointMotorOff
// FUNCTION
//   Turns off a motor previously applied to a joint that supports it. Works on Line 
//   joints, Prismatic joints, and Revolute joints.
// INPUTS
//   iJointIndex -- The ID of the joint to modify.
// SOURCE
void agk::SetJointMotorOff( uint32_t iJointIndex )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	switch( pJoint->GetType() )
	{
		case e_wheelJoint:
		{
			b2WheelJoint *pLineJoint = (b2WheelJoint*)pJoint;
			pLineJoint->EnableMotor( false );
			break;
		}
		case e_prismaticJoint:
		{
			b2PrismaticJoint *pPrismaticJoint = (b2PrismaticJoint*)pJoint;
			pPrismaticJoint->EnableMotor( false );
			break;
		}
		case e_revoluteJoint:
		{
			b2RevoluteJoint *pRevoluteJoint = (b2RevoluteJoint*)pJoint;
			pRevoluteJoint->EnableMotor( false );
			break;
		}
		default:
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Attempted to remove joint motor on a joint that doesn't support motors ID:", 50 );  errStr.AppendInt( iJointIndex );
			Error( errStr );
#endif
			return;
		}
	}
}

//****f* 2DPhysics/Joints/SetJointMouseTarget
// FUNCTION
//   Sets the target point in world coordinates that the mouse joint will attempt to move the attached body towards. Only works
//   on Mouse joints.
// INPUTS
//   iJointIndex -- The ID of the joint to modify.
//   x -- The x coordinate of the new target.
//   y -- The y coordinate of the new target.
// SOURCE
void agk::SetJointMouseTarget( uint32_t iJointIndex, float x, float y )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}
		
	if ( pJoint->GetType() != e_mouseJoint ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Attempted to set mouse target on a non-mouse joint ID:", 50 );  errStr.AppendInt( iJointIndex );
		Error( errStr );
#endif
		return;
	}

	b2MouseJoint *pMouseJoint = (b2MouseJoint*) pJoint;
	pMouseJoint->SetTarget( b2Vec2(agk::WorldToPhyX(x), agk::WorldToPhyY(y)) );
}

//****f* 2DPhysics/Joints/SetJointMouseMaxForce
// FUNCTION
//   Sets the maximum force that can be used by the mouse joint to move an object. By default this is set to 0
// INPUTS
//   iJointIndex -- The ID of the joint to modify.
//   maxForce -- The maximum force to allow.
// SOURCE
void agk::SetJointMouseMaxForce( uint32_t iJointIndex, float maxForce )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}
		
	if ( pJoint->GetType() != e_mouseJoint ) 
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Attempted to set mouse max force on a non-mouse joint ID:", 50 );  errStr.AppendInt( iJointIndex );
		Error( errStr );
#endif
		return;
	}

	b2MouseJoint *pMouseJoint = (b2MouseJoint*) pJoint;
	pMouseJoint->SetMaxForce( maxForce );
}

//****f* 2DPhysics/Joints/GetJointReactionForceX
// FUNCTION
//   Returns the amount of force applied to the joint in the X direction in the last time step. You can use this 
//   to detect large forces and delete the joint to simulate breaking.
// INPUTS
//   iJointIndex -- The ID of the joint to check.
// SOURCE
float agk::GetJointReactionForceX( uint32_t iJointIndex )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return agk::PhyToWorldX( pJoint->GetReactionForce( agk::GetFrameTime() ).x );
}

//****f* 2DPhysics/Joints/GetJointReactionForceY
// FUNCTION
//   Returns the amount of force applied to the joint in the Y direction in the last time step. You can use this 
//   to detect large forces and delete the joint to simulate breaking.
// INPUTS
//   iJointIndex -- The ID of the joint to check.
// SOURCE
float agk::GetJointReactionForceY( uint32_t iJointIndex )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return agk::PhyToWorldY( pJoint->GetReactionForce( 1/agk::GetFrameTime() ).y );
}

//****f* 2DPhysics/Joints/GetJointReactionTorque
// FUNCTION
//   Returns the amount of torque applied to the joint in the last time step. You can use this 
//   to detect large forces and delete the joint to simulate breaking. Torque applies to joints
//   that rotate such as revolute joints.
// INPUTS
//   iJointIndex -- The ID of the joint to check.
// SOURCE
float agk::GetJointReactionTorque( uint32_t iJointIndex )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pJoint->GetReactionTorque( 1/agk::GetFrameTime() );
}

//****f* 2DPhysics/Joints/SetJointDamping
// FUNCTION
//   Damping can be used to make the joint soft, like a spring. The frequency is specified in hertz and should 
//   typically be less than half of the physics step rate. For example if the fps is 60 then the frequency 
//   should be less than 30. The damping ratio should be between 0 and 1, but can be larger.<br/>
//   This can only be used on distance joints, weld joints, line/wheel joints, and mouse joints. By default 
//   distance and weld joints have a damping ratio and frequency of 0 making the joint rigid. By default mouse 
//   joints have a frequency of 5 and a damping ratio of 0.7. By default line/wheel joints have a frequency of 
//   2 and a damping ratio of 0.7.
// INPUTS
//   iJointIndex -- The ID of the joint to modify.
//   dampingRatio -- The damping ratio to use, typically between 0 and 1
//   frequency -- The frequency of the oscillations, should be less than half the frame rate
// SOURCE
void agk::SetJointDamping( uint32_t iJointIndex, float dampingRatio, float frequency )
//****
{
	b2Joint *pJoint = (b2Joint*)m_cJointList.GetItem( iJointIndex );
	if ( pJoint == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Joint ", 50 );  errStr.AppendInt( iJointIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	switch( pJoint->GetType() )
	{
		case e_distanceJoint:
		{
			b2DistanceJoint *pDistJoint = (b2DistanceJoint*)pJoint;
			pDistJoint->SetDampingRatio( dampingRatio );
			pDistJoint->SetFrequency( frequency );
			break;
		}
		case e_weldJoint:
		{
			b2WeldJoint *pWeldJoint = (b2WeldJoint*)pJoint;
			pWeldJoint->SetDampingRatio( dampingRatio );
			pWeldJoint->SetFrequency( frequency );
			break;
		}
		case e_wheelJoint:
		{
			b2WheelJoint *pWheelJoint = (b2WheelJoint*)pJoint;
			pWheelJoint->SetSpringDampingRatio( dampingRatio );
			pWheelJoint->SetSpringFrequencyHz( frequency );
			break;
		}
		case e_mouseJoint:
		{
			b2MouseJoint *pMouseJoint = (b2MouseJoint*)pJoint;
			pMouseJoint->SetDampingRatio( dampingRatio );
			pMouseJoint->SetFrequency( frequency );
			break;
		}
		default:
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Attempted to set joint damping ratio on a joint that doesn't support it, JointIndex:", 50 );  errStr.AppendInt( iJointIndex );
			Error( errStr );
#endif
			return;
		}
	}
}

// ray cast

//****f* 2DPhysics/RayCast/PhysicsRayCast
// FUNCTION
//   Casts a ray through all physics objects including sprites that have physics turned on and stores the closest item 
//   hit. Results of a ray cast can be retrieved using the other ray cast functions such as <i>GetRayCastNormalX</i>.<br><br>
//   If the ray starts inside a shape that shape will not be counted in the results.<br><br>
//   Returns 1 if there was a collision, 0 if not.
// INPUTS
//   x -- The X coordinate of the start point in world coordinates.
//   y -- The Y coordinate of the start point in world coordinates.
//   x2 -- The X coordinate of the end point in world coordinates.
//   y2 -- The Y coordinate of the end point in world coordinates.
// SOURCE
int agk::PhysicsRayCast( float x, float y, float x2, float y2 )
//****
{
	g_RayCastCallback.Reset();
	b2Vec2 point1( agk::WorldToPhyX(x),agk::WorldToPhyY(y) );
	b2Vec2 point2( agk::WorldToPhyX(x2),agk::WorldToPhyY(y2) );
	float length = (point1.x-point2.x)*(point1.x-point2.x) + (point1.y-point2.y)*(point1.y-point2.y);
	if ( length <= 0 ) return 0;
	m_phyWorld->RayCast(&g_RayCastCallback, point1, point2);

	if ( g_RayCastCallback.m_fixture ) 
	{
		b2Body* body = g_RayCastCallback.m_fixture->GetBody();
		cSprite *pSprite = (cSprite*) body->GetUserData();
		g_RayCastCallback.m_sprite = pSprite;
		return 1;
	}
	else return 0;
}

//****f* 2DPhysics/RayCast/PhysicsRayCastGroup
// FUNCTION
//   Casts a ray through all physics objects including sprites that have physics turned on and stores the closest item 
//   hit. Results of a  ray cast can be retrieved using the other ray cast functions such as <i>GetRayCastNormalX</i>.<br><br>
//   If the ray starts inside a shape that shape will not be counted in the results.<br><br>
//   This function filters the sprites that are checked so only sprites of a certain group are checked, a group
//   value of 0 means all groups will be checked.<br><br>
//   Returns 1 if there was a collision, 0 if not.
// INPUTS
//   group -- The group ID to check for intersection with the ray, can be negative.
//   x -- The X coordinate of the start point in world coordinates.
//   y -- The Y coordinate of the start point in world coordinates.
//   x2 -- The X coordinate of the end point in world coordinates.
//   y2 -- The Y coordinate of the end point in world coordinates.
// SOURCE
int agk::PhysicsRayCastGroup( int group, float x, float y, float x2, float y2 )
//****
{
	g_RayCastCallback.Reset();
	g_RayCastCallback.m_group = group;

	b2Vec2 point1( agk::WorldToPhyX(x),agk::WorldToPhyY(y) );
	b2Vec2 point2( agk::WorldToPhyX(x2),agk::WorldToPhyY(y2) );
	float length = (point1.x-point2.x)*(point1.x-point2.x) + (point1.y-point2.y)*(point1.y-point2.y);
	if ( length <= 0 ) return 0;
	m_phyWorld->RayCast(&g_RayCastCallback, point1, point2);

	if ( g_RayCastCallback.m_fixture ) 
	{
		b2Body* body = g_RayCastCallback.m_fixture->GetBody();
		cSprite *pSprite = (cSprite*) body->GetUserData();
		g_RayCastCallback.m_sprite = pSprite;
		return 1;
	}
	else return 0;
}

//****f* 2DPhysics/RayCast/PhysicsRayCastCategory
// FUNCTION
//   Casts a ray through all physics objects including sprites that have physics turned on and stores the closest item 
//   hit. Results of a ray cast can be retrieved using the other ray cast functions such as <i>GetRayCastNormalX</i>.<br><br>
//   If the ray starts inside a shape that shape will not be counted in the results.<br><br>
//   This function filters the sprites that are checked so only sprites of certain categories are checked. The 
//   category parameter is a bitwise field that uses the lower 16 bits to represent each of the possible 16
//   categories used when setting up a sprite. The default value of all 1s means all categories will be included,
//   whereas a value of all 0s means no categories will be included. You can set individual bits to set which ones 
//   should be checked.<br><br>
//   Returns 1 if there was a collision, 0 if not.
// INPUTS
//   category -- The categories to check for intersection with the ray, bitwise field using the lower most 16 bits.
//   x -- The X coordinate of the start point in world coordinates.
//   y -- The Y coordinate of the start point in world coordinates.
//   x2 -- The X coordinate of the end point in world coordinates.
//   y2 -- The Y coordinate of the end point in world coordinates.
// SOURCE
int agk::PhysicsRayCastCategory( uint32_t category, float x, float y, float x2, float y2 )
//****
{
	g_RayCastCallback.Reset();
	g_RayCastCallback.m_category = category;

	b2Vec2 point1( agk::WorldToPhyX(x),agk::WorldToPhyY(y) );
	b2Vec2 point2( agk::WorldToPhyX(x2),agk::WorldToPhyY(y2) );
	float length = (point1.x-point2.x)*(point1.x-point2.x) + (point1.y-point2.y)*(point1.y-point2.y);
	if ( length <= 0 ) return 0;
	m_phyWorld->RayCast(&g_RayCastCallback, point1, point2);

	if ( g_RayCastCallback.m_fixture ) 
	{
		b2Body* body = g_RayCastCallback.m_fixture->GetBody();
		cSprite *pSprite = (cSprite*) body->GetUserData();
		g_RayCastCallback.m_sprite = pSprite;
		return 1;
	}
	else return 0;
}

//****f* 2DPhysics/RayCast/SpriteRayCastSingle
// FUNCTION
//   Casts a ray through a particular sprite (can be physics or non physics) and stores the result of any 
//   intersection. Results of a ray cast can be retrieved using the other ray cast functions such as 
//   <i>GetRayCastNormalX</i>. If the ray starts inside a shape that shape will not be counted in the results.
//   This function is special in that it also works on all sprites even those that do not have physics turned on, 
//   but the sprite must have been assigned a shape using one of the sprite shape commands.<br><br>
//   Returns 1 if there was a collision, 0 if not.
// INPUTS
//   sprite -- The sprite ID to check for intersection with the ray.
//   x -- The X coordinate of the start point in world coordinates.
//   y -- The Y coordinate of the start point in world coordinates.
//   x2 -- The X coordinate of the end point in world coordinates.
//   y2 -- The Y coordinate of the end point in world coordinates.
// SOURCE
int agk::SpriteRayCastSingle( uint32_t sprite, float x, float y, float x2, float y2 )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( sprite );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendUInt( sprite );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return SpriteRayCastSingle( pSprite, x,y, x2,y2 );
}

//***if* 2DPhysics/RayCast/SpriteRayCastSingle
// FUNCTION
//   Casts a ray through a particular sprite (can be physics or non physics) and stores the result of any 
//   intersection. Results of a ray cast can be retrieved using the other ray cast functions such as 
//   <i>GetRayCastNormalX</i>. If the ray starts inside a shape that shape will not be counted in the results.<br><br>
//   This function is special in that it also works on all sprites even those that do not have physics turned on, 
//   but the sprite must have been assigned a shape using one of the sprite shape commands.<br><br>
//   Returns 1 if there was a collision, 0 if not.
// INPUTS
//   sprite -- The sprite pointer to check for intersection with the ray.
//   x -- The X coordinate of the start point in world coordinates.
//   y -- The Y coordinate of the start point in world coordinates.
//   x2 -- The X coordinate of the end point in world coordinates.
//   y2 -- The Y coordinate of the end point in world coordinates.
// SOURCE
int agk::SpriteRayCastSingle( cSprite* sprite, float x, float y, float x2, float y2 )
//***
{
	if ( sprite == 0 ) return 0;

	x = agk::WorldToPhyX(x);
	y = agk::WorldToPhyY(y);
	x2 = agk::WorldToPhyX(x2);
	y2 = agk::WorldToPhyY(y2);

	float length = (x-x2)*(x-x2) + (y-y2)*(y-y2);
	if ( length <= 0 ) return 0;

	g_RayCastCallback.Reset();
	g_RayCastCallback.m_fraction = 1.0f;
		
	if ( sprite->m_phyBody == 0 ) 
	{
		// non physics sprite, check shape
		if ( !sprite->m_phyShape ) 
		{
#ifdef _AGK_ERROR_CHECK
			agk::Error( "Attmepted to perform a single sprite ray cast on a sprite that has no shape or physics, must have one or the other" );
#endif
			return 0;
		}
			
		b2RayCastInput input;
		input.p1.Set( x,y );
		input.p2.Set( x2,y2 );
		input.maxFraction = 1.0f;

		b2RayCastOutput output;
		b2Transform xf;
		xf.Set( b2Vec2( agk::WorldToPhyX(sprite->GetXByOffset()), agk::WorldToPhyY(sprite->GetYByOffset()) ), sprite->GetAngleRad() );
		if ( sprite->m_phyShape->RayCast( &output, input, xf, 0 ) )
		{
			if ( output.fraction < g_RayCastCallback.m_fraction && output.fraction > 0 )
			{
				g_RayCastCallback.m_fixture = 0;
				g_RayCastCallback.m_fraction = output.fraction;
				g_RayCastCallback.m_normal = output.normal;
				g_RayCastCallback.m_point.Set( x + (x2-x)*output.fraction, y + (y2-y)*output.fraction );
				g_RayCastCallback.m_sprite = sprite;
			}
		}
	}
	else
	{
		// physics sprite, check fixtures
		b2Fixture *pFix = sprite->m_phyBody->GetFixtureList();
		while ( pFix )
		{
			b2RayCastInput input;
			input.p1.Set( x,y );
			input.p2.Set( x2,y2 );
			input.maxFraction = 1.0f;

			b2RayCastOutput output;
			b2Transform xf;
			xf.Set( b2Vec2( agk::WorldToPhyX(sprite->GetXByOffset()), agk::WorldToPhyY(sprite->GetYByOffset()) ), sprite->GetAngleRad() );
			if ( pFix->GetShape()->RayCast( &output, input, xf, 0 ) )
			{
				if ( output.fraction < g_RayCastCallback.m_fraction && output.fraction > 0 )
				{
					g_RayCastCallback.m_fixture = pFix;
					g_RayCastCallback.m_fraction = output.fraction;
					g_RayCastCallback.m_normal = output.normal;
					g_RayCastCallback.m_point.Set( x + (x2-x)*output.fraction, y + (y2-y)*output.fraction );
					g_RayCastCallback.m_sprite = sprite;
				}
			}
				
			pFix = pFix->GetNext();
		}
	}

	if ( g_RayCastCallback.m_sprite ) return 1;
	return 0;
}

//****f* 2DPhysics/RayCast/SpriteRayCast
// FUNCTION
//   Casts a ray through all sprites that have a shape (including physics sprites) and stores the result of 
//   any intersection. Results of a ray cast can be retrieved using the other ray cast functions such as 
//   <i>GetRayCastNormalX</i>. Physics sprites will only use the main shape assigned to the sprite using
//   <i>SetSpriteShape</i>, to check compound shapes use <i>PhysicsRayCast</i>.<br><br>
//   If the ray starts inside a shape that shape will not be counted in the results.<br><br>
//   Sprites must be assigned a shape using one of the sprite shape commands or it will not be included in 
//   the collision results. This function is slower than the physics only ray casts as it cannot make use 
//   of optimized structures that represent where the sprites are in the world relative to the ray.<br><br>
//
//   This function can only keep track of sprites created using <i>CreateSprite</i>, if you have manually 
//   allocated memory for sprites you will need to cycle through your list of sprites with 
//   <i>SpriteRayCastSingle</i> or use the physics version.<br><br>
//   Returns 1 if there was a collision, 0 if not.
// INPUTS
//   x -- The X coordinate of the start point in world coordinates.
//   y -- The Y coordinate of the start point in world coordinates.
//   x2 -- The X coordinate of the end point in world coordinates.
//   y2 -- The Y coordinate of the end point in world coordinates.
// SOURCE
int agk::SpriteRayCast( float x, float y, float x2, float y2 )
//****
{
	x = agk::WorldToPhyX(x);
	y = agk::WorldToPhyY(y);
	x2 = agk::WorldToPhyX(x2);
	y2 = agk::WorldToPhyY(y2);

	float length = (x-x2)*(x-x2) + (y-y2)*(y-y2);
	if ( length <= 0 ) return 0;

	b2RayCastInput input;
	input.p1.Set( x,y );
	input.p2.Set( x2,y2 );
	input.maxFraction = 1.0f;

	b2Transform xf;
	b2RayCastOutput output;

	g_RayCastCallback.Reset();
	g_RayCastCallback.m_fraction = 1.0f;

	cSprite *pSprite = (cSprite*) m_cSpriteList.GetFirst();
	while ( pSprite )
	{
		// non physics sprite only, check shape
		if ( pSprite->m_phyShape ) 
		{
			output.fraction = 1.0f;
			xf.Set( b2Vec2( agk::WorldToPhyX(pSprite->GetXByOffset()), agk::WorldToPhyY(pSprite->GetYByOffset()) ), pSprite->GetAngleRad() );
			if ( pSprite->m_phyShape->RayCast( &output, input, xf, 0 ) )
			{
				if ( output.fraction < g_RayCastCallback.m_fraction && output.fraction > 0 )
				{
					g_RayCastCallback.m_fixture = 0;
					g_RayCastCallback.m_fraction = output.fraction;
					g_RayCastCallback.m_normal = output.normal;
					g_RayCastCallback.m_point.Set( x + (x2-x)*output.fraction, y + (y2-y)*output.fraction );
					g_RayCastCallback.m_sprite = pSprite;
				}
			}
		}

		pSprite = (cSprite*) m_cSpriteList.GetNext();
	}

	if ( g_RayCastCallback.m_sprite ) return 1;
	return 0;
}

//****f* 2DPhysics/RayCast/SpriteRayCastGroup
// FUNCTION
//   Casts a ray through all sprites that have a shape (including physics sprites) and stores the result of 
//   any intersection. Results of a ray cast can be retrieved using the other ray cast functions such as 
//   <i>GetRayCastNormalX</i>. Physics sprites will only use the main shape assigned to the sprite using
//   <i>SetSpriteShape</i>, to check compound shapes use <i>PhysicsRayCast</i>.<br><br>
//   If the ray starts inside a shape that shape will not be counted in the results.
//   Sprites must be assigned a shape using one of the sprite shape commands or it will not be included in 
//   the collision results. This function is slower than the physics ray casts as it cannot make use 
//   of optimized structures that represent where the sprites are in the world relative to the ray.<br><br>
//
//   This function filters the sprites that are checked so only sprites of a certain group are checked.
//   By default sprites are created in group 0.<br><br>
//
//   This function can only keep track of sprites created using <i>CreateSprite</i>, if you have manually 
//   allocated memory for sprites you will need to cycle through your list of sprites with 
//   <i>SpriteRayCastSingle</i> or use the physics version.<br><br>
//   Returns 1 if there was a collision, 0 if not.
// INPUTS
//   group -- The group ID to check for intersection with the ray, can be negative.
//   x -- The X coordinate of the start point in world coordinates.
//   y -- The Y coordinate of the start point in world coordinates.
//   x2 -- The X coordinate of the end point in world coordinates.
//   y2 -- The Y coordinate of the end point in world coordinates.
// SOURCE
int agk::SpriteRayCastGroup( int group, float x, float y, float x2, float y2 )
//****
{
	x = agk::WorldToPhyX(x);
	y = agk::WorldToPhyY(y);
	x2 = agk::WorldToPhyX(x2);
	y2 = agk::WorldToPhyY(y2);

	float length = (x-x2)*(x-x2) + (y-y2)*(y-y2);
	if ( length <= 0 ) return 0;

	b2RayCastInput input;
	input.p1.Set( x,y );
	input.p2.Set( x2,y2 );
	input.maxFraction = 1.0f;

	b2Transform xf;
	b2RayCastOutput output;

	g_RayCastCallback.Reset();
	g_RayCastCallback.m_fraction = 1.0f;

	cSprite *pSprite = (cSprite*) m_cSpriteList.GetFirst();
	while ( pSprite )
	{
		// non physics sprite only, check shape
		if ( pSprite->m_phyShape && pSprite->m_iGroup == group ) 
		{
			output.fraction = 1.0f;
			xf.Set( b2Vec2( agk::WorldToPhyX(pSprite->GetXByOffset()), agk::WorldToPhyY(pSprite->GetYByOffset()) ), pSprite->GetAngleRad() );
			if ( pSprite->m_phyShape->RayCast( &output, input, xf, 0 ) )
			{
				if ( output.fraction < g_RayCastCallback.m_fraction && output.fraction > 0 )
				{
					g_RayCastCallback.m_fixture = 0;
					g_RayCastCallback.m_fraction = output.fraction;
					g_RayCastCallback.m_normal = output.normal;
					g_RayCastCallback.m_point.Set( x + (x2-x)*output.fraction, y + (y2-y)*output.fraction );
					g_RayCastCallback.m_sprite = pSprite;
				}
			}
		}

		pSprite = (cSprite*) m_cSpriteList.GetNext();
	}

	if ( g_RayCastCallback.m_sprite ) return 1;
	return 0;
}

//****f* 2DPhysics/RayCast/SpriteRayCastCategory
// FUNCTION
//   Casts a ray through all sprites that have a shape (including physics sprites) and stores the result of 
//   any intersection. Results of a ray cast can be retrieved using the other ray cast functions such as 
//   <i>GetRayCastNormalX</i>. Physics sprites will only use the main shape assigned to the sprite using
//   <i>SetSpriteShape</i>, to check compound shapes use <i>PhysicsRayCast</i>.<br><br>
//   If the ray starts inside a shape that shape will not be counted in the results.<br><br>
//   Sprites must be assigned a shape using one of the sprite shape commands or it will not be included in 
//   the collision results. This function is slower than the physics ray casts as it cannot make use 
//   of optimized structures that represent where the sprites are in the world relative to the ray.<br><br>
//
//   This function filters the sprites that are checked so only sprites of certain categories are checked. The 
//   category parameter is a bitwise field that uses the lower 16 bits to represent each of the possible 16
//   categories used when setting up a sprite. The default value of all 1s means all categories will be included,
//   whereas a value of all 0s means no categories will be included. You can set individual bits to set which ones 
//   should be checked.<br><br>
//
//   This function can only keep track of sprites created using <i>CreateSprite</i>, if you have manually 
//   allocated memory for sprites you will need to cycle through your list of sprites with <i>SpriteRayCastSingle</i> 
//   or use the physics version.<br><br>
//   Returns 1 if there was a collision, 0 if not.
// INPUTS
//   category -- The categories to check for intersection with the ray, bitwise field using the lower most 16 bits.
//   x -- The X coordinate of the start point in world coordinates.
//   y -- The Y coordinate of the start point in world coordinates.
//   x2 -- The X coordinate of the end point in world coordinates.
//   y2 -- The Y coordinate of the end point in world coordinates.
// SOURCE
int agk::SpriteRayCastCategory( uint32_t category, float x, float y, float x2, float y2 )
//****
{
	category &= 0xffff;

	x = agk::WorldToPhyX(x);
	y = agk::WorldToPhyY(y);
	x2 = agk::WorldToPhyX(x2);
	y2 = agk::WorldToPhyY(y2);

	float length = (x-x2)*(x-x2) + (y-y2)*(y-y2);
	if ( length <= 0 ) return 0;

	b2RayCastInput input;
	input.p1.Set( x,y );
	input.p2.Set( x2,y2 );
	input.maxFraction = 1.0f;

	b2Transform xf;
	b2RayCastOutput output;

	g_RayCastCallback.Reset();
	g_RayCastCallback.m_fraction = 1.0f;

	cSprite *pSprite = (cSprite*) m_cSpriteList.GetFirst();
	while ( pSprite )
	{
		if ( pSprite->m_phyShape && (pSprite->m_iCategories & category) > 0 ) 
		{
			output.fraction = 1.0f;
			xf.Set( b2Vec2( agk::WorldToPhyX(pSprite->GetXByOffset()), agk::WorldToPhyY(pSprite->GetYByOffset()) ), pSprite->GetAngleRad() );
			if ( pSprite->m_phyShape->RayCast( &output, input, xf, 0 ) )
			{
				if ( output.fraction < g_RayCastCallback.m_fraction && output.fraction > 0 )
				{
					g_RayCastCallback.m_fixture = 0;
					g_RayCastCallback.m_fraction = output.fraction;
					g_RayCastCallback.m_normal = output.normal;
					g_RayCastCallback.m_point.Set( x + (x2-x)*output.fraction, y + (y2-y)*output.fraction );
					g_RayCastCallback.m_sprite = pSprite;
				}
			}
		}

		pSprite = (cSprite*) m_cSpriteList.GetNext();
	}

	if ( g_RayCastCallback.m_sprite ) return 1;
	return 0;
}

//***f* 2DPhysics/RayCast/GetRayCastSprite
// FUNCTION
//   Returns the pointer of the sprite hit in the most recent ray cast check. If the ray hit a static
//   shape attached to the background body 0 will be returned.
// SOURCE
cSprite* agk::GetRayCastSprite( )
//***2
{
	return g_RayCastCallback.m_sprite;
}

//****f* 2DPhysics/RayCast/GetRayCastSpriteID
// FUNCTION
//   Returns the ID of the sprite hit in the most recent ray cast check. If the ray hit a non-sprite
//   shape 0 will be returned.
// SOURCE
uint32_t agk::GetRayCastSpriteID( )
//****
{
	if ( g_RayCastCallback.m_sprite ) return g_RayCastCallback.m_sprite->GetID();
	else return 0;
}

//****f* 2DPhysics/RayCast/GetRayCastX
// FUNCTION
//   Returns the X coordinate of the intersection point of the most recent ray cast check.
//   The result is in world coordinates.
// SOURCE
float agk::GetRayCastX()
//****
{
	return agk::PhyToWorldX(g_RayCastCallback.m_point.x);
}

//****f* 2DPhysics/RayCast/GetRayCastY
// FUNCTION
//   Returns the Y coordinate of the intersection point of the most recent ray cast check.
//   The result is in world coordinates.
// SOURCE
float agk::GetRayCastY()
//****
{
	return agk::PhyToWorldY(g_RayCastCallback.m_point.y);
}

//****f* 2DPhysics/RayCast/GetRayCastNormalX
// FUNCTION
//   Returns the X component of the normal of the most recent ray cast check. This will not
//   be a unit vector as it has been converted to world coordinates.
// SOURCE
float agk::GetRayCastNormalX()
//****
{
	// use PhyToWorldY to convert X for normals
	return agk::PhyToWorldY(g_RayCastCallback.m_normal.x);
}

//****f* 2DPhysics/RayCast/GetRayCastNormalY
// FUNCTION
//   Returns the Y component of the normal of the most recent ray cast check. This will not
//   be a unit vector as it has been converted to world coordinates.
// SOURCE
float agk::GetRayCastNormalY()
//****
{
	// use PhyToWorldX to convert Y for normals
	return agk::PhyToWorldX(g_RayCastCallback.m_normal.y);
}

//****f* 2DPhysics/RayCast/GetRayCastFraction
// FUNCTION
//   Returns the fraction of the ray travelled before reaching a collision. 0 represents the 
//   start of the ray and 1.0 represents the end of the ray.
// SOURCE
float agk::GetRayCastFraction()
//****
{
	return g_RayCastCallback.m_fraction;
}

// non physics collision commands

//****f* Sprite/Collision/GetSpriteInBox
// FUNCTION
//   Returns 1 if the sprite's collision shape is touching the given box in world coordinates, 0 if not. 
//   If the sprite does not have a shape it is assigned a box shape of its own which will remain 
//   after this command. This command takes into account the rotation and scale of the sprite when checking 
//   intersection.
// INPUTS
//   iSprite -- The ID of the sprite to check
//   x1 -- The X coordinate of the top left corner of the box in world coordinates.
//   y1 -- The Y coordinate of the top left corner of the box in world coordinates.
//   x2 -- The X coordinate of the bottom right corner of the box in world coordinates.
//   y2 -- The Y coordinate of the bottom right corner of the box in world coordinates.
// SOURCE
int agk::GetSpriteInBox( uint32_t iSprite, float x1, float y1, float x2, float y2 )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSprite );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->InBox( x1,y1, x2,y2 );
}

//****f* Sprite/Collision/GetSpriteInCircle
// FUNCTION
//   Returns 1 if the sprite's collision shape is touching the given circle in world coordinates, 0 if not. 
//   If the sprite does not have a shape it is assigned a box shape of its own which will remain 
//   after this command. This command takes into account the rotation and scale of the sprite when checking 
//   intersection.
//   Note that due to aspect ratio modifications this command does not behave as expect when using the 
//   percentage coordinate system. Instead it will check an ellipse with the correct radius in the X direction
//   but a larger radius in the Y direction.
// INPUTS
//   iSprite -- The ID of the sprite to check
//   x1 -- The X coordinate of the center of the circle in world coordinates.
//   y1 -- The Y coordinate of the center of the circle in world coordinates.
//   radius -- The radius of the circle in world coordinates.
// SOURCE
int agk::GetSpriteInCircle( uint32_t iSprite, float x1, float y1, float radius )
//****
{
	cSprite *pSprite = (cSprite*)m_cSpriteList.GetItem( iSprite );
	if ( pSprite == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite->InCircle( x1,y1, radius );
}

//****f* Sprite/Collision/GetSpriteCollision
// FUNCTION
//   Checks two sprites for collision, if they overlap then it returns 1. Otherwise it returns 0. No other
//   information can be returned about this type of collision.<br><br>
//   This command is primarily for sprites that are not using physics. Whilst it can be used on physics sprites
//   the physics system will have already calculated the overlap of all physics sprites during the last frame
//   and stored the results in the contact list. This function actually does the calculation required to determine
//   if the sprites overlap. This function is not limited by group or category settings.<br><br>
//
//   This function only operates on the sprite's base shape. Any additional shapes added to physics sprites will
//   not be used in this function, use <i>GetPhysicsCollision</i> instead. Also Chain shapes will always return 
//   no collision using this command, chain shapes are only used in physics calculations.<br><br>
//
//   If you have not assigned a shape to either sprite using <i>SetSpriteShape</i> they will use the default 
//   box shape based on the sprite's width and height.
// INPUTS
//   iSprite1 -- The sprite to check for intersection with sprite 2
//   iSprite2 -- The sprite to check for intersection with sprite 1
// SOURCE
int agk::GetSpriteCollision( uint32_t iSprite1, uint32_t iSprite2 )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSprite1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSprite2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	m_pLastColCheck = pSprite1;
	return pSprite1->GetCollision( pSprite2 ) ? 1 : 0;
}

//****f* Sprite/Collision/GetSpriteDistance
// FUNCTION
//   Calculates the minimum distance separating the two sprites. If the sprites overlap this will be less 
//   than 0. Otherwise it will be the distance between the closest points on each sprite, these
//   points can be found using <i>GetSpriteDistancePoint1X</i>, etc.
//   This calculation takes longer than simply checking if the sprites overlap, if you don't need the 
//   distance separating the sprites use <i>GetSpriteCollision</i>.<br><br>
//
//   This function is not limited by group or category settings.<br><br>
//
//   If you have not assigned a shape to either sprite using <i>SetSpriteShape</i> they will use the default 
//   box shape based on the sprite's width and height.
// INPUTS
//   iSprite1 -- The sprite to check for distance with sprite 2
//   iSprite2 -- The sprite to check for distance with sprite 1
// SOURCE
float agk::GetSpriteDistance( uint32_t iSprite1, uint32_t iSprite2 )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSprite1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSprite2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pSprite1->GetDistance( pSprite2 );
}

//****f* Sprite/Collision/GetSpriteDistancePoint1X
// FUNCTION
//   Returns the X coordinate of the closest point on sprite 1 to sprite 2 from the last call to <i>GetSpriteDistance</i>
//   in world coordinates.
// SOURCE
float agk::GetSpriteDistancePoint1X( )
//****
{
	if ( !m_pLastColCheck ) return 0;
	return m_pLastColCheck->GetDistancePoint1X();
}

//****f* Sprite/Collision/GetSpriteDistancePoint1Y
// FUNCTION
//   Returns the Y coordinate of the closest point on sprite 1 to sprite 2 from the last call to <i>GetSpriteDistance</i>
//   in world coordinates.
// SOURCE
float agk::GetSpriteDistancePoint1Y( )
//****
{
	if ( !m_pLastColCheck ) return 0;
	return m_pLastColCheck->GetDistancePoint1Y();
}

//****f* Sprite/Collision/GetSpriteDistancePoint2X
// FUNCTION
//   Returns the X coordinate of the closest point on sprite 2 to sprite 1 from the last call to <i>GetSpriteDistance</i>
//   in world coordinates.
// SOURCE
float agk::GetSpriteDistancePoint2X( )
//****
{
	if ( !m_pLastColCheck ) return 0;
	return m_pLastColCheck->GetDistancePoint2X();
}

//****f* Sprite/Collision/GetSpriteDistancePoint2Y
// FUNCTION
//   Returns the Y coordinate of the closest point on sprite 2 to sprite 1 from the last call to <i>GetSpriteDistance</i>
//   in world coordinates.
// SOURCE
float agk::GetSpriteDistancePoint2Y( )
//****
{
	if ( !m_pLastColCheck ) return 0;
	return m_pLastColCheck->GetDistancePoint2Y();
}

// physics collision commands

//****f* 2DPhysics/Contacts/GetFirstContact
// FUNCTION
//   Cycles through the list of all contacts detected in the last physics step. Returns 1 if a contact exists, 
//   you can get the sprites involved in this contact using <i>GetContactSpriteID1</i> and <i>GetContactSpriteID2</i>, you 
//   can move on to the next contact with <i>GetNextContact</i>. Returns 0 if there are no contacts.
// SOURCE
int agk::GetFirstContact()
//****
{
	m_pContactIter = m_phyWorld->GetContactList();
	while ( m_pContactIter && !m_pContactIter->IsTouching() ) m_pContactIter = m_pContactIter->GetNext();
	return m_pContactIter ? 1 : 0;
}

//****f* 2DPhysics/Contacts/GetNextContact
// FUNCTION
//   Returns 1 if a contact exists, you can get the sprites involved in this contact using <i>GetContactSpriteID1</i>
//   and <i>GetContactSpriteID2</i>, you can move on to the next contact by calling this command again, when there are 
//   no more contacts it will return 0.
// SOURCE
int agk::GetNextContact()
//****
{
	if ( m_pContactIter == 0 ) return 0;
	m_pContactIter = m_pContactIter->GetNext();
	while ( m_pContactIter && !m_pContactIter->IsTouching() ) m_pContactIter = m_pContactIter->GetNext();
	return m_pContactIter ? 1 : 0;
}

//****f* 2DPhysics/Contacts/GetContactWorldX
// FUNCTION
//   Returns the X position of the contact point in world coordinates.
// SOURCE
float agk::GetContactWorldX()
//****
{
	if ( m_pContactIter == 0 ) return 0;
	return agk::PhyToWorldX(m_pContactIter->GetFixtureB()->GetBody()->GetWorldPoint(m_pContactIter->GetManifold()->points[0].localPoint).x);
}

//****f* 2DPhysics/Contacts/GetContactWorldY
// FUNCTION
//   Returns the Y position of the contact point in world coordinates.
// SOURCE
float agk::GetContactWorldY()
//****
{
	if ( m_pContactIter == 0 ) return 0;
	return agk::PhyToWorldY(m_pContactIter->GetFixtureB()->GetBody()->GetWorldPoint(m_pContactIter->GetManifold()->points[0].localPoint).y);
}

//****f* 2DPhysics/Contacts/GetContactSpriteID1
// FUNCTION
//   Returns the ID of the first sprite involved in this contact. If this half of the contact is with an 
//   item not associated to a sprite this will return 0.
// SOURCE
uint32_t agk::GetContactSpriteID1()
//****
{
	if ( m_pContactIter == 0 ) return 0;
	cSprite *pSprite = (cSprite*) m_pContactIter->GetFixtureA()->GetBody()->GetUserData();
	if ( pSprite ) return pSprite->GetID();
	return 0;
}

//****f* 2DPhysics/Contacts/GetContactSpriteID2
// FUNCTION
//   Returns the ID of the second sprite involved in this contact. If this half of the contact is with an 
//   item not associated to a sprite this will return 0.
// SOURCE
uint32_t agk::GetContactSpriteID2()
//****
{
	if ( m_pContactIter == 0 ) return 0;
	cSprite *pSprite = (cSprite*) m_pContactIter->GetFixtureB()->GetBody()->GetUserData();
	if ( pSprite ) return pSprite->GetID();
	return 0;
}

cSprite* agk::GetContactSprite1()
{
	if ( m_pContactIter == 0 ) return 0;
	cSprite *pSprite = (cSprite*) m_pContactIter->GetFixtureA()->GetBody()->GetUserData();
	return pSprite;
}

cSprite* agk::GetContactSprite2()
{
	if ( m_pContactIter == 0 ) return 0;
	cSprite *pSprite = (cSprite*) m_pContactIter->GetFixtureB()->GetBody()->GetUserData();
	return pSprite;
}

//****f* 2DPhysics/Contacts/GetSpriteFirstContact
// FUNCTION
//   Cycles through the list of contacts for the given sprite only. Returns 1 if a contact exists, 
//   you can get the other sprite involved in this contact using <i>GetSpriteContactSpriteID2</i>, you can move 
//   on to the next contact with <i>GetSpriteNextContact</i>. Only works on sprites setup for physics.<br><br>
//   Returns 0 if there are no contacts.
// INPUTS
//   iSprite1 -- The sprite to check for physics contacts.
// SOURCE
int agk::GetSpriteFirstContact( uint32_t iSprite1 )
//****
{
	m_pSpriteContactIter = 0;

	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSprite1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Sprite %d does not exist", iSprite1 );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pSprite1->m_phyBody )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Sprite %d is not setup for physics", iSprite1 );
		Error( errStr );
#endif
		return 0;
	}

	int result = pSprite1->GetFirstContact();
	if ( result > 0 ) m_pSpriteContactIter = pSprite1;
	return result;
}

//****f* 2DPhysics/Contacts/GetSpriteNextContact
// FUNCTION
//   Cycles through the list of contacts for the given sprite only. Returns 1 if a contact exists, 
//   you can get the other sprite involved in this contact using <i>GetSpriteContactSpriteID2</i>, you can move 
//   on to the next contact by calling this command again, it will return 0 when no more contacts exist. 
//   Only works on sprites setup for physics.
// SOURCE
int agk::GetSpriteNextContact( )
//****
{
	if ( !m_pSpriteContactIter ) return 0;
	return m_pSpriteContactIter->GetNextContact();
}

//****f* 2DPhysics/Contacts/GetSpriteContactWorldX
// FUNCTION
//   Returns the X coordinate of the contact point in world coordinates.
// SOURCE
float agk::GetSpriteContactWorldX( )
//****
{
	if ( !m_pSpriteContactIter ) return 0;
	return m_pSpriteContactIter->GetContactWorldX();
}

//****f* 2DPhysics/Contacts/GetSpriteContactWorldY
// FUNCTION
//   Returns the Y coordinate of the contact point in world coordinates.
// SOURCE
float agk::GetSpriteContactWorldY( )
//****
{
	if ( !m_pSpriteContactIter ) return 0;
	return m_pSpriteContactIter->GetContactWorldY();
}

//****f* 2DPhysics/Contacts/GetSpriteContactSpriteID2
// FUNCTION
//   Returns the ID of the other sprite involved in this contact.
// SOURCE
uint32_t agk::GetSpriteContactSpriteID2( )
//****
{
	if ( !m_pSpriteContactIter ) return 0;
	cSprite *pSprite = m_pSpriteContactIter->GetContactSprite2();
	if ( pSprite ) return pSprite->GetID();
	else return 0;
}

cSprite* agk::GetSpriteContactSprite2( )
{
	if ( !m_pSpriteContactIter ) return 0;
	return m_pSpriteContactIter->GetContactSprite2();
}

//****f* Sprite/Physics/GetPhysicsCollision
// FUNCTION
//   Returns 1 if two physics sprites overlap, otherwise it returns 0. This function doesn't do
//   any calculation, it simply looks up the results of the last physics step to determine if the sprites
//   currently overlap. If this function returns true you can get the point of collision using
//   <i>GetPhysicsCollisionX</i> and <i>GetPhysicsCollisionY</i>, if there is more than one point of collision it
//   is not known which point will be returned. You can check the sprite's contact list to get the full list
//   of contact points.<br><br>
//
//   This function is affected by group and category settings.
// INPUTS
//   iSprite1 -- The ID of the first sprite to check
//   iSprite2 -- The ID of the second sprite to check
// SOURCE
int agk::GetPhysicsCollision( uint32_t iSprite1, uint32_t iSprite2 )
//****
{
	cSprite *pSprite1 = (cSprite*)m_cSpriteList.GetItem( iSprite1 );
	if ( pSprite1 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite1 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	cSprite *pSprite2 = (cSprite*)m_cSpriteList.GetItem( iSprite2 );
	if ( pSprite2 == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite2 );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( pSprite1->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite1 );  errStr.Append( " not setup for physics" );
		Error( errStr );
#endif
		return 0;
	}

	if ( pSprite2->m_phyBody == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Sprite ", 50 );  errStr.AppendInt( iSprite2 );  errStr.Append( " not setup for physics" );
		Error( errStr );
#endif
		return 0;
	}

	m_pLastColCheck2 = pSprite1;
	return pSprite1->GetPhysicsCollision( pSprite2 ) ? 1 : 0;
}

//****f* Sprite/Physics/GetPhysicsCollisionX
// FUNCTION
//   Returns the X coordinate of the collision point from the last call to <i>GetPhysicsCollision</i>
//   relative to the first sprite's offset.
// SOURCE
float agk::GetPhysicsCollisionX( )
//****
{
	if ( !m_pLastColCheck2 ) return 0;
	return m_pLastColCheck2->GetPhysicsCollisionX();
}

//****f* Sprite/Physics/GetPhysicsCollisionY
// FUNCTION
//   Returns the Y coordinate of the collision point from the last call to <i>GetPhysicsCollision</i>
//   relative to the first sprite's offset.
// SOURCE
float agk::GetPhysicsCollisionY( )
//****
{
	if ( !m_pLastColCheck2 ) return 0;
	return m_pLastColCheck2->GetPhysicsCollisionY();
}

//****f* Sprite/Physics/GetPhysicsCollisionWorldX
// FUNCTION
//   Returns the X coordinate of the collision point from the last call to <i>GetPhysicsCollision</i>
//   in world coordinates.
// SOURCE
float agk::GetPhysicsCollisionWorldX( )
//****
{
	if ( !m_pLastColCheck2 ) return 0;
	return m_pLastColCheck2->GetPhysicsCollisionWorldX();
}

//****f* Sprite/Physics/GetPhysicsCollisionWorldY
// FUNCTION
//   Returns the Y coordinate of the collision point from the last call to <i>GetPhysicsCollision</i>
//   in world coordinates.
// SOURCE
float agk::GetPhysicsCollisionWorldY( )
//****
{
	if ( !m_pLastColCheck2 ) return 0;
	return m_pLastColCheck2->GetPhysicsCollisionWorldY();
}

//
// Particle functions
//

//****f* Particles/Creation/CreateParticles
// FUNCTION
//   Creates a particle emitter with the given ID and the given location in world coordinates. 
//   Particle emitters create a flow of small sprites that last for a fixed amount of time before
//   disappearing. The particles can be influenced by forces during their life using 
//   <i>AddParticlesForce</i>. They can also change color over time using <i>AddParticlesColorKeyFrame</i>.
//   <br><br>Particles cannot be modified individually and behave as a group using the same texture and 
//   depth. This allows the AGK to draw them more efficiently than a similar number of normal 
//   sprites.
// INPUTS
//   ID -- The ID to use when referencing this particle emitter.
//   x -- The x coordinate to position this emitter.
//   y -- The y coordinate to position this emitter.
// SOURCE
void agk::CreateParticles( uint32_t ID, float x, float y )
//****
{
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create particle emitter %d, ID must be greater than 0", ID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cParticleEmitterList.GetItem( ID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create particle emitter %d, ID already exists", ID );
		Error( errStr );
#endif
		return;
	}

	cParticleEmitter *pEmitter = new cParticleEmitter();
	m_cParticleEmitterList.AddItem( pEmitter, ID );
	pEmitter->SetID( ID );
	pEmitter->SetPosition( x, y );
	pEmitter->SetSpriteManager( &m_cSpriteMgrFront );
}

//****f* Particles/Creation/CreateParticles
// FUNCTION
//   Creates a particle emitter in a free ID and at the given location in world coordinates. It 
//   returns the ID used to create the emitter.<br><Br>
//   Particle emitters create a flow of small sprites that last for a fixed amount of time before
//   disappearing. The particles can be influenced by forces during their life using 
//   <i>AddParticlesForce</i>. They can also change color over time using <i>AddParticlesColorKeyFrame</i>.
//   <br><br>Particles cannot be modified individually and behave as a group using the same texture and 
//   depth. This allows the AGK to draw them more efficiently than a similar number of normal 
//   sprites.
// INPUTS
//   x -- The x coordinate to position this emitter.
//   y -- The y coordinate to position this emitter.
// SOURCE
uint32_t agk::CreateParticles( float x, float y )
//****
{
	uint32_t ID = m_cParticleEmitterList.GetFreeID();
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create particle emitter, no free ID found" );
		Error( errStr );
#endif
		return 0;
	}

	cParticleEmitter *pEmitter = new cParticleEmitter();
	m_cParticleEmitterList.AddItem( pEmitter, ID );
	pEmitter->SetID( ID );
	pEmitter->SetPosition( x, y );
	pEmitter->SetSpriteManager( &m_cSpriteMgrFront );
	return ID;
}

//****f* Particles/Properties/GetParticlesExists
// FUNCTION
//   Returns 1 if a particle emitter exists at the given ID. 0 if not.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
int agk::GetParticlesExists( uint32_t ID )
//****
{
	return m_cParticleEmitterList.GetItem( ID ) ? 1 : 0;
}

//****f* Particles/Creation/DeleteParticles
// FUNCTION
//   Deletes a particle emitter and all its particles. If any particles were currently visible they 
//   will disappear instantly.
// INPUTS
//   ID -- The ID of the emitter to delete.
// SOURCE
void agk::DeleteParticles( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.RemoveItem( ID );
	if ( pEmitter )
	{
		delete pEmitter;
	}
}

//****f* Particles/Properties/SetParticlesPosition
// FUNCTION
//   Sets the position of the particle emitter. This is the position that new particles will emerge from 
//   and does not affect particles that are already visible.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   x -- The new x coordinate for the emitter in world coordinates.
//   y -- The new y coordinate for the emitter in world coordinates.
// SOURCE
void agk::SetParticlesPosition( uint32_t ID, float x, float y )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d position, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetPosition( x, y );
}

//****f* Particles/Properties/SetParticlesDepth
// FUNCTION
//   Sets the depth of the particle emitter. This affects all particles, even those that are already visible.
//   All particles are drawn at the same depth as the emitter so that the AGK can group them into a single
//   draw call for faster drawing. The depth should be between 0 and 10000, with 0 being the front of the 
//   screen.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   depth -- The new depth value of the particles.
// SOURCE
void agk::SetParticlesDepth( uint32_t ID, int depth )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d depth, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetDepth( depth );
}

//****f* Particles/Properties/SetParticlesFrequency
// FUNCTION
//   Sets the frequency of new particle generation. The freq value states how many particles should be 
//   produced per second, this is independent of frame rate. This is one of the two values that affects
//   the number of particles generated, the other being <i>SetParticlesLife</i>. The maximum number of 
//   particles that can be on screen at any one time is freq*life, with life being the number of seconds
//   a particle lives before it disappears. This value is independent of frame rate.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   freq -- The rate of new particle production in particles per second.
// SOURCE
void agk::SetParticlesFrequency( uint32_t ID, float freq )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d frequency, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetFrequency( freq );
}

//****f* Particles/Properties/SetParticlesStartZone
// FUNCTION
//   Sets the area around the emitter where new particles may appear. The values are relative to the 
//   emitter position, for example a zone of 0,0,0,0 would mean that all particles start on the emitter
//   position point. A zone of -10 in x and +10 x, with y being 0 (-10,0,10,0) would create a line 
//   centered on the emitter position that particles would randomly appear along. A box zone where
//   both x and y are non-zero sizes would mean that particles could start at any point inside the box.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   x1 -- The x coordinate of the top left corner of the start zone.
//   y1 -- The y coordinate of the top left corner of the start zone.
//   x2 -- The x coordinate of the bottom right corner of the start zone.
//   y2 -- The y coordinate of the bottom right corner of the start zone.
// SOURCE
void agk::SetParticlesStartZone( uint32_t ID, float x1, float y1, float x2, float y2 )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d start zone, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetStartZone( x1, y1, x2, y2 );
}

//****f* Particles/Properties/SetParticlesDirection
// FUNCTION
//   Sets the initial direction of new particles when they emerge from the emitter. This can be used
//   along with the <i>SetParticlesAngle</i> command to set the range of variation from this initial direction
//   that new particles can choose. This also sets the initial speed of the particles by taking the length
//   of the vector as units per second. For example if the initial direction is vx=10, vy=-15, particles
//   will begin by moving to the right at a rate of 10 units per second and upwards at a rate of 15 units
//   per second and will continue this rate of motion for their entire life unless influenced by forces 
//   added with <i>AddParticlesForce</i>.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   vx -- The x direction that particles will move initially.
//   vy -- The y direction that particles will move initially.
// SOURCE
void agk::SetParticlesDirection( uint32_t ID, float vx, float vy )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d direction, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetDirection( vx, vy );
}

//****f* Particles/Properties/SetParticlesVelocityRange
// FUNCTION
//     Sets a minimum and maximum multiplier that will affect particles being emitted. This can
//     be used to ensure that there will be some variation when particles are emitted.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   v1 -- The minimum velocity multiplier.
//   v2 -- The maximum velocity multiplier.
// SOURCE
void agk::SetParticlesVelocityRange( uint32_t ID, float v1, float v2 )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d velocity range, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetVelocityRange( v1, v2 );
}


//****f* Particles/Properties/SetParticlesAngle
// FUNCTION
//   Sets the range of direction in degrees that a particle can choose when it first starts. This takes the base 
//   direction set with <i>SetParticlesDirection</i> and adjusts it by a random amount between 0 and angle/2 degrees. 
//   For example an angle of 0 would mean that all new particles follow exactly the direction specified earlier. 
//   An angle of 360 would mean that particles could appear travelling in any direction, and an angle of 90 would 
//   mean that particles would travel outward in a cone of 90 degrees from their start position with the cone 
//   centered on the given direction.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   angle -- The range of variation a particle can choose from the emitter direction.
// SOURCE
void agk::SetParticlesAngle( uint32_t ID, float angle )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d angle, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetAngle( angle );
}

//****f* Particles/Properties/SetParticlesAngleRad
// FUNCTION
//   Sets the range of direction in radians that a particle can choose when it first starts. This takes the base 
//   direction set with <i>SetParticlesDirection</i> and adjusts it by a random amount between 0 and angle/2 radians. 
//   For example an angle of 0 would mean that all new particles follow exactly the direction specified earlier. 
//   An angle of 2*PI would mean that particles could appear travelling in any direction, and an angle of PI/2 
//   would mean that particles would travel outward in a cone of PI/2 radians from their start position with the 
//   cone centered on the given direction.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   angle -- The range of variation a particle can choose from the emitter direction.
// SOURCE
void agk::SetParticlesAngleRad( uint32_t ID, float angle )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d angle, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetAngleRad( angle );
}

//****f* Particles/Properties/SetParticlesRotationRange
// FUNCTION
//   Sets the range of rotation in radians that a particle can have during its life. When a particle
//   is created it starts at angle 0 and chooses and random rotation rate between angle1 and angle2.
//   The particle will then rotate at that chosen rate for its entire life. Use negative values for 
//   counter-clockwise rotation and positive for clockwise rotation.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   angle1 -- The minimum angle of the range in degrees per second.
//   angle2 -- The maximum angle of the range in degrees per second.
// SOURCE
void agk::SetParticlesRotationRange( uint32_t ID, float angle1, float angle2 )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d rotation range, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetRotationRate( angle1, angle2 );
}

//****f* Particles/Properties/SetParticlesRotationRangeRad
// FUNCTION
//   Sets the range of rotation in radians that a particle can have during its life. When a particle
//   is created it starts at angle 0 and chooses and random rotation rate between angle1 and angle2.
//   The particle will then rotate at that chosen rate for its entire life. Use negative values for 
//   counter-clockwise rotation and positive for clockwise rotation.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   angle1 -- The minimum angle of the range in radians per second.
//   angle2 -- The maximum angle of the range in radians per second.
// SOURCE
void agk::SetParticlesRotationRangeRad( uint32_t ID, float angle1, float angle2 )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d rotation range, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetRotationRateRad( angle1, angle2 );
}

//****f* Particles/Properties/SetParticlesFaceDirection
// FUNCTION
//   Sets particles to rotate to the direction they are moving. This overrides any use of
//   <i>SetParticlesRotationRange</i> to modify the rate at which particles rotate. Instead 
//   particles will always rotate to face their direction of travel.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   mode -- 1 to make particles rotate to the direction they are moving, 0 to use normal rotation.
// SOURCE
void agk::SetParticlesFaceDirection( uint32_t ID, int mode )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d face direction, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetFaceDirection( mode );
}

//****f* Particles/Properties/SetParticlesSize
// FUNCTION
//   Sets the size of all particles in world coordinates. Setting a large number of particles to a large
//   size will perform poorly on mobile devices that have a low fill rate (number of pixels it can draw 
//   per second).
// INPUTS
//   ID -- The ID of the emitter to modify.
//   size -- Size of the particles
// SOURCE
void agk::SetParticlesSize( uint32_t ID, float size )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d size, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetSize( size );
}

//****f* Particles/Properties/SetParticlesLife
// FUNCTION
//   Sets the life of particles once they have been emitted in seconds. After particles have been alive for the
//   given number of seconds they will disappear. This is one of the two values that affects the number of 
//   particles generated, the other being <i>SetParticlesFrequency</i>. The maximum number of particles that can be 
//   on screen at any one time is freq*life, with freq being the number of particles emitted per second.
//   This value is independent of frame rate.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   time -- The time in seconds that a particle is visible.
// SOURCE
void agk::SetParticlesLife( uint32_t ID, float time )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d life, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetLife( time );
}

//****f* Particles/Properties/SetParticlesMax
// FUNCTION
//   Sets the maximum number of particles that will be emitted. If this value is equal to -1 then the number is
//   infinite. The emitter will keep a count of the number of particles it emits and stop when the limit is reached.
//   To check if the emitter has reached its limit use <i>GetParticlesMaxReached</i>. To reset the count and make it start
//   emitting again use <i>ResetParticleCount</i>.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   max -- The maximum number of particles to emit
// SOURCE
void agk::SetParticlesMax( uint32_t ID, int max )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d max, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetMaxParticles( max );
}

//****f* Particles/Properties/ResetParticleCount
// FUNCTION
//   Resets the emitted particle count when the emitter has been set with a maximum number of particles using
//   <i>SetParticlesMax</i>. You can check when the emitter has reached its maximum count using <i>GetParticlesMaxReached</i>.
//   If the maximum is set at -1 then this command has no effect.
// INPUTS
//   ID -- The ID of the emitter to modify.
// SOURCE
void agk::ResetParticleCount( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to reset particle emitter %d count, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->ResetParticleCount();
}

//****f* Particles/Properties/SetParticlesImage
// FUNCTION
//   Sets the image to use for each particle. Since 1083 images can be loaded from sub images contained
//   on atlas textures.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   imageID -- The ID of an image to use for emitted particles.
// SOURCE
void agk::SetParticlesImage( uint32_t ID, uint32_t imageID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d image, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = 0;
	if ( imageID > 0 )
	{
		pImage = m_cImageList.GetItem( imageID );
		if ( pImage == 0 )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "", 100 );
			errStr.Format( "Failed to set particle emitter %d image, image %d does not exist", ID, imageID );
			Error( errStr );
#endif
			return;
		}
	}

	pEmitter->SetImage( pImage );
}

//****f* Particles/Properties/SetParticlesVisible
// FUNCTION
//   Sets whether the emitted particles are drawn. Set to 1 to show particles, 0 to hide
//   them. Particles will still update whilst hidden, you can stop particles updating with <i>SetParticlesActive</i>
// INPUTS
//   ID -- The ID of the emitter to modify.
//   visible -- 1=show, 0=hide
// SOURCE
void agk::SetParticlesVisible( uint32_t ID, int visible )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d visibility, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetVisible( visible );
}

//****f* Particles/Properties/SetParticlesActive
// FUNCTION
//   Sets whether the emitted particles are updated every frame. Set to 1 to update particles as normal, 0 to pause
//   them. Particles will continue to be visible when paused. To hide particles use <i>SetParticlesVisible</i>.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   active -- 1=normal, 0=pause
// SOURCE
void agk::SetParticlesActive( uint32_t ID, int active )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d active, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetActive( active );
}

//****f* Particles/Properties/SetParticlesTransparency
// FUNCTION
//   Set the particle transparency to a particular setting, with a choice of no transparency, alpha transparency,
//   and additive blending. By default particles are created with alpha transparency.
// INPUTS
//   ID -- The ID of the particle emitter to modify.
//   mode -- The transparency mode for these particles, 0=off, 1=alpha transparency, 2=additive blending
// SOURCE
void agk::SetParticlesTransparency( uint32_t ID, int mode )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d transparency, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetTransparency( mode );
}


//****f* Particles/Properties/SetParticlesColorInterpolation
// FUNCTION
//   Sets the interpolation mode for color changes. Colors can be set at certain points in a particle's life using
//   <i>AddParticlesColorKeyFrame</i> and the particle will either blend between these colors or quickly change when it
//   reaches the next color change.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   mode -- 1=smooth interpolation, 0=no interpolation
// SOURCE
void agk::SetParticlesColorInterpolation( uint32_t ID, int mode )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set particle emitter %d color interpolation, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetColorInterpolation( mode );
}

//****f* Particles/Properties/GetParticlesX
// FUNCTION
//   Returns the current X position of the emitter, this is the point that new particles will appear from.
//   It is not possible to get the position of individual particles, they are merely created, follow a 
//   path influenced by forces, and then disappear.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::GetParticlesX( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d X, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetX();
}

//****f* Particles/Properties/GetParticlesY
// FUNCTION
//   Returns the current Y position of the emitter, this is the point that new particles will appear from.
//   It is not possible to get the position of individual particles, they are merely created, follow a 
//   path influenced by forces, and then disappear.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::GetParticlesY( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d Y, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetY();
}

//****f* Particles/Properties/GetParticlesDepth
// FUNCTION
//   Returns the current depth that all particles will be drawn at. This value is in the range 0 to 10000
//   with 0 being the front of the screen.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
int agk::GetParticlesDepth( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d depth, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetDepth();
}

//****f* Particles/Properties/GetParticlesVisible
// FUNCTION
//   Returns 0 if the given particles have been set as invisible using <i>SetParticlesVisible</i>, or 1 if they
//   are currently set as visible (default). This does not check if the particles are within the visible viewport.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
int agk::GetParticlesVisible( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d visibility, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetVisible();
}

//****f* Particles/Properties/GetParticlesActive
// FUNCTION
//   Returns 0 if the given particles have been paused using <i>SetParticlesActive</i>, or 1 if they
//   are currently updating as normal (default). 
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
int agk::GetParticlesActive( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d active, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetActive();
}

//****f* Particles/Properties/GetParticlesFrequency
// FUNCTION
//   Returns the current frequency of particle generation in particles per second. This value is independent 
//   of frame rate.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::GetParticlesFrequency( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d frequency, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetFrequency();
}

//****f* Particles/Properties/GetParticlesDirectionX
// FUNCTION
//   Returns the X component of the emitter direction, which is the base direction that particles will be
//   moving when they are created. Particles can vary their direction slightly when emitted based on the 
//   current <i>GetParticlesAngle</i> value.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::GetParticlesDirectionX( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d direction X, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetDirectionX();
}

//****f* Particles/Properties/GetParticlesDirectionY
// FUNCTION
//   Returns the y component of the emitter direction, which is the base direction that particles will be
//   moving when they are created. Particles can vary their direction slightly when emitted based on the 
//   current <i>SetParticlesAngle</i> value.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::GetParticlesDirectionY( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d direction Y, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetDirectionY();
}

//****f* Particles/Properties/GetParticlesAngle
// FUNCTION
//   Returns the current emitter angle in degrees. This value represents the amount of deviation a particle
//   can have from the emitter direction when emitted. An angle of 0 means there is no deviation while an 
//   angle of 360 means a particle can be travelling in any direction when emitted.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::GetParticlesAngle( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d angle, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetAngle();
}

//****f* Particles/Properties/GetParticlesAngleRad
// FUNCTION
//   Returns the current emitter angle in radians. This value represents the amount of deviation a particle
//   can have from the emitter direction when emitted. An angle of 0 means there is no deviation while an 
//   angle of 2*PI means a particle can be travelling in any direction when emitted.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::GetParticlesAngleRad( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d angle (in radians), emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetAngleRad();
}

//****f* Particles/Properties/GetParticlesSize
// FUNCTION
//   Returns the current size of all particles in world coordinates. For details on setting the particle size
//   see <i>SetParticlesSize</i>.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::GetParticlesSize( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d size, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetSize();
}

//****f* Particles/Properties/GetParticlesLife
// FUNCTION
//   Returns the current life of particles in seconds. It is not possible to get the current life of individual
//   particles. This value is independent of frame rate.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::GetParticlesLife( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d life, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetLife();
}

//****f* Particles/Properties/GetParticlesMaxReached
// FUNCTION
//   Returns 1 if the emitter has emitted the number of particles specified in <i>SetParticlesMax</i> and all emitted particles 
//   have since died, otherwise returns 0. If the max is set at -1 this will always return 0. To reset
//   the count and make the emitter start emitting again use <i>ResetParticleCount</i>.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
int agk::GetParticlesMaxReached( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d max reached, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetMaxParticlesReached();
}

//****f* Particles/Properties/AddParticlesForce
// FUNCTION
//   Adds a force that will act at a given time in every particle's life. For example a force set to start at time
//   2 and end at time 3 will start influencing particles when they have been alive for 2 seconds. It will continue 
//   to act on those particles until they have been alive for 3 seconds. The force's influence is defined by an x
//   and y value that represent acceleration in units per second. For example a force with x=5 will adjust a 
//   particle's horizontal speed by adding 5 units for every second the force is active, if the force is only active 
//   for 0.5 seconds the particle would then be moving 2.5 units per second faster towards the right.
//   Multiple forces can be acting on a particle at the same time if their timings overlap.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   starttime -- The time in a particle's life at which this force should start having an effect.
//   endtime -- The time in a particle's life at which this force should stop having an effect.
//   x -- The x component of the force's influence on a particle's speed in units per second.
//   y -- The y component of the force's influence on a particle's speed in units per second.
// SOURCE
void agk::AddParticlesForce( uint32_t ID, float starttime, float endtime, float x, float y )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to add particle emitter %d force, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->AddForce( starttime, endtime, x, y );
}

//****f* Particles/Properties/ClearParticlesForces
// FUNCTION
//   Clears all forces assigned to this emitter. All forces will immediately stop influencing particles.
// INPUTS
//   ID -- The ID of the emitter to modify.
// SOURCE
void agk::ClearParticlesForces( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to clear particle emitter %d forces, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->ClearForces();
}

//****f* Particles/Properties/AddParticlesColorKeyFrame
// FUNCTION
//   Adds a color change at a certain point in a particle's life. For example a color added with time=1
//   will make the particle equal the given color when it has been alive for 1 second. If color interpolation
//   is turned on using <i>SetParticlesColorInterpolation</i> the particle will gradually transform from its current 
//   color to the next color. For example if you add three colors, red when time=1, green when time=2, and blue when 
//   time=3, then the particle will start its life as red (as that is the nearest color) and remain completely red
//   until it is 1 second old. When the particle is between 1 and 2 seconds old it will gradually change from red
//   to green until it is 2 seconds old, at this point it is completely green. When the particle is between 2 and
//   3 seconds old it will gradually change from green to blue until it is 3 seconds old, at this point it is 
//   completely blue. The particle will remain completely blue until the end of its life as no other colors have
//   been added.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   time -- The time that particles should become this color.
//   red -- The red component of the new color.
//   green -- The green component of the new color.
//   blue -- The blue component of the new color.
//   alpha -- The alpha component of the new color.
// SOURCE
void agk::AddParticlesColorKeyFrame( uint32_t ID, float time, uint32_t red, uint32_t green, uint32_t blue, uint32_t alpha )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to add particle emitter %d color, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->AddColorKeyFrame( time, red, green, blue, alpha );
}

//****f* Particles/Properties/ClearParticlesColors
// FUNCTION
//   Clears all colors that have been assigned to the emitter, the particles will maintain whatever color
//   they currently have.
// INPUTS
//   ID -- The ID of the emitter to modify.
// SOURCE
void agk::ClearParticlesColors( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to clear particle emitter %d colors, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->ClearColors();
}

//****f* Particles/Properties/AddParticlesScaleKeyFrame
// FUNCTION
//   Adds a size change at a certain point in a particle's life. Scale values are relative to the value
//   set by <i>SetParticlesSize</i> so a scale of 2 means double its normal size and 0.5 is half its
//   normal size.
//   A scale added with time=1 will make the particle equal the given size when it has been alive for 1 
//   second. The particle will gradually transform from its current size to the next size. 
// INPUTS
//   ID -- The ID of the emitter to modify.
//   time -- The time that particles should become this size.
//   scale -- The scale relative to the normal particle size, must be greater then or equal to 0.
// SOURCE
void agk::AddParticlesScaleKeyFrame( uint32_t ID, float time, float scale )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to add particle emitter %d scale, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->AddScaleKeyFrame( time, scale );
}

//****f* Particles/Properties/ClearParticlesScales
// FUNCTION
//   Clears all size modifiers that have been assigned to the emitter, the particles will maintain whatever size
//   they currently are.
// INPUTS
//   ID -- The ID of the emitter to modify.
// SOURCE
void agk::ClearParticlesScales( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to clear particle emitter %d scales, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->ClearScales();
}

//****f* Particles/Properties/FixParticlesToScreen
// FUNCTION
//   Fixing particles to the screen will ensure they are not affected by scrolling of the viewport.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   mode -- Use 1 to fix to the screen. Use 0 to allow the particles to be affected by scrolling.
// SOURCE
void agk::FixParticlesToScreen( uint32_t ID, int mode )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to fix particle emitter %d to screen, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->FixToScreen( mode != 0 );
}

//****f* Particles/Properties/UpdateParticles
// FUNCTION
//   Immediately advances the particle emitter by the given amount of time. If you want to advance a high frequency emitter 
//   by a large time period such as 1 second you should call this command multiple times with a small time value such as 0.02
//   so that it creates new particles in batches and spreads them out evenly. Calling it once with a large time value
//   of 1 second would create a huge batch of particles all at once and move them together as a blob instead of spreading them out.
// INPUTS
//   ID -- The ID of the emitter to check.
//   time -- The time in seconds to advance the emitter.
// SOURCE
void agk::UpdateParticles( uint32_t ID, float time )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to update particle emitter %d, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->Update( time );
}

//****f* Particles/Properties/OffsetParticles
// FUNCTION
//   Immediately moves all existing particles by the given offset. For example an offset of x=3,y=5 would move
//   all particles to the right by 3 units and down 5 units. This does not affect the particle emitter
//   but can be used in conjunction with <i>SetParticlesPosition</i> to move both the emitter and the
//   particles that already exist.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   x -- The distance to move the particles in the X direction.
//   y -- The distance to move the particles in the Y direction.
// SOURCE
void agk::OffsetParticles( uint32_t ID, float x, float y )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to offset particle emitter %d, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->Offset( x,y );
}

//****f* Particles/Properties/DrawParticles
// FUNCTION
//   Immediately draws the particle emitter to the backbuffer at its current position, size, and rotation. This is 
//   useful if you want to take control of the order that things are drawn. If you do this then be sure 
//   to make the particles invisible before calling <i>Render</i> or <i>Sync</i> otherwise your particles will 
//   be drawn twice
// INPUTS
//   ID -- The ID of the emitter to draw.
// SOURCE
void agk::DrawParticles( uint32_t ID )
//****
{
	cParticleEmitter *pEmitter = m_cParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to draw particle emitter %d, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->DrawAll();
}

//
// Text functions
//

//****f* Text/Creation/CreateText
// FUNCTION
//   Creates a text object for displaying text on the screen. By default text is drawn at depth 9 above the default depth of 
//   sprites (10). Any sprites set to a depth of 8 or less will appear above the text. You can override this using <i>SetTextDepth</i>
//   to set your own draw order.
// INPUTS
//   iTextIndex -- The text ID to use to reference this text later (separate from image and sprite IDs, so there can be both a sprite 1 and a text 1)
//   string -- The initial string to use in this text object, can be an empty string.
// SOURCE
void agk::CreateText ( uint32_t iTextIndex, const char *string )
//****
{
	if ( m_cTextList.GetItem( iTextIndex ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add text " );
		errStr.AppendUInt( iTextIndex ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cText *pText = new cText();
	if ( string && *string ) pText->SetString( string );
	pText->m_iID = iTextIndex;
	pText->SetSpriteManager( &m_cSpriteMgrFront );

	m_cTextList.AddItem( pText, iTextIndex );
}

//****f* Text/Creation/CreateText
// FUNCTION
//   Creates a text object for displaying text on the screen using a blank ID, returns the ID used.
//   By default text is drawn at depth 9 above the default depth of sprites (10). Any sprites set to 
//   a depth of 8 or less will appear above the text. You can override this using <i>SetTextDepth</i>
//   to set your own draw order.
// INPUTS
//   string -- The initial string to use in this text object, can be an empty string.
// SOURCE
uint32_t agk::CreateText( const char *string )
//****
{
	uint32_t iID = m_cTextList.GetFreeID( MAX_TEXTS );
	
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add text " );
		errStr.Append( string ).Append( " - no free ID found" );
		Error( errStr );
#endif
		return 0;
	}

	agk::CreateText( iID, string );
	return iID;
}

//****f* Text/Properties/GetTextExists
// FUNCTION
//   Returns 1 if the text exists, 0 if not.
// INPUTS
//   iTextIndex -- The ID of the text to check
// SOURCE
uint32_t agk::GetTextExists( uint32_t iTextIndex )
//****
{
	if ( m_cTextList.GetItem( iTextIndex ) ) return 1;
	return 0;
}

//****f* Text/Creation/DeleteText
// FUNCTION
//   Deletes a text object.
// INPUTS
//   iTextIndex -- The ID of the text object to delete.
// SOURCE
void agk::DeleteText( uint32_t iTextIndex )
//****
{
	cText* pText = (cText*) m_cTextList.RemoveItem( iTextIndex );
	if ( pText ) 
	{
		delete pText;
	}
}

//****f* Text/Creation/DeleteAllText
// FUNCTION
//   Deletes all text objects create by CreateText. This also resets the auto text ID to 10000.
// SOURCE
void agk::DeleteAllText()
//****
{
	cText *pText = m_cTextList.GetFirst();
	while ( pText )
	{
		delete pText;		
		pText = m_cTextList.GetNext();
	}
	m_cTextList.ClearAll();
}

//****f* Text/Properties/SetTextString
// FUNCTION
//   Updates the string of a text object, the new text will be displayed on the next screen refresh.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   string -- The new string to use.
// SOURCE
void agk::SetTextString( uint32_t iTextIndex, const char *string )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetString( string );
}

//****f* Text/Properties/SetTextPosition
// FUNCTION
//   Updates the position of a text object in world coordinates,  by default the text is positioned using its top left corner.
//   When using right alignment the text is positioned using its top right corner. When using center alignment the text is 
//   positioned using a point halfway along its top edge.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   fX -- The new X position.
//   fY -- The new Y position.
// SOURCE
void agk::SetTextPosition( uint32_t iTextIndex, float fX, float fY )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetPosition( fX, fY );
}

//****f* Text/Properties/SetTextX
// FUNCTION
//   Updates the X position of a text object in world coordinates, by default the text is positioned using its top left corner.
//   When using right alignment the text is positioned using its top right corner. When using center alignment the text is 
//   positioned using a point halfway along its top edge.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   fX -- The new X position.
// SOURCE
void agk::SetTextX( uint32_t iTextIndex, float fX )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetX( fX );
}

//****f* Text/Properties/SetTextY
// FUNCTION
//   Updates the Y position of a text object in world coordinates, by default the text is positioned using its top left corner.
//   When using right alignment the text is positioned using its top right corner. When using center alignment the text is 
//   positioned using a point halfway along its top edge.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   fY -- The new Y position.
// SOURCE
void agk::SetTextY( uint32_t iTextIndex, float fY )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetY( fY );
}

//****f* Text/Properties/SetTextAngle
// FUNCTION
//   Updates the angle of the text. If the text is aligned to the left then it will rotate around its top left corner.
//   When using center alignment it will rotate around a point halfway along its top edge. When using right alignment
//   it will rotate around its top eight corner.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   fAngle -- The new angle in degrees.
// SOURCE
void agk::SetTextAngle( uint32_t iTextIndex, float fAngle )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetAngle( fAngle );
}

//****f* Text/Properties/SetTextAngleRad
// FUNCTION
//   Updates the angle of the text. If the text is aligned to the left then it will rotate around its top left corner.
//   When using center alignment it will rotate around a point halfway along its top edge. When using right alignment
//   it will rotate around its top eight corner.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   fAngleRad -- The new angle in radians.
// SOURCE
void agk::SetTextAngleRad( uint32_t iTextIndex, float fAngleRad )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetAngleRad( fAngleRad );
}

//****f* Text/Properties/SetTextAlignment
// FUNCTION
//   Sets how the text should be positioned on screen. Left alignment positions the text using its top left corner,
//   right alignment positions it using its top right corner, and center positions it using a point halfway along
//   its top edge.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   iMode -- The alignment mode to use. 0=left, 1=center, 2=right
// SOURCE
void agk::SetTextAlignment( uint32_t iTextIndex, int iMode )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetAlignment( iMode );
}

//****f* Text/Properties/SetTextSize
// FUNCTION
//   Sets the size of the text object, default is 4. This value represents the height of each character in world units.
//   The width of each character is dependant on the font and is calculated to match the given size.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   fSize -- The new size of the text.
// SOURCE
void agk::SetTextSize( uint32_t iTextIndex, float fSize )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetSize( fSize );
}

//****f* Text/Properties/SetTextSpacing
// FUNCTION
//   Sets the spacing between letters. A value of 0 puts no gap between the letter bounding boxes, a positive value
//   increases this gap, a negative value overlaps the letters. If each character is built with some space 
//   either side of it in the font image then that is the default amount of spacing and this command will
//   increase or decrease the spacing from that.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   fSpacing -- The new spacing to use.
// SOURCE
void agk::SetTextSpacing( uint32_t iTextIndex, float fSpacing )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetSpacing( fSpacing );
}

//****f* Text/Properties/SetTextLineSpacing
// FUNCTION
//   Sets the spacing between text lines. A value of 0 puts no gap between the lines, a positive value
//   increases this gap, a negative value overlaps the lines. If each character is built with some space 
//   above and below it in the font image then that is the default amount of spacing and this command will
//   increase or decrease the spacing from that.
// INPUTS
//   iTextIndex -- The ID of the text object to update.
//   fSpacing -- The new spacing to use.
// SOURCE
void agk::SetTextLineSpacing( uint32_t iTextIndex, float fSpacing )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetLineSpacing( fSpacing );
}

//****f* Text/Properties/SetTextDepth
// FUNCTION
//   Sets the draw order for the text between 0-10000, 0 being the front of the screen, 10000 being the back.
//   Anything more than 10000 will result in the text being clipped from view.<br><br>
//   By default text is set to depth 9 and appears above all other sprites in the scene, setting a greater depth 
//   will cause the text to be sorted into the transparent draw order list which may decrease performance.
//   Use depth 0 for best performance.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iDepth -- The depth this text should be drawn at.
// SOURCE
void agk::SetTextDepth( uint32_t iTextIndex, int iDepth )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetDepth( iDepth );
}

//****f* Text/Properties/SetTextVisible
// FUNCTION
//   Sets whether the text is drawn during screen refreshes.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   bVisible -- 1 to draw this text, 0 to hide it.
// SOURCE
void agk::SetTextVisible( uint32_t iTextIndex, int bVisible )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetVisible( bVisible>0 );
}

//****f* Text/Properties/SetTextColor
// FUNCTION
//   Set the color of the text, the values should be in the range 0-255. This will set all characters
//   in the text to be this color. You can set individual characters using <i>SetTextCharColor</i>.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iRed -- The red component of the color.
//   iGreen -- The green component of the color.
//   iBlue -- The blue component of the color.
//   iAlpha -- The alpha component of the color.
// SOURCE
void agk::SetTextColor( uint32_t iTextIndex, uint32_t iRed, uint32_t iGreen, uint32_t iBlue, uint32_t iAlpha )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetColor( iRed, iGreen, iBlue, iAlpha );
}

//****f* Text/Properties/SetTextColorRed
// FUNCTION
//   Set the red component of the text color. The value should be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iRed -- The red component of the color.
// SOURCE
void agk::SetTextColorRed( uint32_t iTextIndex, uint32_t iRed )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetRed( iRed );
}

//****f* Text/Properties/SetTextColorGreen
// FUNCTION
//   Set the green component of the text color. The value should be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iGreen -- The green component of the color.
// SOURCE
void agk::SetTextColorGreen( uint32_t iTextIndex, uint32_t iGreen )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetGreen( iGreen );
}

//****f* Text/Properties/SetTextColorBlue
// FUNCTION
//   Set the blue component of the text color. The value should be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iBlue -- The blue component of the color.
// SOURCE
void agk::SetTextColorBlue( uint32_t iTextIndex, uint32_t iBlue )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetBlue( iBlue );
}

//****f* Text/Properties/SetTextColorAlpha
// FUNCTION
//   Set the alpha component of the text color. The value should be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iAlpha -- The alpha component of the color.
// SOURCE
void agk::SetTextColorAlpha( uint32_t iTextIndex, uint32_t iAlpha )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetAlpha( iAlpha );
}

//****f* Text/Properties/GetTextColorRed
// FUNCTION
//   Get the red component of the text color. The value will be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text to check.
// SOURCE
uint32_t agk::GetTextColorRed( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return agk::Round( pText->GetRed() * 255 );
}

//****f* Text/Properties/GetTextColorGreen
// FUNCTION
//   Get the green component of the text color. The value will be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text to check.
// SOURCE
uint32_t agk::GetTextColorGreen( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return agk::Round( pText->GetGreen( ) * 255 );
}

//****f* Text/Properties/GetTextColorBlue
// FUNCTION
//   Get the blue component of the text color. The value will be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text to check.
// SOURCE
uint32_t agk::GetTextColorBlue( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return agk::Round( pText->GetBlue( ) * 255 );
}

//****f* Text/Properties/GetTextColorAlpha
// FUNCTION
//   Get the alpha component of the text color. The value will be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text to check.
// SOURCE
uint32_t agk::GetTextColorAlpha( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return agk::Round( pText->GetAlpha( ) * 255 );
}

//****f* Text/Properties/SetTextCharPosition
// FUNCTION
//   Set the position of an individual character relative to the text position set earlier. The character will be
//   positioned using its top left corner. If any of the following commands are called the position of all characters 
//   will be reset to a straight line: <i>SetTextPosition</i>, <i>SetTextX</i>, <i>SetTextY</i>, <i>SetTextSize</i>, <i>SetTextSpacing</i>, 
//   <i>SetTextAlignment</i>. Positioning characters within a text object is more efficient than positioning lots of small
//   text objects each containing a character as all the characters can be drawn in a single draw call.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iCharIndex -- The index of the character to modify, indexes start at 0, if the index is out of range it will be ignored.
//   x -- The new X position of the character, relative to the current text position.
//   y -- The new Y position of the character, relative to the current text position.
// SOURCE
void agk::SetTextCharPosition( uint32_t iTextIndex, uint32_t iCharIndex, float x, float y )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharPosition( iCharIndex, x, y );
}

//****f* Text/Properties/SetTextCharX
// FUNCTION
//   Set the X position of an individual character relative to the text position set earlier. The character will be
//   positioned using its top left corner. If any of the following commands are called the position of all characters 
//   will be reset to a straight line: <i>SetTextPosition</i>, <i>SetTextX</i>, <i>SetTextY</i>, <i>SetTextSize</i>, <i>SetTextSpacing</i>, 
//   <i>SetTextAlignment</i>. Positioning characters within a text object is more efficient than positioning lots of small
//   text objects each containing a character as all the characters can be drawn in a single draw call.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iCharIndex -- The index of the character to modify, indexes start at 0, if the index is out of range it will be ignored.
//   x -- The new X position of the character, relative to the current text position.
// SOURCE
void agk::SetTextCharX( uint32_t iTextIndex, uint32_t iCharIndex, float x )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharX( iCharIndex, x );
}

//****f* Text/Properties/SetTextCharY
// FUNCTION
//   Set the Y position of an individual character relative to the text position set earlier. The character will be
//   positioned using its top left corner. If any of the following commands are called the position of all characters 
//   will be reset to a straight line: <i>SetTextPosition</i>, <i>SetTextX</i>, <i>SetTextY</i>, <i>SetTextSize</i>, <i>SetTextSpacing</i>, 
//   <i>SetTextAlignment</i>. Positioning characters within a text object is more efficient than positioning lots of small
//   text objects each containing a character as all the characters can be drawn in a single draw call.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iCharIndex -- The index of the character to modify, indexes start at 0, if the index is out of range it will be ignored.
//   y -- The new Y position of the character, relative to the current text position.
// SOURCE
void agk::SetTextCharY( uint32_t iTextIndex, uint32_t iCharIndex, float y )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharY( iCharIndex, y );
}

//****f* Text/Properties/SetTextCharAngle
// FUNCTION
//   Set the angle of an individual character in degrees, clockwise. The character will rotate around its center. If 
//   any of the following commands are called the rotation of all characters will be reset: <i>SetTextPosition</i>, 
//   <i>SetTextX</i>, <i>SetTextY</i>, <i>SetTextSize</i>, <i>SetTextSpacing</i>, <i>SetTextAlignment</i>.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iCharIndex -- The index of the character to modify, indexes start at 0, if the index is out of range it will be ignored.
//   angle -- The new angle in degrees.
// SOURCE
void agk::SetTextCharAngle( uint32_t iTextIndex, uint32_t iCharIndex, float angle )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharAngle( iCharIndex, angle );
}

//****f* Text/Properties/SetTextCharAngleRad
// FUNCTION
//   Set the angle of an individual character in radians, clockwise. The character will rotate around its center. If 
//   any of the following commands are called the rotation of all characters will be reset: <i>SetTextPosition</i>, 
//   <i>SetTextX</i>, <i>SetTextY</i>, <i>SetTextSize</i>, <i>SetTextSpacing</i>, <i>SetTextAlignment</i>.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   iCharIndex -- The index of the character to modify, indexes start at 0, if the index is out of range it will be ignored.
//   angle -- The new angle in radians.
// SOURCE
void agk::SetTextCharAngleRad( uint32_t iTextIndex, uint32_t iCharIndex, float angle )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharAngleRad( iCharIndex, angle );
}

//****f* Text/Properties/SetTextCharColor
// FUNCTION
//   Sets the color of the specified character. Using the <i>SetTextColor</i> command will override this.
//   Values should be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text object to set.
//   iCharIndex -- The index of the character to set, indexes start at 0, if the index is out of range it will be ignored.
//   red -- the red component of the new color.
//   green -- the green component of the new color.
//   blue -- the blue component of the new color.
//   alpha -- the alpha component of the new color.
// SOURCE
void agk::SetTextCharColor( uint32_t iTextIndex, uint32_t iCharIndex, uint32_t red, uint32_t green, uint32_t blue, uint32_t alpha )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharColor( iCharIndex, red, green ,blue, alpha );
}

//****f* Text/Properties/SetTextCharColorRed
// FUNCTION
//   Sets the red component of the specified characters color. Using the <i>SetTextColor</i> command will override this.
//   Values should be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text object to set.
//   iCharIndex -- The index of the character to set, indexes start at 0, if the index is out of range it will be ignored.
//   red -- The new red value to use
// SOURCE
void agk::SetTextCharColorRed( uint32_t iTextIndex, uint32_t iCharIndex, uint32_t red )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharRed( iCharIndex, red );
}

//****f* Text/Properties/SetTextCharColorGreen
// FUNCTION
//   Sets the green component of the specified character's color. Using the <i>SetTextColor</i> command will override this.
//   Values should be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text object to set.
//   iCharIndex -- The index of the character to set, indexes start at 0, if the index is out of range it will be ignored.
//   green -- The new green value to use
// SOURCE
void agk::SetTextCharColorGreen( uint32_t iTextIndex, uint32_t iCharIndex, uint32_t green )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharGreen( iCharIndex, green );
}

//****f* Text/Properties/SetTextCharColorBlue
// FUNCTION
//   Sets the blue component of the specified character's color. Using the <i>SetTextColor</i> command will override this.
//   Values should be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text object to set.
//   iCharIndex -- The index of the character to set, indexes start at 0, if the index is out of range it will be ignored.
//   blue -- The new blue value to use
// SOURCE
void agk::SetTextCharColorBlue( uint32_t iTextIndex, uint32_t iCharIndex, uint32_t blue )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharBlue( iCharIndex, blue );
}

//****f* Text/Properties/SetTextCharColorAlpha
// FUNCTION
//   Sets the alpha component of the specified character's color. Using the <i>SetTextColor</i> command will override this.
//   Values should be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text object to set.
//   iCharIndex -- The index of the character to set, indexes start at 0, if the index is out of range it will be ignored.
//   alpha -- The new alpha value to use
// SOURCE
void agk::SetTextCharColorAlpha( uint32_t iTextIndex, uint32_t iCharIndex, uint32_t alpha )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharAlpha( iCharIndex, alpha );
}

//****f* Text/Properties/SetTextCharBold
// FUNCTION
//   Sets the character to have the bold style. This only applies if the text is using a TrueType font set with <i>SetTextFont</i>.
//   If you use <i>SetTextString</i> then this setting will be reset to 0. You can use <i>SetTextBold</i> to set the entire string 
//   to bold.
// INPUTS
//   iTextIndex -- The ID of the text object to set.
//   iCharIndex -- The index of the character to set, indexes start at 0, if the index is out of range it will be ignored.
//   bold -- 1 to set the character as bold, 0 to set it as normal weight (default)
// SOURCE
void agk::SetTextCharBold( uint32_t iTextIndex, uint32_t iCharIndex, uint32_t bold )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetCharBold( iCharIndex, bold );
}

//****f* Text/Properties/GetTextCharX
// FUNCTION
//   Returns the current X position of the specified character relative to the text object.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
//   iCharIndex -- The index of the character to check, indexes start at 0, if the index is out of range it will be ignored.
// SOURCE
float agk::GetTextCharX( uint32_t iTextIndex, uint32_t iCharIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetCharX( iCharIndex );
}

//****f* Text/Properties/GetTextCharY
// FUNCTION
//   Returns the current Y position of the specified character relative to the text object.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
//   iCharIndex -- The index of the character to check, indexes start at 0, if the index is out of range it will be ignored.
// SOURCE
float agk::GetTextCharY( uint32_t iTextIndex, uint32_t iCharIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetCharY( iCharIndex );
}

//****f* Text/Properties/GetTextCharAngle
// FUNCTION
//   Returns the current angle in degrees of the specified character.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
//   iCharIndex -- The index of the character to check, indexes start at 0, if the index is out of range it will be ignored.
// SOURCE
float agk::GetTextCharAngle( uint32_t iTextIndex, uint32_t iCharIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetCharAngle( iCharIndex );
}

//****f* Text/Properties/GetTextCharAngleRad
// FUNCTION
//   Returns the current angle in radians of the specified character.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
//   iCharIndex -- The index of the character to check, indexes start at 0, if the index is out of range it will be ignored.
// SOURCE
float agk::GetTextCharAngleRad( uint32_t iTextIndex, uint32_t iCharIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetCharAngleRad( iCharIndex );
}

//****f* Text/Properties/GetTextCharColorRed
// FUNCTION
//   Returns the red component of the given character color. The value will be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
//   iCharIndex -- The index of the character to check, indexes start at 0, if the index is out of range it will be ignored.
// SOURCE
uint32_t agk::GetTextCharColorRed( uint32_t iTextIndex, uint32_t iCharIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetCharRed( iCharIndex );
}

//****f* Text/Properties/GetTextCharColorGreen
// FUNCTION
//   Returns the green component of the given character color. The value will be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
//   iCharIndex -- The index of the character to check, indexes start at 0, if the index is out of range it will be ignored.
// SOURCE
uint32_t agk::GetTextCharColorGreen( uint32_t iTextIndex, uint32_t iCharIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetCharGreen( iCharIndex );
}

//****f* Text/Properties/GetTextCharColorBlue
// FUNCTION
//   Returns the blue component of the given character color. The value will be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
//   iCharIndex -- The index of the character to check, indexes start at 0, if the index is out of range it will be ignored.
// SOURCE
uint32_t agk::GetTextCharColorBlue( uint32_t iTextIndex, uint32_t iCharIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetCharBlue( iCharIndex );
}

//****f* Text/Properties/GetTextCharColorAlpha
// FUNCTION
//   Returns the alpha component of the given character color. The value will be in the range 0-255.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
//   iCharIndex -- The index of the character to check, indexes start at 0, if the index is out of range it will be ignored.
// SOURCE
uint32_t agk::GetTextCharColorAlpha( uint32_t iTextIndex, uint32_t iCharIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetCharAlpha( iCharIndex );
}

//****f* Text/Properties/GetTextX
// FUNCTION
//   Returns the current X position of a text object in world coordinates, the text is positioned using its top left corner.
// INPUTS
//   iTextIndex -- The ID of the text object to return.
// SOURCE
float agk::GetTextX( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetX( );
}

//****f* Text/Properties/GetTextY
// FUNCTION
//   Returns the current Y position of a text object in world coordinates, the text is positioned using its top left corner.
// INPUTS
//   iTextIndex -- The ID of the text object to return.
// SOURCE
float agk::GetTextY( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetY( );
}

//****f* Text/Properties/GetTextLength
// FUNCTION
//   Returns the current length of the string the text object is displaying.
// INPUTS
//   iTextIndex -- The ID of the text object to return.
// SOURCE
uint32_t agk::GetTextLength( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetLength( );
}

//****f* Text/Properties/GetTextTotalWidth
// FUNCTION
//   Returns the current width of the text object in world units. If the text object is displaying text over multiple
//   lines it will return the width of the longest line. This does not take into account the individual offsets of 
//   characters, if you have used <i>SetTextCharX</i> or similar to move a character. The returned value is the width used
//   by the default drawing position of the text characters.
// INPUTS
//   iTextIndex -- The ID of the text object to return.
// SOURCE
float agk::GetTextTotalWidth( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetTotalWidth( );
}

//****f* Text/Properties/GetTextTotalHeight
// FUNCTION
//   Returns the current height of the text object in world units. This does not take into account the individual 
//   offsets of characters, if you have used <i>SetTextCharY</i> or similar to move a character. The returned value is 
//   the height used by the default drawing position of the text characters. Note that if the string of the text is
//   empty then this value will return 0.
// INPUTS
//   iTextIndex -- The ID of the text object to return.
// SOURCE
float agk::GetTextTotalHeight( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetTotalHeight( );
}

//****f* Text/Properties/GetTextHitTest
// FUNCTION
//   Returns 1 if the given point in world coordinates is inside the bounding box of the text.
//   If you are testing a mouse or touch coordinate, remember to convert it to world 
//   coordinates using <i>ScreenToWorldX</i> and <i>ScreenToWorldY</i>.<br><Br>
//   This does not take into account individual character positions, for example if you have 
//   positioned a character using <i>SetTextCharX</i> or similar. Only the bounding box created by
//   drawing the characters in their default positions is checked.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
//   x -- The x coordinate of the point to check in world coordinates.
//   y -- The y coordinate of the point to check in world coordinates.
// SOURCE
int agk::GetTextHitTest( uint32_t iTextIndex, float x, float y )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetHitTest( x, y ) ? 1 : 0;
}

//****f* Text/Properties/SetTextFontImage
// FUNCTION
//   Sets the font to use for this text object. AGK has a built in font that it uses for text objects,
//   this allows you to override it. If you are setting all your text objects to the same font you should use 
//   <i>SetTextDefaultFontImage</i> instead as this will save some processing time.<br><br>
//   The image should contain all white characters surrounded by a transparent alpha channel. Fully transparent 
//   pixels should also contain white in their RGB components.<br><br>
//   The font image may either be fixed width or variable width. For fixed width the font image must be laid out
//   in a grid of 16 characters across and 6 characters down, starting with the ascii character 32 (space) in 
//   the top left and proceeding left to right, top to bottom, ending with ascii character 127 (DEL) in the 
//   bottom right. The image width must be divisible by 16 and the image height must be divisible by 6. 
//   For variable width the image must be an atlas texture accompanied by a subimages.txt file that states the
//   location of each character on the image. The AGK will look for images "32" up to and including "127"
//   in the subimages file and any not found will default to the space character (32).
//   Variable height characters are not supported and all characters must be the same height with any necessary
//   padding included in the font image.<br/><br/>
//   As of version 2.0.20 you can use <i>SetTextFont</i> to use TrueType fonts instead of bitmap fonts. You must
//   choose one or the other, setting a bitmap font will remove the Truetype font, and setting a TrueType font
//   will remove the bitmap font.
// INPUTS
//   iTextIndex -- The ID of the text object to modify
//   iImageID -- The image containing the new font.
// SOURCE
void agk::SetTextFontImage( uint32_t iTextIndex, uint32_t iImageID )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set text font image - Text ", 50 );  
		errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = 0;
	if ( iImageID > 0 )
	{
		pImage = m_cImageList.GetItem( iImageID );
		if ( !pImage )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set text font image - Image ", 50 );  
			errStr.AppendInt( iImageID ); errStr.Append( " does not exist" );
			Error( errStr );
#endif	
			return;
		}
	}

	pText->SetFontImage( pImage );
}

//****f* Text/Properties/SetTextExtendedFontImage
// FUNCTION
//   Sets the extended font to use for this text object. The extended font is for non standard characters
//   above ascii value 127 and can be set separately to the standard characters so you can have multiple
//   images for the extended set and a base image for the normal font characters.
//   AGK has a built in extended font that it uses for text objects with characters 128 to 255, this 
//   command allows you to override it. If you are setting all your text objects to the same extended font 
//   you should use <i>SetTextDefaultExtendedFontImage</i> instead as this will save some processing time.<br><br>
//   The image should contain all white characters surrounded by a transparent alpha channel. Fully transparent 
//   pixels should also contain white in their RGB components.<br><br>
//   The font image may either be fixed width or variable width. For fixed width the font image must be laid out
//   in a grid of 16 characters across and 8 characters down, starting with the ascii character 32 (space) in 
//   the top left and proceeding left to right, top to bottom, ending with ascii character 127 (DEL) in the 
//   bottom right. The image width must be divisible by 16 and the image height must be divisible by 6. 
//   For variable width the image must be an atlas texture accompanied by a subimages.txt file that states the
//   location of each character on the image. The AGK will look for images "32" up to and including "127"
//   in the subimages file and any not found will default to the space character (32).
//   Variable height characters are not supported and all characters must be the same height with any necessary
//   padding included in the font image.<br/><br/>
//   If this text object is using a TrueType font then this command has no affect, the TrueType font handles 
//   both normal and extended (unicode) characters.
// INPUTS
//   iTextIndex -- The ID of the text object to modify
//   iImageID -- The image containing the new font.
// SOURCE
void agk::SetTextExtendedFontImage( uint32_t iTextIndex, uint32_t iImageID )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set text extended font image - Text ", 50 );  
		errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = 0;
	if ( iImageID > 0 )
	{
		pImage = m_cImageList.GetItem( iImageID );
		if ( !pImage )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set text extended font image - Image ", 50 );  
			errStr.AppendInt( iImageID ); errStr.Append( " does not exist" );
			Error( errStr );
#endif	
			return;
		}
	}

	pText->SetExtendedFontImage( pImage );
}

//****f* Text/Properties/SetTextFont
// FUNCTION
//   Sets the TrueType font to use for this text object. The font must have been loaded with <i>LoadFont</i> from
//   a TrueType font file. This is different from the old bitmap fonts in that it supports unicode characters
//   and the characters will usually appear sharper on screen at all sizes. <br/>
//   Note that resizing a text object that is using a TrueType font will redraw all the characters from the font 
//   file onto an image for drawing, for large text sizes using hundreds of different unicode characters this 
//   could be a slow process but in normal use it is usually not noticeable. <br/>
//   Recently used sizes are kept for a short period of time so if you are frequently switching between two or 
//   three text sizes then no redrawing will need to be done and it will be faster. <br/>
//   Use a font ID of 0 to use the built in TrueType font that supports a wide range of unicode characters.
// INPUTS
//   iTextIndex -- The ID of the text object to change.
//   iFontID -- The ID of the font to use.
// SOURCE
void agk::SetTextFont( uint32_t iTextIndex, uint32_t iFontID )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set text font - Text ", 50 );  
		errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	AGKFont *pFont = 0;
	if ( iFontID > 0 )
	{
		pFont = m_cFontList.GetItem( iFontID );
		if ( !pFont )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set text font - Font ", 50 );  
			errStr.AppendInt( iFontID ); errStr.Append( " does not exist" );
			Error( errStr );
#endif	
			return;
		}
	}

	pText->SetFont( pFont );
}

//****f* Text/Properties/SetTextDefaultFontImage
// FUNCTION
//   Sets the default font to use for text objects. The AGK has a built in font that it uses for text objects, 
//   this allows you to override it. If you do choose to override it you must do so before creating any text 
//   objects. You can set the font on a per text basis using <i>SetTextFontImage</i>. The image should contain 
//   all white characters surrounded by a transparent alpha channel. Fully transparent pixels should also 
//   contain white in their RGB components.<br><br>
//   The font image may either be fixed width or variable width. For fixed width the font image must be laid out
//   in a grid of 16 characters across and 6 characters down, starting with the ascii character 32 (space) in 
//   the top left and proceeding left to right, top to bottom, ending with ascii character 127 (DEL) in the 
//   bottom right. The image width must be divisible by 16 and the image height must be divisible by 6. 
//   For variable width the image must be an atlas texture accompanied by a subimages.txt file that states the
//   location of each character on the image. The AGK will look for images "32" up to and including "127"
//   in the subimages file and any not found will default to the space character (32).
// INPUTS
//   iImageID -- The image containing the new font.
// SOURCE
void agk::SetTextDefaultFontImage( uint32_t iImageID )
//****
{
	cImage *pImage = 0;
	if ( iImageID > 0 )
	{
		pImage = m_cImageList.GetItem( iImageID );
		if ( !pImage )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set text default font image - Image ", 50 );  
			errStr.AppendInt( iImageID ); errStr.Append( " does not exist" );
			Error( errStr );
#endif	
			return;
		}
	}

	cText::SetDefaultFontImage( pImage );
}

//****f* Text/Properties/SetTextDefaultExtendedFontImage
// FUNCTION
//   Sets the default extended font to use for text objects. The extended font is for non standard characters
//   above ascii value 127 and can be set separately to the standard characters so you can have multiple
//   images for the extended set and a base image for the normal font characters.<br><br>
//   The AGK has a built in extended font for characters 128 to 255 that it uses for text objects, this allows 
//   you to override it. If you do choose to override it you must do so before creating any text objects. 
//   You can set the font on a per text basis using <i>SetTextExtendedFontImage</i>. The image should contain all 
//   white characters surrounded by a transparent alpha channel. Fully transparent pixels should also contain 
//   white in their RGB components.<br><br>
//   The extended font image may either be fixed width or variable width. For fixed width the font image must be laid out
//   in a grid of 16 characters across and 8 characters down, starting with the ascii character 128 in the top left and 
//   proceeding left to right, top to bottom, ending with ascii character 255 in the bottom right. The image width must 
//   be divisible by 16 and the image height must be divisible by 8. For variable width the image must be an atlas texture 
//   accompanied by a subimages.txt file that states the location of each character on the image. The AGK will look for 
//   images "128" up to and including "255" in the subimages file and any not found will default to the space character (32).
// INPUTS
//   iImageID -- The image containing the new font.
// SOURCE
void agk::SetTextDefaultExtendedFontImage( uint32_t iImageID )
//****
{
	cImage *pImage = 0;
	if ( iImageID > 0 )
	{
		pImage = m_cImageList.GetItem( iImageID );
		if ( !pImage )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set text default extended font image - Image ", 50 );  
			errStr.AppendInt( iImageID ); errStr.Append( " does not exist" );
			Error( errStr );
#endif	
			return;
		}
	}

	cText::SetDefaultExtendedFontImage( pImage );
}


//****f* Text/Properties/SetTextDefaultMinFilter
// FUNCTION
//   Sets the image filter for all text objects and print functions that are using the default font when 
//   the text image is smaller than the screen space it occupies. Nearest filtering chooses the closest 
//   pixel to display and can look blocky. Linear filtering blends the 4 closest pixels and can look blurry.
// INPUTS
//   mode -- The filtering mode to use, 0=nearest, 1=linear
// SOURCE
void agk::SetTextDefaultMinFilter( uint32_t mode )
//****
{
	cText::SetDefaultMinFilter( mode );
}

//****f* Text/Properties/SetTextDefaultMagFilter
// FUNCTION
//   Sets the image filter for all text objects and print functions that are using the default font when 
//   the text image is larger than the screen space it occupies. Nearest filtering chooses the closest 
//   pixel to display and can look blocky. Linear filtering blends the 4 closest pixels and can look blurry.
// INPUTS
//   mode -- The filtering mode to use, 0=nearest, 1=linear
// SOURCE
void agk::SetTextDefaultMagFilter( uint32_t mode )
//****
{
	cText::SetDefaultMagFilter( mode );
}

//****f* Text/Properties/FixTextToScreen
// FUNCTION
//   By default text objects are created in world coordinates and <i>SetViewOffset</i> can be used to move around the world.
//   Use this command to instead fix the text to the screen so it will move with the viewport when the viewport 
//   is moved around. You can still reposition a text that is fixed to the screen, it only affects what happens 
//   when the viewport is moved.
// INPUTS
//   iTextIndex -- The ID of the text to change.
//   mode -- 1=screen text, 0=world text
// SOURCE
void agk::FixTextToScreen( uint32_t iTextIndex, int mode )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	return pText->FixToScreen( mode );
}

//****f* Text/Properties/SetTextMaxWidth
// FUNCTION
//   Sets the maximum width the text object will use to draw, any characters that extend beyond this
//   value will wrap onto a new line.
// INPUTS
//   iTextIndex -- The ID of the text object to modify
//   width -- The maximum width the text will use
// SOURCE
void agk::SetTextMaxWidth( uint32_t iTextIndex, float width )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetMaxWidth( width );
}

//****f* Text/Properties/SetTextScissor
// FUNCTION
//   Clips the text to the specified world coordinates when drawn. Use the values 0,0,0,0 to turn off
//   the text scissor
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   x -- The x coordinate of the top left corner of the box to use as a clip boundary.
//   y -- The y coordinate of the top left corner of the box to use as a clip boundary.
//   x2 -- The x coordinate of the bottom right corner of the box to use as a clip boundary.
//   y2 -- The y coordinate of the bottom right corner of the box to use as a clip boundary.
// SOURCE
void agk::SetTextScissor( uint32_t iTextIndex, float x, float y, float x2, float y2 )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetScissor( x,y, x2,y2 );
}

//****f* Text/Properties/SetTextTransparency
// FUNCTION
//   Set the text transparency to a particular setting, with a choice of no transparency, alpha transparency,
//   and additive blending. By default text is created with alpha transparency.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   mode -- The transparency mode for this text, 0=off, 1=alpha transparency, 2=additive blending
// SOURCE
void agk::SetTextTransparency( uint32_t iTextIndex, int mode )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetTransparency( mode );
}

//****f* Text/Properties/SetTextBold
// FUNCTION
//   Sets all characters in the text to bold regardless of the current <i>SetTextCharBold</i> state.
//   This setting will remain active until it is changed, setting a new text string will not change it.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   bold -- 1 to use bold, 0 to use normal weight (default)
// SOURCE
void agk::SetTextBold( uint32_t iTextIndex, uint32_t bold )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->SetBold( bold );
}


//****f* Text/Properties/SetTextShader
// FUNCTION
//   Sets the shader used to draw this Text, loaded with <i>Loadshader</i>.
//   By default Text objects are assigned an internal shader that can handle 1 texture and a color.
//   If you use a shader ID of 0 the Text is assigned the internal shader.
// INPUTS
//   iTextIndex -- The ID of the text to modify.
//   shaderID	-- The ID of the shader to use.
// SOURCE
void agk::SetTextShader(UINT iTextIndex, UINT shaderID)
//****
{
	cText* pText = m_cTextList.GetItem(iTextIndex);
	if (!pText)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr("Failed to set shader for text ");
		errStr.AppendUInt(iTextIndex).Append(" - text does not exist");
		Error(errStr);
#endif
		return;
	}

	AGKShader* pShader = 0;
	if (shaderID > 0)
	{
		pShader = m_cShaderList.GetItem(shaderID);
		if (!pText)
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr("Failed to set shader for text ");
			errStr.AppendUInt(iTextIndex).Append(" - shader ");
			errStr.AppendUInt(shaderID).Append(" does not exist");
			Error(errStr);
#endif
			return;
		}
	}

	pText->SetShader(pShader);
}

//****f* Text/Properties/SetTextShaderConstantByName
// FUNCTION
//   Sets a shader constant for a text by name, the constant must be marked as "uniform" in the shader source.
//   The Text will set the specified constant to this value for any shader that it is applied to it.
//   All shader values have 1 to 4 components, this command accepts 4 values and discards any that are not used 
//   by the named variable.
// INPUTS
//   textID	  -- The ID of the text to modify.
//   szName   -- The name of the constant to change, as defined in the shader source file.
//   value1   -- The X or R component of the new value, this value will always be used.
//   value2   -- The Y or G component of the new value, if the constant only uses 1 component this value is discarded.
//   value3   -- The Z or B component of the new value, if the constant only uses 2 components this value is discarded.
//   value4   -- The W or A component of the new value, if the constant only uses 3 components this value is discarded.
// SOURCE
void agk::SetTextShaderConstantByName(UINT iTextIndex, const char* szName, float value1, float value2, float value3, float value4)
//****
{
	cText* pText = m_cTextList.GetItem(iTextIndex);
	if (!pText) {
#ifdef _AGK_ERROR_CHECK
		uString errStr("Failed to set shader constant for object ");
		errStr.AppendUInt(iTextIndex).Append(" - text does not exist");
		Error(errStr);
#endif
		return;
	}

	pText->SetShaderConstantByName(szName, value1, value2, value3, value4);
}

//****f* Text/Properties/SetTextShaderConstantArrayByName
// FUNCTION
//   Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.
//   Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will 
//   be made.
//   This will affect only the specified text this shader.
//   All shader values have 1 to 4 components, this command accepts 4 values and discards any that are not used 
//   by the named variable.
// INPUTS
//   textID     -- The ID of the text to modify.
//   szName     -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The element of the array to modify.
//   value1     -- The X or R component of the new value, this value will always be used.
//   value2     -- The Y or G component of the new value, if the constant only uses 1 component this value is discarded.
//   value3     -- The Z or B component of the new value, if the constant only uses 2 components this value is discarded.
//   value4     -- The W or A component of the new value, if the constant only uses 3 components this value is discarded.
// SOURCE
void agk::SetTextShaderConstantArrayByName(UINT iTextIndex, const char* szName, UINT arrayIndex, float value1, float value2, float value3, float value4)
//****
{
	cText* pText = m_cTextList.GetItem(iTextIndex);
	if (!pText) {
#ifdef _AGK_ERROR_CHECK
		uString errStr("Failed to set shader constant for object ");
		errStr.AppendUInt(iTextIndex).Append(" - text does not exist");
		Error(errStr);
#endif
		return;
	}

	pText->SetShaderConstantArrayByName(szName, arrayIndex, 4, value1, value2, value3, value4);
}

//****f* Text/Properties/SetTextShaderConstantDefault
// FUNCTION
//   Stops a text setting the given constant name in its shaders and uses the shader's default value from now on.
// INPUTS
//   iTextIndex	-- The ID of the text to modify.
//   szName     -- The name of the constant to stop changing.
// SOURCE
void agk::SetTextShaderConstantDefault(UINT iTextIndex, const char* szName)
//****
{
	cText* pText = m_cTextList.GetItem(iTextIndex);
	if (!pText) {
#ifdef _AGK_ERROR_CHECK
		uString errStr("Failed to set shader constant default for object ");
		errStr.AppendUInt(iTextIndex).Append(" - text does not exist");
		Error(errStr);
#endif
		return;
	}

	pText->SetShaderConstantDefault(szName);
}

//****f* Text/Properties/GetTextVisible
// FUNCTION
//   Returns 0 if the current text has been set as invisible using <i>SetTextVisible</i>, 1 if it is set as visible (default).
//   This does not check if the text is currently positioned withing the visible viewport.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
// SOURCE
int agk::GetTextVisible( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetVisible() ? 1 : 0;
}

//****f* Text/Properties/GetTextDepth
// FUNCTION
//   Returns the current depth of the text object, with 0 being the front of the screen and 10000 being the back.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
// SOURCE
int agk::GetTextDepth( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetDepth();
}

//****f* Text/Properties/GetTextSize
// FUNCTION
//   Returns the current size of the text object set with <i>SetTextSize</i>.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
// SOURCE
float agk::GetTextSize( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetSize();
}

//****f* Text/Properties/GetTextSpacing
// FUNCTION
//   Returns the current spacing of the text object set with <i>SetTextSpacing</i>.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
// SOURCE
float agk::GetTextSpacing( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetSpacing();
}

//****f* Text/Properties/GetTextLineSpacing
// FUNCTION
//   Returns the current line spacing of the text object set with <i>SetTextLineSpacing</i>.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
// SOURCE
float agk::GetTextLineSpacing( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetLineSpacing();
}

//****f* Text/Properties/GetTextAlignment
// FUNCTION
//   Returns the current alignment of the text object set with <i>SetTextAlignment</i>.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
// SOURCE
int agk::GetTextAlignment( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pText->GetAlignment();
}

//****f* Text/Properties/GetTextString
// FUNCTION
//   Returns the current string being displayed by the text object. In tier 2 the returned string must be
//   deleted when you are done with it.
// INPUTS
//   iTextIndex -- The ID of the text object to check.
// SOURCE
char* agk::GetTextString( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*) m_cTextList.GetItem( iTextIndex );
	if ( !pText )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		char* str = new char[ 1 ];
		str[0] = '\0';
		return str;
	}

	uString out;
	pText->GetText( out );

	char* str = new char[ out.GetLength()+1 ];
	strcpy( str, out.GetStr() );
	return str;
}

//****f* Text/Properties/DrawText
// FUNCTION
//   Immediately draws the text to the backbuffer at its current position, size, and rotation. This is 
//   useful if you want to take control of the order that things are drawn. If you do this then be sure 
//   to make the text invisible before calling <i>Render</i> or <i>Sync</i> otherwise your text will 
//   be drawn twice
// INPUTS
//   iTextIndex -- The ID of the text to draw.
// SOURCE
void agk::DrawText( uint32_t iTextIndex )
//****
{
	cText *pText = (cText*)m_cTextList.GetItem( iTextIndex );
	if ( pText == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Text ", 50 );  errStr.AppendUInt( iTextIndex );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pText->Draw();
}

// Font commands

//****f* Font/General/LoadFont
// FUNCTION
//   Loads a font file into AGK, typically in the TrueType format, but anything supported by FreeType should work.
//   The szFontFile parameter can either be a font file located in your media folder or the name of a system font,
//   this command will check your media folder first before checking for system fonts. If loading a system font then
//   the file extension is optional, for example "Arial.ttf" and "Arial" would both load the system font "Arial" if 
//   it exists. When loading a system font the filename must not have any folder paths in the filename, i.e. no 
//   forward or backward slashes.<br/>
//   To improve performance you should only load a font once. For example if you wanted to use the "Arial" font in 
//   multiple places then you should load it into an ID then use that ID for all uses, rather than loading multiple 
//   copies of the Arial font file into separate IDs.<br/>
//   Returns an ID that you can use to refer to this font in future.
// INPUTS
//   szFontFile -- The filename of the font to load
// SOURCE
uint32_t agk::LoadFont( const char *szFontFile )
//****
{
	uint32_t iFontID = m_cFontList.GetFreeID();
	
	if ( iFontID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load font " );
		errStr.Append( szFontFile ).Append( " - no free ID found" );
		Error( errStr );
#endif
		return 0;
	}

	agk::LoadFont( iFontID, szFontFile );
	return iFontID;
}

//****f* Font/General/LoadFont
// FUNCTION
//   Loads a font file into AGK, typically in the TrueType format, but anything supported by FreeType should work.
//   The szFontFile parameter can either be a font file located in your media folder or the name of a system font,
//   this command will check your media folder first before checking for system fonts. If loading a system font then
//   the file extension is optional, for example "Arial.ttf" and "Arial" would both load the system font "Arial" if 
//   it exists. When loading a system font the filename must not have any folder paths in the filename, i.e. no 
//   forward or backward slashes.<br/>
//   To improve performance you should only load a font once. For example if you wanted to use the "Arial" font in 
//   multiple places then you should load it into an ID then use that ID for all uses, rather than loading multiple 
//   copies of the Arial font file into separate IDs.
// INPUTS
//   iFontID -- The ID to use to reference this font in future
//   szFontFile -- The filename of the font to load
// SOURCE
void agk::LoadFont( uint32_t iFontID, const char *szFontFile )
//****
{
	if ( m_cFontList.GetItem( iFontID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load font " );
		errStr.AppendUInt( iFontID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	AGKFont *pFont = new AGKFont( szFontFile );
	if ( !pFont )
	{
		uString errStr( "Failed to load font " );
		errStr.Append( szFontFile );
		Error( errStr );
		return;
	}
	if ( !pFont->GetLoaded() ) return;

	m_cFontList.AddItem( pFont, iFontID );
}

//****f* Font/General/GetFontExists
// FUNCTION
//   Returns 1 if a font has been loaded successfully at the given ID.
// INPUTS
//   iFontID -- The ID of the font to check.
// SOURCE
int agk::GetFontExists( uint32_t iFontID )
//****
{
	return m_cFontList.GetItem( iFontID ) ? 1 : 0;
}

//****f* Font/General/GetSystemFontExists
// FUNCTION
//   Returns 1 if the system contains a font with the given name, 0 otherwise. If 1 is returned then
//   passing the same filename to <i>LoadFont</i> will succeed. On iOS this will always return 0 as
//   the system font files are not accessible, however AGK comes with a built in font you can use by
//   using font ID 0 with text objects.
// INPUTS
//   szFontFile -- The name of the font to check
// SOURCE
int agk::GetSystemFontExists( const char *szFontFile )
//****
{
	return AGKFont::GetSystemFontExists( szFontFile );
}

//****f* Font/General/DeleteFont
// FUNCTION
//   Deletes the font at the given ID. The font must not currently be in use by any text objects.
// INPUTS
//   iFontID -- The ID of the font to delete.
// SOURCE
void agk::DeleteFont( uint32_t iFontID )
//****
{
	AGKFont *pFont = m_cFontList.RemoveItem( iFontID );
	if ( pFont ) delete pFont;
}


//
// Print commands
//

//****f* Text/Print/Print
// FUNCTION
//   Prints the given value or string to the screen and adds a new line character so that the next print command
//   will be one line down.
// INPUTS
//   szString -- The string to print.
// SOURCE
void agk::Print( const char *szString )
//****
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	if ( szString && *szString ) m_cPrintStr.Append( szString );
	m_cPrintStr.AppendAscii( '\n' );
}

void agk::Print( const uString &string )
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	if ( string.GetLength() > 0 ) m_cPrintStr.Append( string );
	m_cPrintStr.AppendAscii( '\n' );
}

//****f* Text/Print/Print
// FUNCTION
//   Prints the given value or string to the screen and adds a new line character so that the next print command
//   will be one line down.
// INPUTS
//   i -- The integer to print.
// SOURCE
void agk::Print( int i )
//****
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	sprintf( m_szConvStr, "%d\n", i );
	m_cPrintStr.AppendUTF8( m_szConvStr );
}

void agk::Print( uint32_t u )
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	sprintf( m_szConvStr, "%u\n", u );
	m_cPrintStr.AppendUTF8( m_szConvStr );
}

//****f* Text/Print/Print
// FUNCTION
//   Prints the given value or string to the screen and adds a new line character so that the next print command
//   will be one line down.
// INPUTS
//   f -- The float to print.
// SOURCE
void agk::Print( float f )
//****
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	sprintf( m_szConvStr, "%.6f\n", f );
	m_cPrintStr.AppendUTF8( m_szConvStr );
}

//****f* Text/Print/PrintC
// FUNCTION
//   Prints the given value or string to the screen but does not add a new line character to the end. The next
//   Print or PrintC command will follow on directly from this one.
// INPUTS
//   szString -- The string to print.
// SOURCE
void agk::PrintC( const char *szString )
//****
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	if ( szString && *szString ) m_cPrintStr.Append( szString );
}

void agk::PrintC( const uString &string )
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	if ( string.GetLength() > 0 ) m_cPrintStr.Append( string );
}

//****f* Text/Print/PrintC
// FUNCTION
//   Prints the given value or string to the screen but does not add a new line character to the end. The next
//   Print or PrintC command will follow on directly from this one.
// INPUTS
//   i -- The integer to print.
// SOURCE
void agk::PrintC( int i )
//****
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	sprintf( m_szConvStr, "%d", i );
	m_cPrintStr.AppendUTF8( m_szConvStr );
}

void agk::PrintC( uint32_t u )
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	sprintf( m_szConvStr, "%u", u );
	m_cPrintStr.AppendUTF8( m_szConvStr );
}

//****f* Text/Print/PrintC
// FUNCTION
//   Prints the given value or string to the screen but does not add a new line character to the end. The next
//   Print or PrintC command will follow on directly from this one.
// INPUTS
//   f -- The float to print.
// SOURCE
void agk::PrintC( float f )
//****
{
	if ( m_cPrintStr.GetLength() > AGK_MAX_PRINT_LENGTH ) return;
	sprintf( m_szConvStr, "%.6f", f );
	m_cPrintStr.AppendUTF8( m_szConvStr );
}

//****f* Text/Print/SetPrintSize
// FUNCTION
//   Sets the size that printed text will appear on the screen. This is a global command and will
//   affect all printed text in the next call to <i>Sync</i>. To control size on a per string basis use 
//   the Text commands.
// INPUTS
//   fSize -- The size in virtual resolution pixels for the text.
// SOURCE
void agk::SetPrintSize( float fSize )
//****
{
	m_iPrintSizeChanged = 1;
	if ( !m_pPrintText ) return;
	m_pPrintText->SetSize( fSize );
}

//****f* Text/Print/SetPrintSpacing
// FUNCTION
//   Sets the spacing between letters. A value of 0 puts no gap between the letter bounding boxes, 
//   a positive value increases this gap, a negative value overlaps the letters. This is a global 
//   command and will affect all printed text in the next call to <i>Sync</i>. To control spacing on a 
//   per string basis use the Text commands.
// INPUTS
//   fSpacing -- The letter spacing to use.
// SOURCE
void agk::SetPrintSpacing( float fSpacing )
//****
{
	if ( !m_pPrintText ) return;
	m_pPrintText->SetSpacing( fSpacing );
}

//****f* Text/Print/SetPrintColor
// FUNCTION
//   Sets the color of the printed text. This is a global command and will affect all printed text 
//   in the next call to <i>Sync</i>. To control color on a per string basis use the Text commands.
//   This version sets the alpha to 255, fully opaque.
// INPUTS
//   iRed -- The red component of the color.
//   iGreen -- The green component of the color.
//   iBlue -- The blue component of the color.
// SOURCE
void agk::SetPrintColor( uint32_t iRed, uint32_t iGreen, uint32_t iBlue )
//****
{
	if ( !m_pPrintText ) return;
	m_pPrintText->SetColor( iRed, iGreen, iBlue );
}

//****f* Text/Print/SetPrintColor
// FUNCTION
//   Sets the color and alpha of the printed text. This is a global command and will affect all 
//   printed text in the next call to <i>Sync</i>. To control color on a per string basis use the Text 
//   commands. Each component should be in the range 0-255, an alpha of 0 is invisible.
// INPUTS
//   iRed -- The red component of the color.
//   iGreen -- The green component of the color.
//   iBlue -- The blue component of the color.
//   iAlpha -- The alpha component of the color.
// SOURCE
void agk::SetPrintColor( uint32_t iRed, uint32_t iGreen, uint32_t iBlue, uint32_t iAlpha )
//****
{
	if ( !m_pPrintText ) return;
	m_pPrintText->SetColor( iRed, iGreen, iBlue, iAlpha );
}

//****f* Text/Print/SetPrintFont
// FUNCTION
//   Sets the font to use for all Print text, the font must have been previously loaded with <i>LoadFont</i>.
//   Use a font ID of 0 to use the AGK default font.
// INPUTS
//   fontID -- The font ID to use for Print text
// SOURCE
void agk::SetPrintFont( int fontID )
//****
{
	if ( !m_pPrintText ) return;

	AGKFont *pFont = 0;
	if ( fontID > 0 )
	{
		pFont = m_cFontList.GetItem( fontID );
		if ( !pFont )
		{
			uString err; err.Format( "Failed to set Print font, font %d does not exist" );
			agk::Error( err );
			return;
		}
	}

	m_pPrintText->SetFont( pFont );
}

//
// Skeleton2D
//

//****f* Skeleton/2D/CreateSkeleton2D
// FUNCTION
//   Creates a 2D skeleton the can be used to animate sprites using bones. 
//   Currently this command is not very useful as there aren't many commands for setting up a skeleton.
//   Instead skeletons should be loaded with <i>LoadSkeleton2DFromSpineFile</i>
// INPUTS
//   iSkeleton -- ID to use to reference this skeleton
// SOURCE
void agk::CreateSkeleton2D( uint32_t iSkeleton )
//****
{
	if ( iSkeleton == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create 2D skeleton %d, ID must be greater than 0", iSkeleton );
		Error( errStr );
#endif
		return;
	}

	if ( m_cSkeleton2DList.GetItem( iSkeleton ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create 2D skeleton " );
		errStr.AppendUInt( iSkeleton ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	Skeleton2D *pSkeleton = new Skeleton2D();
	pSkeleton->m_iID = iSkeleton;
	m_cSpriteMgrFront.AddSkeleton2D( pSkeleton );
	m_cSkeleton2DList.AddItem( pSkeleton, iSkeleton );
}

//****f* Skeleton/2D/CreateSkeleton2D
// FUNCTION
//   Creates a 2D skeleton the can be used to animate sprites using bones. 
//   Currently this command is not very useful as there aren't many commands for setting up a skeleton.
//   Instead skeletons should be loaded with <i>LoadSkeleton2DFromSpineFile</i>
// SOURCE
uint32_t agk::CreateSkeleton2D()
//****
{
	uint32_t skelID = m_cSkeleton2DList.GetFreeID();
	if ( skelID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create 2D skeleton - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateSkeleton2D( skelID ); 
	return skelID;
}

//****f* Skeleton/2D/GetSkeleton2DExists
// FUNCTION
//   Returns 1 if a skeleton exists at the specified ID, otherwise 0.
// INPUTS
//   iSkeleton -- The ID of the skeleton to check
// SOURCE
int agk::GetSkeleton2DExists( uint32_t iSkeleton )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	return pSkeleton ? 1 : 0;
}

//****f* Skeleton/2D/DeleteSkeleton2D
// FUNCTION
//   Deletes the skeleton at the specified ID. If no skeleton exists at this ID then nothing happens.
// INPUTS
//   iSkeleton -- The ID of the skeleton to delete
// SOURCE
void agk::DeleteSkeleton2D( uint32_t iSkeleton )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.RemoveItem( iSkeleton );
	if ( pSkeleton )
	{
		m_cSpriteMgrFront.RemoveSkeleton2D( pSkeleton );
		delete pSkeleton;
	}
}

//****f* Skeleton/2D/LoadSkeleton2DFromSpineFile
// FUNCTION
//   Loads a Spine animation exported in the JSON format. Please see the guide section for details 
//   on what is supported.
//   You must first load the atlas image exported by Spine into an AGK image with the normal 
//   LoadImage command and pass it into this function.
//   You can choose to load animations as well, or just the sprites and bones and move or modify them 
//   manually.
//   You can use the scale value to change the size of the sprites and bones to match your chosen 
//   resolution. A value of 1 will not change the sizes, a value of 2 will make everything twice as
//   big, a value of 0.5 will half the size, and so on.
// INPUTS
//   iSkeleton -- ID to use for this skeleton
//   filename -- Name of the file to load, should be the .json export from Spine
//   scale -- The amount to scale the object sizes
//   atlasImage -- ID of the atlas image containing all the images
//   loadAnim -- 1 to load animation, 0 to only load sprites and bones
// SOURCE
void agk::LoadSkeleton2DFromSpineFile( uint32_t iSkeleton, const char* filename, float scale, uint32_t atlasImage, int loadAnim )
//****
{
	if ( iSkeleton == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load 2D skeleton %d, ID must be greater than 0", iSkeleton );
		Error( errStr );
#endif
		return;
	}

	if ( m_cSkeleton2DList.GetItem( iSkeleton ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load 2D skeleton " );
		errStr.AppendUInt( iSkeleton ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cImage *pAtlas = 0;
	if ( atlasImage > 0 )
	{
		pAtlas = m_cImageList.GetItem( atlasImage );
		if ( !pAtlas )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr;
			errStr.Format( "Failed to load 2D skeleton %d - Atlas image %d does not exist", iSkeleton, atlasImage );
			Error( errStr );
#endif
			return;			
		}
	}

	Skeleton2D *pSkeleton = new Skeleton2D();
	pSkeleton->LoadFromSpine( filename, scale, pAtlas, loadAnim );
	m_cSpriteMgrFront.AddSkeleton2D( pSkeleton );
	m_cSkeleton2DList.AddItem( pSkeleton, iSkeleton );
	return;
}

//****f* Skeleton/2D/LoadSkeleton2DFromSpineFile
// FUNCTION
//   Loads a Spine animation exported in the JSON format. Please see the guide section for details 
//   on what is supported. Returns an ID to use to reference this skeleton.
//   You must first load the atlas image exported by Spine into an AGK image with the normal 
//   LoadImage command and pass it into this function.
//   You can choose to load animations as well, or just the sprites and bones and move or modify them 
//   manually.
//   You can use the scale value to change the size of the sprites and bones to match your chosen 
//   resolution. A value of 1 will not change the sizes, a value of 2 will make everything twice as
//   big, a value of 0.5 will half the size, and so on.
// INPUTS
//   filename -- Name of the file to load, should be the .json export from Spine
//   scale -- The amount to scale the object sizes
//   atlasImage -- ID of the atlas image containing all the images
//   loadAnim -- 1 to load animation, 0 to only load sprites and bones
// SOURCE
uint32_t agk::LoadSkeleton2DFromSpineFile( const char* filename, float scale, uint32_t atlasImage, int loadAnim )
//****
{
	uint32_t iSkeleton = m_cSkeleton2DList.GetFreeID();
	if ( iSkeleton == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create 2D skeleton - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	agk::LoadSkeleton2DFromSpineFile( iSkeleton, filename, scale, atlasImage, loadAnim );
	return iSkeleton;
}

//****f* Skeleton/2D/LoadSkeleton2DFromSpriterFile
// FUNCTION
//   Loads a Spriter animation exported in the JSON format. Please see the guide section for details 
//   on what is supported.
//   The atlas image parameter is not yet supported and must be 0, the images will be loaded from the 
//   paths specified in the Spriter JSON file.
//   You can use the scale value to change the size of the sprites and bones to match your chosen 
//   resolution. A value of 1 will not change the sizes, a value of 2 will make everything twice as
//   big, a value of 0.5 will half the size, and so on.
// INPUTS
//   iSkeleton -- ID to use for this skeleton
//   filename -- Name of the file to load, should be the .json export from Spine
//   scale -- The amount to scale the object sizes
//   atlasImage -- reserved, must be 0
// SOURCE
void agk::LoadSkeleton2DFromSpriterFile( uint32_t iSkeleton, const char* filename, float scale, uint32_t atlasImage )
//****
{
	if ( iSkeleton == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load 2D skeleton %d, ID must be greater than 0", iSkeleton );
		Error( errStr );
#endif
		return;
	}

	if ( m_cSkeleton2DList.GetItem( iSkeleton ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load 2D skeleton " );
		errStr.AppendUInt( iSkeleton ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cImage *pAtlas = 0;
	if ( atlasImage > 0 )
	{
		pAtlas = m_cImageList.GetItem( atlasImage );
		if ( !pAtlas )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr;
			errStr.Format( "Failed to load 2D skeleton %d - Atlas image %d does not exist", iSkeleton, atlasImage );
			Error( errStr );
#endif
			return;			
		}
	}

	Skeleton2D *pSkeleton = new Skeleton2D();
	pSkeleton->LoadFromSpriter( filename, scale, pAtlas );
	m_cSpriteMgrFront.AddSkeleton2D( pSkeleton );
	m_cSkeleton2DList.AddItem( pSkeleton, iSkeleton );
	return;
}

//****f* Skeleton/2D/LoadSkeleton2DFromSpriterFile
// FUNCTION
//   Loads a Spriter animation exported in the JSON format. Please see the guide section for details 
//   on what is supported. Returns an ID to use to reference this skeleton.
//   The atlas image parameter is not yet supported and must be 0, the images will be loaded from the 
//   paths specified in the Spriter JSON file.
//   You can use the scale value to change the size of the sprites and bones to match your chosen 
//   resolution. A value of 1 will not change the sizes, a value of 2 will make everything twice as
//   big, a value of 0.5 will half the size, and so on.
// INPUTS
//   filename -- Name of the file to load, should be the .json export from Spine
//   scale -- The amount to scale the object sizes
//   atlasImage -- reserved, must be 0
// SOURCE
uint32_t agk::LoadSkeleton2DFromSpriterFile( const char* filename, float scale, uint32_t atlasImage )
//****
{
	uint32_t iSkeleton = m_cSkeleton2DList.GetFreeID();
	if ( iSkeleton == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create 2D skeleton - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	agk::LoadSkeleton2DFromSpriterFile( iSkeleton, filename, scale, atlasImage );
	return iSkeleton;
}

//****f* Skeleton/2D/SetSkeleton2DPosition
// FUNCTION
//   Sets the position of the root of the skeleton, the bone positions will be relative to this spot.
//   This can be used to move the skeleton whilst it is animating to make it look like it is walking.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   x -- The X position of the skeleton
//   y -- The Y position of the skeleton
// SOURCE
void agk::SetSkeleton2DPosition( uint32_t iSkeleton, float x, float y )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set position for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->SetPosition( x, y );
}

//****f* Skeleton/2D/SetSkeleton2DRotation
// FUNCTION
//   Sets the angle of the root of the skeleton, the bone angles will be relative to this angle.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   r -- The angle to use in degrees
// SOURCE
void agk::SetSkeleton2DRotation( uint32_t iSkeleton, float r )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set rotation for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->SetAngle( r );
}

//****f* Skeleton/2D/SetSkeleton2DFlip
// FUNCTION
//   Sets the horizontal and vertical flip mode of the skeleton, this will flip all bones and sprites
//   along the horizontal or vertical axis (or both).
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   flipH -- 1 to flip the skeleton in the horizontal axis, 0 for no flip.
//   flipV -- 1 to flip the skeleton in the vertical axis, 0 for no flip.
// SOURCE
void agk::SetSkeleton2DFlip( uint32_t iSkeleton, int flipH, int flipV )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set flip mode for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->SetFlipH( flipH );
	pSkeleton->SetFlipV( flipV );
}

//****f* Skeleton/2D/SetSkeleton2DDepth
// FUNCTION
//   Sets the depth of this skeleton in the range 0-10000 with 0 being top.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   depth -- The depth value to use
// SOURCE
void agk::SetSkeleton2DDepth( uint32_t iSkeleton, uint32_t depth )
//****
{
	if ( depth > 10000 ) depth = 10000;

	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set depth for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->SetDepth( depth );
}

//****f* Skeleton/2D/FixSkeleton2DToScreen
// FUNCTION
//   Fixes the specified skeleton to the screen so that it is not affected by SetViewOffset
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   mode -- 1 to fix to screen, 0 to behave normally (default)
// SOURCE
void agk::FixSkeleton2DToScreen( uint32_t iSkeleton, int mode )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to fix skeleton %d to screen - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->FixToScreen( mode );
}

//****f* Skeleton/2D/SetSkeleton2DVisible
// FUNCTION
//   Sets whether the specified skeleton is visible or not. AGK will automatically hide the skeleton 
//   when it moves off screen to improve performance, so you only need to do this if you want to hide
//   it whilst it is on screen.
//   When hidden a skeleton will still animate.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   mode -- 1 to make it visible, 0 to hide it
// SOURCE
void agk::SetSkeleton2DVisible( uint32_t iSkeleton, int mode )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set skeleton %d visibility - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->SetVisible( mode );
}

//****f* Skeleton/2D/GetSkeleton2DX
// FUNCTION
//   Gets the X position of the root of the skeleton, does not change whilst animating.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
// SOURCE
float agk::GetSkeleton2DX( uint32_t iSkeleton )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get X position for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	return pSkeleton->GetX();
}

//****f* Skeleton/2D/GetSkeleton2DY
// FUNCTION
//   Gets the Y position of the root of the skeleton, does not change whilst animating.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
// SOURCE
float agk::GetSkeleton2DY( uint32_t iSkeleton )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get Y position for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	return pSkeleton->GetY();
}

//****f* Skeleton/2D/GetSkeleton2DAngle
// FUNCTION
//   Gets the Angle of the root of the skeleton, does not change whilst animating.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
// SOURCE
float agk::GetSkeleton2DAngle( uint32_t iSkeleton )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get Y position for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	return pSkeleton->GetAngle();
}

//****f* Skeleton/2D/GetSkeleton2DDepth
// FUNCTION
//   Gets the current depth of the skeleton. This is in the range 0-10000. 0 is on top, 10000 is at the back
// INPUTS
//   iSkeleton -- ID of the skeleton to check
// SOURCE
int agk::GetSkeleton2DDepth(uint32_t iSkeleton)
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem(iSkeleton);
	if (!pSkeleton)
	{
		uString errStr;
		errStr.Format("Failed to get depth for skeleton %d - ID does not exist", iSkeleton);
		agk::Error(errStr);
		return 0;
	}

	return pSkeleton->GetDepth();
}

//****f* Skeleton/2D/GetSkeleton2DBone
// FUNCTION
//   Returns the ID of the specified bone for this skeleton. If no bone with the given name exists it 
//   will return -1. Index 0 is a valid bone.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
//   name -- Name of the bone to find
// SOURCE
int agk::GetSkeleton2DBone( uint32_t iSkeleton, const char* name )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get bone for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return -1;
	}

	return pSkeleton->GetBoneIndex( name );
}

//****f* Skeleton/2D/GetSkeleton2DBoneParent
// FUNCTION
//   Returns the ID of the parent of the specified bone. If the bone does not exist or it does not 
///  have a parent it will return -1. Indices start at 0.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
//   bone -- ID of the bone to check
// SOURCE
int agk::GetSkeleton2DBoneParent( uint32_t iSkeleton, int bone )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get bone for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return -1;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone || !pBone->m_pParent ) return -1;
	
	return pSkeleton->GetBoneIndex( pBone->m_pParent->m_sName );
}

//****f* Skeleton/2D/GetSkeleton2DBoneX
// FUNCTION
//   Returns the original X position of the specified bone also known as the setup pose. This value 
//   will not change whilst the bone is animating, instead the animation builds on top of the setup
//   pose to create the bone position seen on screen. 
//   If the bone does not exist it will return 0. Bone IDs start at 0.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
//   bone -- ID of the bone to check
// SOURCE
float agk::GetSkeleton2DBoneX( uint32_t iSkeleton, int bone )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get bone for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return 0;
	
	return pBone->origX;
}

//****f* Skeleton/2D/GetSkeleton2DBoneY
// FUNCTION
//   Returns the original Y position of the specified bone also known as the setup pose. This value 
//   will not change whilst the bone is animating, instead the animation builds on top of the setup
//   pose to create the bone position seen on screen. 
//   If the bone does not exist it will return 0. Bone IDs start at 0.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
//   bone -- ID of the bone to check
// SOURCE
float agk::GetSkeleton2DBoneY( uint32_t iSkeleton, int bone )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get bone for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return 0;
	
	return pBone->origY;
}

//****f* Skeleton/2D/GetSkeleton2DBoneAngle
// FUNCTION
//   Returns the original angle of the specified bone also known as the setup pose. This value 
//   will not change whilst the bone is animating, instead the animation builds on top of the setup
//   pose to create the bone rotation seen on screen. 
//   If the bone does not exist it will return 0. Bone IDs start at 0.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
//   bone -- ID of the bone to check
// SOURCE
float agk::GetSkeleton2DBoneAngle( uint32_t iSkeleton, int bone )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get bone for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return 0;
	
	return pBone->origAngle;
}

//****f* Skeleton/2D/GetSkeleton2DBoneCurrX
// FUNCTION
//   Returns the current X position of the specified bone in its currently animated position. 
//   This value will change whilst the bone is animating. 
//   If the bone does not exist it will return 0. Bone IDs start at 0.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
//   bone -- ID of the bone to check
// SOURCE
float agk::GetSkeleton2DBoneCurrX( uint32_t iSkeleton, int bone )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get bone for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return 0;
	
	return pBone->worldX;
}

//****f* Skeleton/2D/GetSkeleton2DBoneCurrY
// FUNCTION
//   Returns the current Y position of the specified bone in its currently animated position. 
//   This value will change whilst the bone is animating. 
//   If the bone does not exist it will return 0. Bone IDs start at 0.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
//   bone -- ID of the bone to check
// SOURCE
float agk::GetSkeleton2DBoneCurrY( uint32_t iSkeleton, int bone )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get bone for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return 0;
	
	return pBone->worldY;
}

//****f* Skeleton/2D/GetSkeleton2DBoneCurrAngle
// FUNCTION
//   Returns the current angle of the specified bone in its currently animated position. 
//   This value will change whilst the bone is animating. 
//   If the bone does not exist it will return 0. Bone IDs start at 0.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
//   bone -- ID of the bone to check
// SOURCE
float agk::GetSkeleton2DBoneCurrAngle( uint32_t iSkeleton, int bone )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get bone for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return 0;
	
	return pBone->worldAngle;
}

//****f* Skeleton/2D/SetSkeleton2DBonePosition
// FUNCTION
//   Set the original position of a bone relative to its parent also know as the setup pose. 
//   All animation will be relative to this position, this can be changed whilst an animation 
//   is playing.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   bone -- The ID of the bone to modify
//   x -- The new X position to use
//   y -- The new Y position to use
// SOURCE
void agk::SetSkeleton2DBonePosition( uint32_t iSkeleton, int bone, float x, float y )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set bone position for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return;
	pBone->origX = x;
	pBone->origY = y;
}

//****f* Skeleton/2D/SetSkeleton2DBoneAngle
// FUNCTION
//   Set the original angle of a bone relative to its parent. All animation will be relative to this 
//   angle, this can be changed whilst an animation is playing.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   bone -- ID of the bone to modify
//   r -- The new angle to use
// SOURCE
void agk::SetSkeleton2DBoneAngle( uint32_t iSkeleton, int bone, float r )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set bone angle for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return;
	pBone->origAngle = r;
}

//****f* Skeleton/2D/SetSkeleton2DBoneScale
// FUNCTION
//   Set the original scale of a bone. Animations will override this value.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   bone -- ID of the bone to modify
//   sx -- The new X scale value to use
//   sy -- The new Y scale value to use
// SOURCE
void agk::SetSkeleton2DBoneScale( uint32_t iSkeleton, int bone, float sx, float sy )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set bone scale for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return;
	pBone->origSX = sx;
	pBone->origSY = sy;
}

//****f* Skeleton/2D/SetSkeleton2DBoneMode
// FUNCTION
//   Sets whether the bone can animate or if it remains stationary. You can still modify the bone position,
//   angle, and scale manually.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   bone -- ID of the bone to modify
//   mode -- 1 to let the bone animate, 0 to stop it
// SOURCE
void agk::SetSkeleton2DBoneMode( uint32_t iSkeleton, int bone, int mode )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get bone for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	Bone2D *pBone = pSkeleton->GetBone( bone );
	if ( !pBone ) return;
	if ( mode == 0 ) pBone->m_bFlags &= ~AGK_BONE_ANIMATE;
	else pBone->m_bFlags |= AGK_BONE_ANIMATE;
}

//****f* Skeleton/2D/FixSpriteToSkeleton2D
// FUNCTION
//   Attaches the specified sprite to the given skeleton and bone ID. The bone ID can be found by using
//   the <i>GetSkeleton2DBone</i> command. When a sprite is attached to a skeleton bone then it's position
//   and rotation become relative to the bone's position. For example if the sprite position was 0,0 then
//   it would be drawn in the same position as the bone, but if the position was 0,10 then the sprite
//   would be drawn above the bone, relative to the bone. i.e. if the bone is rotated left by 90 degrees
//   then 'above' the bone would be to the left of the screen in world coordinates.<br/>
//   <br/>
//   The ZOrder can be specified to draw the sprite in between two of the skeleton's existing sprites, any 
//   integer value is valid and corresponds to the current order of the sprites in the skeleton. For example 
//   a ZOrder of 0 would always draw before the first sprite in the skeleton's ZOrder, a value of 1 would 
//   always draw before the second sprite in the skeleton, and so on. Note that this ian't affected by 
//   other sprites you have attached to the skeleton, it only counts sprites that were originally loaded 
//   with the skeleton. For example if you fixed two new sprites to the skeleton both with a zorder equal to 
//   1, then they would both be drawn between between the first and second sprites in the original skeleton.
//   Any sprites that are attached to the skeleton using the same zorder value will be drawn in the order they 
//   were attached.<br/>
//   <br/>
//   Whilst this sprite is attached to a skeleton it will be removed from the normal drawing routines and 
//   only drawn when the skeleton is visible. You can still force the sprite to draw by calling <i>DrawSprite</i>
//   but it will not be ordered with the other sprites in the skeleton.<br/>
//   <br/>
//   To detach a sprite from a skeleton call this command with 0 as the skeletonID, the bone ID and zorder
//   parameters do not matter in this case.
// INPUTS
//   spriteID -- The ID of the sprite to attach
//   iSkeletonID -- ID of the skeleton to attach to
//   bone -- The ID of the bone in the skeleton to attach to
//   zorder -- The ZOrder to place the new sprite in the skeleton draw order
// SOURCE
void agk::FixSpriteToSkeleton2D( uint32_t spriteID, uint32_t iSkeletonID, int bone, int zorder )
//****
{
	cSprite *pSprite = m_cSpriteList.GetItem( spriteID );
	if ( !pSprite )
	{
		uString errStr;
		errStr.Format( "Failed to attach sprite to skeleton - Sprite ID %d does not exist", spriteID );
		agk::Error( errStr );
		return;
	}

	Skeleton2D *pSkeleton = 0;
	Bone2D *pBone = 0;
	if ( iSkeletonID )
	{
		pSkeleton = m_cSkeleton2DList.GetItem( iSkeletonID );
		if ( !pSkeleton )
		{
			uString errStr;
			errStr.Format( "Failed to attach sprite to skeleton %d - Skeleton ID does not exist", iSkeletonID );
			agk::Error( errStr );
			return;
		}

		pBone = pSkeleton->GetBone( bone );
		if ( !pBone ) 
		{
			uString errStr;
			errStr.Format( "Failed to attach sprite to skeleton %d - Bone %d does not exist", iSkeletonID, bone );
			agk::Error( errStr );
			return;
		}
	}

	if ( pSkeleton ) m_cSpriteMgrFront.RemoveSprite( pSprite );
	else m_cSpriteMgrFront.AddSprite( pSprite );
	pSprite->FixToSkeleton( pSkeleton, pBone, zorder );
}

//****f* Skeleton/2D/PlaySkeleton2DAnimation
// FUNCTION
//   Plays the given animation by name if it exists with an optional start time (Default 0), optional 
//   looping, and optional tween time (Default 0).
//   The tween time will smoothly interpolate the skeleton from its current state to the first frame of
//   the specified animation before it starts animating so that there is no sharp transition.
//   A loop value of 1 will loop forever, a loop value greater than 1 will loop for that many times and 
//   then stop, and a loop value of 0 will play the animation once and then stop
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   anim -- The name of the animation to play
//   starttime -- An optional offset into the animation to skip some frames
//   loop -- 1 to loop the animation until stopped, 0 to play it once, greater than 1 to loop that many times
//   tweentime -- Number of seconds to transition from its current state before animating
// SOURCE
void agk::PlaySkeleton2DAnimation( uint32_t iSkeleton, const char* anim, float starttime, int loop, float tweentime )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to play animation for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->PlayAnimation( anim, starttime, loop, tweentime );
}

//****f* Skeleton/2D/SetSkeleton2DAnimationFrame
// FUNCTION
//   Sets the skeleton to a specific point in the animation based on time, with optional tweening time.
//   The tween time will smoothly interpolate the skeleton from its current state to the chosen frame of
//   the specified animation so that there is no sharp transition.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   anim -- The name of the animation to use
//   time -- The time offset to use to set the frame of the skeleton
//   tweentime -- Number of seconds to transition from its current state to the given frame
// SOURCE
void agk::SetSkeleton2DAnimationFrame( uint32_t iSkeleton, const char* anim, float time, float tweentime )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set animation frame for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->SetAnimationFrame( anim, time, tweentime );
}

//****f* Skeleton/2D/SetSkeleton2DAnimationSpeed
// FUNCTION
//   Sets the animation speed (Default 1.0), negative values are allowed to reverse the animation.
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
//   speed -- The speed of the animation with 1.0 being normal speed
// SOURCE
void agk::SetSkeleton2DAnimationSpeed( uint32_t iSkeleton, float speed )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to set animation speed for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->SetAnimationSpeed( speed );
}

//****f* Skeleton/2D/GetSkeleton2DCurrentTime
// FUNCTION
//   Get the current time of the currently playing animation in seconds
// INPUTS
//   iSkeleton -- ID of the skeleton to check
// SOURCE
float agk::GetSkeleton2DCurrentTime( uint32_t iSkeleton )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get current time for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	return pSkeleton->m_fCurrTime;
}

//****f* Skeleton/2D/StopSkeleton2DAnimation
// FUNCTION
//   Stop the skeleton animating
// INPUTS
//   iSkeleton -- ID of the skeleton to modify
// SOURCE
void agk::StopSkeleton2DAnimation( uint32_t iSkeleton )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to stop animation for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return;
	}

	pSkeleton->StopAnimation();
}

//****f* Skeleton/2D/GetSkeleton2DIsAnimating
// FUNCTION
//   returns 1 if the skeleton is animating, or tweening to the first frame of a playing animation
// INPUTS
//   iSkeleton -- ID of the skeleton to check
// SOURCE
int agk::GetSkeleton2DIsAnimating( uint32_t iSkeleton )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get is animating for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	return pSkeleton->GetIsAnimating();
}

//****f* Skeleton/2D/GetSkeleton2DIsTweening
// FUNCTION
//   returns 1 if the skeleton is tweening to an animation frame.
// INPUTS
//   iSkeleton -- ID of the skeleton to check
// SOURCE
int agk::GetSkeleton2DIsTweening( uint32_t iSkeleton )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get is tweening for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	return pSkeleton->GetIsTweening();
}

//****f* Skeleton/2D/GetSkeleton2DAnimationTime
// FUNCTION
//   get the total time of a named animation
// INPUTS
//   iSkeleton -- ID of the skeleton to check
//   anim -- NAme of the animation to check
// SOURCE
float agk::GetSkeleton2DAnimationTime( uint32_t iSkeleton, const char* anim )
//****
{
	Skeleton2D *pSkeleton = m_cSkeleton2DList.GetItem( iSkeleton );
	if ( !pSkeleton )
	{
		uString errStr;
		errStr.Format( "Failed to get animation time for skeleton %d - ID does not exist", iSkeleton );
		agk::Error( errStr );
		return 0;
	}

	return pSkeleton->GetAnimationTime( anim );
}

// 
// Tweening
//

//****f* Tweening/Interpolation/TweenLinear
// FUNCTION
//   Uses linear interpolation to move from start to end, this is the simplest form of interpolation.
//   This is just a helper function to avoid having to remember the integer value for this which is 0.
// SOURCE
int agk::TweenLinear() 
//****
{ return 0; }

//****f* Tweening/Interpolation/TweenSmooth1
// FUNCTION
//   Uses a smooth curve to move from start to end, this avoids a sudden start and stop.
//   This is just a helper function to avoid having to remember the integer value for this which is 1.
// SOURCE
int agk::TweenSmooth1()  
//****
{ return 1; }

//****f* Tweening/Interpolation/TweenSmooth2
// FUNCTION
//   Uses a smooth curve to move from start to end, similar to TweenSmooth1 but more exaggerated.
//   This is just a helper function to avoid having to remember the integer value for this which is 2.
// SOURCE
int agk::TweenSmooth2()  
//****
{ return 2; }

//****f* Tweening/Interpolation/TweenEaseIn1
// FUNCTION
//   Uses a smooth curve to move from the start, this avoids a sudden start but still ends abruptly.
//   This is just a helper function to avoid having to remember the integer value for this which is 3.
// SOURCE
int agk::TweenEaseIn1()  
//****
{ return 3; }

//****f* Tweening/Interpolation/TweenEaseIn2
// FUNCTION
//   Uses a smooth curve to move from the start, similar to TweenEaseIn1 but more exaggerated.
//   This is just a helper function to avoid having to remember the integer value for this which is 4.
// SOURCE
int agk::TweenEaseIn2()  
//****
{ return 4; }

//****f* Tweening/Interpolation/TweenEaseOut1
// FUNCTION
//   Uses a smooth curve to move towards the end, this avoids a sudden stop but still starts abruptly.
//   This is just a helper function to avoid having to remember the integer value for this which is 5.
// SOURCE
int agk::TweenEaseOut1()  
//****
{ return 5; }

//****f* Tweening/Interpolation/TweenEaseOut2
// FUNCTION
//   Uses a smooth curve to move towards the end, similar to TweenEaseOut1 but more exaggerated.
//   This is just a helper function to avoid having to remember the integer value for this which is 6.
// SOURCE
int agk::TweenEaseOut2()  
//****
{ return 6; }

//****f* Tweening/Interpolation/TweenBounce
// FUNCTION
//   Uses a bounce affect at the end of the interpolation.
//   This is just a helper function to avoid having to remember the integer value for this which is 7.
// SOURCE
int agk::TweenBounce()  
//****
{ return 7; }

//****f* Tweening/Interpolation/TweenOvershoot
// FUNCTION
//   Uses an elastic affect at the end of the interpolation. This is the only interpolation method that
//   exceeds the given range and is not suitable for colors.
//   This is just a helper function to avoid having to remember the integer value for this which is 8.
// SOURCE
int agk::TweenOvershoot()  
//****
{ return 8; }

//****f* Tweening/General/DeleteTween
// FUNCTION
//   Delete a given tween ID. This can be used for all types of tween, sprite, text, object, etc.
// INPUTS
//   tweenID -- ID of the tween to delete
// SOURCE
void agk::DeleteTween( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.RemoveItem( tweenID );
	if ( pTween ) 
	{
		TweenChain *pChain = m_cTweenChainList.GetFirst();
		while( pChain )
		{
			pChain->DeleteTween( pTween );
			pChain = m_cTweenChainList.GetNext();
		}

		TweenInstance::DeleteTween( pTween );
		delete pTween;
	}
}

//****f* Tweening/General/GetTweenExists
// FUNCTION
//   Returns 1 if a tween of any type exists at the given ID, 0 otherwise.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenExists( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween ) return 0;
	else return 1;
}

//****f* Tweening/General/SetTweenDuration
// FUNCTION
//   Changes a tween's duration after it has been created. If the tween is currently running or is part
//   of a chain that is currently running, then changing its duration may produce unexpected results.
// INPUTS
//   tweenID -- ID of the tween to change, can be any type of tween
//   duration -- The new duration to use in seconds
// SOURCE
void agk::SetTweenDuration( uint32_t tweenID, float duration )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween ) 
	{
		uString err;
		err.Format( "Failed to change tween duration, tween %d does not exist", tweenID );
		agk::Error( err );
		return;
	}

	pTween->m_fDuration = duration;
		
	TweenChain *pChain = m_cTweenChainList.GetFirst();
	while( pChain )
	{
		pChain->ChangedTweenDuration( pTween );
		pChain = m_cTweenChainList.GetNext();
	}
}

// custom tweening

//****f* Tweening/Custom/CreateTweenCustom
// FUNCTION
//   Creates a custom tween at the given ID with a given duration. This tween is not associated with any item and its
//   values can be read whilst it is running. This makes it useful for controlling values that are not covered by any
//   of the other tween templates.
//   All tween types share the same ID space, so a custom tween of ID 1 cannot exist at the same time as a sprite tween
//   with ID 1.
//   You can set multiple parameters for this tween, up to 4 float values and 4 integer values, that will all move from 
//   their start values to their end values over the given duration.
// INPUTS
//   tweenID -- ID of the tween
//   duration -- The duration of the tween in seconds
// SOURCE
void agk::CreateTweenCustom( uint32_t tweenID, float duration )
//****
{
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create custom tween %d, ID must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cTweenList.GetItem( tweenID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create custom tween " );
		errStr.AppendUInt( tweenID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	if ( duration <= 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create custom tween %d, duration must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;		
	}

	TweenCustom *pTween = new TweenCustom();
	pTween->m_fDuration = duration;
	m_cTweenList.AddItem( pTween, tweenID );
}

//****f* Tweening/Custom/CreateTweenCustom
// FUNCTION
//   Creates a custom tween with a given duration and returns an ID for it. This tween is not associated with any item and its
//   values can be read whilst it is running. This makes it useful for controlling values that are not covered by any
//   of the other tween templates.
//   All tween types share the same ID space, so a custom tween of ID 1 cannot exist at the same time as a sprite tween
//   with ID 1.
//   You can set multiple parameters for this tween, up to 4 float values and 4 integer values, that will all move from 
//   their start values to their end values over the given duration.
// INPUTS
//   duration -- The duration of the tween in seconds
// SOURCE
uint32_t agk::CreateTweenCustom( float duration )
//****
{
	uint32_t tweenID = m_cTweenList.GetFreeID();
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create custom tween - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateTweenCustom( tweenID, duration ); 
	return tweenID;
}

//****f* Tweening/Custom/GetTweenCustomExists
// FUNCTION
//   Returns 1 if a tween with the given ID exists and it is a custom tween, otherwise 0.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenCustomExists( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;
	else return 1;
}

//****f* Tweening/Custom/GetTweenCustomTime
// FUNCTION
//   Returns the current time of the custom tween
// INPUTS
//   tweenID -- ID of the tween
// SOURCE
float agk::GetTweenCustomTime ( UINT tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_CUSTOM ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, 0 );

	if ( pInstance ) return pInstance->m_fCurrentTime;

	return 0.0f;
}

//****f* Tweening/Custom/GetTweenCustomEndTime
// FUNCTION
//   Returns the end time of the custom tween
// INPUTS
//   tweenID -- ID of the tween
float agk::GetTweenCustomEndTime ( UINT tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_CUSTOM ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, 0 );

	if ( pInstance ) return pInstance->m_pTween->m_fDuration;

	return 0.0f;
}


//****f* Tweening/Custom/SetTweenCustomFloat1
// FUNCTION
//   Sets the first float value of the given custom tween ID. A Tween can modify several parameters at 
//   the same time. Set the begin value and the end value and an interpolation method. 
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   begin -- The starting point for this value
//   end -- The end point for this value
//   interpolation -- The interpolation method whilst the value is moving from begin to end
// SOURCE
void agk::SetTweenCustomFloat1( uint32_t tweenID, float begin, float end, int interpolation )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween float1 for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween float1 for ID %d, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBegin1 = begin;
	pTween->m_fEnd1 = end;
	pTween->m_iInterp1 = interpolation;
}

//****f* Tweening/Custom/SetTweenCustomFloat2
// FUNCTION
//   Sets the second float value of the given custom tween ID. A Tween can modify several parameters at 
//   the same time. Set the begin value and the end value and an interpolation method. 
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   begin -- The starting point for this value
//   end -- The end point for this value
//   interpolation -- The interpolation method whilst the value is moving from begin to end
// SOURCE
void agk::SetTweenCustomFloat2( uint32_t tweenID, float begin, float end, int interpolation )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween float2 for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween float2 for ID %d, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBegin2 = begin;
	pTween->m_fEnd2 = end;
	pTween->m_iInterp2 = interpolation;
}

//****f* Tweening/Custom/SetTweenCustomFloat3
// FUNCTION
//   Sets the third float value of the given custom tween ID. A Tween can modify several parameters at 
//   the same time. Set the begin value and the end value and an interpolation method. 
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   begin -- The starting point for this value
//   end -- The end point for this value
//   interpolation -- The interpolation method whilst the value is moving from begin to end
// SOURCE
void agk::SetTweenCustomFloat3( uint32_t tweenID, float begin, float end, int interpolation )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween float3 for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween float3 for ID %d, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBegin3 = begin;
	pTween->m_fEnd3 = end;
	pTween->m_iInterp3 = interpolation;
}

//****f* Tweening/Custom/SetTweenCustomFloat4
// FUNCTION
//   Sets the fourth float value of the given custom tween ID. A Tween can modify several parameters at 
//   the same time. Set the begin value and the end value and an interpolation method. 
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   begin -- The starting point for this value
//   end -- The end point for this value
//   interpolation -- The interpolation method whilst the value is moving from begin to end
// SOURCE
void agk::SetTweenCustomFloat4( uint32_t tweenID, float begin, float end, int interpolation )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween float4 for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween float4 for ID %d, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBegin4 = begin;
	pTween->m_fEnd4 = end;
	pTween->m_iInterp4 = interpolation;
}

//****f* Tweening/Custom/SetTweenCustomInteger1
// FUNCTION
//   Sets the first integer value of the given custom tween ID. A Tween can modify several parameters at 
//   the same time. Set the begin value and the end value and an interpolation method. 
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   begin -- The starting point for this value
//   end -- The end point for this value
//   interpolation -- The interpolation method whilst the value is moving from begin to end
// SOURCE
void agk::SetTweenCustomInteger1( uint32_t tweenID, int begin, int end, int interpolation )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween integer1 for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween integer1 for ID %d, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBegin1 = begin;
	pTween->m_iEnd1 = end;
	pTween->m_iInterpI1 = interpolation;
}

//****f* Tweening/Custom/SetTweenCustomInteger2
// FUNCTION
//   Sets the second integer value of the given custom tween ID. A Tween can modify several parameters at 
//   the same time. Set the begin value and the end value and an interpolation method. 
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   begin -- The starting point for this value
//   end -- The end point for this value
//   interpolation -- The interpolation method whilst the value is moving from begin to end
// SOURCE
void agk::SetTweenCustomInteger2( uint32_t tweenID, int begin, int end, int interpolation )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween integer2 for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween integer2 for ID %d, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBegin2 = begin;
	pTween->m_iEnd2 = end;
	pTween->m_iInterpI2 = interpolation;
}

//****f* Tweening/Custom/SetTweenCustomInteger3
// FUNCTION
//   Sets the third integer value of the given custom tween ID. A Tween can modify several parameters at 
//   the same time. Set the begin value and the end value and an interpolation method. 
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   begin -- The starting point for this value
//   end -- The end point for this value
//   interpolation -- The interpolation method whilst the value is moving from begin to end
// SOURCE
void agk::SetTweenCustomInteger3( uint32_t tweenID, int begin, int end, int interpolation )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween integer3 for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween integer3 for ID %d, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBegin3 = begin;
	pTween->m_iEnd3 = end;
	pTween->m_iInterpI3 = interpolation;
}

//****f* Tweening/Custom/SetTweenCustomInteger4
// FUNCTION
//   Sets the fourth integer value of the given custom tween ID. A Tween can modify several parameters at 
//   the same time. Set the begin value and the end value and an interpolation method. 
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   begin -- The starting point for this value
//   end -- The end point for this value
//   interpolation -- The interpolation method whilst the value is moving from begin to end
// SOURCE
void agk::SetTweenCustomInteger4( uint32_t tweenID, int begin, int end, int interpolation )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween integer4 for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set custom tween integer4 for ID %d, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBegin4 = begin;
	pTween->m_iEnd4 = end;
	pTween->m_iInterpI4 = interpolation;
}

//****f* Tweening/Custom/GetTweenCustomFloat1
// FUNCTION
//   Returns the current value of the first float of the custom tween.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
float agk::GetTweenCustomFloat1( uint32_t tweenID )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;

	return pTween->m_fValue1;
}

//****f* Tweening/Custom/GetTweenCustomFloat2
// FUNCTION
//   Returns the current value of the second float of the custom tween.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
float agk::GetTweenCustomFloat2( uint32_t tweenID )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;

	return pTween->m_fValue2;
}

//****f* Tweening/Custom/GetTweenCustomFloat3
// FUNCTION
//   Returns the current value of the third float of the custom tween.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
float agk::GetTweenCustomFloat3( uint32_t tweenID )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;

	return pTween->m_fValue3;
}

//****f* Tweening/Custom/GetTweenCustomFloat4
// FUNCTION
//   Returns the current value of the fourth float of the custom tween.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
float agk::GetTweenCustomFloat4( uint32_t tweenID )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;

	return pTween->m_fValue4;
}

//****f* Tweening/Custom/GetTweenCustomInteger1
// FUNCTION
//   Returns the current value of the first integer of the custom tween.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenCustomInteger1( uint32_t tweenID )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;

	return pTween->m_iValue1;
}

//****f* Tweening/Custom/GetTweenCustomInteger2
// FUNCTION
//   Returns the current value of the second integer of the custom tween.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenCustomInteger2( uint32_t tweenID )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;

	return pTween->m_iValue2;
}

//****f* Tweening/Custom/GetTweenCustomInteger3
// FUNCTION
//   Returns the current value of the third integer of the custom tween.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenCustomInteger3( uint32_t tweenID )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;

	return pTween->m_iValue3;
}

//****f* Tweening/Custom/GetTweenCustomInteger4
// FUNCTION
//   Returns the current value of the fourth integer of the custom tween.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenCustomInteger4( uint32_t tweenID )
//****
{
	TweenCustom *pTween = (TweenCustom*) m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;

	return pTween->m_iValue4;
}

//****f* Tweening/Custom/PlayTweenCustom
// FUNCTION
//   Plays the given custom tween ID with an optional delay and starts playing it. Unlike other tweens 
//   this is not applied to any specific item or object and cannot have multiple copies running at the 
//   same time, you will have to create a separate custom tween for each copy you want to run 
//   simultaneously. The tween values will not be modified until the delay time has passed, at which 
//   point the tween will start at the begin values and move towards the end values over the tween 
//   duration.
//   If a tween end value is modified whilst the tween is playing the tween will adjust its 
//   interpolation accordingly. Modifying the duration whilst playing is undefined and not compatible 
//   with chains.
// INPUTS
//   tweenID -- ID of the tween to use
//   delay -- Number of seconds before the tween should start playing
// SOURCE
void agk::PlayTweenCustom( uint32_t tweenID, float delay )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play custom tween %d, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play custom tween %d, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	TweenInstance *pInstance = new TweenInstance();
	pInstance->m_pNext = TweenInstance::g_pInstances;
	TweenInstance::g_pInstances = pInstance;
	pInstance->m_pTarget = 0;
	pInstance->m_pTween = pTween;
	pInstance->m_fDelay = delay;
}

//****f* Tweening/Custom/PauseTweenCustom
// FUNCTION
//   Pauses the given tween at its current point. It will not update again until <i>ResumeTweenCustom</i> 
//   is called. If the tween has already stopped or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to pause
// SOURCE
void agk::PauseTweenCustom( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, 0 );
	if ( pInstance ) pInstance->Pause();
}

//****f* Tweening/Custom/ResumeTweenCustom
// FUNCTION
//   Resumes the given tween from the point it was paused with <i>PauseTweenCustom</i>. 
//   If the tween is already resumed or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to resume
// SOURCE
void agk::ResumeTweenCustom( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, 0 );
	if ( pInstance ) pInstance->Resume();
}

//****f* Tweening/Custom/StopTweenCustom
// FUNCTION
//   Stops a given custom tween ID if it is playing. If the tween is not playing or has finished then this 
//   command has no effect. If the tween was in the middle of an interpolation its values will remain at 
//   their current values, it will not skip to the end or return to the beginning.
// INPUTS
//   tweenID -- ID of the tween to stop
// SOURCE
void agk::StopTweenCustom( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return;

	TweenInstance::DeleteInstance( pTween, 0 );
}

//****f* Tweening/Custom/GetTweenCustomPlaying
// FUNCTION
//   Returns 1 if the given custom tween ID is currently playing, otherwise 0.
//   This will still return 1 if the tween is currently paused.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenCustomPlaying( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return 0;

	if ( TweenInstance::GetInstance( pTween, 0 ) ) return 1;
	
	TweenChain *pChain = m_cTweenChainList.GetFirst();
	while ( pChain )
	{
		if ( pChain->IsCurrentTween( pTween, 0 ) ) return 1;
		pChain = m_cTweenChainList.GetNext();
	}

	return 0;
}

// sprite tweening

//****f* Tweening/Sprites/CreateTweenSprite
// FUNCTION
//   Creates a sprite tween at the given ID with a given duration. This tween is merely a template that can be applied
//   to multiple sprites or chains at the same time.
//   All tween types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a text tween
//   with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
//   values to their end values over the given duration.
// INPUTS
//   tweenID -- ID of the tween
//   duration -- The duration of the tween in seconds
// SOURCE
void agk::CreateTweenSprite( uint32_t tweenID, float duration )
//****
{
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create sprite tween %d, ID must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cTweenList.GetItem( tweenID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create sprite tween " );
		errStr.AppendUInt( tweenID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	if ( duration <= 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create sprite tween %d, duration must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;		
	}

	TweenSprite *pTween = new TweenSprite();
	pTween->m_fDuration = duration;
	m_cTweenList.AddItem( pTween, tweenID );
}

//****f* Tweening/Sprites/CreateTweenSprite
// FUNCTION
//   Creates a sprite tween with a given duration and returns an ID for it. This tween is merely a template that can be applied
//   to multiple sprites or chains at the same time.
//   All tween types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a text tween
//   with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
//   values to their end values over the given duration.
// INPUTS
//   duration -- The duration of the tween in seconds
// SOURCE
uint32_t agk::CreateTweenSprite( float duration )
//****
{
	uint32_t tweenID = m_cTweenList.GetFreeID();
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create sprite tween - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateTweenSprite( tweenID, duration ); 
	return tweenID;
}

//****f* Tweening/Sprites/GetTweenSpriteExists
// FUNCTION
//   Returns 1 if a tween with the given ID exists and it is a sprite tween, otherwise 0.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenSpriteExists( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_SPRITE ) return 0;
	else return 1;
}

//****f* Tweening/Sprites/ClearTweenSprite
// FUNCTION
//   Clears all tweens for the sprite tween
// INPUTS
//   tweenID -- ID of the tween
// SOURCE
void agk::ClearTweenSprite ( UINT tweenID )
//****
{
	TweenSprite *pTween = ( TweenSprite* ) m_cTweenList.GetItem ( tweenID );
	if ( !pTween )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear tween sprite ID %d, ID does not exist", tweenID ); Error ( errStr );
		return;
	}

	if ( pTween->GetType ( ) != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear sprite tween for ID %d, tween ID is not a sprite tween", tweenID ); Error ( errStr );
		return;
	}

	pTween->Reset ( );
}

//****f* Tweening/Custom/ClearTweenCustom
// FUNCTION
//   Clears all tweens for the custom tween
// INPUTS
//   tweenID -- ID of the tween
// SOURCE
void agk::ClearTweenCustom ( UINT tweenID )
//****
{
	TweenCustom *pTween = ( TweenCustom* ) m_cTweenList.GetItem ( tweenID );
	if ( !pTween )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear tween custom ID %d, ID does not exist", tweenID ); Error ( errStr );
		return;
	}

	if ( pTween->GetType ( ) != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear custom tween for ID %d, tween ID is not a custom tween", tweenID ); Error ( errStr );
		return;
	}

	pTween->Reset ( );
}

//****f* Tweening/Text/ClearTweenText
// FUNCTION
//   Clears all tweens for the text tween
// INPUTS
//   tweenID -- ID of the tween
// SOURCE
void agk::ClearTweenText ( UINT tweenID )
//****
{
	TweenText *pTween = ( TweenText* ) m_cTweenList.GetItem ( tweenID );
	if ( !pTween )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear tween text ID %d, ID does not exist", tweenID ); Error ( errStr );
		return;
	}

	if ( pTween->GetType ( ) != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear text tween for ID %d, tween ID is not a text tween", tweenID ); Error ( errStr );
		return;
	}

	pTween->Reset ( );
}

//****f* Tweening/Char/ClearTweenChar
// FUNCTION
//   Clears all tweens for the char tween
// INPUTS
//   tweenID -- ID of the tween
// SOURCE
void agk::ClearTweenChar ( UINT tweenID )
//****
{
	TweenChar *pTween = ( TweenChar* ) m_cTweenList.GetItem ( tweenID );
	if ( !pTween )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear tween char ID %d, ID does not exist", tweenID ); Error ( errStr );
		return;
	}

	if ( pTween->GetType ( ) != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear char tween for ID %d, tween ID is not a char tween", tweenID ); Error ( errStr );
		return;
	}

	pTween->Reset ( );
}

//****f* Tweening/Object/ClearTweenObject
// FUNCTION
//   Clears all tweens for the object tween
// INPUTS
//   tweenID -- ID of the tween
// SOURCE
void agk::ClearTweenObject ( UINT tweenID )
//****
{
	TweenObject *pTween = ( TweenObject* ) m_cTweenList.GetItem ( tweenID );
	if ( !pTween )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear tween object ID %d, ID does not exist", tweenID ); Error ( errStr );
		return;
	}

	if ( pTween->GetType ( ) != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear object tween for ID %d, tween ID is not an object tween", tweenID ); Error ( errStr );
		return;
	}

	pTween->Reset ( );
}

//****f* Tweening/Camera/ClearTweenCamera
// FUNCTION
//   Clears all tweens for the camera tween
// INPUTS
//   tweenID -- ID of the tween
// SOURCE
void agk::ClearTweenCamera ( UINT tweenID )
//****
{
	TweenCamera *pTween = ( TweenCamera* ) m_cTweenList.GetItem ( tweenID );
	if ( !pTween )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear tween camera ID %d, ID does not exist", tweenID ); Error ( errStr );
		return;
	}

	if ( pTween->GetType ( ) != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr ( "", 100 ); errStr.Format ( "Failed to clear camera tween for ID %d, tween ID is not a camera tween", tweenID ); Error ( errStr );
		return;
	}

	pTween->Reset ( );
}

//****f* Tweening/Sprites/SetTweenSpriteX
// FUNCTION
//   Sets the X parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite. This modifies the position of the sprite using its top left corner.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginX -- The starting X value for the sprite, the sprite will be positioned here when playing starts
//   endX -- The end X value for the sprite, the sprite will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginX to endX
// SOURCE
void agk::SetTweenSpriteX( uint32_t tweenID, float beginX, float endX, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween X for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween X for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginX = beginX;
	pTween->m_fEndX = endX;
	pTween->m_iInterpX = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteY
// FUNCTION
//   Sets the Y parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite. This modifies the position of the sprite using its top left corner.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginY -- The starting Y value for the sprite, the sprite will be positioned here when playing starts
//   endY -- The end Y value for the sprite, the sprite will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginY to endY
// SOURCE
void agk::SetTweenSpriteY( uint32_t tweenID, float beginY, float endY, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Y for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Y for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginY = beginY;
	pTween->m_fEndY = endY;
	pTween->m_iInterpY = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteXByOffset
// FUNCTION
//   Sets the X parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite. This modifies the position of the sprite using its offset point, usually the
//   center of the sprite.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginX -- The starting X value for the sprite, the sprite will be positioned here when playing starts
//   endX -- The end X value for the sprite, the sprite will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginX to endX
// SOURCE
void agk::SetTweenSpriteXByOffset( uint32_t tweenID, float beginX, float endX, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween X by offset for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween X by offset for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginXByOffset = beginX;
	pTween->m_fEndXByOffset = endX;
	pTween->m_iInterpXByOffset = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteYByOffset
// FUNCTION
//   Sets the Y parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite. This modifies the position of the sprite using its offset point, usually the
//   center of the sprite.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginY -- The starting Y value for the sprite, the sprite will be positioned here when playing starts
//   endY -- The end Y value for the sprite, the sprite will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginY to endY
// SOURCE
void agk::SetTweenSpriteYByOffset( uint32_t tweenID, float beginY, float endY, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Y by offset for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Y by offset for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginYByOffset = beginY;
	pTween->m_fEndYByOffset = endY;
	pTween->m_iInterpYByOffset = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteAngle
// FUNCTION
//   Sets the Angle parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginA -- The starting Angle value for the sprite, the sprite will be rotated at this angle when playing starts
//   endA -- The end Angle value for the sprite, the sprite will be rotated at this angle when playing ends
//   interpolation -- The interpolation method whilst the sprite is rotating from beginA to endA
// SOURCE
void agk::SetTweenSpriteAngle( uint32_t tweenID, float beginA, float endA, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Angle for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Angle for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginAngle = beginA;
	pTween->m_fEndAngle = endA;
	pTween->m_iInterpAngle = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteSizeX
// FUNCTION
//   Sets the SizeX parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginSX -- The starting SizeX value for the sprite, the sprite will be this size when playing starts
//   endSX -- The end SizeX value for the sprite, the sprite will be this size when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginSX to endSX
// SOURCE
void agk::SetTweenSpriteSizeX( uint32_t tweenID, float beginSX, float endSX, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween SizeX for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween SizeX for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginSizeX = beginSX;
	pTween->m_fEndSizeX = endSX;
	pTween->m_iInterpSizeX = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteSizeY
// FUNCTION
//   Sets the SizeY parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginSY -- The starting SizeY value for the sprite, the sprite will be this size when playing starts
//   endSY -- The end SizeY value for the sprite, the sprite will be this size when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginSX to endSX
// SOURCE
void agk::SetTweenSpriteSizeY( uint32_t tweenID, float beginSY, float endSY, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween SizeY for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween SizeY for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginSizeY = beginSY;
	pTween->m_fEndSizeY = endSY;
	pTween->m_iInterpSizeY = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteRed
// FUNCTION
//   Sets the Red parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginR -- The starting Red color for the sprite (0 to 255), the sprite will be this color when playing starts
//   endR -- The end Red color for the sprite (0 to 255), the sprite will be this color when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginR to endR
// SOURCE
void agk::SetTweenSpriteRed( uint32_t tweenID, int beginR, int endR, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Red for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Red for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginRed = beginR;
	pTween->m_iEndRed = endR;
	pTween->m_iInterpRed = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteGreen
// FUNCTION
//   Sets the Green parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginG -- The starting Green color for the sprite (0 to 255), the sprite will be this color when playing starts
//   endG -- The end Green color for the sprite (0 to 255), the sprite will be this color when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginG to endG
// SOURCE
void agk::SetTweenSpriteGreen( uint32_t tweenID, int beginG, int endG, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Green for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Green for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginGreen = beginG;
	pTween->m_iEndGreen = endG;
	pTween->m_iInterpGreen = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteBlue
// FUNCTION
//   Sets the Blue parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginB -- The starting Blue color for the sprite (0 to 255), the sprite will be this color when playing starts
//   endB -- The end Blue color for the sprite (0 to 255), the sprite will be this color when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginB to endB
// SOURCE
void agk::SetTweenSpriteBlue( uint32_t tweenID, int beginB, int endB, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Blue for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Blue for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginBlue = beginB;
	pTween->m_iEndBlue = endB;
	pTween->m_iInterpBlue = interpolation;
	
}

//****f* Tweening/Sprites/SetTweenSpriteAlpha
// FUNCTION
//   Sets the Alpha parameter of the given tween ID. A Tween can modify several parameters of a sprite 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many sprites or chains at the same time with PlayTweenSprite 
//   or AddTweenChainSprite.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginA -- The starting Alpha color for the sprite (0 to 255), the sprite will be this color when playing starts
//   endA -- The end Alpha color for the sprite (0 to 255), the sprite will be this color when playing ends
//   interpolation -- The interpolation method whilst the sprite is moving from beginA to endA
// SOURCE
void agk::SetTweenSpriteAlpha( uint32_t tweenID, int beginA, int endA, int interpolation )
//****
{
	TweenSprite *pTween = (TweenSprite*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Alpha for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set sprite tween Alpha for ID %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginAlpha = beginA;
	pTween->m_iEndAlpha = endA;
	pTween->m_iInterpAlpha = interpolation;
	
}

//****f* Tweening/Sprites/PlayTweenSprite
// FUNCTION
//   Applies the given tween ID to a given sprite ID with an optional delay and starts playing it.
//   A tween can be played on multiple sprites at the same time, simply call this command again with
//   a different sprite ID. The sprite will not be modified until the delay time has passed, at 
//   which point the tween will start at the begin values and move towards the end values over the
//   tween duration.
//   If a tween end value is modified whilst the tween is playing on a sprite the sprite will adjust
//   its interpolation accordingly. Modifying the duration whilst playing is undefined and not 
//   compatible with chains.
// INPUTS
//   tweenID -- ID of the tween to use
//   spriteID -- ID of the sprite to modify
//   delay -- Number of seconds before the tween should start playing
// SOURCE
void agk::PlayTweenSprite( uint32_t tweenID, uint32_t spriteID, float delay )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play sprite tween %d, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play sprite tween %d, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	cSprite *pSprite = m_cSpriteList.GetItem( spriteID );
	if ( !pSprite )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play sprite tween %d on sprite %d, sprite ID does not exist", tweenID, spriteID ); Error( errStr );
		return;		
	}

	TweenInstance *pInstance = new TweenInstance();
	pInstance->m_pNext = TweenInstance::g_pInstances;
	TweenInstance::g_pInstances = pInstance;
	pInstance->m_pTarget = pSprite;
	pInstance->m_pTween = pTween;
	pInstance->m_fDelay = delay;	
}

//****f* Tweening/Sprites/PauseTweenSprite
// FUNCTION
//   Pauses the given tween at its current point. It will not update again until <i>ResumeTweenSprite</i> 
//   is called. If the tween has already stopped or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to pause
//   spriteID -- ID of the sprite to pause
// SOURCE
void agk::PauseTweenSprite( uint32_t tweenID, uint32_t spriteID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_SPRITE ) return;

	cSprite *pSprite = m_cSpriteList.GetItem( spriteID );
	if ( !pSprite ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pSprite );
	if ( pInstance ) pInstance->Pause();
}

//****f* Tweening/Sprites/GetTweenSpriteTime
// FUNCTION
//   Returns the current time of the tween sprite
// INPUTS
//   tweenID -- ID of the tween
//   spriteID -- ID of the sprite
// SOURCE
float agk::GetTweenSpriteTime ( UINT tweenID, UINT spriteID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_SPRITE ) return 0.0f;

	cSprite *pSprite = m_cSpriteList.GetItem ( spriteID );
	if ( !pSprite ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, pSprite );
	if ( pInstance ) return pInstance->m_fCurrentTime;

	return 0.0f;
}

//****f* Tweening/Sprites/GetTweenSpriteEndTime
// FUNCTION
//   Returns the end time of the tween sprite
// INPUTS
//   tweenID -- ID of the tween
//   spriteID -- ID of the sprite
// SOURCE
float agk::GetTweenSpriteEndTime ( UINT tweenID, UINT spriteID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_SPRITE ) return 0.0f;

	cSprite *pSprite = m_cSpriteList.GetItem ( spriteID );
	if ( !pSprite ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, pSprite );
	if ( pInstance ) return pInstance->m_pTween->m_fDuration;

	return 0.0f;
}

//****f* Tweening/Sprites/ResumeTweenSprite
// FUNCTION
//   Resumes the given tween from the point it was paused with <i>PauseTweenSprite</i>. 
//   If the tween is already resumed or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to resume
//   spriteID -- ID of the sprite to resume
// SOURCE
void agk::ResumeTweenSprite( uint32_t tweenID, uint32_t spriteID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_SPRITE ) return;

	cSprite *pSprite = m_cSpriteList.GetItem( spriteID );
	if ( !pSprite ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pSprite );
	if ( pInstance ) pInstance->Resume();
}

//****f* Tweening/Sprites/StopTweenSprite
// FUNCTION
//   Stops a given tween ID if it is playing on a given sprite. If the tween is not playing or has 
//   finished then this command has no effect.
//   If the sprite was in the middle of an interpolation it will remain at its current position, it
//   will not skip to the end or return to the beginning.
// INPUTS
//   tweenID -- ID of the tween to stop
//   spriteID -- ID of the sprite to stop
// SOURCE
void agk::StopTweenSprite( uint32_t tweenID, uint32_t spriteID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_SPRITE ) return;

	cSprite *pSprite = m_cSpriteList.GetItem( spriteID );
	if ( !pSprite ) return;

	TweenInstance::DeleteInstance( pTween, pSprite );
}

//****f* Tweening/Sprites/GetTweenSpritePlaying
// FUNCTION
//   Returns 1 if the given tween ID is currently playing on the given sprite, otherwise 0.
//   This will still return 1 if the tween is currently paused.
// INPUTS
//   tweenID -- ID of the tween to check
//   spriteID -- ID of the sprite to check
// SOURCE
int agk::GetTweenSpritePlaying( uint32_t tweenID, uint32_t spriteID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_SPRITE ) return 0;

	cSprite *pSprite = m_cSpriteList.GetItem( spriteID );
	if ( !pSprite ) return 0;

	if ( TweenInstance::GetInstance( pTween, pSprite ) ) return 1;
	
	TweenChain *pChain = m_cTweenChainList.GetFirst();
	while ( pChain )
	{
		if ( pChain->IsCurrentTween( pTween, pSprite ) ) return 1;
		pChain = m_cTweenChainList.GetNext();
	}

	return 0;
}


// text tweening

//****f* Tweening/Text/CreateTweenText
// FUNCTION
//   Creates a text tween at the given ID with a given duration. This tween is merely a template that can be applied
//   to multiple text objects or chains at the same time.
//   All tween types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a text tween
//   with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
//   values to their end values over the given duration.
// INPUTS
//   tweenID -- ID of the tween
//   duration -- The duration of the tween in seconds
// SOURCE
void agk::CreateTweenText( uint32_t tweenID, float duration )
//****
{
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create text tween %d, ID must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cTweenList.GetItem( tweenID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create text tween " );
		errStr.AppendUInt( tweenID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	if ( duration <= 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create text tween %d, duration must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;		
	}

	TweenText *pTween = new TweenText();
	pTween->m_fDuration = duration;
	m_cTweenList.AddItem( pTween, tweenID );
}

//****f* Tweening/Text/CreateTweenText
// FUNCTION
//   Creates a text tween with a given duration and returns an ID for it. This tween is merely a template that can be applied
//   to multiple text objects or chains at the same time.
//   All tween types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a text tween
//   with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
//   values to their end values over the given duration.
// INPUTS
//   duration -- The duration of the tween in seconds
// SOURCE
uint32_t agk::CreateTweenText( float duration )
//****
{
	uint32_t tweenID = m_cTweenList.GetFreeID();
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create text tween - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateTweenText( tweenID, duration ); 
	return tweenID;
}

//****f* Tweening/Text/GetTweenTextExists
// FUNCTION
//   Returns 1 if a tween with the given ID exists and it is a text tween, otherwise 0.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenTextExists( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_TEXT ) return 0;
	else return 1;
}

//****f* Tweening/Text/SetTweenTextX
// FUNCTION
//   Sets the X parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginX -- The starting X value for the text, the text will be positioned here when playing starts
//   endX -- The end X value for the text, the text will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginX to endX
// SOURCE
void agk::SetTweenTextX( uint32_t tweenID, float beginX, float endX, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween X for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween X for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginX = beginX;
	pTween->m_fEndX = endX;
	pTween->m_iInterpX = interpolation;
	
}

//****f* Tweening/Text/SetTweenTextY
// FUNCTION
//   Sets the Y parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginY -- The starting Y value for the text, the text will be positioned here when playing starts
//   endY -- The end Y value for the text, the text will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginY to endY
// SOURCE
void agk::SetTweenTextY( uint32_t tweenID, float beginY, float endY, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Y for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Y for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginY = beginY;
	pTween->m_fEndY = endY;
	pTween->m_iInterpY = interpolation;
	
}

//****f* Tweening/Text/SetTweenTextAngle
// FUNCTION
//   Sets the Angle parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginA -- The starting Angle value for the text, the text will be rotated at this angle when playing starts
//   endA -- The end Angle value for the text, the text will be rotated at this angle when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginA to endA
// SOURCE
void agk::SetTweenTextAngle( uint32_t tweenID, float beginA, float endA, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Angle for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Angle for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginAngle = beginA;
	pTween->m_fEndAngle = endA;
	pTween->m_iInterpAngle = interpolation;
	
}

//****f* Tweening/Text/SetTweenTextSize
// FUNCTION
//   Sets the Size parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginS -- The starting Size value for the text, the text will be this size when playing starts
//   endS -- The end Size value for the text, the text will be this size when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginS to endS
// SOURCE
void agk::SetTweenTextSize( uint32_t tweenID, float beginS, float endS, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Size for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Size for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginSize = beginS;
	pTween->m_fEndSize = endS;
	pTween->m_iInterpSize = interpolation;
	
}

//****f* Tweening/Text/SetTweenTextSpacing
// FUNCTION
//   Sets the Spacing parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginSP -- The starting Spacing value for the text, the text will have this spacing when playing starts
//   endSP -- The end Spacing value for the text, the text will have this spacing when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginSP to endSP
// SOURCE
void agk::SetTweenTextSpacing( uint32_t tweenID, float beginSP, float endSP, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Spacing for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Spacing for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginSpacing = beginSP;
	pTween->m_fEndSpacing = endSP;
	pTween->m_iInterpSpacing = interpolation;
	
}

//****f* Tweening/Text/SetTweenTextLineSpacing
// FUNCTION
//   Sets the Line Spacing parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginLSP -- The starting Line Spacing value for the text, the text will have this spacing when playing starts
//   endLSP -- The end Line Spacing value for the text, the text will have this spacing when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginLSP to endLSP
// SOURCE
void agk::SetTweenTextLineSpacing( uint32_t tweenID, float beginLSP, float endLSP, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Line Spacing for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Line Spacing for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginLineSpacing = beginLSP;
	pTween->m_fEndSpacing = endLSP;
	pTween->m_iInterpSpacing = interpolation;
	
}

//****f* Tweening/Text/SetTweenTextRed
// FUNCTION
//   Sets the Red parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginR -- The starting Red color for the text, the text will be this color when playing starts
//   endR -- The end Red color for the text, the text will be this color when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginR to endR
// SOURCE
void agk::SetTweenTextRed( uint32_t tweenID, int beginR, int endR, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Red for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Red for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginRed = beginR;
	pTween->m_iEndRed = endR;
	pTween->m_iInterpRed = interpolation;
	
}

//****f* Tweening/Text/SetTweenTextGreen
// FUNCTION
//   Sets the Green parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginG -- The starting Green color for the text, the text will be this color when playing starts
//   endG -- The end Green color for the text, the text will be this color when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginG to endG
// SOURCE
void agk::SetTweenTextGreen( uint32_t tweenID, int beginG, int endG, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Green for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Green for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginGreen = beginG;
	pTween->m_iEndGreen = endG;
	pTween->m_iInterpGreen = interpolation;
	
}

//****f* Tweening/Text/SetTweenTextBlue
// FUNCTION
//   Sets the Blue parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginB -- The starting Blue color for the text, the text will be this color when playing starts
//   endB -- The end Blue color for the text, the text will be this color when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginB to endB
// SOURCE
void agk::SetTweenTextBlue( uint32_t tweenID, int beginB, int endB, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Blue for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Blue for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginBlue = beginB;
	pTween->m_iEndBlue = endB;
	pTween->m_iInterpBlue = interpolation;
	
}

//****f* Tweening/Text/SetTweenTextAlpha
// FUNCTION
//   Sets the Alpha parameter of the given tween ID. A Tween can modify several parameters of a text object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many text objects or chains at the same time with 
//   PlayTweenText or AddTweenChainText.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginA -- The starting Alpha color for the text, the text will be this color when playing starts
//   endA -- The end Alpha color for the text, the text will be this color when playing ends
//   interpolation -- The interpolation method whilst the text is moving from beginA to endA
// SOURCE
void agk::SetTweenTextAlpha( uint32_t tweenID, int beginA, int endA, int interpolation )
//****
{
	TweenText *pTween = (TweenText*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Alpha for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set text tween Alpha for ID %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginAlpha = beginA;
	pTween->m_iEndAlpha = endA;
	pTween->m_iInterpAlpha = interpolation;
	
}

//****f* Tweening/Text/PlayTweenText
// FUNCTION
//   Applies the given tween ID to a given text ID with an optional delay and starts playing it.
//   A tween can be played on multiple text objects at the same time, simply call this command again with
//   a different text ID. The text will not be modified until the delay time has passed, at 
//   which point the tween will start at the begin values and move towards the end values over the
//   tween duration.
//   If a tween end value is modified whilst the tween is playing on a text object the text will adjust
//   its interpolation accordingly. Modifying the duration whilst playing is undefined and not 
//   compatible with chains.
// INPUTS
//   tweenID -- ID of the tween to use
//   textID -- ID of the text object to modify
//   delay -- Number of seconds before the tween should start playing
// SOURCE
void agk::PlayTweenText( uint32_t tweenID, uint32_t textID, float delay )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play text tween %d, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play text tween %d, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play text tween %d on text %d, text ID does not exist", tweenID, textID ); Error( errStr );
		return;		
	}

	TweenInstance *pInstance = new TweenInstance();
	pInstance->m_pNext = TweenInstance::g_pInstances;
	TweenInstance::g_pInstances = pInstance;
	pInstance->m_pTarget = pText;
	pInstance->m_pTween = pTween;
	pInstance->m_fDelay = delay;
}

//****f* Tweening/Text/PauseTweenText
// FUNCTION
//   Pauses the given tween at its current point. It will not update again until <i>ResumeTweenText</i> 
//   is called. If the tween has already stopped or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to pause
//   textID -- ID of the text to pause
// SOURCE
void agk::PauseTweenText( uint32_t tweenID, uint32_t textID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_TEXT ) return;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pText );
	if ( pInstance ) pInstance->Pause();
}

//****f* Tweening/Text/ResumeTweenText
// FUNCTION
//   Resumes the given tween from the point it was paused with <i>PauseTweenText</i>. 
//   If the tween is already resumed or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to resume
//   textID -- ID of the text to resume
// SOURCE
void agk::ResumeTweenText( uint32_t tweenID, uint32_t textID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_TEXT ) return;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pText );
	if ( pInstance ) pInstance->Resume();
}

//****f* Tweening/Text/StopTweenText
// FUNCTION
//   Stops a given tween ID if it is playing on a given text object. If the tween is not playing or has 
//   finished then this command has no effect.
//   If the text was in the middle of an interpolation it will remain at its current position, it
//   will not skip to the end or return to the beginning.
// INPUTS
//   tweenID -- ID of the tween to stop
//   textID -- ID of the text object to stop
// SOURCE
void agk::StopTweenText( uint32_t tweenID, uint32_t textID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_TEXT ) return;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return;

	TweenInstance::DeleteInstance( pTween, pText );
}

//****f* Tweening/Text/GetTweenTextPlaying
// FUNCTION
//   Returns 1 if the given tween ID is currently playing on the given text object, otherwise 0.
//   This will still return 1 if the tween is currently paused.
// INPUTS
//   tweenID -- ID of the tween to check
//   textID -- ID of the text to check
// SOURCE
int agk::GetTweenTextPlaying( uint32_t tweenID, uint32_t textID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_TEXT ) return 0;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return 0;

	if ( TweenInstance::GetInstance( pTween, pText ) ) return 1;
	
	TweenChain *pChain = m_cTweenChainList.GetFirst();
	while ( pChain )
	{
		if ( pChain->IsCurrentTween( pTween, pText ) ) return 1;
		pChain = m_cTweenChainList.GetNext();
	}

	return 0;
}

//****f* Tweening/Text/GetTweenTextTime
// FUNCTION
//   Returns the current time of the tween text
// INPUTS
//   tweenID -- ID of the tween
//   textID -- ID of the text
// SOURCE
float agk::GetTweenTextTime ( UINT tweenID, UINT textID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_TEXT ) return 0.0f;

	cText *pText = m_cTextList.GetItem ( textID );
	if ( !pText ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, pText );
	if ( pInstance ) return pInstance->m_fCurrentTime;

	return 0.0f;
}

//****f* Tweening/Text/GetTweenTextEndTime
// FUNCTION
//   Returns the end time of the tween text
// INPUTS
//   tweenID -- ID of the tween
//   textID -- ID of the text
// SOURCE
float agk::GetTweenTextEndTime ( UINT tweenID, UINT textID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_TEXT ) return 0.0f;

	cText *pText = m_cTextList.GetItem ( textID );
	if ( !pText ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, pText );
	if ( pInstance ) return pInstance->m_pTween->m_fDuration;

	return 0.0f;
}


// text char tweening

//****f* Tweening/Char/CreateTweenChar
// FUNCTION
//   Creates a char tween at the given ID with a given duration. This can be applied to individual characters
//   of a text object.
//   This tween is merely a template that can be appliedto multiple text characters or chains at the same time.
//   All tween types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a char tween
//   with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
//   values to their end values over the given duration.
// INPUTS
//   tweenID -- ID of the tween
//   duration -- The duration of the tween in seconds
// SOURCE
void agk::CreateTweenChar( uint32_t tweenID, float duration )
//****
{
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create text char tween %d, ID must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cTweenList.GetItem( tweenID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create text char tween " );
		errStr.AppendUInt( tweenID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	if ( duration <= 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create text char tween %d, duration must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;		
	}

	TweenChar *pTween = new TweenChar();
	pTween->m_fDuration = duration;
	m_cTweenList.AddItem( pTween, tweenID );
}

//****f* Tweening/Char/CreateTweenChar
// FUNCTION
//   Creates a char tween with a given duration and returns an ID for it. This can be applied to individual characters
//   of a text object.
//   This tween is merely a template that can be applied to multiple text characters or chains at the same time.
//   All tween types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a char tween
//   with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
//   values to their end values over the given duration.
// INPUTS
//   duration -- The duration of the tween in seconds
// SOURCE
uint32_t agk::CreateTweenChar( float duration )
//****
{
	uint32_t tweenID = m_cTweenList.GetFreeID();
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create text char tween - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateTweenChar( tweenID, duration ); 
	return tweenID;
}

//****f* Tweening/Char/GetTweenCharExists
// FUNCTION
//   Returns 1 if a tween with the given ID exists and it is a char tween, otherwise 0.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenCharExists( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CHAR ) return 0;
	else return 1;
}

//****f* Tweening/Char/SetTweenCharX
// FUNCTION
//   Sets the X parameter of the given tween ID. A Tween can modify several parameters of a character 
//   at the same time. Set the begin value and the end value and an interpolation method. Character 
//   positions ar relative to the parent text object.
//   A tween is just a template that can be applied to many characters or chains at the same time, 
//   including from different text objects, with PlayTweenChar or AddTweenChainChar.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginX -- The starting X value for the character, the character will be positioned here when playing starts
//   endX -- The end X value for the character, the character will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the character is moving from beginX to endX
// SOURCE
void agk::SetTweenCharX( uint32_t tweenID, float beginX, float endX, int interpolation )
//****
{
	TweenChar *pTween = (TweenChar*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween X for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween X for ID %d, tween ID is not a char tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginX = beginX;
	pTween->m_fEndX = endX;
	pTween->m_iInterpX = interpolation;
	
}

//****f* Tweening/Char/SetTweenCharY
// FUNCTION
//   Sets the Y parameter of the given tween ID. A Tween can modify several parameters of a character 
//   at the same time. Set the begin value and the end value and an interpolation method. Character 
//   positions ar relative to the parent text object.
//   A tween is just a template that can be applied to many characters or chains at the same time, 
//   including from different text objects, with PlayTweenChar or AddTweenChainChar.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginY -- The starting Y value for the character, the character will be positioned here when playing starts
//   endY -- The end Y value for the character, the character will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the character is moving from beginY to endY
// SOURCE
void agk::SetTweenCharY( uint32_t tweenID, float beginY, float endY, int interpolation )
//****
{
	TweenChar *pTween = (TweenChar*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Y for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Y for ID %d, tween ID is not a char tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginY = beginY;
	pTween->m_fEndY = endY;
	pTween->m_iInterpY = interpolation;
	
}

//****f* Tweening/Char/SetTweenCharAngle
// FUNCTION
//   Sets the Angle parameter of the given tween ID. A Tween can modify several parameters of a character 
//   at the same time. Set the begin value and the end value and an interpolation method.
//   A tween is just a template that can be applied to many characters or chains at the same time, 
//   including from different text objects, with PlayTweenChar or AddTweenChainChar.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginA -- The starting Angle value for the character, the character will be rotated at this angle when playing starts
//   endA -- The end Angle value for the character, the character will be rotated at this angle when playing ends
//   interpolation -- The interpolation method whilst the character is moving from beginA to endA
// SOURCE
void agk::SetTweenCharAngle( uint32_t tweenID, float beginA, float endA, int interpolation )
//****
{
	TweenChar *pTween = (TweenChar*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Angle for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Angle for ID %d, tween ID is not a char tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginAngle = beginA;
	pTween->m_fEndAngle = endA;
	pTween->m_iInterpAngle = interpolation;
	
}

//****f* Tweening/Char/SetTweenCharRed
// FUNCTION
//   Sets the Red parameter of the given tween ID. A Tween can modify several parameters of a character 
//   at the same time. Set the begin value and the end value and an interpolation method.
//   A tween is just a template that can be applied to many characters or chains at the same time, 
//   including from different text objects, with PlayTweenChar or AddTweenChainChar.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginR -- The starting Red value for the character, the character will be this color when playing starts
//   endR -- The end Red value for the character, the character will be this color when playing ends
//   interpolation -- The interpolation method whilst the character is moving from beginR to endR
// SOURCE
void agk::SetTweenCharRed( uint32_t tweenID, int beginR, int endR, int interpolation )
//****
{
	TweenChar *pTween = (TweenChar*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Red for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Red for ID %d, tween ID is not a char tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginRed = beginR;
	pTween->m_iEndRed = endR;
	pTween->m_iInterpRed = interpolation;
	
}

//****f* Tweening/Char/SetTweenCharGreen
// FUNCTION
//   Sets the Green parameter of the given tween ID. A Tween can modify several parameters of a character 
//   at the same time. Set the begin value and the end value and an interpolation method.
//   A tween is just a template that can be applied to many characters or chains at the same time, 
//   including from different text objects, with PlayTweenChar or AddTweenChainChar.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginG -- The starting Green value for the character, the character will be this color when playing starts
//   endG -- The end Green value for the character, the character will be this color when playing ends
//   interpolation -- The interpolation method whilst the character is moving from beginG to endG
// SOURCE
void agk::SetTweenCharGreen( uint32_t tweenID, int beginG, int endG, int interpolation )
//****
{
	TweenChar *pTween = (TweenChar*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Green for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Green for ID %d, tween ID is not a char tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginGreen = beginG;
	pTween->m_iEndGreen = endG;
	pTween->m_iInterpGreen = interpolation;
	
}

//****f* Tweening/Char/SetTweenCharBlue
// FUNCTION
//   Sets the Blue parameter of the given tween ID. A Tween can modify several parameters of a character 
//   at the same time. Set the begin value and the end value and an interpolation method.
//   A tween is just a template that can be applied to many characters or chains at the same time, 
//   including from different text objects, with PlayTweenChar or AddTweenChainChar.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginB -- The starting Blue value for the character, the character will be this color when playing starts
//   endB -- The end Blue value for the character, the character will be this color when playing ends
//   interpolation -- The interpolation method whilst the character is moving from beginB to endB
// SOURCE
void agk::SetTweenCharBlue( uint32_t tweenID, int beginB, int endB, int interpolation )
//****
{
	TweenChar *pTween = (TweenChar*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Blue for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween BLue for ID %d, tween ID is not a char tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginBlue = beginB;
	pTween->m_iEndBlue = endB;
	pTween->m_iInterpBlue = interpolation;
	
}

//****f* Tweening/Char/SetTweenCharAlpha
// FUNCTION
//   Sets the Alpha parameter of the given tween ID. A Tween can modify several parameters of a character 
//   at the same time. Set the begin value and the end value and an interpolation method.
//   A tween is just a template that can be applied to many characters or chains at the same time, 
//   including from different text objects, with PlayTweenChar or AddTweenChainChar.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginA -- The starting Alpha value for the character, the character will be this color when playing starts
//   endA -- The end Alpha value for the character, the character will be this color when playing ends
//   interpolation -- The interpolation method whilst the character is moving from beginA to endA
// SOURCE
void agk::SetTweenCharAlpha( uint32_t tweenID, int beginA, int endA, int interpolation )
//****
{
	TweenChar *pTween = (TweenChar*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Alpha for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set char tween Alpha for ID %d, tween ID is not a char tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginAlpha = beginA;
	pTween->m_iEndAlpha = endA;
	pTween->m_iInterpAlpha = interpolation;
	
}

//****f* Tweening/Char/PlayTweenChar
// FUNCTION
//   Applies the given tween ID to a given character in a text object with an optional delay 
//   and starts playing it.
//   A tween can be played on multiple characters across multiple text objects at the same 
//   time, simply call this command again with a different text or character ID. The character 
//   will not be modified until the delay time has passed, at which point the tween will 
//   start at the begin values and move towards the end values over the tween duration.
//   If a tween end value is modified whilst the tween is playing on a character the character 
//   will adjust its interpolation accordingly. Modifying the duration whilst playing is 
//   undefined and not compatible with chains.
// INPUTS
//   tweenID -- ID of the tween to use
//   textID -- ID of the text object to modify
//   charID -- The index of the character, indices start at 0, if out of range it will be ignored
//   delay -- Number of seconds before the tween should start playing
// SOURCE
void agk::PlayTweenChar( uint32_t tweenID, uint32_t textID, uint32_t charID, float delay )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play char tween %d, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play char tween %d, tween ID is not a char tween", tweenID ); Error( errStr );
		return;				
	}

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play text char tween %d on text %d, text ID does not exist", tweenID, textID ); Error( errStr );
		return;		
	}

	TweenInstance *pInstance = new TweenInstance();
	pInstance->m_pNext = TweenInstance::g_pInstances;
	TweenInstance::g_pInstances = pInstance;
	pInstance->m_pTarget = pText;
	pInstance->m_iSubTarget = charID;
	pInstance->m_pTween = pTween;
	pInstance->m_fDelay = delay;
	
}

//****f* Tweening/Char/PauseTweenChar
// FUNCTION
//   Pauses the given tween at its current point. It will not update again until <i>ResumeTweenChar</i> 
//   is called. If the tween has already stopped or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to pause
//   textID -- ID of the text to pause
//   charID -- Index of the character to pause
// SOURCE
void agk::PauseTweenChar( uint32_t tweenID, uint32_t textID, uint32_t charID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CHAR ) return;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pText, charID );
	if ( pInstance ) pInstance->Pause();
}

//****f* Tweening/Char/ResumeTweenChar
// FUNCTION
//   Resumes the given tween from the point it was paused with <i>PauseTweenChar</i>. 
//   If the tween is already resumed or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to resume
//   textID -- ID of the text to resume
//   charID -- Index of the character to resume
// SOURCE
void agk::ResumeTweenChar( uint32_t tweenID, uint32_t textID, uint32_t charID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CHAR ) return;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pText );
	if ( pInstance ) pInstance->Resume();
}

//****f* Tweening/Char/StopTweenChar
// FUNCTION
//   Stops a given tween ID if it is playing on a given character of a text object. If the tween 
//   is not playing or has finished then this command has no effect.
//   If the character was in the middle of an interpolation it will remain at its current position, 
//   it will not skip to the end or return to the beginning.
// INPUTS
//   tweenID -- ID of the tween to stop
//   textID -- ID of the text object containing the character
//   charID -- The index of the character to stop, indices start at 0, if out of range it will be ignored
// SOURCE
void agk::StopTweenChar( uint32_t tweenID, uint32_t textID, uint32_t charID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CHAR ) return;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return;

	TweenInstance::DeleteInstance( pTween, pText, charID );
}

//****f* Tweening/Char/GetTweenCharPlaying
// FUNCTION
//   Returns 1 if the given tween ID is currently playing on the given character and text 
//   object, otherwise 0.
//   This will still return 1 if the tween is currently paused.
// INPUTS
//   tweenID -- ID of the tween to check
//   textID -- ID of the text to check
//   charID -- Index of the character to check, indices start at 0, if out of range it is ignored
// SOURCE
int agk::GetTweenCharPlaying( uint32_t tweenID, uint32_t textID, uint32_t charID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CHAR ) return 0;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return 0;

	if ( TweenInstance::GetInstance( pTween, pText, charID ) ) return 1;
	
	TweenChain *pChain = m_cTweenChainList.GetFirst();
	while ( pChain )
	{
		if ( pChain->IsCurrentTween( pTween, pText, charID ) ) return 1;
		pChain = m_cTweenChainList.GetNext();
	}

	return 0;
}

//****f* Tweening/Char/GetTweenCharTime
// FUNCTION
//   Returns the current time of the tween char
// INPUTS
//   tweenID -- ID of the tween
//   textID -- ID of the text
//   charID -- Index of the character to check, indices start at 0, if out of range it is ignored
// SOURCE
float agk::GetTweenCharTime ( UINT tweenID, UINT textID, UINT charID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_CHAR ) return 0.0f;

	cText *pText = m_cTextList.GetItem ( textID );
	if ( !pText ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, pText, charID );
	if ( pInstance ) return pInstance->m_fCurrentTime;

	return 0.0f;
}

//****f* Tweening/Char/GetTweenCharEndTime
// FUNCTION
//   Returns the end time of the tween char
// INPUTS
//   tweenID -- ID of the tween
//   textID -- ID of the text
//   charID -- Index of the character to check, indices start at 0, if out of range it is ignored
// SOURCE
float agk::GetTweenCharEndTime ( UINT tweenID, UINT textID, UINT charID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_CHAR ) return 0.0f;

	cText *pText = m_cTextList.GetItem ( textID );
	if ( !pText ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, pText, charID );
	if ( pInstance ) return pInstance->m_pTween->m_fDuration;

	return 0.0f;
}

// object tweening

//****f* Tweening/Objects/CreateTweenObject
// FUNCTION
//   Creates an object tween at the given ID with a given duration. This tween is merely a template that can be applied
//   to multiple objects or chains at the same time.
//   All tween types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as an object tween
//   with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
//   values to their end values over the given duration.
// INPUTS
//   tweenID -- ID of the tween
//   duration -- The duration of the tween in seconds
// SOURCE
void agk::CreateTweenObject( uint32_t tweenID, float duration )
//****
{
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object tween %d, ID must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cTweenList.GetItem( tweenID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create object tween " );
		errStr.AppendUInt( tweenID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	if ( duration <= 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object tween %d, duration must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;		
	}

	TweenObject *pTween = new TweenObject();
	pTween->m_fDuration = duration;
	m_cTweenList.AddItem( pTween, tweenID );
}

//****f* Tweening/Objects/CreateTweenObject
// FUNCTION
//   Creates an object tween with a given duration and returns an ID for it. This tween is merely a template 
//   that can be applied to multiple objects or chains at the same time.
//   All tween types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as an 
//   object tween with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from 
//   their start values to their end values over the given duration.
// INPUTS
//   duration -- The duration of the tween in seconds
// SOURCE
uint32_t agk::CreateTweenObject( float duration )
//****
{
	uint32_t tweenID = m_cTweenList.GetFreeID();
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create object tween - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateTweenObject( tweenID, duration ); 
	return tweenID;
}

//****f* Tweening/Objects/GetTweenObjectExists
// FUNCTION
//   Returns 1 if a tween exists at the given ID and it is an object tween, otherwise 0.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenObjectExists( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_OBJECT ) return 0;
	else return 1;
}

//****f* Tweening/Objects/SetTweenObjectX
// FUNCTION
//   Sets the X parameter of the given tween ID. A Tween can modify several parameters of an object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many objects or chains at the same time with 
//   PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginX -- The starting X value for the object, the object will be positioned here when playing starts
//   endX -- The end X value for the object, the object will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginX to endX
// SOURCE
void agk::SetTweenObjectX( uint32_t tweenID, float beginX, float endX, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween X for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween X for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginX = beginX;
	pTween->m_fEndX = endX;
	pTween->m_iInterpX = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectY
// FUNCTION
//   Sets the Y parameter of the given tween ID. A Tween can modify several parameters of an object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many objects or chains at the same time with 
//   PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginY -- The starting Y value for the object, the object will be positioned here when playing starts
//   endY -- The end Y value for the object, the object will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginY to endY
// SOURCE
void agk::SetTweenObjectY( uint32_t tweenID, float beginY, float endY, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Y for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Y for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginY = beginY;
	pTween->m_fEndY = endY;
	pTween->m_iInterpY = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectZ
// FUNCTION
//   Sets the Z parameter of the given tween ID. A Tween can modify several parameters of an object 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many objects or chains at the same time with 
//   PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginZ -- The starting Z value for the object, the object will be positioned here when playing starts
//   endZ -- The end Z value for the object, the object will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginZ to endZ
// SOURCE
void agk::SetTweenObjectZ( uint32_t tweenID, float beginZ, float endZ, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Z for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Z for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginZ = beginZ;
	pTween->m_fEndZ = endZ;
	pTween->m_iInterpZ = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectAngleX
// FUNCTION
//   Sets the Euler AngleX parameter of the given tween ID. A Tween can modify several parameters 
//   of an object at the same time. Set the begin value and the end value and an interpolation 
//   method. A tween is just a template that can be applied to many objects or chains at the same 
//   time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginAX -- The starting AngleX value for the object, the object will be rotated to this angle when playing starts
//   endAX -- The end AngleX value for the object, the object will be rotated to this angle when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginAX to endAX
// SOURCE
void agk::SetTweenObjectAngleX( uint32_t tweenID, float beginAX, float endAX, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween AngleX for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween AngleX for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginAngleX = beginAX;
	pTween->m_fEndAngleX = endAX;
	pTween->m_iInterpAngleX = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectAngleY
// FUNCTION
//   Sets the Euler AngleY parameter of the given tween ID. A Tween can modify several parameters 
//   of an object at the same time. Set the begin value and the end value and an interpolation 
//   method. A tween is just a template that can be applied to many objects or chains at the same 
//   time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginAY -- The starting AngleY value for the object, the object will be rotated to this angle when playing starts
//   endAY -- The end AngleY value for the object, the object will be rotated to this angle when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginAY to endAY
// SOURCE
void agk::SetTweenObjectAngleY( uint32_t tweenID, float beginAY, float endAY, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween AngleY for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween AngleY for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginAngleY = beginAY;
	pTween->m_fEndAngleY = endAY;
	pTween->m_iInterpAngleY = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectAngleZ
// FUNCTION
//   Sets the Euler AngleZ parameter of the given tween ID. A Tween can modify several parameters 
//   of an object at the same time. Set the begin value and the end value and an interpolation 
//   method. A tween is just a template that can be applied to many objects or chains at the same 
//   time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginAZ -- The starting AngleZ value for the object, the object will be rotated to this angle when playing starts
//   endAZ -- The end AngleZ value for the object, the object will be rotated to this angle when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginAZ to endAZ
// SOURCE
void agk::SetTweenObjectAngleZ( uint32_t tweenID, float beginAZ, float endAZ, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween AngleZ for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween AngleZ for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginAngleZ = beginAZ;
	pTween->m_fEndAngleZ = endAZ;
	pTween->m_iInterpAngleZ = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectScaleX
// FUNCTION
//   Sets the ScaleX parameter of the given tween ID. The scale is absolute so a value of 1.0 will
//   be normal size, whilst 2.0 would be two times bigger.
//   A Tween can modify several parameters of an object at the same time. Set the begin value and 
//   the end value and an interpolation method. A tween is just a template that can be applied to 
//   many objects or chains at the same time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginSX -- The starting ScaleX value for the object, the object will be rotated to this angle when playing starts
//   endSX -- The end ScaleX value for the object, the object will be rotated to this angle when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginSX to endSX
// SOURCE
void agk::SetTweenObjectScaleX( uint32_t tweenID, float beginSX, float endSX, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween ScaleX for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween ScaleX for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginScaleX = beginSX;
	pTween->m_fEndScaleX = endSX;
	pTween->m_iInterpScaleX = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectScaleY
// FUNCTION
//   Sets the ScaleY parameter of the given tween ID. The scale is absolute so a value of 1.0 will
//   be normal size, whilst 2.0 would be two times bigger.
//   A Tween can modify several parameters of an object at the same time. Set the begin value and 
//   the end value and an interpolation method. A tween is just a template that can be applied to 
//   many objects or chains at the same time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginSY -- The starting ScaleY value for the object, the object will be rotated to this angle when playing starts
//   endSY -- The end ScaleY value for the object, the object will be rotated to this angle when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginSY to endSY
// SOURCE
void agk::SetTweenObjectScaleY( uint32_t tweenID, float beginSY, float endSY, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween ScaleY for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween ScaleY for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginScaleY = beginSY;
	pTween->m_fEndScaleY = endSY;
	pTween->m_iInterpScaleY = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectScaleZ
// FUNCTION
//   Sets the ScaleZ parameter of the given tween ID. The scale is absolute so a value of 1.0 will
//   be normal size, whilst 2.0 would be two times bigger.
//   A Tween can modify several parameters of an object at the same time. Set the begin value and 
//   the end value and an interpolation method. A tween is just a template that can be applied to 
//   many objects or chains at the same time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginSZ -- The starting ScaleY value for the object, the object will be rotated to this angle when playing starts
//   endSZ -- The end ScaleY value for the object, the object will be rotated to this angle when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginSZ to endSZ
// SOURCE
void agk::SetTweenObjectScaleZ( uint32_t tweenID, float beginSZ, float endSZ, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween ScaleZ for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween ScaleZ for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginScaleZ = beginSZ;
	pTween->m_fEndScaleZ = endSZ;
	pTween->m_iInterpScaleZ = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectRed
// FUNCTION
//   Sets the Red parameter of the given tween ID in the range 0 to 255. 
//   A Tween can modify several parameters of an object at the same time. Set the begin value and 
//   the end value and an interpolation method. A tween is just a template that can be applied to 
//   many objects or chains at the same time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginR -- The starting Red color for the object, the object will be this color when playing starts
//   endR -- The end Red color for the object, the object will be this color when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginR to endR
// SOURCE
void agk::SetTweenObjectRed( uint32_t tweenID, int beginR, int endR, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Red for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Red for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginRed = beginR;
	pTween->m_iEndRed = endR;
	pTween->m_iInterpRed = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectGreen
// FUNCTION
//   Sets the Green parameter of the given tween ID in the range 0 to 255. 
//   A Tween can modify several parameters of an object at the same time. Set the begin value and 
//   the end value and an interpolation method. A tween is just a template that can be applied to 
//   many objects or chains at the same time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginG -- The starting Green color for the object, the object will be this color when playing starts
//   endG -- The end Green color for the object, the object will be this color when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginG to endG
// SOURCE
void agk::SetTweenObjectGreen( uint32_t tweenID, int beginG, int endG, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Green for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Green for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginGreen = beginG;
	pTween->m_iEndGreen = endG;
	pTween->m_iInterpGreen = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectBlue
// FUNCTION
//   Sets the Blue parameter of the given tween ID in the range 0 to 255. 
//   A Tween can modify several parameters of an object at the same time. Set the begin value and 
//   the end value and an interpolation method. A tween is just a template that can be applied to 
//   many objects or chains at the same time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginB -- The starting Blue color for the object, the object will be this color when playing starts
//   endB -- The end Blue color for the object, the object will be this color when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginB to endB
// SOURCE
void agk::SetTweenObjectBlue( uint32_t tweenID, int beginB, int endB, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Blue for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Blue for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginBlue = beginB;
	pTween->m_iEndBlue = endB;
	pTween->m_iInterpBlue = interpolation;
	
}

//****f* Tweening/Objects/SetTweenObjectAlpha
// FUNCTION
//   Sets the Alpha parameter of the given tween ID in the range 0 to 255. 
//   A Tween can modify several parameters of an object at the same time. Set the begin value and 
//   the end value and an interpolation method. A tween is just a template that can be applied to 
//   many objects or chains at the same time with PlayTweenObject or AddTweenChainObject.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginA -- The starting Alpha color for the object, the object will be this color when playing starts
//   endA -- The end ALpha color for the object, the object will be this color when playing ends
//   interpolation -- The interpolation method whilst the object is moving from beginA to endA
// SOURCE
void agk::SetTweenObjectAlpha( uint32_t tweenID, int beginA, int endA, int interpolation )
//****
{
	TweenObject *pTween = (TweenObject*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Alpha for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set object tween Alpha for ID %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_iBeginAlpha = beginA;
	pTween->m_iEndAlpha = endA;
	pTween->m_iInterpAlpha = interpolation;
	
}

//****f* Tweening/Objects/PlayTweenObject
// FUNCTION
//   Applies the given tween ID to a given object ID with an optional delay and starts playing it.
//   A tween can be played on multiple objects at the same time, simply call this command again with
//   a different object ID. The object will not be modified until the delay time has passed, at 
//   which point the tween will start at the begin values and move towards the end values over the
//   tween duration.
//   If a tween end value is modified whilst the tween is playing on a object the object will adjust
//   its interpolation accordingly. Modifying the duration whilst playing is undefined and not 
//   compatible with chains.
// INPUTS
//   tweenID -- ID of the tween to use
//   objectID -- ID of the object to modify
//   delay -- Number of seconds before the tween should start playing
// SOURCE
void agk::PlayTweenObject( uint32_t tweenID, uint32_t objectID, float delay )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play object tween %d, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play object tween %d, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	cObject3D *pObject = m_cObject3DList.GetItem( objectID );
	if ( !pObject )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play object tween %d on text %d, object ID does not exist", tweenID, objectID ); Error( errStr );
		return;		
	}

	TweenInstance *pInstance = new TweenInstance();
	pInstance->m_pNext = TweenInstance::g_pInstances;
	TweenInstance::g_pInstances = pInstance;
	pInstance->m_pTarget = pObject;
	pInstance->m_pTween = pTween;
	pInstance->m_fDelay = delay;
}

//****f* Tweening/Objects/PauseTweenObject
// FUNCTION
//   Pauses the given tween at its current point. It will not update again until <i>ResumeTweenObject</i> 
//   is called. If the tween has already stopped or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to pause
//   objectID -- ID of the object to pause
// SOURCE
void agk::PauseTweenObject( uint32_t tweenID, uint32_t objectID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_OBJECT ) return;

	cObject3D *pObject = m_cObject3DList.GetItem( objectID );
	if ( !pObject ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pObject );
	if ( pInstance ) pInstance->Pause();
}

//****f* Tweening/Objects/ResumeTweenObject
// FUNCTION
//   Resumes the given tween from the point it was paused with <i>PauseTweenObject</i>. 
//   If the tween is already resumed or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to resume
//   objectID -- ID of the object to resume
// SOURCE
void agk::ResumeTweenObject( uint32_t tweenID, uint32_t objectID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_OBJECT ) return;

	cObject3D *pObject = m_cObject3DList.GetItem( objectID );
	if ( !pObject ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pObject );
	if ( pInstance ) pInstance->Resume();
}

//****f* Tweening/Objects/StopTweenObject
// FUNCTION
//   Stops a given tween ID if it is playing on a given object. If the tween is not playing or has 
//   finished then this command has no effect.
//   If the object was in the middle of an interpolation it will remain at its current position, it
//   will not skip to the end or return to the beginning.
// INPUTS
//   tweenID -- ID of the tween to stop
//   objectID -- ID of the object to stop
// SOURCE
void agk::StopTweenObject( uint32_t tweenID, uint32_t objectID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_OBJECT ) return;

	cObject3D *pObject = m_cObject3DList.GetItem( objectID );
	if ( !pObject ) return;

	TweenInstance::DeleteInstance( pTween, pObject );
}

//****f* Tweening/Objects/GetTweenObjectPlaying
// FUNCTION
//   Returns 1 if the given tween ID is currently playing on the given object, otherwise 0.
//   This will still return 1 if the tween is currently paused.
// INPUTS
//   tweenID -- ID of the tween to check
//   objectID -- ID of the object to check
// SOURCE
int agk::GetTweenObjectPlaying( uint32_t tweenID, uint32_t objectID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_OBJECT ) return 0;

	cObject3D *pObject = m_cObject3DList.GetItem( objectID );
	if ( !pObject ) return 0;

	if ( TweenInstance::GetInstance( pTween, pObject ) ) return 1;
	
	TweenChain *pChain = m_cTweenChainList.GetFirst();
	while ( pChain )
	{
		if ( pChain->IsCurrentTween( pTween, pObject ) ) return 1;
		pChain = m_cTweenChainList.GetNext();
	}

	return 0;
}

//****f* Tweening/Objects/GetTweenObjectTime
// FUNCTION
//   Returns the current time of the tween object
// INPUTS
//   tweenID -- ID of the tween
//   objectID -- ID of the object
// SOURCE
float agk::GetTweenObjectTime ( UINT tweenID, UINT objectID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_OBJECT ) return 0.0f;

	cObject3D *pObject = m_cObject3DList.GetItem ( objectID );
	if ( !pObject ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, pObject );
	if ( pInstance ) return pInstance->m_fCurrentTime;

	return 0.0f;
}

//****f* Tweening/Objects/GetTweenObjectEndTime
// FUNCTION
//   Returns the current end of the tween object
// INPUTS
//   tweenID -- ID of the tween
//   objectID -- ID of the object
// SOURCE
float agk::GetTweenObjectEndTime ( UINT tweenID, UINT objectID )
//****
{
	Tween *pTween = m_cTweenList.GetItem ( tweenID );
	if ( !pTween || pTween->GetType ( ) != AGK_TWEEN_TYPE_OBJECT ) return 0.0f;

	cObject3D *pObject = m_cObject3DList.GetItem ( objectID );
	if ( !pObject ) return 0.0f;

	TweenInstance *pInstance = TweenInstance::GetInstance ( pTween, pObject );
	if ( pInstance ) return pInstance->m_pTween->m_fDuration;

	return 0.0f;
}

// camera tweening

//****f* Tweening/Cameras/CreateTweenCamera
// FUNCTION
//   Creates an camera tween at the given ID with a given duration. This tween is merely a template that can be applied
//   to multiple cameras or chains at the same time.
//   All tween types share the same ID space, so a camera tween of ID 1 cannot exist at the same time as an object tween
//   with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
//   values to their end values over the given duration.
// INPUTS
//   tweenID -- ID of the tween
//   duration -- The duration of the tween in seconds
// SOURCE
void agk::CreateTweenCamera( uint32_t tweenID, float duration )
//****
{
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create camera tween %d, ID must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cTweenList.GetItem( tweenID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create camera tween " );
		errStr.AppendUInt( tweenID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	if ( duration <= 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create camera tween %d, duration must be greater than 0", tweenID );
		Error( errStr );
#endif
		return;		
	}

	TweenCamera *pTween = new TweenCamera();
	pTween->m_fDuration = duration;
	m_cTweenList.AddItem( pTween, tweenID );
}

//****f* Tweening/Cameras/CreateTweenCamera
// FUNCTION
//   Creates an camera tween with a given duration and returns an ID for it. This tween is merely a template 
//   that can be applied to multiple cameras or chains at the same time.
//   All tween types share the same ID space, so a camera tween of ID 1 cannot exist at the same time as an 
//   object tween with ID 1.
//   You can set multiple parameters for this tween, such as X position and Angle, that will all move from 
//   their start values to their end values over the given duration.
// INPUTS
//   duration -- The duration of the tween in seconds
// SOURCE
uint32_t agk::CreateTweenCamera( float duration )
//****
{
	uint32_t tweenID = m_cTweenList.GetFreeID();
	if ( tweenID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create camera tween - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateTweenCamera( tweenID, duration ); 
	return tweenID;
}

//****f* Tweening/Cameras/GetTweenCameraExists
// FUNCTION
//   Returns 1 if a tween exists at the given ID and it is a camera tween, otherwise 0.
// INPUTS
//   tweenID -- ID of the tween to check
// SOURCE
int agk::GetTweenCameraExists( uint32_t tweenID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CAMERA ) return 0;
	else return 1;
}

//****f* Tweening/Cameras/SetTweenCameraX
// FUNCTION
//   Sets the X parameter of the given tween ID. A Tween can modify several parameters of a camera 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many cameras or chains at the same time with 
//   PlayTweenCamera or AddTweenChainCamera.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginX -- The starting X value for the camera, the camera will be positioned here when playing starts
//   endX -- The end X value for the camera, the camera will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the camera is moving from beginX to endX
// SOURCE
void agk::SetTweenCameraX( uint32_t tweenID, float beginX, float endX, int interpolation )
//****
{
	TweenCamera *pTween = (TweenCamera*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween X for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween X for ID %d, tween ID is not a camera tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginX = beginX;
	pTween->m_fEndX = endX;
	pTween->m_iInterpX = interpolation;
	
}

//****f* Tweening/Cameras/SetTweenCameraY
// FUNCTION
//   Sets the Y parameter of the given tween ID. A Tween can modify several parameters of a camera 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many cameras or chains at the same time with 
//   PlayTweenCamera or AddTweenChainCamera.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginY -- The starting Y value for the camera, the camera will be positioned here when playing starts
//   endY -- The end Y value for the camera, the camera will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the camera is moving from beginY to endY
// SOURCE
void agk::SetTweenCameraY( uint32_t tweenID, float beginY, float endY, int interpolation )
//****
{
	TweenCamera *pTween = (TweenCamera*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween Y for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween Y for ID %d, tween ID is not a camera tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginY = beginY;
	pTween->m_fEndY = endY;
	pTween->m_iInterpY = interpolation;
	
}

//****f* Tweening/Cameras/SetTweenCameraZ
// FUNCTION
//   Sets the Z parameter of the given tween ID. A Tween can modify several parameters of a camera 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many cameras or chains at the same time with 
//   PlayTweenCamera or AddTweenChainCamera.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginZ -- The starting Z value for the camera, the camera will be positioned here when playing starts
//   endZ -- The end Z value for the camera, the camera will be positioned here when playing ends
//   interpolation -- The interpolation method whilst the camera is moving from beginZ to endZ
// SOURCE
void agk::SetTweenCameraZ( uint32_t tweenID, float beginZ, float endZ, int interpolation )
//****
{
	TweenCamera *pTween = (TweenCamera*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween Z for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween Z for ID %d, tween ID is not a camera tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginZ = beginZ;
	pTween->m_fEndZ = endZ;
	pTween->m_iInterpZ = interpolation;
	
}

//****f* Tweening/Cameras/SetTweenCameraAngleX
// FUNCTION
//   Sets the Euler AngleX parameter of the given tween ID. A Tween can modify several parameters of a camera 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many cameras or chains at the same time with 
//   PlayTweenCamera or AddTweenChainCamera.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginAX -- The starting Euler AngleX value for the camera, the camera will be rotated to this angle when playing starts
//   endAX -- The end Euler AngleX value for the camera, the camera will be rotated to this angle when playing ends
//   interpolation -- The interpolation method whilst the camera is moving from beginAX to endAX
// SOURCE
void agk::SetTweenCameraAngleX( uint32_t tweenID, float beginAX, float endAX, int interpolation )
//****
{
	TweenCamera *pTween = (TweenCamera*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween AngleX for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween AngleX for ID %d, tween ID is not a camera tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginAngleX = beginAX;
	pTween->m_fEndAngleX = endAX;
	pTween->m_iInterpAngleX = interpolation;
	
}

//****f* Tweening/Cameras/SetTweenCameraAngleY
// FUNCTION
//   Sets the Euler AngleY parameter of the given tween ID. A Tween can modify several parameters of a camera 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many cameras or chains at the same time with 
//   PlayTweenCamera or AddTweenChainCamera.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginAY -- The starting Euler AngleY value for the camera, the camera will be rotated to this angle when playing starts
//   endAY -- The end Euler AngleY value for the camera, the camera will be rotated to this angle when playing ends
//   interpolation -- The interpolation method whilst the camera is moving from beginAY to endAY
// SOURCE
void agk::SetTweenCameraAngleY( uint32_t tweenID, float beginAY, float endAY, int interpolation )
//****
{
	TweenCamera *pTween = (TweenCamera*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween AngleY for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween AngleY for ID %d, tween ID is not a camera tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginAngleY = beginAY;
	pTween->m_fEndAngleY = endAY;
	pTween->m_iInterpAngleY = interpolation;
	
}

//****f* Tweening/Cameras/SetTweenCameraAngleZ
// FUNCTION
//   Sets the Euler AngleZ parameter of the given tween ID. A Tween can modify several parameters of a camera 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many cameras or chains at the same time with 
//   PlayTweenCamera or AddTweenChainCamera.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginAZ -- The starting Euler AngleZ value for the camera, the camera will be rotated to this angle when playing starts
//   endAZ -- The end Euler AngleZ value for the camera, the camera will be rotated to this angle when playing ends
//   interpolation -- The interpolation method whilst the camera is moving from beginAZ to endAZ
// SOURCE
void agk::SetTweenCameraAngleZ( uint32_t tweenID, float beginAZ, float endAZ, int interpolation )
//****
{
	TweenCamera *pTween = (TweenCamera*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween AngleZ for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween AngleZ for ID %d, tween ID is not a camera tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginAngleZ = beginAZ;
	pTween->m_fEndAngleZ = endAZ;
	pTween->m_iInterpAngleZ = interpolation;
	
}

//****f* Tweening/Cameras/SetTweenCameraFOV
// FUNCTION
//   Sets the Field Of View parameter of the given tween ID. A Tween can modify several parameters of a camera 
//   at the same time. Set the begin value and the end value and an interpolation method. A tween
//   is just a template that can be applied to many cameras or chains at the same time with 
//   PlayTweenCamera or AddTweenChainCamera.
//   Available interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
//   TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot()
//   Use an interpolation method of -1 to turn off interpolation on this value
// INPUTS
//   tweenID -- ID of the tween to modify
//   beginF -- The starting FOV value for the camera, the camera will have this FOV value when playing starts
//   endF -- The end FOV value for the camera, the camera will have this FOV value when playing ends
//   interpolation -- The interpolation method whilst the camera is moving from beginF to endF
// SOURCE
void agk::SetTweenCameraFOV( uint32_t tweenID, float beginF, float endF, int interpolation )
//****
{
	TweenCamera *pTween = (TweenCamera*) m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween FOV for ID %d, ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to set camera tween FOV for ID %d, tween ID is not a camera tween", tweenID ); Error( errStr );
		return;				
	}

	pTween->m_fBeginFOV = beginF;
	pTween->m_fEndFOV = endF;
	pTween->m_iInterpFOV = interpolation;
	
}

//****f* Tweening/Cameras/PlayTweenCamera
// FUNCTION
//   Applies the given tween ID to a given camera ID with an optional delay and starts playing it.
//   A tween can be played on multiple cameras at the same time, simply call this command again with
//   a different camera ID. The camera will not be modified until the delay time has passed, at 
//   which point the tween will start at the begin values and move towards the end values over the
//   tween duration.
//   If a tween end value is modified whilst the tween is playing on a camera the camera will adjust
//   its interpolation accordingly. Modifying the duration whilst playing is undefined and not 
//   compatible with chains.
// INPUTS
//   tweenID -- ID of the tween to use
//   cameraID -- ID of the camera to modify
//   delay -- Number of seconds before the tween should start playing
// SOURCE
void agk::PlayTweenCamera( uint32_t tweenID, uint32_t cameraID, float delay )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play camera tween %d, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play camera tween %d, tween ID is not an camera tween", tweenID ); Error( errStr );
		return;				
	}

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play camera tween %d on camera %d, camera ID does not exist", tweenID, cameraID ); Error( errStr );
		return;		
	}

	TweenInstance *pInstance = new TweenInstance();
	pInstance->m_pNext = TweenInstance::g_pInstances;
	TweenInstance::g_pInstances = pInstance;
	pInstance->m_pTarget = pCamera;
	pInstance->m_pTween = pTween;
	pInstance->m_fDelay = delay;
}

//****f* Tweening/Cameras/PauseTweenCamera
// FUNCTION
//   Pauses the given tween at its current point. It will not update again until <i>ResumeTweenCamera</i> 
//   is called. If the tween has already stopped or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to pause
//   cameraID -- ID of the camera to pause
// SOURCE
void agk::PauseTweenCamera( uint32_t tweenID, uint32_t cameraID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CAMERA ) return;

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pCamera );
	if ( pInstance ) pInstance->Pause();
}

//****f* Tweening/Cameras/ResumeTweenCamera
// FUNCTION
//   Resumes the given tween from the point it was paused with <i>PauseTweenCamera</i>. 
//   If the tween is already resumed or doesn't exist then this does nothing.
// INPUTS
//   tweenID -- ID of the tween to resume
//   cameraID -- ID of the camera to resume
// SOURCE
void agk::ResumeTweenCamera( uint32_t tweenID, uint32_t cameraID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CAMERA ) return;

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pCamera );
	if ( pInstance ) pInstance->Resume();
}

//****f* Tweening/Cameras/StopTweenCamera
// FUNCTION
//   Stops a given tween ID if it is playing on a given camera. If the tween is not playing or has 
//   finished then this command has no effect.
//   If the camera was in the middle of an interpolation it will remain at its current position, it
//   will not skip to the end or return to the beginning.
// INPUTS
//   tweenID -- ID of the tween to stop
//   cameraID -- ID of the camera to stop
// SOURCE
void agk::StopTweenCamera( uint32_t tweenID, uint32_t cameraID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CAMERA ) return;

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera ) return;

	TweenInstance::DeleteInstance( pTween, pCamera );
}

//****f* Tweening/Cameras/GetTweenCameraPlaying
// FUNCTION
//   Returns 1 if the given tween ID is currently playing on the given camera, otherwise 0.
//   This will still return 1 if the tween is currently paused.
// INPUTS
//   tweenID -- ID of the tween to check
//   cameraID -- ID of the camera to check
// SOURCE
int agk::GetTweenCameraPlaying( uint32_t tweenID, uint32_t cameraID )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CAMERA ) return 0;

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera ) return 0;

	if ( TweenInstance::GetInstance( pTween, pCamera ) ) return 1;

	TweenChain *pChain = m_cTweenChainList.GetFirst();
	while ( pChain )
	{
		if ( pChain->IsCurrentTween( pTween, pCamera ) ) return 1;
		pChain = m_cTweenChainList.GetNext();
	}

	return 0;
}


// tween chaining

//****f* Tweening/Chains/CreateTweenChain
// FUNCTION
//   Creates a tween chain that can be used to order tweens so they play one after the other.
//   A tween chain can contain multiple sprites, characters, objects, etc, so that a camera
//   tween can be triggered after a sprite tween has finished or vice versa.
//   Multiple chains can be applied to the same sprites, objects, or others as long as the 
//   chains do not modify the same parameter at the same time. For example if chain 1 starts
//   by modifying a sprites X value, and is played at the same time as chain 2 which also starts
//   modifying the X value of the same sprite one chain will overwrite the changes of the other.
//   Otherwise multiple chains on the same sprite will work correctly.
// INPUTS
//   chainID -- ID of the chain
// SOURCE
void agk::CreateTweenChain( uint32_t chainID )
//****
{
	if ( chainID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create tween chain %d, ID must be greater than 0", chainID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cTweenChainList.GetItem( chainID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create tween chain " );
		errStr.AppendUInt( chainID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	TweenChain *pChain = new TweenChain();
	m_cTweenChainList.AddItem( pChain, chainID );
}

//****f* Tweening/Chains/CreateTweenChain
// FUNCTION
//   Creates a tween chain that can be used to order tweens so they play one after the other.
//   A tween chain can contain multiple sprites, characters, objects, etc, so that a camera
//   tween can be triggered after a sprite tween has finished or vice versa.
//   Multiple chains can be applied to the same sprites, objects, or others as long as the 
//   chains do not modify the same parameter at the same time. For example if chain 1 starts
//   by modifying a sprites X value, and is played at the same time as chain 2 which also starts
//   modifying the X value of the same sprite one chain will overwrite the changes of the other.
//   Otherwise multiple chains on the same sprite will work correctly.
// SOURCE
uint32_t agk::CreateTweenChain()
//****
{
	uint32_t chainID = m_cTweenChainList.GetFreeID();
	if ( chainID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create tween chain - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateTweenChain( chainID ); 
	return chainID;
}

//****f* Tweening/Chains/DeleteTweenChain
// FUNCTION
//   Deletes a chain and stops any tweens that were associated with it. 
//   Any tweens that were added to it are unaffected and can be used in
//   future chains.
// INPUTS
//   chainID -- ID of the chain to delete
// SOURCE
void agk::DeleteTweenChain( uint32_t chainID )
//****
{
	TweenChain *pChain = m_cTweenChainList.RemoveItem( chainID );
	if ( pChain )
	{
		delete pChain;
	}
}

//****f* Tweening/Chains/ClearTweenChain
// FUNCTION
//   Empties a chain of all tweens and stops any that were running.
//   Any tweens that were added to it are unaffected and can be used in
//   future chains.
// INPUTS
//   chainID -- ID of the tween chain to clear
// SOURCE
void agk::ClearTweenChain( uint32_t chainID )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( pChain )
	{
		pChain->ClearAll();
	}
}

//****f* Tweening/Chains/AddTweenChainCustom
// FUNCTION
//   Adds the given custom tween ID to the end of the chain with an optional delay.
//   The tween will not start until all preceding tweens in this chain have finished and the delay 
//   time has passed, at which point the tween will start at the begin values and move towards the 
//   end values over the tween duration.
//   If a tween end value is modified whilst the tween is playing it will adjust its interpolation 
//   accordingly. Modifying the duration whilst playing is undefined and not compatible with chains.
// INPUTS
//   chainID -- ID of the chain to add to
//   tweenID -- ID of the tween to add
//   delay -- Number of seconds to wait before playing this tween when it is triggered
// SOURCE
void agk::AddTweenChainCustom( uint32_t chainID, uint32_t tweenID, float delay )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( !pChain )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add custom tween %d to chain %d, chain ID does not exist", tweenID, chainID ); Error( errStr );
		return;		
	}

	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add custom tween %d to chain, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add custom tween %d to chain, tween ID is not a custom tween", tweenID ); Error( errStr );
		return;				
	}

	pChain->AddTweenForCustom( pTween, delay );
}

//****f* Tweening/Chains/AddTweenChainSprite
// FUNCTION
//   Applies the given tween ID to a given sprite ID with an optional delay and adds it to the end
//   of the chain.
//   A tween can be added to multiple sprites at the same time, simply call this command again with
//   a different sprite ID. The sprite will not be modified until all preceding tweens in this 
//   chain have finished and the delay time has passed, at which point the tween will start at the 
//   begin values and move towards the end values over the tween duration.
//   If a tween end value is modified whilst the tween is playing on a sprite the sprite will adjust
//   its interpolation accordingly. Modifying the duration whilst playing is undefined and not 
//   compatible with chains.
// INPUTS
//   chainID -- ID of the chain to add to
//   tweenID -- ID of the tween to add
//   spriteID -- ID of the sprite to modify
//   delay -- Number of seconds to wait before playing this tween when it is triggered
// SOURCE
void agk::AddTweenChainSprite( uint32_t chainID, uint32_t tweenID, uint32_t spriteID, float delay )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( !pChain )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add sprite tween %d to chain %d, chain ID does not exist", tweenID, chainID ); Error( errStr );
		return;		
	}

	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add sprite tween %d to chain, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_SPRITE )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add sprite tween %d to chain, tween ID is not a sprite tween", tweenID ); Error( errStr );
		return;				
	}

	cSprite *pSprite = m_cSpriteList.GetItem( spriteID );
	if ( !pSprite )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add sprite tween %d to chain with sprite %d, sprite ID does not exist", tweenID, spriteID ); Error( errStr );
		return;		
	}

	pChain->AddTweenForSprite( pTween, pSprite, delay );
}

//****f* Tweening/Chains/AddTweenChainText
// FUNCTION
//   Applies the given tween ID to a given text object ID with an optional delay and adds it to the end
//   of the chain.
//   A tween can be added to multiple text objects at the same time, simply call this command again with
//   a different text object ID. The text object will not be modified until all preceding tweens in this 
//   chain have finished and the delay time has passed, at which point the tween will start at the 
//   begin values and move towards the end values over the tween duration.
//   If a tween end value is modified whilst the tween is playing on a text object the text will adjust
//   its interpolation accordingly. Modifying the duration whilst playing is undefined and not 
//   compatible with chains.
// INPUTS
//   chainID -- ID of the chain to add to
//   tweenID -- ID of the tween to add
//   textID -- ID of the text to modify
//   delay -- Number of seconds to wait before playing this tween when it is triggered
// SOURCE
void agk::AddTweenChainText( uint32_t chainID, uint32_t tweenID, uint32_t textID, float delay )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( !pChain )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add text tween %d to chain %d, chain ID does not exist", tweenID, chainID ); Error( errStr );
		return;		
	}

	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add text tween %d to chain, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_TEXT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add text tween %d to chain, tween ID is not a text tween", tweenID ); Error( errStr );
		return;				
	}

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add text tween %d to chain with text %d, text ID does not exist", tweenID, textID ); Error( errStr );
		return;		
	}

	pChain->AddTweenForText( pTween, pText, delay );
}

//****f* Tweening/Chains/AddTweenChainChar
// FUNCTION
//   Applies the given tween ID to a given character in a text object with an optional delay and 
//   adds it to the end of the chain.
//   A tween can be added to multiple characters at the same time, simply call this command again with
//   a different character or text ID. The character will not be modified until all preceding tweens in this 
//   chain have finished and the delay time has passed, at which point the tween will start at the 
//   begin values and move towards the end values over the tween duration.
//   If a tween end value is modified whilst the tween is playing on a character the character will adjust
//   its interpolation accordingly. Modifying the duration whilst playing is undefined and not 
//   compatible with chains.
// INPUTS
//   chainID -- ID of the chain to add to
//   tweenID -- ID of the tween to add
//   textID -- ID of the text object containing the character
//   charID -- Index of the character to modify, indices start at 0
//   delay -- Number of seconds to wait before playing this tween when it is triggered
// SOURCE
void agk::AddTweenChainChar( uint32_t chainID, uint32_t tweenID, uint32_t textID, uint32_t charID, float delay )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( !pChain )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add char tween %d to chain %d, chain ID does not exist", tweenID, chainID ); Error( errStr );
		return;		
	}

	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add char tween %d to chain, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CHAR )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add char tween %d to chain, tween ID is not a char tween", tweenID ); Error( errStr );
		return;				
	}

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add char tween %d to chain with text %d, text ID does not exist", tweenID, textID ); Error( errStr );
		return;		
	}

	pChain->AddTweenForChar( pTween, pText, charID, delay );
}

//****f* Tweening/Chains/AddTweenChainObject
// FUNCTION
//   Applies the given tween ID to a given object ID with an optional delay and adds it to the end
//   of the chain.
//   A tween can be added to multiple objects at the same time, simply call this command again with
//   a different object ID. The object will not be modified until all preceding tweens in this 
//   chain have finished and the delay time has passed, at which point the tween will start at the 
//   begin values and move towards the end values over the tween duration.
//   If a tween end value is modified whilst the tween is playing on an object the object will adjust
//   its interpolation accordingly. Modifying the duration whilst playing is undefined and not 
//   compatible with chains.
// INPUTS
//   chainID -- ID of the chain to add to
//   tweenID -- ID of the tween to add
//   objectID -- ID of the object to modify
//   delay -- Number of seconds to wait before playing this tween when it is triggered
// SOURCE
void agk::AddTweenChainObject( uint32_t chainID, uint32_t tweenID, uint32_t objectID, float delay )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( !pChain )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add object tween %d to chain %d, chain ID does not exist", tweenID, chainID ); Error( errStr );
		return;		
	}

	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add object tween %d to chain, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_OBJECT )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add object tween %d to chain, tween ID is not an object tween", tweenID ); Error( errStr );
		return;				
	}

	cObject3D *pObject = m_cObject3DList.GetItem( objectID );
	if ( !pObject )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add object tween %d to chain with object %d, object ID does not exist", tweenID, objectID ); Error( errStr );
		return;		
	}

	pChain->AddTweenForObject( pTween, pObject, delay );
}

//****f* Tweening/Chains/AddTweenChainCamera
// FUNCTION
//   Applies the given tween ID to a given camera ID with an optional delay and adds it to the end
//   of the chain.
//   A tween can be added to multiple cameras at the same time, simply call this command again with
//   a different camera ID. The camera will not be modified until all preceding tweens in this 
//   chain have finished and the delay time has passed, at which point the tween will start at the 
//   begin values and move towards the end values over the tween duration.
//   If a tween end value is modified whilst the tween is playing on a camera the camera will adjust
//   its interpolation accordingly. Modifying the duration whilst playing is undefined and not 
//   compatible with chains.
// INPUTS
//   chainID -- ID of the chain to add to
//   tweenID -- ID of the tween to add
//   cameraID -- ID of the camera to modify
//   delay -- Number of seconds to wait before playing this tween when it is triggered
// SOURCE
void agk::AddTweenChainCamera( uint32_t chainID, uint32_t tweenID, uint32_t cameraID, float delay )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( !pChain )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add camera tween %d to chain %d, chain ID does not exist", tweenID, chainID ); Error( errStr );
		return;		
	}

	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add camera tween %d to chain, tween ID does not exist", tweenID ); Error( errStr );
		return;		
	}

	if ( pTween->GetType() != AGK_TWEEN_TYPE_CAMERA )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add camera tween %d to chain, tween ID is not a camera tween", tweenID ); Error( errStr );
		return;				
	}

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to add camera tween %d to chain with camera %d, camera ID does not exist", tweenID, cameraID ); Error( errStr );
		return;		
	}

	pChain->AddTweenForCamera( pTween, pCamera, delay );
}

//****f* Tweening/Chains/PlayTweenChain
// FUNCTION
//   Starts playing the given chain from the beginning or resumes it if it was paused.
// INPUTS
//   chainID -- ID of the chain to modify
// SOURCE
void agk::PlayTweenChain( uint32_t chainID )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( !pChain )
	{
		uString errStr( "", 100 ); errStr.Format( "Failed to play tween chain %d, chain ID does not exist", chainID ); Error( errStr );
		return;		
	}

	pChain->Play();
}

//****f* Tweening/Chains/PauseTweenChain
// FUNCTION
//   Pauses the given chain that has started playing, it can be resumed with <i>PlayTweenChain</i>
// INPUTS
//   chainID -- ID of the chain to modify
// SOURCE
void agk::PauseTweenChain( uint32_t chainID )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( pChain ) pChain->Pause();
}

//****f* Tweening/Chains/StopTweenChain
// FUNCTION
//   Stops the given chain. If an item was in the middle of an interpolation it will stay 
//   at its current position, it will not skip to the end or return to the beginning.
//   Playing the chain again will start it from the beginning.
// INPUTS
//   chainID -- ID of the chain to modify
// SOURCE
void agk::StopTweenChain( uint32_t chainID )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( pChain ) pChain->Stop();
}

//****f* Tweening/Chains/GetTweenChainPlaying
// FUNCTION
//   Returns 1 if the chain is currently working through its list of tweens. If the last tween
//   has finished or the chain has yet to be started it will return 0.
// INPUTS
//   chainID -- ID of the chain to check
// SOURCE
int agk::GetTweenChainPlaying( uint32_t chainID )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( pChain ) return pChain->IsPlaying();
	return 0;
}

//****f* Tweening/Chains/SetTweenChainTime
// FUNCTION
//   Jumps a tween chain to the specified position in its time line. If the tween chain is currently 
//   playing then the interpolation will evaluate the given time value and update the necessary objects.
//   If the tween chain is not playing then this command has no effect as calling PlayTweenChain resets 
//   the time to 0.
//   If the time happens to fall on a delay between tweens then the interpolation will remain unchanged 
//   until the delay is passed.
// INPUTS
//   chainID -- ID of the chain to modify
//   time -- The time in seconds to jump to in the tween chain
// SOURCE
void agk::SetTweenChainTime( uint32_t chainID, float time )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( pChain ) pChain->SetTime( time );
}

//****f* Tweening/Chains/GetTweenChainEndTime
// FUNCTION
//   Returns the total length of the tween chain in seconds.
// INPUTS
//   chainID -- ID of the chain to check
// SOURCE
float agk::GetTweenChainEndTime( uint32_t chainID )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( pChain ) return pChain->m_fTotalTime;
	else return 0;
}

//****f* Tweening/General/UpdateAllTweens
// FUNCTION
//   Updates all tweens started on individual items and chains. The time value allows you to control
//   how quickly the tweens advance, and in most cases the result of <i>GetFrameTime</i> should be used.
//   The time can be set negative so that any playing tweens will play in reverse until they reach 
//   their start points, however they will not stop playing when they reach the beginning and will instead
//   wait for the time to become positive again or wait for you to stop them manually.
// INPUTS
//   fTime -- The time to advance the tweens
// SOURCE
void agk::UpdateAllTweens( float fTime )
//****
{
	TweenInstance *pTween = TweenInstance::g_pInstances;
	TweenInstance *pLast = 0;

	while ( pTween )
	{
		pTween->Update( fTime );

		if ( pTween->m_fCurrentTime >= pTween->m_pTween->m_fDuration )
		{
			if ( pLast ) pLast->m_pNext = pTween->m_pNext;
			else TweenInstance::g_pInstances = pTween->m_pNext;

			TweenInstance *pNext = pTween->m_pNext;
			delete pTween;
			pTween = pNext;
		}
		else 
		{
			pLast = pTween;
			pTween = pTween->m_pNext;
		}
	}

	// update chains
	TweenChain *pChain = m_cTweenChainList.GetFirst();
	while ( pChain )
	{
		pChain->Update( fTime );
		pChain = m_cTweenChainList.GetNext();
	}
}

//****f* Tweening/General/UpdateTweenCustom
// FUNCTION
//   Updates a specific tween that has been started. The time value allows you to control how quickly the 
//   tween advances, and in most cases the result of <i>GetFrameTime</i> should be used.
//   The time can be set negative so that the tween will play in reverse until it reaches its start point, 
//   however it will not stop playing when it reaches the beginning and will instead wait for the time to 
//   become positive again or wait for you to stop it manually.
//   If you have started a lot of tweens playing, then updating each tween individually will be a lot more 
//   expensive than using <i>UpdateAllTweens</i>.
// INPUTS
//   tweenID -- The ID of the tween to update
//   fTime -- The time to advance the tween
// SOURCE
void agk::UpdateTweenCustom( uint32_t tweenID, float fTime )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CUSTOM ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, 0 );
	if ( !pInstance ) return;

	pInstance->Update( fTime );

	if ( pInstance->m_fCurrentTime >= pInstance->m_pTween->m_fDuration )
	{
		TweenInstance::DeleteInstance( pTween, 0 );
	}
}

//****f* Tweening/General/UpdateTweenSprite
// FUNCTION
//   Updates a specific tween that has been started. The time value allows you to control how quickly the 
//   tween advances, and in most cases the result of <i>GetFrameTime</i> should be used.
//   The time can be set negative so that the tween will play in reverse until it reaches its start point, 
//   however it will not stop playing when it reaches the beginning and will instead wait for the time to 
//   become positive again or wait for you to stop it manually.
//   The tween must have already been started on the given sprite with PlayTweenSprite or nothing will happen.
//   If you have started a lot of tweens playing, then updating each tween individually will be a lot more 
//   expensive than using <i>UpdateAllTweens</i>.
// INPUTS
//   tweenID -- The ID of the tween to update
//   spriteID -- The ID of the sprite to update
//   fTime -- The time to advance the tween
// SOURCE
void agk::UpdateTweenSprite( uint32_t tweenID, uint32_t spriteID, float fTime )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_SPRITE ) return;

	cSprite *pSprite = m_cSpriteList.GetItem( spriteID );
	if ( !pSprite ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pSprite );
	if ( !pInstance ) return;

	pInstance->Update( fTime );

	if ( pInstance->m_fCurrentTime >= pInstance->m_pTween->m_fDuration )
	{
		TweenInstance::DeleteInstance( pTween, pSprite );
	}
}

//****f* Tweening/General/UpdateTweenText
// FUNCTION
//   Updates a specific tween that has been started. The time value allows you to control how quickly the 
//   tween advances, and in most cases the result of <i>GetFrameTime</i> should be used.
//   The time can be set negative so that the tween will play in reverse until it reaches its start point, 
//   however it will not stop playing when it reaches the beginning and will instead wait for the time to 
//   become positive again or wait for you to stop it manually.
//   The tween must have already been started on the given text with PlayTweenText or nothing will happen.
//   If you have started a lot of tweens playing, then updating each tween individually will be a lot more 
//   expensive than using <i>UpdateAllTweens</i>.
// INPUTS
//   tweenID -- The ID of the tween to update
//   textID -- The ID of the text to update
//   fTime -- The time to advance the tween
// SOURCE
void agk::UpdateTweenText( uint32_t tweenID, uint32_t textID, float fTime )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_TEXT ) return;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pText );
	if ( !pInstance ) return;

	pInstance->Update( fTime );

	if ( pInstance->m_fCurrentTime >= pInstance->m_pTween->m_fDuration )
	{
		TweenInstance::DeleteInstance( pTween, pText );
	}
}

//****f* Tweening/General/UpdateTweenChar
// FUNCTION
//   Updates a specific tween that has been started. The time value allows you to control how quickly the 
//   tween advances, and in most cases the result of <i>GetFrameTime</i> should be used.
//   The time can be set negative so that the tween will play in reverse until it reaches its start point, 
//   however it will not stop playing when it reaches the beginning and will instead wait for the time to 
//   become positive again or wait for you to stop it manually.
//   The tween must have already been started on the given character with PlayTweenChar or nothing will happen.
//   If you have started a lot of tweens playing, then updating each tween individually will be a lot more 
//   expensive than using <i>UpdateAllTweens</i>.
// INPUTS
//   tweenID -- The ID of the tween to update
//   textID -- The ID of the text to update
//   charID -- The index of the character, indices start at 0, if out of range it will be ignored
//   fTime -- The time to advance the tween
// SOURCE
void agk::UpdateTweenChar( uint32_t tweenID, uint32_t textID, uint32_t charID, float fTime )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CHAR ) return;

	cText *pText = m_cTextList.GetItem( textID );
	if ( !pText ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pText, charID );
	if ( !pInstance ) return;

	pInstance->Update( fTime );

	if ( pInstance->m_fCurrentTime >= pInstance->m_pTween->m_fDuration )
	{
		TweenInstance::DeleteInstance( pTween, pText, charID );
	}
}

//****f* Tweening/General/UpdateTweenObject
// FUNCTION
//   Updates a specific tween that has been started. The time value allows you to control how quickly the 
//   tween advances, and in most cases the result of <i>GetFrameTime</i> should be used.
//   The time can be set negative so that the tween will play in reverse until it reaches its start point, 
//   however it will not stop playing when it reaches the beginning and will instead wait for the time to 
//   become positive again or wait for you to stop it manually.
//   The tween must have already been started on the given object with PlayTweenObject or nothing will happen.
//   If you have started a lot of tweens playing, then updating each tween individually will be a lot more 
//   expensive than using <i>UpdateAllTweens</i>.
// INPUTS
//   tweenID -- The ID of the tween to update
//   objectID -- The ID of the object to update
//   fTime -- The time to advance the tween
// SOURCE
void agk::UpdateTweenObject( uint32_t tweenID, uint32_t objectID, float fTime )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_OBJECT ) return;

	cObject3D *pObject = m_cObject3DList.GetItem( objectID );
	if ( !pObject ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pObject );
	if ( !pInstance ) return;

	pInstance->Update( fTime );

	if ( pInstance->m_fCurrentTime >= pInstance->m_pTween->m_fDuration )
	{
		TweenInstance::DeleteInstance( pTween, pObject );
	}
}

//****f* Tweening/General/UpdateTweenCamera
// FUNCTION
//   Updates a specific tween that has been started. The time value allows you to control how quickly the 
//   tween advances, and in most cases the result of <i>GetFrameTime</i> should be used.
//   The time can be set negative so that the tween will play in reverse until it reaches its start point, 
//   however it will not stop playing when it reaches the beginning and will instead wait for the time to 
//   become positive again or wait for you to stop it manually.
//   The tween must have already been started on the given camera with PlayTweenCamera or nothing will happen.
//   If you have started a lot of tweens playing, then updating each tween individually will be a lot more 
//   expensive than using <i>UpdateAllTweens</i>.
// INPUTS
//   tweenID -- The ID of the tween to update
//   cameraID -- The ID of the object to update
//   fTime -- The time to advance the tween
// SOURCE
void agk::UpdateTweenCamera( uint32_t tweenID, uint32_t cameraID, float fTime )
//****
{
	Tween *pTween = m_cTweenList.GetItem( tweenID );
	if ( !pTween || pTween->GetType() != AGK_TWEEN_TYPE_CAMERA ) return;

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera ) return;

	TweenInstance *pInstance = TweenInstance::GetInstance( pTween, pCamera );
	if ( !pInstance ) return;

	pInstance->Update( fTime );

	if ( pInstance->m_fCurrentTime >= pInstance->m_pTween->m_fDuration )
	{
		TweenInstance::DeleteInstance( pTween, pCamera );
	}
}

//****f* Tweening/General/UpdateTweenChain
// FUNCTION
//   Updates the given tween chain. The time value allows you to control how quickly the chain advances, 
//   and in most cases the result of <i>GetFrameTime</i> should be used.
//   The time can be set negative so that the chain and the tweens it contains will play in reverse until 
//   it reaches the start point, however it will not stop playing when it reaches the beginning and will 
//   instead wait for the time to become positive again or wait for you to stop it manually.
// INPUTS
//   chainID -- The ID of the chain to update
//   fTime -- The time to advance the chain
// SOURCE
void agk::UpdateTweenChain( uint32_t chainID, float fTime )
//****
{
	TweenChain *pChain = m_cTweenChainList.GetItem( chainID );
	if ( pChain ) pChain->Update( fTime );
}



//
// Touch functions
//

//****f* Input-Raw/Multitouch/GetRawTouchCount
// FUNCTION
//   Returns the number of touch events currently taking place. By default the AGK does not count an event 
//   until it knows what type of event it is, e.g. short, long, drag, etc. To count unknown events as well, 
//   set bIncludeUnknown to 1. Use 0 to ignore unknown events.
// INPUTS
//   bIncludeUnknown -- Set to 1 to count unknown events which may become any type of touch event in the future.
// SOURCE
uint32_t agk::GetRawTouchCount( int bIncludeUnknown )
//****
{
	return cTouch::GetCount( bIncludeUnknown>0 );
}

//****f* Input-Raw/Multitouch/GetRawFirstTouchEvent
// FUNCTION
//   Returns an index to the first touch event available for reading. By default the AGK does not count an event 
//   until it knows what type of event it is, e.g. short, long, drag, etc. To receive unknown events as well 
//   set bIncludeUnknown to 1. Use 0 to ignore unknown events. All you can be sure about with unknown events is 
//   that the finger is currently on screen and has been there less than 1 second. After 1 second it automatically 
//   becomes a hold event. If the user lifts their finger off the screen it becomes a short event, and if they move 
//   their finger it becomes a drag event. If no events are available it returns 0.
// INPUTS
//   bIncludeUnknown -- Set to true to receive unknown events which may become any type of event in the future.
// SOURCE
uint32_t agk::GetRawFirstTouchEvent( int bIncludeUnknown )
//****
{
	cTouch *pPoint = cTouch::GetFirstEvent( bIncludeUnknown>0 );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetID();
}

//****f* Input-Raw/Multitouch/GetRawNextTouchEvent
// FUNCTION
//   Returns an index to the next touch event available for reading, if no more events are available it returns 0.
// SOURCE
uint32_t agk::GetRawNextTouchEvent( )
//****
{
	cTouch *pPoint = cTouch::GetNextEvent( );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetID();
}

//****f* Input-Raw/Multitouch/GetRawTouchType
// FUNCTION
//   Returns the type of the given touch event. All you can be sure about with unknown events is that the 
//   finger is currently on screen and has been there less than 1 second. After 1 second it automatically 
//   becomes a hold event. If the user lifts their finger off the screen before this then it becomes a 
//   short event, and if they move their finger further than the distance specified by 
//   <i>SetRawTouchMoveSensitivity</i> then it becomes a drag event. If the current event is not known then 
//   it returns 0. Events may change from being hold events to being drag events, but short and drag events 
//   do not change type. Unknown events are guaranteed to change type once more information is available.
//   Possible return values are 0 to indicate unknown, 1 for a short touch, 2 for a hold and 3 for dragging.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
int agk::GetRawTouchType( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 0;

	switch( pPoint->GetType() )
	{
		case cTouch::eShort: return 1;
		case cTouch::eHold: return 2;
		case cTouch::eDrag: return 3;
		default: return 0;
	}

	return 0;
}

//****f* Input-Raw/Multitouch/GetRawTouchStartX
// FUNCTION
//   Returns the X position in screen coordinates where the touch event started. This coordinate will be in
//   view coordinates, if you are offsetting the view port you may want to convert it to world coordinates
//   using <i>ScreenToWorldX</i>.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
float agk::GetRawTouchStartX( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetStartX();
}

//****f* Input-Raw/Multitouch/GetRawTouchStartY
// FUNCTION
//   Returns the Y position in screen coordinates where the touch event started. This coordinate will be in
//   view coordinates, if you are offsetting the view port you may want to convert it to world coordinates
//   using <i>ScreenToWorldY</i>.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
float agk::GetRawTouchStartY( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetStartY();
}

//****f* Input-Raw/Multitouch/GetRawTouchCurrentX
// FUNCTION
//   Returns the X position in screen coordinates where the touch event is currently located. This coordinate 
//   will be in view coordinates, if you are offsetting the view port you may want to convert it to world 
//   coordinates using <i>ScreenToWorldX</i>.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
float agk::GetRawTouchCurrentX( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetCurrentX();
}

//****f* Input-Raw/Multitouch/GetRawTouchCurrentY
// FUNCTION
//   Returns the Y position in screen coordinates where the touch event is currently located. This coordinate 
//   will be in view coordinates, if you are offsetting the view port you may want to convert it to world 
//   coordinates using <i>ScreenToWorldY</i>.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
float agk::GetRawTouchCurrentY( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetCurrentY();
}

//****f* Input-Raw/Multitouch/GetRawTouchLastX
// FUNCTION
//   Returns the X position in screen coordinates where the touch event was last recorded before its current location.
//   This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert 
//   it to world coordinates using <i>ScreenToWorldX</i>.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
float agk::GetRawTouchLastX( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetLastX();
}

//****f* Input-Raw/Multitouch/GetRawTouchLastY
// FUNCTION
//   Returns the Y position in screen coordinates where the touch event was last recorded before its current location.
//   This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert 
//   it to world coordinates using <i>ScreenToWorldY</i>.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
float agk::GetRawTouchLastY( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetLastY();
}

//****f* Input-Raw/Multitouch/GetRawTouchReleased
// FUNCTION
//   Returns 1 if the touch has been released, this will always be 1 for short events, hold and drag events will
//   keep reporting 0 until they are released at which point you may wish to take some action.
//   Each event will only report released as 1 once before being removed from the event list.
//   If a touch event is ignored (not queried) for one frame after it is released it will be deleted from the event list.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
int agk::GetRawTouchReleased( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 1;

	return pPoint->GetReleased() ? 1 : 0;
}

//****f* Input-Raw/Multitouch/SetRawTouchValue
// FUNCTION
//   Allows you to set some custom data to be stored in this event that you can retrieve later. Could be a value or pointer.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
//   value -- The value to store with this event.
// SOURCE
void agk::SetRawTouchValue( uint32_t iIndex, int value )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return;

	pPoint->SetData( value );
}

//****f* Input-Raw/Multitouch/GetRawTouchValue
// FUNCTION
//   Retrieves a value previously stored in this event by <i>SetRawTouchValue</i>.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
int agk::GetRawTouchValue( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetData();
}

//****f* Input-Raw/Multitouch/GetRawTouchTime
// FUNCTION
//   Returns the total time that this event took, from press to release in seconds.
// INPUTS
//   iIndex -- The index of the event to check, received from <i>GetRawNextTouchEvent</i> or <i>GetRawFirstTouchEvent</i>.
// SOURCE
float agk::GetRawTouchTime( uint32_t iIndex )
//****
{
	cTouch *pPoint = cTouch::GetEvent( iIndex );
	if ( pPoint == 0 ) return 0;

	return pPoint->GetTotalTime();
}

//****f* Input-Raw/Multitouch/SetRawTouchMoveSensitivity
// FUNCTION
//   Sets the distance a touch event has to move before it gets classed as a drag event.
//   By default this is set at 6.
// INPUTS
//   distance -- The distance the touch event has to move in virtual coordinates
// SOURCE
void agk::SetRawTouchMoveSensitivity( int distance )
//****
{
	cTouch::SetMoveSensitivity( distance );
}

//
// Sound functions
//

//****f* Sound/Device/SetSoundDeviceMode
// FUNCTION
//   Sets whether the app will allow background music from other apps to continue playing (mode=0)
//   or silence other apps whilst this app is active (mode=1). Note that in mode 0 the device considers
//   your app audio to be unimportant so will be silenced if the device ringer is set to silent.<br/><br/>
//   This only works on iOS.
// INPUTS
//   mode -- The sound mode to use (default=0)
// SOURCE
void agk::SetSoundDeviceMode( int mode )
//****
{
#ifdef AGK_IOS
	AVAudioSession *audioSession = [AVAudioSession sharedInstance];
	if ( mode == 1 ) [audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];
	else [audioSession setCategory:AVAudioSessionCategoryAmbient error:nil];
	[audioSession setActive:YES error:nil];
#endif
}

//****f* Sound/Creation/LoadSound
// FUNCTION
//   Loads a sound file from the application media folder. File paths must be relative, not absolute, you cannot load sound files
//   from elsewhere on the disk.<br><br>
//   Please note that compressed WAV files are not supported. You must use uncompressed WAV files to ensure compatibility on all platforms.
// INPUTS
//   iID -- The sound number to store the sound.
//   sFilename -- The filename of the sound file to load, must be a WAV file.
// SOURCE
void agk::LoadSound( uint32_t iID, const char* sFilename )
//****
{
	uString sFile ( sFilename );
	cSoundMgr::AddFile( iID, sFile, -1 );
}

//****f* Sound/Creation/LoadSound
// FUNCTION
//   Loads a sound file from the application media folder and returns the sound number. File paths must be relative,
//   not absolute, you cannot load sound files from elsewhere on the disk.<br><br>
//   Please note that compressed WAV files are not supported. You must use uncompressed WAV files to ensure compatibility on all platforms.
// INPUTS
//   sFilename -- The filename of the sound file to load, must be a WAV file.
// SOURCE
uint32_t agk::LoadSound( const char* sFilename )
//****
{
	uString sFile ( sFilename );
	return cSoundMgr::AddFile( sFile, -1 );
}

void agk::LoadSound( uint32_t iID, const uString &sFile )
{
	cSoundMgr::AddFile( iID, sFile, -1 );
}

uint32_t agk::LoadSound( const uString &sFile )
{
	return cSoundMgr::AddFile( sFile, -1 );
}

//****f* Sound/Creation/LoadSoundOGG
// FUNCTION
//   Loads a sound file from the application media folder. File paths must be relative, not absolute, you cannot load sound files
//   from elsewhere on the disk.<br><br>
//   This command takes a compressed OGG file and decompresses it during loading, allowing you to save file size, but memory usage 
//   will be the same as if you used a WAV file. If you want to use OGG whilst also saving memory then use the new <i>LoadMusicOGG</i>
//   commands.
// INPUTS
//   iID -- The sound number to store the sound.
//   sFilename -- The filename of the sound file to load, must be a OGG file.
// SOURCE
void agk::LoadSoundOGG( uint32_t iID, const char* sFilename )
//****
{
	uString sFile ( sFilename );
	cSoundMgr::AddOGGFile( iID, sFile, -1 );
}

//****f* Sound/Creation/LoadSoundOGG
// FUNCTION
//   Loads a sound file from the application media folder and returns the sound number. File paths must be relative,
//   not absolute, you cannot load sound files from elsewhere on the disk.<br><br>
//   This command takes a compressed OGG file and decompresses it during loading, allowing you to save file size, but memory usage 
//   will be the same as if you used a WAV file. If you want to use OGG whilst also saving memory and improving load times then 
//   use the new <i>LoadMusicOGG</i> commands.
// INPUTS
//   Filename -- The filename of the sound file to load, must be a OGG file.
// SOURCE
uint32_t agk::LoadSoundOGG( const char* sFilename )
//****
{
	uString sFile ( sFilename );
	return cSoundMgr::AddOGGFile( sFile, -1 );
}

//****f* Sound/Creation/SaveSound
// FUNCTION
//   Saves a sound file to the application write folder.
// INPUTS
//   iID -- The ID of the sound to save.
//   sFilename -- The filename to use for the sound file, recommended it end in .wav.
// SOURCE
void agk::SaveSound( uint32_t iID, const char* sFilename )
//****
{
	uString sFile ( sFilename );
	cSoundMgr::SaveFile( iID, sFile );
}

//****f* Sound/Creation/PlaySound
// FUNCTION
//   Play the sound previously loaded into the specified sound number. This command can be called multiple 
//   times for the same sound ID and it will start multiple copies of that sound playing as instances.
//   The command will return an instance ID that can be used to interact with this instance whilst it is 
//   still playing. When an instance stops playing then it is automatically deleted and can no longer be
//   referenced.
//   By default the sound is played at full volume and not looped.
// INPUTS
//   iID -- The sound number to play.
// SOURCE
uint32_t agk::PlaySound( uint32_t iID )
//****
{
	return cSoundMgr::PlayInstance( iID, 100, 0, 0 );
}

//****f* Sound/Creation/PlaySound
// FUNCTION
//   Play the sound previously loaded into the specified sound number. This command can be called multiple 
//   times for the same sound ID and it will start multiple copies of that sound playing as instances.
//   The command will return an instance ID that can be used to interact with this instance whilst it is 
//   still playing. When an instance stops playing then it is automatically deleted and can no longer be
//   referenced.
//   By default the sound is not looped.
// INPUTS
//   iID -- The sound number to play.
//   iVol -- The volume at which the sound should be played (optional, default 100).
// SOURCE
uint32_t agk::PlaySound( uint32_t iID, int iVol )
//****
{
	return cSoundMgr::PlayInstance( iID, iVol, 0, 0 );
}

//****f* Sound/Creation/PlaySound
// FUNCTION
//   Play the sound previously loaded into the specified sound number. This command can be called multiple 
//   times for the same sound ID and it will start multiple copies of that sound playing as instances.
//   The command will return an instance ID that can be used to interact with this instance whilst it is 
//   still playing. When an instance stops playing then it is automatically deleted and can no longer be
//   referenced.
//   The loop parameter allows you to loop the instance forever or a limited number of times. Use a value of 1
//   to loop forever, or a value greater than 1 to loop that many times. For example a loop values of 5 
//   would play the instance 5 times (using the same instance ID) and then delete the instance. A loop 
//   value of 0 plays the instance once and then deletes it.
// INPUTS
//   iID -- The sound number to play.
//   iVol -- The volume at which the sound should be played (optional, default 100).
//   iLoop -- The number of times to loop the instance, or 1 for forever.
// SOURCE
uint32_t agk::PlaySound( uint32_t iID, int iVol, int iLoop )
//****
{
	return cSoundMgr::PlayInstance( iID, iVol, iLoop, 0 );
}

//****f* Sound/Creation/PlaySound
// FUNCTION
//   Play the sound previously loaded into the specified sound number. This command can be called multiple 
//   times for the same sound ID and it will start multiple copies of that sound playing as instances.
//   The command will return an instance ID that can be used to interact with this instance whilst it is 
//   still playing. When an instance stops playing then it is automatically deleted and can no longer be
//   referenced.
//   The loop parameter allows you to loop the instance forever or a limited number of times. Use a value of 1
//   to loop forever, or a value greater than 1 to loop that many times. For example a loop values of 5 
//   would play the instance 5 times (using the same instance ID) and then delete the instance. A loop 
//   value of 0 plays the instance once and then deletes it.
//   Currently the priority parameter is not used by any platform.
// INPUTS
//   iID -- The sound number to play.
//   iVol -- The volume at which the sound should be played (optional, default 100).
//   iLoop -- The number of times to loop the instance, or 1 for forever.
//   iPriority -- Reserved for future use, must be 0 (optional, default 0).
// SOURCE
uint32_t agk::PlaySound( uint32_t iID, int iVol, int iLoop, int iPriority )
//****
{
	return cSoundMgr::PlayInstance( iID, iVol, iLoop, iPriority );
}

//****f* Sound/Creation/StopSound
// FUNCTION
//   Stop the sound currently playing at the specified sound number.
// INPUTS
//   iID -- The sound number to stop.
// SOURCE
void agk::StopSound( uint32_t iID )
//****
{
	cSoundMgr::StopAll( iID );
}

//****f* Sound/Creation/DeleteSound
// FUNCTION
//   Delete the sound at the specified sound number. This will also delete all instances of the sound.
// INPUTS
//   iID -- The sound number to delete.
// SOURCE
void agk::DeleteSound( uint32_t iID )
//****
{
	cSoundMgr::DeleteFile( iID );
}

//****f* Sound/Properties/GetSoundExists
// FUNCTION
//   Returns a value of 1 if the specified sound number exists, otherwise 0 is returned.
// INPUTS
//   iID -- The sound number to check.
// SOURCE
uint32_t agk::GetSoundExists( uint32_t iID )
//****
{
	return cSoundMgr::Exists( iID );
}

//****f* Sound/Properties/GetSoundInstances
// FUNCTION
//   Returns the number of instances of this sound ID that are currently playing or looping.
//   This is exactly the same as <i>GetSoundsPlaying</i>.
// INPUTS
//   iID -- The sound number to check.
// SOURCE
uint32_t agk::GetSoundInstances( uint32_t iID )
//****
{
	return cSoundMgr::CountInstances( iID );
}

//****f* Sound/Properties/GetSoundsPlaying
// FUNCTION
//   Returns the number of instances of this sound ID that are currently playing or looping.
//   This is exactly the same as <i>GetSoundInstances</i>.
// INPUTS
//   iID -- The sound number to check.
// SOURCE
uint32_t agk::GetSoundsPlaying( uint32_t iID )
//****
{
	return cSoundMgr::CountInstances( iID );
}

//****f* Sound/Properties/SetSoundSystemVolume
// FUNCTION
//   Sets the master sound volume for all sounds. The individual sound volumes will remain intact,
//   but all volumes are multiplied by the master sound volume allowing features such as fading.
// INPUTS
//   iVol -- The master sound volume for all sounds.
// SOURCE
void agk::SetSoundSystemVolume( int iVol )
//****
{
	cSoundMgr::SetVolume( iVol );
}

//****f* Sound/Properties/GetSoundMaxRate
// FUNCTION
//   Gets the maximum rate and which sound files can be played on this device. A rate of 1.0 is normal speed,
//   a rate of 2.0 would be double speed, 0.5 would be half speed, and so on. If you attempt to change a sound 
//   playback rate outside of these values it will be clamped to these values. If both min and max return 1.0 
//   then changing the speed of sound playback is not supported on this device.
// SOURCE
float agk::GetSoundMaxRate()
//****
{
	return cSoundMgr::GetMaxRate();
}

//****f* Sound/Properties/GetSoundMinRate
// FUNCTION
//   Gets the minimum rate and which sound files can be played on this device. A rate of 1.0 is normal speed,
//   a rate of 2.0 would be double speed, 0.5 would be half speed, and so on. If you attempt to change a sound 
//   playback rate outside of these values it will be clamped to these values. If both min and max return 1.0 
//   then changing the speed of sound playback is not supported on this device.
// SOURCE
float agk::GetSoundMinRate()
//****
{
	return cSoundMgr::GetMinRate();
}

//****f* Sound/Properties/GetSoundInstancePlaying
// FUNCTION
//   Returns 1 if the given instance is still playing or looping, 0 if it has stopped. The instance ID is 
//   the value returned from <i>PlaySound</i> when you initiated the playing of the sound.
//   Once this command returns 0 the instance has been deleted and can no longer be referenced, any attempt
//   to modify it will be ignored. You will need to create a new instance by using <i>PlaySound</i> again.
// INPUTS
//   iID -- The ID of the instance to check
// SOURCE
int agk::GetSoundInstancePlaying( uint32_t iID )
//****
{
	return cSoundMgr::GetInstancePlaying( iID );
}

//****f* Sound/Properties/GetSoundInstanceVolume
// FUNCTION
//   Returns the current volume of the specified instance, between 0 and 100.
// INPUTS
//   iID -- The ID of the instance to check
// SOURCE
int agk::GetSoundInstanceVolume( uint32_t iID )
//****
{
	return cSoundMgr::GetInstanceVolume( iID );
}

//****f* Sound/Properties/GetSoundInstanceRate
// FUNCTION
//   Returns the current playback rate of the specified instance, with 1.0 being normal speed, 2.0 being double 
//   speed, and so on. Not all devices are guaranteed to support modifying playback rates.
// INPUTS
//   iID -- The ID of the instance to check
// SOURCE
float agk::GetSoundInstanceRate( uint32_t iID )
//****
{
	return cSoundMgr::GetInstanceRate( iID );
}

//****f* Sound/Properties/SetSoundInstanceVolume
// FUNCTION
//   Sets the current volume of the specified instance, between 0 and 100. The instance ID is 
//   the value returned from <i>PlaySound</i> when you initiated the playing of the sound.
// INPUTS
//   iID -- The ID of the instance to modify
//   vol -- The new volume of the instance, 0 to 100
// SOURCE
void agk::SetSoundInstanceVolume( uint32_t iID, int vol )
//****
{
	cSoundMgr::SetInstanceVolume( iID, vol );
}

//****f* Sound/Properties/SetSoundInstanceRate
// FUNCTION
//   Sets the current playback rate of the specified instance, with 1.0 being normal speed, 2.0 being double 
//   speed, and so on. Not all devices are guaranteed to support modifying playback rates. Use <i>GetSoundMaxRate</i>
//   and <i>GetSoundMinRate</i> to check the valid ranges for the current device, any values outside this range 
//   will be clamped.
//   The instance ID is the value returned from <i>PlaySound</i> when you initiated the playing of the sound.
// INPUTS
//   iID -- The ID of the instance to modify
//   rate -- The new playback rate of the instance
// SOURCE
void agk::SetSoundInstanceRate( uint32_t iID, float rate )
//****
{
	cSoundMgr::SetInstanceRate( iID, rate );
}

//****f* Sound/Properties/SetSoundInstanceBalance
// FUNCTION
//   Sets the current balance of the specified instance, with 0 being centered, -1.0 being all on the left speaker, 
//   and 1.0 being all on the right speaker, any values outside this range will be clamped. This works best with
//   mono sounds but can be applied to stereo sounds.
//   The instance ID is the value returned from <i>PlaySound</i> when you initiated the playing of the sound.
// INPUTS
//   iID -- The ID of the instance to modify
//   balance -- The new balance of the instance
// SOURCE
void agk::SetSoundInstanceBalance( uint32_t iID, float balance )
//****
{
	cSoundMgr::SetInstanceBalance( iID, balance );
}

//****f* Sound/Properties/GetSoundInstanceLoopCount
// FUNCTION
//   If the sound was played with looping turned on this command returns the number of loops completed so far.
//   If the instance is using a fixed number of loops then it will never actually reach that loop count value as 
//   it will be immediately deleted upon reaching the end of its last loop.
//   The instance ID is the value returned from <i>PlaySound</i> when you initiated the playing of the sound.
// INPUTS
//   iID -- The ID of the instance to check
// SOURCE
int agk::GetSoundInstanceLoopCount( uint32_t iID )
//****
{
	return cSoundMgr::GetInstanceLoopCount( iID );
}

//****f* Sound/Properties/StopSoundInstance
// FUNCTION
//   Stops the current instance if it hasn't already. This deletes the instance and its ID cannot be used again.
//   The instance ID is the value returned from <i>PlaySound</i> when you initiated the playing of the sound.
// INPUTS
//   iID -- The ID of the instance to check
// SOURCE
void agk::StopSoundInstance( uint32_t iID )
//****
{
	cSoundMgr::StopInstance( iID );
}


//
// Music functions
//

//****f* Music/Deprecated/LoadMusic
// FUNCTION
//   Loads a music file from the application media folder. File paths must be relative, not absolute, you cannot load music files
//   from elsewhere on the disk. It returns the ID of the music file for referencing it later. The recommended format for cross
//   platform compatibility is MP3.<br><br>
//   Please note that the Meego platform does not currently support MP3, it will instead attempt to load an OGG Vorbis file. For
//   example, if you attempt to load "music.mp3", on Meego this will be intepreted as "music.ogg".<br><br>
//   The ID will be in the range 1 to 50.
// INPUTS
//   sFile -- The filename of the music file to load.
// SOURCE
uint32_t agk::LoadMusic( const char *sFile )
//****
{
	agk::Warning( "LoadMusic has been deprecated, use LoadMusicOGG instead" );
	return m_cMusicMgr.AddFile( sFile );
}

//****f* Music/Deprecated/LoadMusic
// FUNCTION
//   Loads a music file from the application media folder into a specified ID. File paths must be relative, not absolute, you 
//   cannot load music files from elsewhere on the disk. It returns the ID of the music file for referencing it later. The 
//   recommended format for cross platform compatibility is MP3.<br><br>
//   Please note that the Meego platform does not currently support MP3, it will instead attempt to load an OGG Vorbis file. For
//   example, if you attempt to load "music.mp3", on Meego this will be intepreted as "music.ogg".<br><br>
//   The ID must be in the range 1 to 50.
// INPUTS
//   iID -- The music number to store the music.
//   sFile -- The filename of the music file to load.
// SOURCE
void agk::LoadMusic( uint32_t iID, const char *sFile )
//****
{
	agk::Warning( "LoadMusic has been deprecated, use LoadMusicOGG instead" );
	m_cMusicMgr.AddFile( iID, sFile );
}

//****f* Music/Deprecated/SetMusicFileVolume
// FUNCTION
//   Sets the volume on a per file basis, this volume level is combined with the music system volume to create the final volume.
//   By default files are played at volume 100. The volume level should be between 0 and 100.
// INPUTS
//   ID -- The music number to set.
//   vol -- The volume to use for this file.
// SOURCE
void agk::SetMusicFileVolume( uint32_t ID, int vol )
//****
{
	m_cMusicMgr.SetFileVolume( ID, vol );
}

//****f* Music/Deprecated/PlayMusic
// FUNCTION
//   Plays the music files one after the other, starting at the first ID found and continuing to the last ID found, it will
//   loop back to the first ID when it reaches the end and continue playing files it finds forever.<br><br>
//   Only one music file may be playing at any one time.
// SOURCE
void agk::PlayMusic()
//****
{
	m_cMusicMgr.Play( 0, true, 1, MAX_MUSIC_FILES-1 );
}

//****f* Music/Deprecated/PlayMusic
// FUNCTION
//   Plays the given music file once and then stops. This is a change from previous versions where AGK
//   would continue playing the next music track after this one. Now you must use the additional parameters of
//   <i>PlayMusic</i> to play tracks one after the other.<br><br>
//   Only one music file may be playing at any one time.
// INPUTS
//   iID -- The music file to start with.
// SOURCE
void agk::PlayMusic( uint32_t iID )
//****
{
	m_cMusicMgr.Play( iID, false, iID, iID );
}

//****f* Music/Deprecated/PlayMusic
// FUNCTION
//   Plays the given music file only and loops it if desired. This is a change from previous versions where AGK
//   would continue playing the next music track after this one. Now you must use the additional parameters of
//   <i>PlayMusic</i> to play tracks one after the other.<br><br>
//   Only one music file may be playing at any one time.
// INPUTS
//   iID -- The music file to start with.
//   bLoop -- 1 to loop forever, 0 to stop after the last ID.
// SOURCE
void agk::PlayMusic( uint32_t iID, int bLoop )
//****
{
	m_cMusicMgr.Play( iID, bLoop>0, iID, iID );
}

//****f* Music/Deprecated/PlayMusic
// FUNCTION
//   Plays the music files one after the other starting at the given ID. It will continue looking for music files up to
//   the ID specified in iEndID. At this point if bLoop is set to 1 it will continue looking for music files to play from
//   iStartID and continue looping from iStartID to iEndID forever. If bLoop is set to 0 it will stop after reaching iEndID.
//   The initial ID may be outside the range iStartID to iEndID.<br><br>
//   Only one music file may be playing at any one time.
// INPUTS
//   iID -- The music file to start with.
//   bLoop -- 1 to loop forever, 0 to stop after the last ID.
//   iStartID -- The ID to return to when looping from the end to the beginning of the file list.
//   iEndID -- The ID after which it should loop back to the beginning.
// SOURCE
void agk::PlayMusic( uint32_t iID, int bLoop, uint32_t iStartID, uint32_t iEndID )
//****
{
	m_cMusicMgr.Play( iID, bLoop>0, iStartID, iEndID );
}

//****f* Music/Deprecated/PauseMusic
// FUNCTION
//   Pauses the currently playing music, whichever ID that may be.
// SOURCE
void agk::PauseMusic( )
//****
{
	m_cMusicMgr.Pause();
}

//****f* Music/Deprecated/ResumeMusic
// FUNCTION
//   Resumes the paused music where it left off.
// SOURCE
void agk::ResumeMusic( )
//****
{
	m_cMusicMgr.Resume();
}

//****f* Music/Deprecated/StopMusic
// FUNCTION
//   Stops any playing music, the music can then only be restarted by calling <i>PlayMusic</i>.
// SOURCE
void agk::StopMusic( )
//****
{
	m_cMusicMgr.Stop();
}

//****f* Music/Deprecated/DeleteMusic
// FUNCTION
//   Deletes a music file from the playlist.
// INPUTS
//   iID -- The ID of the music to delete.
// SOURCE
void agk::DeleteMusic( uint32_t iID )
//****
{
	m_cMusicMgr.RemoveFile( iID );
}

//****f* Music/Deprecated/GetMusicPlaying
// FUNCTION
//   Returns the ID of the currently playing music file. If no music is playing it returns 0.
// SOURCE
int agk::GetMusicPlaying()
//****
{
	return m_cMusicMgr.CurrentlyPlaying();
}

//****f* Music/Deprecated/SetMusicSystemVolume
// FUNCTION
//   Sets the master volume of the music player, in the range 0 to 100.
// INPUTS
//   iVol -- The new volume value to use.
// SOURCE
void agk::SetMusicSystemVolume( int iVol )
//****
{
	m_cMusicMgr.SetMasterVolume( iVol );
}

//****f* Music/Deprecated/GetMusicExists
// FUNCTION
//   Returns 1 if a music file exists at the current ID, 0 if not.
// INPUTS
//   iID -- The ID to check.
// SOURCE
uint32_t agk::GetMusicExists( uint32_t iID )
//****
{
	return m_cMusicMgr.Exists( iID );
}

//****f* Music/Deprecated/GetMusicDuration
// FUNCTION
//   Returns the number of seconds it will take to play the given music file from start to finish.
//   There must be no sounds playing for this command to work, or the given ID must be the track 
//   currently playing. For example if you try to get the duration of ID 2 and ID 1 is currently 
//   playing then it will fail, but if ID 2 is currently playing it will succeed. 
//   For variable bit rate files this command will return an approximation.
// INPUTS
//   iID -- The ID of the music to check.
// SOURCE
float agk::GetMusicDuration( uint32_t iID )
//****
{
	return m_cMusicMgr.GetDuration( iID );
}

//****f* Music/Deprecated/GetMusicPosition
// FUNCTION
//   Returns the number of seconds played of the current music file. If no music is currently playing
//   this command will return 0.
// SOURCE
float agk::GetMusicPosition()
//****
{
	return m_cMusicMgr.GetPosition();
}

//****f* Music/Deprecated/SeekMusic
// FUNCTION
//   Seeks the currently playing music to the speicifed number of seconds, either relative to the current
//   position or an absolute position. For example if the music track is 60 seconds long and is currently 
//   at a position of 10 seconds (it has played 10 seconds of music), seeking to an absolute value of 3
//   seconds will take it back to 3 seconds after the start of the music track. Using a relative value of
//   3 will add 3 seconds to the current position, taking it to 13.
// INPUTS
//   seconds -- The number of seconds to seek to.
//   mode -- 0 to use an absolute position, 1 to use a relative position
// SOURCE
void agk::SeekMusic( float seconds, int mode )
//****
{
	m_cMusicMgr.Seek( seconds, mode );
}

// OGG Music

//****f* Music/OGG/LoadMusicOGG
// FUNCTION
//   Loads a music file compressed with OGG Vorbis. This is supported on all platforms as is the new preferred way 
//   of playing music, replacing the <i>LoadMusic</i> command. Multiple OGG music files can be played at the same 
//   time. OGG music file IDs are separate from normal music file IDs and are not limited to a specific range of 
//   numbers.
// INPUTS
//   sFile -- The filename of the music file to load.
// SOURCE
uint32_t agk::LoadMusicOGG( const char* sFile )
//****
{
	uint32_t musicID = m_cMusicOGGList.GetFreeID();
	if ( musicID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load OGG music - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	LoadMusicOGG( musicID, sFile );
	if ( m_cMusicOGGList.GetItem( musicID ) == 0 ) return 0;
	else return musicID;
}

//****f* Music/OGG/LoadMusicOGG
// FUNCTION
//   Loads a music file compressed with OGG Vorbis. This is supported on all platforms as is the new preferred way 
//   of playing music, replacing the <i>LoadMusic</i> command. Multiple OGG music files can be played at the same 
//   time. OGG music file IDs are separate from normal music file IDs and are not limited to a specific range of 
//   numbers.
// INPUTS
//   musicID -- The ID to use to refer to this music file.
//   sFile -- The filename of the music file to load.
// SOURCE
void agk::LoadMusicOGG( uint32_t musicID, const char* sFile )
//****
{
	if ( musicID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load music %d, ID must be greater than 0", musicID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cMusicOGGList.GetItem( musicID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load music " );
		errStr.AppendUInt( musicID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	AGKMusicOGG *pMusic = new AGKMusicOGG();
	if ( !pMusic->Load( sFile ) ) 
	{
		delete pMusic;
		return;
	}
	else
	{
		m_cMusicOGGList.AddItem( pMusic, musicID );
	}
}

//****f* Music/OGG/GetMusicExistsOGG
// FUNCTION
//   Returns 1 if a music file exists at the specified ID, 0 otherwise.
// INPUTS
//   musicID -- The ID to check
// SOURCE
int agk::GetMusicExistsOGG( uint32_t musicID )
//****
{
	if ( m_cMusicOGGList.GetItem( musicID ) ) return 1;
	else return 0;
}

//****f* Music/OGG/SetMusicVolumeOGG
// FUNCTION
//   Sets the volume on a per file basis. By default files are played at volume 100. The volume level should be 
//   between 0 and 100.
// INPUTS
//   musicID -- The ID of the music file to modify.
//   vol -- The volume to use for this file.
// SOURCE
void agk::SetMusicVolumeOGG( uint32_t musicID, int vol )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set music volume - music %d does not exist", musicID );
		Error( errStr );
#endif
		return;
	}

	pMusic->SetVolume( vol );
}

//****f* Music/OGG/PlayMusicOGG
// FUNCTION
//   Plays the music file. Multiple OGG music files can be playing at the same time. By default the file plays
//   once and then stops, you can use the loop parameter to make it loop. Use a loop value of 1 to loop forever,
//   a loop value greater than 1 will loop for that number of times. A value of 0 will play once and then stop.
// INPUTS
//   musicID -- The ID of the music file to play
// SOURCE
void agk::PlayMusicOGG( uint32_t musicID )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to play music - music %d does not exist", musicID );
		Error( errStr );
#endif
		return;
	}

	pMusic->Play( 0 );
}

//****f* Music/OGG/PlayMusicOGG
// FUNCTION
//   Plays the music file. Multiple OGG music files can be playing at the same time.
// INPUTS
//   musicID -- The ID of the music file to play
//   iLoop -- The number of times to loop, or 1 to loop forever
// SOURCE
void agk::PlayMusicOGG( uint32_t musicID, int iLoop )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to play music - music %d does not exist", musicID );
		Error( errStr );
#endif
		return;
	}

	pMusic->Play( iLoop );
}

//****f* Music/OGG/PauseMusicOGG
// FUNCTION
//   Pauses the music file. <i>GetMusicPlayingOGG</i> will continue to return 1.
// INPUTS
//   musicID -- The ID of the music file to pause
// SOURCE
void agk::PauseMusicOGG( uint32_t musicID )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to pause music - music %d does not exist", musicID );
		Error( errStr );
#endif
		return;
	}

	pMusic->Pause();
}

//****f* Music/OGG/ResumeMusicOGG
// FUNCTION
//   Resumes the music file if it was paused.
// INPUTS
//   musicID -- The ID of the music file to pause
// SOURCE
void agk::ResumeMusicOGG( uint32_t musicID )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to resume music - music %d does not exist", musicID );
		Error( errStr );
#endif
		return;
	}

	pMusic->Resume();
}

//****f* Music/OGG/StopMusicOGG
// FUNCTION
//   Stops the music file and resets its position to the beginning of the file.
// INPUTS
//   musicID -- The ID of the music file to stop
// SOURCE
void agk::StopMusicOGG( uint32_t musicID )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to stop music - music %d does not exist", musicID );
		Error( errStr );
#endif
		return;
	}

	pMusic->Stop();
}

//****f* Music/OGG/DeleteMusicOGG
// FUNCTION
//   Deletes the music file and frees up the ID to be used again.
// INPUTS
//   musicID -- The ID of the music file to delete
// SOURCE
void agk::DeleteMusicOGG( uint32_t musicID )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.RemoveItem( musicID );
	if ( pMusic )
	{
		delete pMusic;
	}
}

//****f* Music/OGG/GetMusicPlayingOGG
// FUNCTION
//   Returns 1 if the music file is currently playing, 0 otherwise. This will continue to return 1
//   whilst the file is paused.
// INPUTS
//   musicID -- The ID of the music file to check
// SOURCE
int agk::GetMusicPlayingOGG( uint32_t musicID )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get music playing - music %d does not exist", musicID );
		Error( errStr );
#endif
		return 0;
	}

	return pMusic->GetPlaying();
}

//****f* Music/OGG/GetMusicLoopCountOGG
// FUNCTION
//   Returns the number of times this music file has looped.
// INPUTS
//   musicID -- The ID of the music file to check
// SOURCE
int agk::GetMusicLoopCountOGG( uint32_t musicID )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get music loop count - music %d does not exist", musicID );
		Error( errStr );
#endif
		return 0;
	}

	return pMusic->GetLoopCount();
}

//****f* Music/OGG/GetMusicDurationOGG
// FUNCTION
//   Returns the duration of the music file in seconds as a floating point value
// INPUTS
//   musicID -- The ID of the music file to check
// SOURCE
float agk::GetMusicDurationOGG( uint32_t musicID )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get music duration - music %d does not exist", musicID );
		Error( errStr );
#endif
		return 0;
	}

	return pMusic->GetDuration();
}

//****f* Music/OGG/GetMusicPositionOGG
// FUNCTION
//   Returns the current position in the music file, between 0 for the beginning of the file and 
//   <i>GetMusicDurationOGG</i> for the end of the file.
// INPUTS
//   musicID -- The ID of the music file to check
// SOURCE
float agk::GetMusicPositionOGG( uint32_t musicID )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get music position - music %d does not exist", musicID );
		Error( errStr );
#endif
		return 0;
	}

	return pMusic->GetPosition();
}

//****f* Music/OGG/SeekMusicOGG
// FUNCTION
//   Seeks to a given time value, if the file is currently playing then it will immediately continue 
//   playing from there. If the file is not currently playing then it will take effect after the next 
//   call to <i>PlayMusicOGG</i>. The mode parameter lets you choose whether to seek based on an 
//   absolute or relative time value. Absolute will seek to that position in the file, whilst relative
//   will seek relative to the current position.
// INPUTS
//   musicID -- The ID of the music file to seek
//   seconds -- The time in seconds to seek to
//   mode -- 0 for absolute seeking, 1 for relative seeking
// SOURCE
void agk::SeekMusicOGG( uint32_t musicID, float seconds, int mode )
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem( musicID );
	if ( !pMusic )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to seek music - music %d does not exist", musicID );
		Error( errStr );
#endif
		return;
	}

	pMusic->Seek( seconds, mode );
}

//****f* Music/OGG/SetMusicSystemVolumeOGG
// FUNCTION
//   Sets the master volume for all OGG music files. This is multiplied by the file volume, so if the 
//   system volume is set to 100 but the file volume is set to 0 then the file will still be at volume 0.
// INPUTS
//   vol -- The master volume to use, between 0 and 100
// SOURCE
void agk::SetMusicSystemVolumeOGG( int vol )
//****
{
	AGKMusicOGG::SetMasterVolume( vol );
}

//****f* Music/OGG/SetMusicLoopTimesOGG
// FUNCTION
//   Sets the start and end times of the music loop. When <i>PlayMusicOGG</i> is used with the loop 
//   parameter it will by default stop at the end of the file and return to the beginning of the file. 
//   This command will change it to the looping begins and ends at specific times in the music file.
//   Using a start time of -1 will return to the beginning of the file, using and end time of -1 will 
//   stop at the end of the file, these match the default behaviour.
//   If the start time is greater than the current play time then the music file will continue playing
//   until it reaches the end time, it will then return to the chosen start time.
// INPUTS
//   musicID -- The ID of the music file to change
//   startTime -- The time in seconds to return to at the beginning of a loop
//   endTime -- The time in seconds to end the loop and return to the start
// SOURCE
void agk::SetMusicLoopTimesOGG(uint32_t musicID, float startTime, float endTime)
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem(musicID);
	if (!pMusic)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to set music loop time - music %d does not exist", musicID);
		Error(errStr);
#endif
		return;
	}

	pMusic->SetLoopTimes(startTime, endTime);
}

//****f* Music/OGG/SetMusicLoopCountOGG
// FUNCTION
//   Changes the number of times the music file will loop, can be set whilst it is playing. Use
//   a value of 0 to play to the end of the file, or the current loop end time, and then stop.
//   A loop value of 1 will loop forever, a value greater than 1 will loop for that number of times.
//   This command resets the <i>GetMusicLoopCountOGG</i> command and it starts counting again from 0.
// INPUTS
//   musicID -- The ID of the music file to change
//   loop -- The number of times to loop, 0 to stop looping.
// SOURCE
void agk::SetMusicLoopCountOGG(uint32_t musicID, int loop)
//****
{
	AGKMusicOGG *pMusic = m_cMusicOGGList.GetItem(musicID);
	if (!pMusic)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to set music loop count - music %d does not exist", musicID);
		Error(errStr);
#endif
		return;
	}

	pMusic->SetLoopCount(loop);
}

// Record sound

//****f* Sound/Recording/RecordSound
// FUNCTION
//   Not yet functional.
// INPUTS
//   szFilename -- The file to save the sound to.
// SOURCE
void agk::RecordSound( const char* szFilename )
//****
{
	
}

//****f* Sound/Recording/StopSoundRecording
// FUNCTION
//   Not yet functional.
// SOURCE
void agk::StopSoundRecording()
//****
{
	
}

//****f* Sound/Recording/IsSoundRecording
// FUNCTION
//   Not yet functional.
// SOURCE
int agk::IsSoundRecording()
//****
{
	return 0;
}

// Filesystem commands

//****f* File/Access/DeleteFile
// FUNCTION
//   Deletes a given file from the write folder. File paths must be relative, not absolute, you cannot delete files
//   from the application folder or from elsewhere on the disk.
// INPUTS
//   szFile -- The filename to delete.
// SOURCE
void agk::DeleteFile( const char *szFile )
//****
{
	cFile::DeleteFile( szFile );
}

//****f* File/Access/GetFileExists
// FUNCTION
//   Returns 1 if the given file is located in either the resource directory or the write directory assigned to the app.
// INPUTS
//   szFile -- The filename to check.
// SOURCE
int agk::GetFileExists( const char *szFile )
//****
{
	return cFile::Exists( szFile ) ? 1 : 0;
}

//****f* File/Access/ChooseRawFile
// FUNCTION
//   Presents the user with an option to choose a file stored on their current platform (Windows/Mac only), for example
//   a photo or sound file. If the user cancels the operation an empty string will be returned, otherwise the file will
//   be copied to the apps current directory and the filename returned so that it can be used by your app.<br><br>
//   You may specify an optional extension filter to limit the types of files the user will see when browsing. For
//   example using an extension filter of "*.wav" would limit the user to choosing .wav files. For multiple extensions
//   separate them with a semicolon like so "*.wav;*.mp3;*.png".<br><br>
//   If using this command is used in tier 2 the returned string must be deleted when you are finished with it, even
//   if it is an empty string. A null string will not be returned.
//   If you set returnFullPath to 1 then the file will not be copied to the write folder, instead the full path will be
//   returned to you and you can load it using the "raw:" prefix with the normal file commands.
// INPUTS
//   ext -- The extensions to allow
// SOURCE
char* agk::ChooseRawFile( const char* ext )
//****
{
	return ChooseRawFile( ext, 0 );
}

//****f* File/Access/ChooseRawFile
// FUNCTION
//   Presents the user with an option to choose a file stored on their current platform (Windows/Mac only), for example
//   a photo or sound file. If the user cancels the operation an empty string will be returned, otherwise the file will
//   be copied to the apps current directory and the filename returned so that it can be used by your app.<br><br>
//   You may specify an optional extension filter to limit the types of files the user will see when browsing. For
//   example using an extension filter of "*.wav" would limit the user to choosing .wav files. For multiple extensions
//   separate them with a semicolon like so "*.wav;*.mp3;*.png".<br><br>
//   If using this command is used in tier 2 the returned string must be deleted when you are finished with it, even
//   if it is an empty string. A null string will not be returned.
//   If you set returnFullPath to 1 then the file will not be copied to the write folder, instead the full path will be
//   returned to you and you can load it using the "raw:" prefix with the normal file commands.
// INPUTS
//   ext -- The extensions to allow
//   returnFullPath -- 1 to return the full path, 0 to copy it to the write folder and return the write folder path
// SOURCE
char* agk::ChooseRawFile( const char* ext, int returnFullPath )
//****
{
	uString out;
	bool result = agk::PlatformChooseFile( out, ext, returnFullPath );
	if ( !result )
	{
		char *str = new char[1];
		*str = '\0';
		return str;
	}
	else 
	{
		char *str = new char[ out.GetLength() + 1 ];
		strcpy( str, out.GetStr() );
		return str;
	}
}

int agk::GetRealPath( uString &inout )
{
	int mode = 0;
	const char *szFilename = inout.GetStr();
	if ( cFile::ExistsRaw( szFilename ) ) 
	{
		uString sRealPath; sRealPath.SetStrUTF8( szFilename+4 );
		inout.SetStr( sRealPath );
	}
	else if ( cFile::ExistsWrite( szFilename ) ) agk::PlatformGetFullPathWrite( inout );
	else if ( cFile::ExistsRead( szFilename, &mode ) ) agk::PlatformGetFullPathRead( inout, mode );
	else return 0;

	return 1;
}

//****f* File/Paths/SimplifyPath
// FUNCTION
//   Removes any occurrences of ../ or ..\ and shortens the path appropriately by removing folders. Also replaces all
//   back slashes with forward slashes, as forward slashes will work on any platform.
//   This works with both relative and absolute paths, if the path is absolute then all occurrences of ../ will be removed
//   even if there are too many. If the path is relative then any occurrences of ../ that start the path will not be 
//   removed. For example the relative path "../../MyFile.txt" cannot be simplified further, whereas 
//   "C:/../../MyFile.txt" will be converted to "C:/MyFile.txt".
//   The path may begin with the prefix "raw:" or not, both are accepted.
//   If you are using this function in Tier 2 then you must delete the returned string with agk::DeleteString() when you 
//   are done with it.
// INPUTS
//   szPath -- The path to simplify
// SOURCE
char* agk::SimplifyPath( const char *szPath )
//****
{
	if ( !szPath || !*szPath ) return 0;
	
	char *szNewPath = new char[ strlen(szPath)+1 ];
	char *szNewPathPtr = szNewPath;
	*szNewPath = 0;

	if ( strncmp( szPath, "raw:", 4 ) == 0 ) 
	{
		strcpy( szNewPath, "raw:" );
		szNewPathPtr += 4;
		szPath += 4;
	}
	
	int absolute = 0;
	const char *relativePath = szPath;
	if ( *relativePath == '/' ) 
	{
		// Unix root
		*szNewPathPtr = '/';
		szNewPathPtr++;
		relativePath++;
		absolute = 1;
	}
	else if ( *(relativePath+1) == ':' ) 
	{
		// Windows drive root
		szNewPathPtr[ 0 ] = szPath[ 0 ];
		szNewPathPtr[ 1 ] = ':';
		szNewPathPtr[ 2 ] = '/';
		relativePath += 3;
		szNewPathPtr += 3;
		absolute = 1;
	}
	else if ( *relativePath == '\\' && *(relativePath+1) == '\\' )
	{
		// Windows server root
		szNewPathPtr[ 0 ] = '\\';
		szNewPathPtr[ 1 ] = '\\';
		szNewPathPtr += 2;

		const char *ptr = relativePath+2;
		while( *ptr && *ptr != '/' && *ptr != '\\' ) 
		{
			*szNewPathPtr = *ptr;
			szNewPathPtr++;
			ptr++;
		}
		relativePath = ptr;
		if ( *ptr )
		{
			*szNewPathPtr = '/';
			szNewPathPtr++;
			relativePath++;
		}

		absolute = 1;
	}

	*szNewPathPtr = 0;

	if ( !*relativePath ) return szNewPath;

	uString sPath( relativePath );
	sPath.Replace( '\\', '/' );
	relativePath = sPath.GetStr();

	int count = 0;
	const char* ptr = relativePath;
	char prev = '/';
	while( *ptr )
	{
		if ( *ptr == '/' ) 
		{
			if ( prev == '/' )
			{
				uString err; err.Format( "Invalid path \"%s\", folder names must have at least one character", szPath );
				agk::Error( err );
				char *str = new char[1]; *str = 0;
				return str;
			}
			count++;
		}
		prev = *ptr;
		ptr++;
	}

	int numFolders = count+1;
	uString *pFolders = new uString[ numFolders+1 ];
	char *pFolderType = new char[ numFolders+1 ]; 
	
	count = 0;
	const char *szSlash = 0;
	const char *szPrev = relativePath;
	while( (szSlash = strchr(szPrev, '/')) )
	{
		uint32_t length = (uint32_t)(szSlash-szPrev);
		if ( length == 0 )
		{
			uString err; err.Format( "Invalid path \"%s\", folder names must have at least one character", szPath );
			agk::Error( err );
			char *str = new char[1]; *str = 0;
			return str;
		}

		pFolders[ count ].SetStrN( szPrev, length );
		int matches = (pFolders[ count ].CompareTo("..") == 0) ? 1 : 0;
		pFolderType[ count ] = matches;
		count++;

		szPrev = szSlash+1;
	}

	pFolders[ count ].SetStr( szPrev );
	int matches = (pFolders[ count ].CompareTo("..") == 0) ? 1 : 0;
	pFolderType[ count ] = matches;

	int writeIndex = 0;
	for( int readIndex = 0; readIndex < numFolders; readIndex++ )
	{
		if ( pFolderType[ readIndex ] == 1 )
		{
			// want to go backwards
			if ( writeIndex > 0 && pFolderType[ writeIndex-1 ] != 1 )
			{
				// go backwards
				writeIndex--;
			}
			else 
			{
				// can't go backwards, copy it like a normal folder if it is a relative path
				if ( absolute == 0 )
				{
					if ( writeIndex != readIndex )
					{
						pFolderType[ writeIndex ] = pFolderType[ readIndex ];
						pFolders[ writeIndex ].SetStr( pFolders[readIndex] );
					}
					writeIndex++;
				}
			}
		}
		else
		{
			// normal folder
			if ( writeIndex != readIndex )
			{
				pFolderType[ writeIndex ] = pFolderType[ readIndex ];
				pFolders[ writeIndex ].SetStr( pFolders[readIndex] );
			}
			writeIndex++;
		}
	}

	strcat( szNewPathPtr, pFolders[ 0 ].GetStr() );
	for( int i = 1; i < writeIndex; i++ )
	{
		strcat( szNewPathPtr, "/" );
		if ( pFolders[i].GetNumChars() > 0 ) 
		{
			strcat( szNewPathPtr, pFolders[ i ].GetStr() );
		}
	}

	return szNewPath;
}

//****f* File/Paths/JoinPaths
// FUNCTION
//   Joins two paths together and simplifies them, for example joining a path with ../ will remove the last 
//   folder from the path. A forward slash will be added between them if necessary, if the first path ends 
//   in a forward slash and the second path starts with a forward slash then one will be removed to make a 
//   valid path. Any back slashes will be converted to forward slashes. The first path can be relative or 
//   absolute, the second path must be relative. This will not be checked.
// INPUTS
//   szPath -- The first part of the path
//   szPath2 -- The second part of the path
// SOURCE
char* agk::JoinPaths( const char *szPath, const char *szPath2 )
//****
{
	uString sPath( szPath );
	uString sPath2( szPath2 );

	sPath.Replace( '\\', '/' );
	sPath2.Replace( '\\', '/' );

	char *szNewPath = new char[ sPath.GetLength() + sPath.GetLength() + 2 ];
	strcpy( szNewPath, sPath.GetStr() );

	int numChars = sPath.GetNumChars();
	if ( sPath.CharAtConst(numChars-1) == '/' )
	{
		if ( sPath2.CharAt(0) == '/' ) strcat( szNewPath, sPath2.GetStr()+1 );
		else strcat( szNewPath, sPath2.GetStr() );
	}
	else
	{
		if ( sPath2.CharAt(0) == '/' ) strcat( szNewPath, sPath2.GetStr() );
		else 
		{
			strcat( szNewPath, "/" );
			strcat( szNewPath, sPath2.GetStr() );
		}
	}

	char* szNewPath2 = SimplifyPath( szNewPath );
	delete [] szNewPath;
	return szNewPath2;
}

//****f* File/Paths/IsAbsolutePath
// FUNCTION
//   Returns 1 if the given path is absolute, 0 if it is relative. This varies by platform, so a path 
//   beginning "C:/" is consider absolute on Windows but not on Linux, whilst a path beginning with
//   a forward slash is considered absolute on Linux but not on Windows.
//   The path may begin with the prefix "raw:" or not, both are accepted.
// INPUTS
//   szPath -- The path to check
// SOURCE
int agk::IsAbsolutePath( const char *szPath )
//****
{
	if ( !*szPath ) return 0;
	if ( strncmp( szPath, "raw:", 4 ) == 0 ) szPath += 4;

#ifdef AGK_WINDOWS
	if ( *(szPath+1) == ':' ) 
	{
		// Windows drive root
		return 1;
	}
	else if ( *szPath == '\\' && *(szPath+1) == '\\' )
	{
		// Windows server root
		return 1;
	}
#else
	if ( *szPath == '/' ) 
	{
		// Unix root
		return 1;
	}
#endif
	
	return 0;
}

//****f* File/Paths/CountWindowsDrives
// FUNCTION
//   Returns the number of drives currently available on this devices, only applies to Windows. Other platforms will return 0.
// SOURCE
int agk::CountWindowsDrives()
//****
{
#ifndef AGK_WINDOWS
	return 0;
#else
	uint32_t drives = GetLogicalDrives();
	int count = 0;
	while( drives )
	{
		if ( drives & 1 ) count++;
		drives >>= 1;
	}
	return count;
#endif
}

//****f* File/Paths/GetWindowsDrive
// FUNCTION
//   Returns the drive letter of the specified drive, between 0 and <i>CountWindowsDrives</i> minus one.
//   Values outside this range will return an empty string.
//   The returned string will include the drive letter and a colon, nothing else. This only applies to 
//   Windows, other platforms will return an empty string.
//   If you are calling this command from Tier 2 then you must delete the returned string with agk::DeleteString()
//   when you are done with it.
// INPUTS
//   index -- The index of the drive to return
// SOURCE
char* agk::GetWindowsDrive( int index )
//****
{
#ifndef AGK_WINDOWS
	char *str = new char[1]; *str = 0;
	return str;
#else
	char *str = new char[3];
	uint32_t drives = GetLogicalDrives();
	if ( index < 0 ) { *str = 0; return str; }
	str[0] = 'A'; str[1] = ':'; str[2] = 0;
	int count = 0;
	while( drives )
	{
		if ( drives & 1 ) count++;
		if ( count > index ) return str;
		drives >>= 1;
		(*str)++; // increase letter
	}
	// not found
	*str = 0;
	return str;
#endif
}

//****f* File/Directory Raw/OpenRawFolder
// FUNCTION
//   Opens a folder any where on the file system and reads the list of files and folders it contains. This is done
//   immediately so any changes that occur to the folder after this command will not be noticed, you would need to
//   call this command again to get the updated contents. The file path must be absolute for the current device, i.e.
//   it must begin with a drive letter and colon on Windows, and a forward slash on all other platforms.
//   The path must exist and be accessible to the current app or this command will generate an error.
//   The path may begin with the text "raw:" or not, both forms are accepted. This command will return an ID that you can 
//   use to access the file list that was found, it will remain accessible until you close it with <i>CloseRawFolder</i>.
//   Multiple folders can be open at the same time, they will each be given a different ID.
// INPUTS
//   szPath -- The path to the folder to open
// SOURCE
uint32_t agk::OpenRawFolder( const char *szPath )
//****
{
	uint32_t ID = m_cFolderList.GetFreeID( );
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		Error( "Failed to open folder, no free IDs found" );
#endif
		return 0;
	}

	cFolder *pFolder = new cFolder();
	if ( !pFolder->OpenFolder( szPath ) ) 
	{
		delete pFolder;
		return 0;
	}
	m_cFolderList.AddItem( pFolder, ID );
	return ID;
}

//****f* File/Directory Raw/CloseRawFolder
// FUNCTION
//   Closes a previously open folder and frees the file list that was generated for it. No actual file system
//   changes are made, i.e. the folder is not held open on the file system. The folder is read in its entirety
//   during <i>OpenRawFolder</i> so it does not need to exist on the file system after calling that command.
// INPUTS
//   ID -- The ID of the folder to close
// SOURCE
void agk::CloseRawFolder( uint32_t ID )
//****
{
	cFolder *pFolder = m_cFolderList.RemoveItem( ID );
	if ( pFolder ) delete pFolder;
}

//****f* File/Directory Raw/GetRawFolderNumFiles
// FUNCTION
//   Returns the number of files that were found when the <i>OpenRawFolder</i> was called.
// INPUTS
//   ID -- The ID of the folder to check
// SOURCE
int agk::GetRawFolderNumFiles( uint32_t ID )
//****
{
	cFolder *pFolder = (cFolder*) m_cFolderList.GetItem( ID );
	if ( !pFolder )
	{
		uString errStr; errStr.Format( "Folder %d does not exist", ID );
		Error( errStr );
		return 0;
	}

	return pFolder->GetNumFiles();
}

//****f* File/Directory Raw/GetRawFolderNumFolders
// FUNCTION
//   Returns the number of folders that were found when the <i>OpenRawFolder</i> was called.
// INPUTS
//   ID -- The ID of the folder to check
// SOURCE
int agk::GetRawFolderNumFolders( uint32_t ID )
//****
{
	cFolder *pFolder = (cFolder*) m_cFolderList.GetItem( ID );
	if ( !pFolder )
	{
		uString errStr; errStr.Format( "Folder %d does not exist", ID );
		Error( errStr );
		return 0;
	}

	return pFolder->GetNumFolders();
}

//****f* File/Directory Raw/GetRawFolderFileName
// FUNCTION
//   Return a particular filename from the file list, the index must be in the range 0 to <i>GetRawFolderNumFiles</i> minus one.
// INPUTS
//   ID -- The ID of the folder to check
//   index -- The index of the file to return, indices start at 0
// SOURCE
char* agk::GetRawFolderFileName( uint32_t ID, int index )
//****
{
	cFolder *pFolder = (cFolder*) m_cFolderList.GetItem( ID );
	if ( !pFolder )
	{
		uString errStr; errStr.Format( "Folder %d does not exist", ID );
		Error( errStr );
		return 0;
	}

	const char *szFile = pFolder->GetFile( index );
	char *str;
	if ( !szFile )
	{
		str = new char[ 1 ];
		*str = 0;
	}
	else
	{
		str = new char[ strlen(szFile)+1 ];
		strcpy( str, szFile );
	}
	return str;
}

//****f* File/Directory Raw/GetRawFolderFolderName
// FUNCTION
//   Return a particular folder name from the file list, the index must be in the range 0 to <i>GetRawFolderNumFolders</i> minus one.
// INPUTS
//   ID -- The ID of the folder to check
//   index -- The index of the folder to return, indices start at 0
// SOURCE
char* agk::GetRawFolderFolderName( uint32_t ID, int index )
//****
{
	cFolder *pFolder = (cFolder*) m_cFolderList.GetItem( ID );
	if ( !pFolder )
	{
		uString errStr; errStr.Format( "Folder %d does not exist", ID );
		Error( errStr );
		return 0;
	}

	const char *szFolder = pFolder->GetFolder( index );
	char *str;
	if ( !szFolder )
	{
		str = new char[ 1 ];
		*str = 0;
	}
	else
	{
		str = new char[ strlen(szFolder)+1 ];
		strcpy( str, szFolder );
	}
	return str;
}


//****f* File/Write/OpenToWrite
// FUNCTION
//   Opens a file stored on the local filesystem for writing into the specified ID. By default all platforms are restricted to a 
//   single folder for writing so file paths must be relative, not absolute. This write folder is not the same folder 
//   as the application itself, so images, sounds, and the application itself cannot be overwritten. Files written to 
//   this folder can be read using <i>OpenToRead</i>. If the file does not exist it will be created, if the file does exist 
//   it will be overwritten if append is 0. or appended to if append is 1. If a directory is given in the filename and 
//   does not exist it will be created.<br/><br/>
//
//   To write a file outside the normal write folder you can use "raw:" followed by an absolute path for the current
//   platform, for example "raw:C:\MyFolder\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on Android.
//   If any folders in your chosen path do not exist they will be created.<br/><br/>
//
//   Note that on Android 11 and higher write access to the sdcard folder is restricted so raw paths pointing there will not work.<br/><br/>
//   
//   On Raspberry Pi you can use this command to open a GPIO pin for writing by using the filename "gpio:" followed by the 
//   GPIO pin number, for example OpenToWrite(1, "gpio:4"), this is case sensitive. You can then use <i>WriteByte</i> to 
//   write 0 or 1 to the pin and <i>CloseFile</i> to close the pin.
// INPUTS
//   ID -- The ID to use to reference this file later.
//   szFile -- The filename to open for writing.
//   append -- Set to 1 to append to the file, 0 to overwrite all data (optional, default 0).
// SOURCE
void agk::OpenToWrite( uint32_t ID, const char *szFile, int append )
//****
{
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		Error( "Failed to open file for writing, ID must be greater than 0" );
#endif
		return;
	}

	cFile *pFile = (cFile*) m_cFileList.GetItem( ID );
	if ( pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to open file for writing, File %d already exists", ID );
		Error( errStr );
#endif
		return;
	}

	pFile = new cFile();
	if ( !pFile->OpenToWrite( szFile, append>0 ) ) 
	{
		delete pFile;
		return;
	}
	m_cFileList.AddItem( pFile, ID );
}

//****f* File/Write/OpenToWrite
// FUNCTION
//   Opens a file stored on the local filesystem for writing into the specified ID. All platforms are restricted to a 
//   single folder for writing so file paths must be relative, not absolute. This write folder is not the same folder 
//   as the application itself, so images, sounds, and the application itself cannot be overwritten. Files written to 
//   this folder can be read using <i>OpenToRead</i>. If the file does not exist it will be created, if the file does exist 
//   it will be overwritten if append is 0. or appended to if append is 1. If a directory is given in the filename and 
//   does not exist it will be created.<br/><br/>
//
//   To write a file outside the normal write folder you can use "raw:" followed by an absolute path for the current
//   platform, for example "raw:C:\MyFolder\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on Android. 
//   If any folders in your chosen path do not exist they will be created.<br/><br/>
//   
//   On Raspberry Pi you can use this command to open a GPIO pin for writing by using the filename "gpio:" followed by the 
//   GPIO pin number, for example OpenToWrite(1, "gpio:4"), this is case sensitive. You can then use <i>WriteByte</i> to 
//   write 0 or 1 to the pin and <i>CloseFile</i> to close the pin.
// INPUTS
//   ID -- The ID to use to reference this file later.
//   szFile -- The filename to open for writing.
// SOURCE
void agk::OpenToWrite( uint32_t ID, const char *szFile )
//****
{
	OpenToWrite( ID, szFile, 0 );
}

//****f* File/Write/OpenToWrite
// FUNCTION
//   Opens a file stored on the local filesystem for writing into the specified ID. All platforms are restricted to a 
//   single folder for writing so file paths must be relative, not absolute. This write folder is not the same folder 
//   as the application itself, so images, sounds, and the application itself cannot be overwritten. Files written to 
//   this folder can be read using <i>OpenToRead</i>. If the file does not exist it will be created, if the file does exist 
//   it will be overwritten if append is 0. or appended to if append is 1. If a directory is given in the filename and 
//   does not exist it will be created.<br/><br/>
//
//   To write a file outside the normal write folder you can use "raw:" followed by an absolute path for the current
//   platform, for example "raw:C:\MyFolder\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on Android. 
//   If any folders in your chosen path do not exist they will be created.<br/><br/>
//   
//   On Raspberry Pi you can use this command to open a GPIO pin for writing by using the filename "gpio:" followed by the 
//   GPIO pin number, for example OpenToWrite(1, "gpio:4"), this is case sensitive. You can then use <i>WriteByte</i> to 
//   write 0 or 1 to the pin and <i>CloseFile</i> to close the pin.
// INPUTS
//   szFile -- The filename to open for writing.
//   append -- Set to 1 to append to the file, 0 to overwrite all data (optional, default 0).
// SOURCE
uint32_t agk::OpenToWrite( const char *szFile, int append )
//****
{
	uint32_t ID = m_cFileList.GetFreeID( );
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		Error( "Failed to open file for writing, no free IDs found" );
#endif
		return 0;
	}

	cFile *pFile = new cFile();
	if ( !pFile->OpenToWrite( szFile, append>0 ) ) 
	{
		delete pFile;
		return 0;
	}
	m_cFileList.AddItem( pFile, ID );
	return ID;
}

//****f* File/Write/OpenToWrite
// FUNCTION
//   Opens a file stored on the local filesystem for writing into the specified ID. All platforms are restricted to a 
//   single folder for writing so file paths must be relative, not absolute. This write folder is not the same folder 
//   as the application itself, so images, sounds, and the application itself cannot be overwritten. Files written to 
//   this folder can be read using <i>OpenToRead</i>. If the file does not exist it will be created, if the file does exist 
//   it will be overwritten if append is 0. or appended to if append is 1. If a directory is given in the filename and 
//   does not exist it will be created.<br/><br/>
//
//   To write a file outside the normal write folder you can use "raw:" followed by an absolute path for the current
//   platform, for example "raw:C:\MyFolder\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on Android. 
//   If any folders in your chosen path do not exist they will be created.<br/><br/>
//   
//   On Raspberry Pi you can use this command to open a GPIO pin for writing by using the filename "gpio:" followed by the 
//   GPIO pin number, for example OpenToWrite(1, "gpio:4"), this is case sensitive. You can then use <i>WriteByte</i> to 
//   write 0 or 1 to the pin and <i>CloseFile</i> to close the pin.
// INPUTS
//   szFile -- The filename to open for writing.
// SOURCE
uint32_t agk::OpenToWrite( const char *szFile )
//****
{
	return OpenToWrite( szFile, 0 );
}

//****f* File/Read/OpenToRead
// FUNCTION
//   Opens a file stored on the local filesystem for reading. All platforms are restricted to a single folder for reading
//   and writing so file paths must be relative, not absolute. This command will check the special write folder first, and 
//   if it cannot locate the file it will check the media folder, so you may load images, sounds, and other bundled
//   media files using this command.<br><br>
//   
//   Returns and ID you can use to reference this file later.<br/><br/>
//
//   To read a file outside the normal read or write folders you can use "raw:" followed by an absolute path for the current
//   platform, for example "raw:C:\MyFolder\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on Android.<br/><br/>
//   
//   On Raspberry Pi you can use this command to open a GPIO pin for reading by using the filename "gpio:" followed by the 
//   GPIO pin number, for example OpenToRead(1, "gpio:4"), this is case sensitive. You can then use <i>ReadByte</i> to 
//   read from the pin and <i>CloseFile</i> to close the pin.
// INPUTS
//   szFile -- The filename to open for reading.
// SOURCE
uint32_t agk::OpenToRead( const char *szFile )
//****
{
	uint32_t ID = m_cFileList.GetFreeID( );
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		Error( "Failed to open file for reading, no free IDs found" );
#endif
		return 0;
	}

	cFile *pFile = new cFile();
	if ( !pFile->OpenToRead( szFile ) ) 
	{
		delete pFile;
		return 0;
	}
	m_cFileList.AddItem( pFile, ID );
	return ID;
}

//****f* File/Read/OpenToRead
// FUNCTION
//   Opens a file stored on the local filesystem for reading into the specified ID. All platforms are restricted to a single 
//   folder for reading and writing so file paths must be relative, not absolute. This command will check the special write 
//   folder first, and if it cannot locate the file it will check the media folder, so you may load images, sounds, and 
//   other bundled media files using this command.<br/><br/>
//
//   To read a file outside the normal read or write folders you can use "raw:" followed by an absolute path for the current
//   platform, for example "raw:C:\MyFolder\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on Android.<br/><br/>
//   
//   On Raspberry Pi you can use this command to open a GPIO pin for reading by using the filename "gpio:" followed by the 
//   GPIO pin number, for example OpenToRead(1, "gpio:4"), this is case sensitive. You can then use <i>ReadByte</i> to 
//   read from the pin and <i>CloseFile</i> to close the pin.
// INPUTS
//   ID -- The ID to use for referencing this file later.
//   szFile -- The filename to open for reading.
// SOURCE
void agk::OpenToRead( uint32_t ID, const char *szFile )
//****
{
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		Error( "Failed to open file for reading, ID must be greater than 0" );
#endif
		return;
	}

	cFile *pFile = (cFile*) m_cFileList.GetItem( ID );
	if ( pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to open file for reading, File %d already exists", ID );
		Error( errStr );
#endif
		return;
	}

	pFile = new cFile();
	if ( !pFile->OpenToRead( szFile ) ) 
	{
		delete pFile;
		return;
	}
	m_cFileList.AddItem( pFile, ID );
}

//****f* File/Access/FileIsOpen
// FUNCTION
//   Returns 1 if the given file was opened successfully, 0 if not. You can use <i>GetErrorOccurred</i> to check if
//   it was the result of an error and <i>GetLastError</i> to get said error.
// INPUTS
//   iFileID -- The ID of the file to check.
// SOURCE
int agk::FileIsOpen( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return 0;
	}

	return pFile->IsOpen() ? 1 : 0;
}

//****f* File/Access/CloseFile
// FUNCTION
//   Closes a file and clears the ID used to create it, no further file commands can be called with this ID.
// INPUTS
//   iFileID -- The ID of the file to close
// SOURCE
void agk::CloseFile( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return;
	}

	pFile->Close( );
	m_cFileList.RemoveItem( iFileID ); 
	delete pFile;
}

//****f* File/Read/FileEOF
// FUNCTION
//   Returns 1 if the given file has reached the end of its data stream, 0 otherwise. Only used when reading.
// INPUTS
//   iFileID -- The ID of the file to check.
// SOURCE
int agk::FileEOF( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return 1;
	}

	return pFile->IsEOF( ) ? 1 : 0;
}

//****f* File/Access/GetFileSize
// FUNCTION
//   Returns the size in bytes of the opened file.
// INPUTS
//   iFileID -- The ID of the file to check.
// SOURCE
int agk::GetFileSize( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return 0;
	}

	return pFile->GetSize();
}

//****f* File/Access/GetFilePos
// FUNCTION
//   Returns the current read position in the file
// INPUTS
//   iFileID -- The ID of the file to check.
// SOURCE
int agk::GetFilePos( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return 0;
	}

	return (int)pFile->GetPos();
}

//****f* File/Access/SetFilePos
// FUNCTION
//   Sets the current read position in the file
// INPUTS
//   iFileID -- The ID of the file to check.
//   pos -- The new position to continue reading from
// SOURCE
void agk::SetFilePos( uint32_t iFileID, int pos )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return;
	}

	pFile->Seek((uint32_t)pos);
}

//****f* File/Write/WriteByte
// FUNCTION
//   Writes a 1 byte unsigned integer (0-255) to the given file, which must have been opened for writing.
//   Note that this command is not meant for human readable files and should only be used for
//   files that will later be read with ReadByte. To create human readable files use <i>WriteLine</i>
// INPUTS
//   iFileID -- The ID of the file to modify.
//   b -- The byte to write.
// SOURCE
void agk::WriteByte( uint32_t iFileID, int b )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return;
	}

	pFile->WriteByte( (unsigned char)b );
}

//****f* File/Write/WriteInteger
// FUNCTION
//   Writes a 4 byte integer to the given file, which must have been opened for writing.
//   Note that this command is not meant for human readable files and should only be used for
//   files that will later be read with ReadInteger. To create human readable files use <i>WriteLine</i>
// INPUTS
//   iFileID -- The ID of the file to modify.
//   i -- The integer to write.
// SOURCE
void agk::WriteInteger( uint32_t iFileID, int i )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return;
	}

	pFile->WriteInteger( i );
}

//****f* File/Write/WriteFloat
// FUNCTION
//   Writes a 4 byte float to the given file, which must have been opened for writing.
//   Note that this command is not meant for human readable files and should only be used for
//   files that will later be read with ReadFloat. To create human readable files use <i>WriteLine</i>
// INPUTS
//   iFileID -- The ID of the file to modify.
//   f -- The float to write.
// SOURCE
void agk::WriteFloat( uint32_t iFileID, float f )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return;
	}

	pFile->WriteFloat( f );
}

//****f* File/Write/WriteString
// FUNCTION
//   Writes a null terminated string to the given file, which must have been opened for writing.
//   Note that this command is not meant for human readable files and should only be used for
//   files that will later be read with ReadString. To create human readable files use <i>WriteLine</i>
// INPUTS
//   iFileID -- The ID of the file to modify.
//   str -- The string to write.
// SOURCE
void agk::WriteString( uint32_t iFileID, const char* str )
//****
{
	if ( !str ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to write string, the string has not been assigned a value" );
#endif
		return;
	}

	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return;
	}

	pFile->WriteString( str );
}

//****f* File/Write/WriteString2
// FUNCTION
//   Writes a string to the given file, which must have been opened for writing.
//   Note that this command is not meant for human readable files and should only be used for
//   files that will later be read with ReadString2. To create human readable files use <i>WriteLine</i>
//   This uses a different method from <i>WriteString</i> that will be faster for AGK to read later, but 
//   it is not compatible with <i>ReadString</i>, you must use <i>ReadString2</i> to read strings written 
//   with <i>WriteString2</i>
// INPUTS
//   iFileID -- The ID of the file to modify.
//   str -- The string to write.
// SOURCE
void agk::WriteString2( uint32_t iFileID, const char* str )
//****
{
	if ( !str ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to write string, the string has not been assigned a value" );
#endif
		return;
	}

	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return;
	}

	pFile->WriteString2( str );
}

//****f* File/Write/WriteLine
// FUNCTION
//   Writes a CR(\n) terminated string to the given file, which must have been opened for writing.
// INPUTS
//   iFileID -- The ID of the file to modify.
//   str -- The string to write.
// SOURCE
void agk::WriteLine( uint32_t iFileID, const char* str )
//****
{
	if ( !str ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to write line, the string has not been assigned a value" );
#endif
		return;
	}

	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return;
	}

	pFile->WriteLine( str );
}

//****f* File/Read/ReadByte
// FUNCTION
//   Reads a 1 byte unsigned integer (0-255) from the given file, which must have been opened for reading.
// INPUTS
//   iFileID -- The ID of the file to read.
// SOURCE
int agk::ReadByte( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return 0;
	}

	return (int) pFile->ReadByte( );
}

//****f* File/Read/ReadInteger
// FUNCTION
//   Reads a 4 byte integer from the given file, which must have been opened for reading.
// INPUTS
//   iFileID -- The ID of the file to read.
// SOURCE
int agk::ReadInteger( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return 0;
	}

	return pFile->ReadInteger( );
}

//****f* File/Read/ReadFloat
// FUNCTION
//   Reads a 4 byte float from the given file, which must have been opened for reading.
// INPUTS
//   iFileID -- The ID of the file to read.
// SOURCE
float agk::ReadFloat( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		return 0;
	}

	return pFile->ReadFloat( );
}

//****f* File/Read/ReadString
// FUNCTION
//   Reads a null terminated string from the given file, which must have been opened for reading.
//   Note that this can only read strings in binary form such as those written using <i>WriteString</i>, 
//   if you are trying to read strings separated by new lines then use <i>ReadLine</i> instead.
//   If you use this command in tier 2 you must delete the returned string with agk::DeleteString when you are finished with it.
// INPUTS
//   iFileID -- The ID of the file to read.
// SOURCE
char* agk::ReadString( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	uString str;
	int written = pFile->ReadString( str );
	if ( written == 0 ) 
	{
		char *str = new char[1];
		*str = '\0';
		return str;
	}
	char *szStr = new char[ written+1 ];
	strcpy( szStr, str.GetStr() );
	return szStr;
}

//****f* File/Read/ReadString2
// FUNCTION
//   Reads a string from the given file, which must have been opened for reading.
//   Note that this can only read strings in binary form such as those written using <i>WriteString2</i>, 
//   if you are trying to read strings separated by new lines then use <i>ReadLine</i> instead.
//   If you use this command in tier 2 you must delete the returned string with agk::DeleteString when you are finished with it.
//   This uses a different method from <i>ReadString</i> that is slightly faster but this command can 
//   only read strings written with <i>WriteString2</i>
// INPUTS
//   iFileID -- The ID of the file to read.
// SOURCE
char* agk::ReadString2( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	uString str;
	int written = pFile->ReadString2( str );
	if ( written == 0 ) 
	{
		char *str = new char[1];
		*str = '\0';
		return str;
	}
	char *szStr = new char[ written+1 ];
	strcpy( szStr, str.GetStr() );
	return szStr;
}

//****f* File/Read/ReadLine
// FUNCTION
//   Reads a new line terminated string from the given file, which must have been opened for reading.
//   If you use this command in tier 2 you must delete the returned string with agk::DeleteString when you are finished with it.
// INPUTS
//   iFileID -- The ID of the file to read.
// SOURCE
char* agk::ReadLine( uint32_t iFileID )
//****
{
	cFile *pFile = (cFile*) m_cFileList.GetItem( iFileID );
	if ( !pFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "File %d does not exist", iFileID );
		Error( errStr );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	uString str;
	int written = pFile->ReadLine( str );
	if ( written == 0 ) 
	{
		char *str = new char[1];
		*str = '\0';
		return str;
	}
	char *szStr = new char[ written+1 ];
	strcpy( szStr, str.GetStr() );
	return szStr;
}

// string commands

//****f* Core/Strings/Str
// FUNCTION
//   Converts a value into a string, if you are calling this command from tier 2 this string must
//   be deleted when you are done with it.
// INPUTS
//   valueInt -- Value to convert into a string.
// SOURCE
char* agk::Str( int valueInt )
//****
{
	char *str = new char[ 20 ];
	sprintf( str, "%d", valueInt );
	return str;
}

//****f* Core/Strings/Str
// FUNCTION
//   Converts a value into a string, if you are calling this command from tier 2 this string must
//   be deleted when you are done with it.
// INPUTS
//   valueFloat -- Value to convert into a string.
// SOURCE
char* agk::Str( float valueFloat )
//****
{
	char *str = new char[ 400 ];
	sprintf( str, "%f", valueFloat );
	return str;
}

//****f* Core/Strings/Str
// FUNCTION
//   Converts a value into a string, if you are calling this command from tier 2 this string must
//   be deleted when you are done with it. Note that due to floating point inaccuracies some decimal
//   values cannot be represented exactly in binary, for example 0.1 will be stored as 0.0999999998.
//   Displaying more than roughly 7 decimal places may result in these unexpected values. 
// INPUTS
//   value -- Value to convert into a string.
//   decimals -- The number of places after the decimal point to include.
// SOURCE
char* agk::Str( float valueFloat, uint32_t decimals )
//****
{
	if ( decimals > 30 ) decimals = 30;
	char *str = new char[ 400 ];
	sprintf( str, "%.*f", decimals, valueFloat );
	return str;
}

//****f* Core/Strings/Bin
// FUNCTION
//   Converts an integer value into a string containing its binary representation. For example <i>Bin(7)</i> would 
//   return a string containing "111".<br><br>
//   If you are calling this command from tier 2 this string must be deleted when you are done with it.
// INPUTS
//   i -- Inegert value to convert into a binary string
// SOURCE
char* agk::Bin( int i )
//****
{
	char *str = new char[ 40 ];
	str[ 0 ] = '\0';

	bool first = true;
	uint32_t mask = 0x80000000;
	while ( mask > 0 )
	{
		uint32_t value = (i & mask);
		if ( value > 0 ) 
		{
			first = false;
			value = 1;
		}

		if ( !first )
		{
			if ( value ) strcat( str, "1" );
			else strcat( str, "0" );
		}

		mask = mask >> 1;
	}

	// bugfix - 081011
	if ( strlen(str)==0 ) strcpy ( str, "0" );

	return str;
}

//****f* Core/Strings/Hex
// FUNCTION
//   Converts an integer value into a string containing its hexadecimal representation. For example <i>Hex(31)</i> would 
//   return a string containing "1F".<br><br>
//   If you are calling this command from tier 2 this string must be deleted when you are done with it.
// INPUTS
//   i -- Integer value to convert into a hexadecimal string
// SOURCE
char* agk::Hex( int i )
//****
{
	char *str = new char[ 40 ];
	sprintf( str, "%X", i );
	return str;
}

//****f* Core/Strings/StringToBase64
// FUNCTION
//   Converts a UTF-8 string to a Base64 string.
//   If you are calling this command from tier 2 this string must be deleted when you are done with it.
// INPUTS
//   input -- The string to convert
// SOURCE
char* agk::StringToBase64( const char* input )
//****
{
	const char *b64values = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		
	int length = (int) strlen(input);
	int extra = length % 3;

	if ( length == 0 ) 
	{
		char *str = new char[1]; *str = 0;
		return str;
	}

	uString sOutput( "", length/3 + 4 );
	
	int pos = 0;
	for ( int i = 0; i < length/3; i++ )
	{
		// first byte
		int value1 = *((unsigned char*)(input+pos));
		pos++;
		
		// second byte
		int value2 = *((unsigned char*)(input+pos));
		pos++;
		
		// third byte
		int value3 = *((unsigned char*)(input+pos));
		pos++;
		
		int b64value1 = value1 >> 2;
		int b64value2 = ((value1 & 3) << 4) | (value2 >> 4);
		int b64value3 = ((value2 & 15) << 2) | (value3 >> 6);
		int b64value4 = value3 & 63;
		
		sOutput.AppendAscii( b64values[b64value1] );
		sOutput.AppendAscii( b64values[b64value2] );
		sOutput.AppendAscii( b64values[b64value3] );
		sOutput.AppendAscii( b64values[b64value4] );
	}
	
	if ( extra > 0 )
	{
		int value1 = *((unsigned char*)(input+pos));
		pos++;

		int value2 = 0;
		if ( extra > 1 )
		{
			value2 = *((unsigned char*)(input+pos));
			pos++;
		}
		
		int b64value1 = value1 >> 2;
		int b64value2 = ((value1 & 3) << 4) | (value2 >> 4);
		int b64value3 = ((value2 & 15) << 2);
		
		sOutput.AppendAscii( b64values[b64value1] );
		sOutput.AppendAscii( b64values[b64value2] );
		
		if ( extra == 2 ) 
		{
			sOutput.AppendAscii( b64values[b64value3] );
			sOutput.AppendAscii( '=' );
		}
		else
		{
			sOutput.AppendUTF8( "==" );
		}
	}

	char *str = new char[ sOutput.GetLength() + 1 ];
	strcpy( str, sOutput.GetStr() );
	return str;
}

//****f* Core/Strings/HexToBase64
// FUNCTION
//   Converts a Hex string to a Base64 string. A hex string is a string containing only the characters 
//   0-9 and A-F.
//   If you are calling this command from tier 2 this string must be deleted when you are done with it.
// INPUTS
//   input -- The string to convert
// SOURCE
char* agk::HexToBase64( const char* input )
//****
{
	const char *b64values = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		
	int length = (int) strlen(input) / 2; // hex has two characters per byte
	int extra = length % 3;

	if ( length == 0 ) 
	{
		char *str = new char[1]; *str = 0;
		return str;
	}

	uString sOutput( "", length/3 + 4 );
	
	int pos = 0;
	char byte[3]; byte[2] = 0;
	for ( int i = 0; i < length/3; i++ )
	{
		// first byte
		strncpy( byte, input+pos, 2 );
		int value1 = strtol( byte, 0, 16 );
		pos += 2;
		
		// second byte
		strncpy( byte, input+pos, 2 );
		int value2 = strtol( byte, 0, 16 );
		pos += 2;
		
		// third byte
		strncpy( byte, input+pos, 2 );
		int value3 = strtol( byte, 0, 16 );
		pos += 2;
		
		int b64value1 = value1 >> 2;
		int b64value2 = ((value1 & 3) << 4) | (value2 >> 4);
		int b64value3 = ((value2 & 15) << 2) | (value3 >> 6);
		int b64value4 = value3 & 63;
		
		sOutput.AppendAscii( b64values[b64value1] );
		sOutput.AppendAscii( b64values[b64value2] );
		sOutput.AppendAscii( b64values[b64value3] );
		sOutput.AppendAscii( b64values[b64value4] );
	}
	
	if ( extra > 0 )
	{
		strncpy( byte, input+pos, 2 );
		int value1 = strtol( byte, 0, 16 );
		pos += 2;

		int value2 = 0;
		if ( extra > 1 )
		{
			strncpy( byte, input+pos, 2 );
			value2 = strtol( byte, 0, 16 );
			pos += 2;
		}
		
		int b64value1 = value1 >> 2;
		int b64value2 = ((value1 & 3) << 4) | (value2 >> 4);
		int b64value3 = ((value2 & 15) << 2);
		
		sOutput.AppendAscii( b64values[b64value1] );
		sOutput.AppendAscii( b64values[b64value2] );
		
		if ( extra == 2 ) 
		{
			sOutput.AppendAscii( b64values[b64value3] );
			sOutput.AppendAscii( '=' );
		}
		else
		{
			sOutput.AppendUTF8( "==" );
		}
	}

	char *str = new char[ sOutput.GetLength() + 1 ];
	strcpy( str, sOutput.GetStr() );
	return str;
}

//****f* Core/Strings/Val
// FUNCTION
//   Converts a string into an integer value. For example <i>Val("10")</i> would return the value 10.
// INPUTS
//   str -- The string to convert to an integer.
// SOURCE
int agk::Val( const char* str )
//****
{
	if ( !str ) return 0;
	uString uStr( str );
	if ( uStr.GetLength() == 0 ) return 0;
	return uStr.ToInt();
}

//****f* Core/Strings/Val
// FUNCTION
//   Converts a string from a given base value into an integer value. For example a base value of 2 would
//   interpret the string as a binary value, and return its integer equivalent. A base value of 16 would
//   interpret the string as a hexadecimal value. 
// INPUTS
//   str -- The string to convert to an integer.
//   base -- The base that the string number is in.
// SOURCE
int agk::Val( const char* str, int base )
//****
{
	if ( !str || strlen(str) == 0 ) return 0;
	return (int)strtol( str, 0, base );
}

//****f* Core/Strings/ValFloat
// FUNCTION
//   Converts a string into an floating point value. For example <i>ValFloat("1.045")</i> would return the value 1.045
// INPUTS
//   str -- The string to convert to an integer.
// SOURCE
float agk::ValFloat( const char* str )
//****
{
	if ( !str ) return 0;
	uString uStr( str );
	if ( uStr.GetLength() == 0 ) return 0;
	return uStr.ToFloat();
}

//****f* Core/Strings/Left
// FUNCTION
//   Crops the given string retaining the left most number of characters up to the specified count value.
// INPUTS
//   strin -- The string to be cropped
//   count -- The number of characters to retain
// SOURCE
char* agk::Left( const char* strin, uint32_t count )
//****
{
	if ( !strin || !*strin || count <= 0 ) 
	{
		char *str = new char[1];
		*str = '\0';
		return str;
	}
	
	uString sIn( strin );

	if ( count > sIn.GetNumChars() ) count = sIn.GetNumChars();

	uString sOut;
	sIn.SubString( sOut, 0, count );

	char *str = new char[ sOut.GetLength()+1 ];
	strcpy( str, sOut.GetStr() );
	return str;
}

//****f* Core/Strings/Right
// FUNCTION
//   Crops the given string retaining the right most number of characters up to the specified count value.
// INPUTS
//   strin -- The string to be cropped
//   count -- The number of characters to retain
// SOURCE
char* agk::Right( const char* strin, uint32_t count )
//****
{
	if ( !strin || !*strin || count <= 0 ) 
	{
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	uString sIn( strin );

	if ( count > sIn.GetNumChars() ) count = sIn.GetNumChars();

	uString sOut;
	sIn.SubString( sOut, sIn.GetNumChars()-count, -1 );

	char *str = new char[ sOut.GetLength()+1 ];
	strcpy( str, sOut.GetStr() );
	return str;
}

//****f* Core/Strings/Mid
// FUNCTION
//   Extracts a sub string from the given string located at the position provided.
// INPUTS
//   strin -- The string to be extracted from
//   position -- The position to start within the string, the first character is position 1.
//   length -- The number of characters to extract from the string, use minus 1 to continue to the end of the string
// SOURCE
char* agk::Mid( const char* strin, uint32_t position, int length )
//****
{
	if ( position == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid position passed to Mid(), must be greater then 0." );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	uString sOut;
	uString sIn( strin );
	sIn.SubString( sOut, position-1, length );

	char *str = new char[ sOut.GetLength()+1 ];
	strcpy( str, sOut.GetStr() );
	return str;
}

//****f* Core/Strings/Asc
// FUNCTION
//   Converts a single character string to the Unicode value it represents.
// INPUTS
//   strin -- The string character to convert to the Unicode value
// SOURCE
uint32_t agk::Asc( const char* strin )
//****
{
	if ( !strin ) return 0;
	return uString::DecodeUTF8Char( strin, 0 );
}

//****f* Core/Strings/Len
// FUNCTION
//   Returns the number of characters in the given string. Note that for strings encoded in UTF-8 this
//   may not be equal to the number of bytes in the string, as each character can use up to 4 bytes.
// INPUTS
//   strin -- The string to measure the length of
// SOURCE
uint32_t agk::Len( const char* strin )
//****
{
	if ( !strin ) return 0;
	return uString::CountUTF8Chars( strin, 0 );
}

//****f* Core/Strings/ByteLen
// FUNCTION
//   Returns the number of bytes in the given string. Note that for strings encoded in UTF-8 this may
//   not be equal to the number of characters in the string, as each character can use up to 4 bytes.
// INPUTS
//   strin -- The string to measure the length of
// SOURCE
uint32_t agk::ByteLen( const char* strin )
//****
{
	if ( !strin ) return 0;
	return (uint32_t) strlen( strin );
}

//****f* Core/Strings/Chr
// FUNCTION
//   Returns the string of the Unicode value passed in.
// INPUTS
//   unicodevalue -- The string to measure the length of
// SOURCE
char* agk::Chr( uint32_t unicodevalue )
//****
{
	char *szOut = new char[5];
	szOut[ 0 ] = 0; szOut[ 1 ] = 0; szOut[ 2 ] = 0; szOut[ 3 ] = 0; szOut[ 4 ] = 0;
	uString::GetUTF8FromUnicode( unicodevalue, szOut );
	return szOut;
}

//****f* Core/Strings/Lower
// FUNCTION
//   Converts the string to lower case characters.
// INPUTS
//   strin -- The string to convert
// SOURCE
char* agk::Lower( const char* strin )
//****
{
	uString sOut( strin );
	sOut.Lower();

	char *str = new char[ sOut.GetLength()+1 ];
	strcpy ( str, sOut.GetStr() );
	return str;
}

//****f* Core/Strings/Upper
// FUNCTION
//   Converts the string to upper case characters.
// INPUTS
//   strin -- The string to convert
// SOURCE
char* agk::Upper( const char* strin )
//****
{
	uString sOut( strin );
	sOut.Upper();

	char *str = new char[ sOut.GetLength()+1 ];
	strcpy ( str, sOut.GetStr() );
	return str;
}

//****f* Core/Strings/Spaces
// FUNCTION
//   Creates a string of spaces equal to the length passed in.
// INPUTS
//   length -- The length of the string of spaces to create
// SOURCE
char* agk::Spaces( uint32_t length )
//****
{
	if ( length <= 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error ( "Negative valued passed into the Spaces command" );
#endif
		return 0;
	}

	char *str = new char[ length+1 ];
	uint32_t n = 0;
	for ( n=0; n<length; n++ ) str[n]=32;
	str[n]=0;
	return str;
}

//****f* Core/Strings/FindStringCount
// FUNCTION
//   Returns the number of times findStr appears in the given string.
//   By default this is case insensitive, use the ignoreCase parameter to set case sensitivity.
// INPUTS
//   str -- The string to check
//   findStr -- The string to find
// SOURCE
int agk::FindStringCount( const char* str, const char* findStr )
//****
{
	return FindStringCount( str, findStr, 1, 1 );
}

//****f* Core/Strings/FindStringCount
// FUNCTION
//   Returns the number of times findStr appears in the given string.
//   By default this is case insensitive, use the ignoreCase parameter to set case sensitivity.
// INPUTS
//   str -- The string to check
//   findStr -- The string to find
//   ignoreCase -- 1 to ignore case when searching, 0 to match case
//   start -- The index to start from, the first character is at index 1
// SOURCE
int agk::FindStringCount( const char* str, const char* findStr, int ignoreCase, int start )
//****
{
	uString sStr( str );
	return sStr.FindStrCount( findStr, ignoreCase, start-1 );
}

//****f* Core/Strings/FindString
// FUNCTION
//   Returns the index of the first occurrence of findStr in the given string.
//   Index 1 is the first character in the string, returns 0 if not found.
//   By default this is case insensitive, use the ignoreCase parameter to set case sensitivity.
// INPUTS
//   str -- The string to check
//   findStr -- The string to find
// SOURCE
int agk::FindString( const char* str, const char* findStr )
//****
{
	return FindString( str, findStr, 1, 1 );
}

//****f* Core/Strings/FindString
// FUNCTION
//   Returns the index of the first occurrence of findStr in the given string.
//   Index 1 is the first character in the string, returns 0 if not found.
//   By default this is case insensitive, use the ignoreCase parameter to set case sensitivity.
// INPUTS
//   str -- The string to check
//   findStr -- The string to find
//   ignoreCase -- 1 to ignore case when searching, 0 to match case
//   start -- The index to start from, the first character is at index 1
// SOURCE
int agk::FindString( const char* str, const char* findStr, int ignoreCase, int start )
//****
{
	uString sStr( str );
	return sStr.FindStr( findStr, ignoreCase, start-1 ) + 1;
}

//****f* Core/Strings/FindStringReverse
// FUNCTION
//   Returns the index of the first occurrence of findStr in the given string, starting from the
//   end of the string and moving backwards. Use a start value of -1 to start at the very end of
//   the string regardless of length.
//   Index 1 is the first character in the string, returns 0 if not found.
//   By default this is case insensitive, use the ignoreCase parameter to set case sensitivity.
// INPUTS
//   str -- The string to check
//   findStr -- The string to find
// SOURCE
int agk::FindStringReverse( const char* str, const char* findStr )
//****
{
	return FindStringReverse( str, findStr, 1, -1 );
}

//****f* Core/Strings/FindStringReverse
// FUNCTION
//   Returns the index of the first occurrence of findStr in the given string, starting from the
//   end of the string and moving backwards. Use a start value of -1 to start at the very end of
//   the string regardless of length.
//   Index 1 is the first character in the string, returns 0 if not found.
//   By default this is case insensitive, use the ignoreCase parameter to set case sensitivity.
// INPUTS
//   str -- The string to check
//   findStr -- The string to find
//   ignoreCase -- 1 to ignore case when searching, 0 to match case
//   start -- The index to start from, the first character is at index 1, use minus 1 to start at the very end
// SOURCE
int agk::FindStringReverse( const char* str, const char* findStr, int ignoreCase, int start )
//****
{
	uString sStr( str );
	return sStr.RevFindStr( findStr, ignoreCase, start-1 ) + 1;
}

//****f* Core/Strings/CompareString
// FUNCTION
//   Returns 1 if the two strings are equal to each other, otherwise returns 0. 
//   By default this is case insensitive, use the ignoreCase parameter to set case sensitivity.
//   Use the maxChars parameter to specify the maximum number of characters to check, if the 
//   strings match after that many characters have been checked then they are considered equal. 
//   Use a value of -1 to check all characters regardless of length.
// INPUTS
//   str -- The first string to check
//   str2 -- The second string to check
// SOURCE
int agk::CompareString( const char* str, const char* str2 )
//****
{
	return CompareString( str, str2, 1, -1 );
}

//****f* Core/Strings/CompareString
// FUNCTION
//   Returns 1 if the two strings are equal to each other, otherwise returns 0. 
//   By default this is case insensitive, use the ignoreCase parameter to set case sensitivity.
//   Use the maxChars parameter to specify the maximum number of characters to check, if the 
//   strings match after that many characters have been checked then they are considered equal. 
//   Use a value of -1 to check all characters regardless of length.
// INPUTS
//   str -- The first string to check
//   str2 -- The second string to check
//   ignoreCase -- 1 to ignore case when comparing, 0 to match case
//   maxChars -- The number of characters to check, minus 1 for all
// SOURCE
int agk::CompareString( const char* str, const char* str2, int ignoreCase, int maxChars )
//****
{
	uString sStr( str );
	if ( ignoreCase == 0 )
	{
		if ( maxChars < 0 ) return (sStr.CompareTo( str2 ) == 0) ? 1 : 0;
		else return (sStr.CompareToN( str2, maxChars ) == 0) ? 1 : 0;
	}
	else
	{
		if ( maxChars < 0 ) return (sStr.CompareCaseTo( str2 ) == 0) ? 1 : 0;
		else return (sStr.CompareCaseToN( str2, maxChars ) == 0) ? 1 : 0;
	}
}

//****f* Core/Strings/ReplaceString
// FUNCTION
//   Returns a string with all instances of "find" replaced with "replace". You can use the qty
//   parameter to limit the number of replacements made, or use -1 for no limit. The original
//   string is unmodified and a new string is returned with the replacements in it.
//   Note that if you are calling this command from tier 2 then the returned string must be deleted
//   when you are done with it.
// INPUTS
//   str -- The string to modify
//   find -- The string to find
//   replace -- The string to replace it with
//   qty -- The maximum number of replacements to make, use minus 1 for no limit
// SOURCE
char* agk::ReplaceString( const char* str, const char* find, const char* replace, int qty )
//****
{
	uString sStr( str );
	sStr.ReplaceStr( find, replace, qty );
	
	char* result = new char[ sStr.GetLength() + 1 ];
	strcpy( result, sStr.GetStr() );
	return result;
}

//****f* Core/Strings/StripString
// FUNCTION
//   Returns a string with all characters in "chars" removed from it. The original string is 
//   unmodified and a new string is returned with the characters removed. For example 
//   StripString("my string", "yn") would return "m strig".
//   Note that if you are calling this command from tier 2 then the returned string must be deleted
//   when you are done with it.
// INPUTS
//   str -- The string to modify
//   chars -- The characters to remove
// SOURCE
char* agk::StripString( const char* str, const char* chars )
//****
{
	uString sStr( str );
	sStr.Strip( chars );
	
	char* result = new char[ sStr.GetLength() + 1 ];
	strcpy( result, sStr.GetStr() );
	return result;
}

//****f* Core/Strings/TrimString
// FUNCTION
//   Returns a string with all characters in "chars" removed from the ends of the string. The original 
//   string is unmodified and a new string is returned with the characters removed. This can be used to
//   remove extra whitespace from the ends of an input string.
//   Note that if you are calling this command from tier 2 then the returned string must be deleted
//   when you are done with it.
// INPUTS
//   str -- The string to modify
//   chars -- The characters to remove
// SOURCE
char* agk::TrimString( const char* str, const char* chars )
//****
{
	uString sStr( str );
	sStr.Trim( chars );
	
	char* result = new char[ sStr.GetLength() + 1 ];
	strcpy( result, sStr.GetStr() );
	return result;
}

//****f* Core/Strings/TruncateString
// FUNCTION
//   Returns a string with all characters removed after a given character. The original string is 
//   unmodified and a new string is returned with the characters removed. This searches backwards
//   from the end of the string to the beginning and at the first occurrence of the character 
//   removes it and everything after it.
//   Note that if you are calling this command from tier 2 then the returned string must be deleted
//   when you are done with it.
// INPUTS
//   str -- The string to modify
//   character -- The character to look for, must be a single character
// SOURCE
char* agk::TruncateString( const char* str, const char* character )
//****
{
	uString sStr( str );
	if ( character ) sStr.Trunc( character[0] );
	
	char* result = new char[ sStr.GetLength() + 1 ];
	strcpy( result, sStr.GetStr() );
	return result;
}


//****f* Core/Strings/CountStringTokens
// FUNCTION
//   Counts the number of tokens separated by a specified set of delimiters, for example a string containing
//   "first:second:third" has three tokens delimited by ":" and "first:second;third" has three tokens separated
//   by the delimiters ":;". You can have multiple delimiters between each token, for example "first:;second:third"
//   is valid, and has three tokens.
//   This command is useful for separating words in a sentence, which can be delimited by both white space and 
//   punctuation.
// INPUTS
//   str -- The string to check.
//   delimiters -- The set of characters that delimit the string
// SOURCE
int agk::CountStringTokens( const char* str, const char* delimiters )
//****
{
	uString sStr( str );
	return sStr.CountTokens( delimiters );
}

//****f* Core/Strings/GetStringToken
// FUNCTION
//   Returns a specific token from a string separated by the given delimiters, for example a string containing
//   "first:second:third" has three tokens delimited by ":" and "first:second;third" has three tokens separated
//   by the delimiters ":;". You can have multiple delimiters between each token, for example "first:;second:third"
//   is valid, and has three tokens. In tier 2 the returned string must be deleted when you are done with it.
//   You can use <i>CountStringTokens</i> to count the number of tokens in the string.
//   This command is useful for separating words in a sentence, which can be delimited by both white space and 
//   punctuation.
// INPUTS
//   str -- The string to check.
//   delimiters -- The set of characters that delimit the string.
//   token -- the index of the token to return, starting at 1 for the first token.
// SOURCE
char* agk::GetStringToken( const char* str, const char* delimiters, int token )
//****
{
	uString sStr( str );
	return sStr.GetToken( delimiters, token );
}

//****f* Core/Strings/CountStringTokens2
// FUNCTION
//   Counts the number of tokens separated by a specified delimiter, for example a string containing 
//   "first:second:third" has three tokens delimited by ":". Similar to <i>CountStringTokens</i> except that 
//   this command accepts only a single character as the delimiter and recognises empty fields. For example 
//   "first:second::fourth" has four tokens with the third being an empty string.
// INPUTS
//   str -- The string to check.
//   delimiter -- The character that delimits the string
// SOURCE
int agk::CountStringTokens2( const char* str, const char* delimiter )
//****
{
	uString sStr( str );
	if ( delimiter ) return sStr.CountTokens2( uString::DecodeUTF8Char(delimiter,0) );
	else return 0;
}

//****f* Core/Strings/GetStringToken2
// FUNCTION
//   Returns a specific token from a string separated by the given delimiter, for example a string containing
//   "first:second:third" has three tokens delimited by ":". Similar to <i>GetStringToken</i> except that this 
//   command accepts only a single character as the delimiter and recognises empty fields. For example 
//   "first:second::fourth" has four tokens with the third being an empty string.
//   In tier 2 the returned string must be deleted when you are done with it.
//   You can use <i>CountStringTokens2</i> to count the number of tokens in the string.
// INPUTS
//   str -- The string to check.
//   delimiter -- The character that delimits the string.
//   token -- the index of the token to return, starting at 1 for the first token.
// SOURCE
char* agk::GetStringToken2( const char* str, const char* delimiter, int token )
//****
{
	uString out;
	uString sStr( str );
	if ( delimiter ) sStr.GetToken2( uString::DecodeUTF8Char(delimiter,0), token, out );

	char *result = new char[ out.GetLength()+1 ];
	strcpy( result, out.GetStr() );
	return result;
}

// directory commands

//****f* File/Directory/GetCurrentDir
// FUNCTION
//   This command is deprecated and has been replaced with <i>GetFolder</i>.
// SOURCE
char* agk::GetCurrentDir()
//****
{
	char* str = new char[ m_sCurrentDir.GetLength()+1 ];
	strcpy( str, m_sCurrentDir.GetStr() );
	return str;
}

//****f* File/Directory/GetFolder
// FUNCTION
//   Returns the current folder previously set with <i>SetFolder</i>. The returned path will always have
//   a slash as the final character except when in the root folder in which case an empty string will 
//   be returned.
// SOURCE
char* agk::GetFolder()
//****
{
	char* str = new char[ m_sCurrentDir.GetLength()+1 ];
	strcpy( str, m_sCurrentDir.GetStr() );
	return str;
}

//****f* File/Directory/SetFolder
// FUNCTION
//   In normal use only two folders are accessible to your AGK app; the read folder and the write folder. The read folder is 
//   the location of your executable and includes the media folder. The write folder (which also has read 
//   permission), is located in a platform safe location and is different depending on the device. On Windows, 
//   for example, the default write location is C:\Users\username\AppData\AGKApps\appName (By default this is 
//   a hidden folder on Windows and you may have to show hidden files to see it). These are your root 
//   folders. Any files created/written using <i>OpenToWrite</i> will be saved into the write folder.<br/><br/>
//
//   For simplicity, AGK merges these two read and write folders into a single command set. What this means is 
//   that when you attempt to open or load a file, AGK will first look in the write folder before looking in 
//   the read folder.<br/><br/>
//
//   When using SetFolder, its behavior is what you'd expect from the CD command in the Windows or Linux console; 
//   It works from the current directory. For instance, if the current read folder is C:\games\myApp\ then
//   SetFolder("images") will put you in C:\games\myApp\images. Calling the command a second time with
//   SetFolder("backgrounds") will place you at C:\games\myApp\images\backgrounds\.<br/><br/>
//   
//   There are two ways to return to the base path. The first is to call SetFolder("") using an empty string. 
//   The other is to precede your path with a forward slash, SetFolder("/stuff"). This also applies to loading 
//   your files with other commands as well. Assume you're still located in the images\backgrounds folders and 
//   you want to load bk.png located in the base of the read folder. You can simply say LoadImage("/bk.png") which will load
//   C:\games\myApp\bk.png.<br/><br/>
//
//   Setting the path to a folder that does not exist and using OpenToWrite will create that folder in the 
//   write path. SetFolder does not check that the folder exists, it just sets an internal path that will be 
//   used in the next file command. By default, AGK calls SetFolder("media") as the first thing it does.<br/><br/>
//
//   This command returns 1 on success or 0 if you use an invalid path such as SetFolder("C:\").<br/><br/>
//
//   Note: It is important to remember when setting paths to always use forward slashes instead of backslash. 
//   AGK will convert them into the appropriate file separator for the given platform.<br/><br/>
//
//   If you want to access files outside of the read and write folders you can use the normal file commands such as
//   <i>OpenToRead</i> with a "raw:" file path, see that command for more details. To access folders outside the
//   read and write folders you can use the <i>OpenRawFolder</i> commands.
// INPUTS
//   str -- The path of the folder to set
// SOURCE
int agk::SetFolder( const char* str )
//****
{
	return SetCurrentDir( str );
}

//****f* File/Directory/GetFirstFolder
// FUNCTION
//   Returns the name of the first folder found in the current folder, which is set using <i>SetFolder</i>.
//   You can call <i>GetNextFolder</i> to continue down the list of folders in the current folder.
//   Returns an empty string if there are no folders in the current folder. Does not include . or ..
//   Note that there is a known limitation on Android that any folders within the "assets" folder cannot
//   be found using this command. You may be able to work around this by using MakeFolder to create the same 
//   folder structure in the write folder which AGK can then use to find files in the assets folder with 
//   GetFirstFile.<br/><br/>
//   By default this command will combine the folder lists from the read and write folders into a single list (mode=2)
//   this can be changed to only return folders in the read folder (mode=0) or only return folders from the write
//   folder (mode=1)
// INPUTS
//   mode -- 0 to only return folders from the read folder, 1 to only return folders from the write folder, 2 for both (default)
// SOURCE
char* agk::GetFirstFolder()
//****
{
    return GetFirstFolder( 2 );
}

//****f* File/Directory/GetFirstFolder
// FUNCTION
//   Returns the name of the first folder found in the current folder, which is set using <i>SetFolder</i>.
//   You can call <i>GetNextFolder</i> to continue down the list of folders in the current folder.
//   Returns an empty string if there are no folders in the current folder. Does not include . or ..
//   Note that there is a known limitation on Android that any folders within the "assets" folder cannot
//   be found using this command. You may be able to work around this by using MakeFolder to create the same 
//   folder structure in the write folder which AGK can then use to find files in the assets folder with 
//   GetFirstFile.<br/><br/>
//   By default this command will combine the folder lists from the read and write folders into a single list (mode=2)
//   this can be changed to only return folders in the read folder (mode=0) or only return folders from the write
//   folder (mode=1)
// INPUTS
//   mode -- 0 to only return folders from the read folder, 1 to only return folders from the write folder, 2 for both (default)
// SOURCE
char* agk::GetFirstFolder( int mode )
//****
{
    if ( m_bUpdateFileLists ) agk::ParseCurrentDirectory();
    
	char *str = new char[ 256 ];
	*str = '\0';

	m_iCurrentDirectoryMode = mode;
	m_pCurrentDirectoryIter = m_pCurrentDirectories;

	if ( mode == 0 )
	{
		while( m_pCurrentDirectoryIter && (m_pCurrentDirectoryIter->iFlags & AGK_FILE_TYPE_READ) == 0 )
		{
			m_pCurrentDirectoryIter = m_pCurrentDirectoryIter->m_pNext;
		}
	}
	else if ( mode == 1 )
	{
		while( m_pCurrentDirectoryIter && (m_pCurrentDirectoryIter->iFlags & AGK_FILE_TYPE_WRITE) == 0 )
		{
			m_pCurrentDirectoryIter = m_pCurrentDirectoryIter->m_pNext;
		}
	}

	if ( !m_pCurrentDirectoryIter )	return str;
	else
	{	
		strcpy( str, m_pCurrentDirectoryIter->m_sItem.GetStr() );
		return str;
	}
}

//****f* File/Directory/GetNextFolder
// FUNCTION
//   Returns the name of the next folder found in the current folder, which is set using <i>SetFolder</i>.
//   <i>GetFirstFolder</i> must have been called first for this to work, any call to <i>SetFolder</i> or
//   <i>OpenToWrite</i> will require starting again with <i>GetFirstFolder</i>.<br><br>
//   Returns an empty string if there are no more folders in the current folder. Does not include . or ..
// SOURCE
char* agk::GetNextFolder()
//****
{
	char *str = new char[ 256 ];
	*str = '\0';

	if ( !m_pCurrentDirectoryIter )	return str;

	m_pCurrentDirectoryIter = m_pCurrentDirectoryIter->m_pNext;

	if ( m_iCurrentDirectoryMode == 0 )
	{
		while( m_pCurrentDirectoryIter && (m_pCurrentDirectoryIter->iFlags & AGK_FILE_TYPE_READ) == 0 )
		{
			m_pCurrentDirectoryIter = m_pCurrentDirectoryIter->m_pNext;
		}
	}
	else if ( m_iCurrentDirectoryMode == 1 )
	{
		while( m_pCurrentDirectoryIter && (m_pCurrentDirectoryIter->iFlags & AGK_FILE_TYPE_WRITE) == 0 )
		{
			m_pCurrentDirectoryIter = m_pCurrentDirectoryIter->m_pNext;
		}
	}

	if ( !m_pCurrentDirectoryIter )	return str;
	else
	{
		strcpy( str, m_pCurrentDirectoryIter->m_sItem.GetStr() );
		return str;
	}
}

//****f* File/Directory/GetFolderCount
// FUNCTION
//   Returns the number of folders in the current folder. Does not include . or ..
// INPUTS
//   mode -- 0 to count only folders in the read folder, 1 to only count the write folder, 2 to count both
// SOURCE
int agk::GetFolderCount()
//****
{
    return GetFolderCount(2);
}

//****f* File/Directory/GetFolderCount
// FUNCTION
//   Returns the number of folders in the current folder. Does not include . or ..
// INPUTS
//   mode -- 0 to count only folders in the read folder, 1 to only count the write folder, 2 to count both
// SOURCE
int agk::GetFolderCount( int mode )
//****
{
    if ( m_bUpdateFileLists ) agk::ParseCurrentDirectory();
    
    int count = 0;
    cDirectoryItem *pDir = m_pCurrentDirectories;
    while( pDir )
    {
		if ( 1 == mode )
		{
			if ( pDir->iFlags & AGK_FILE_TYPE_WRITE ) count++;
		}
		else if ( 0 == mode )
		{
			if ( pDir->iFlags & AGK_FILE_TYPE_READ ) count++;
		}
		else count++;

        pDir = pDir->m_pNext;
    }
    return count;
}

//****f* File/Directory/GetFirstFile
// FUNCTION
//   Returns the name of the first file found in the current folder, which is set using <i>SetFolder</i>.
//   You can call <i>GetNextFile</i> to continue down the list of files in the current folder.
//   Returns an empty string if there are no files in the current folder.<br/><br/>
//   By default this command will combine the file lists from the read and write folders into a single list (mode=2)
//   this can be changed to only return files in the read folder (mode=0) or only return files from the write
//   folder (mode=1)<br/><br/>
//   Note that the read folder does not exist when using broadcast or debug to run the app, as files are copied into 
//   the write folder of the AGK Player for these run modes. On the other hand the write folder starts out as empty
//   when running the app directly from the IDE, or when running the final app executable in the project folder.
// INPUTS
//   mode -- 0 to only return files from the read folder, 1 to only return files from the write folder, 2 for both (default)
// SOURCE
char* agk::GetFirstFile()
//****
{
    return GetFirstFile(2);
}

//****f* File/Directory/GetFirstFile
// FUNCTION
//   Returns the name of the first file found in the current folder, which is set using <i>SetFolder</i>.
//   You can call <i>GetNextFile</i> to continue down the list of files in the current folder.
//   Returns an empty string if there are no files in the current folder.<br/><br/>
//   By default this command will combine the file lists from the read and write folders into a single list (mode=2)
//   this can be changed to only return files in the read folder (mode=0) or only return files from the write
//   folder (mode=1)<br/><br/>
//   Note that the read folder does not exist when using broadcast or debug to run the app, as files are copied into 
//   the write folder of the AGK Player for these run modes. On the other hand the write folder starts out as empty
//   when running the app directly from the IDE, or when running the final app executable in the project folder.
// INPUTS
//   mode -- 0 to only return files from the read folder, 1 to only return files from the write folder, 2 for both (default)
// SOURCE
char* agk::GetFirstFile( int mode )
//****
{
    if ( m_bUpdateFileLists ) agk::ParseCurrentDirectory();
        
	char *str = new char[ 256 ];
	*str = '\0';

	m_iCurrentFileMode = mode;
	m_pCurrentFileIter = m_pCurrentFiles;

	if ( mode == 0 )
	{
		while( m_pCurrentFileIter && (m_pCurrentFileIter->iFlags & AGK_FILE_TYPE_READ) == 0 ) 
		{
			m_pCurrentFileIter = m_pCurrentFileIter->m_pNext;
		}
	}
	else if ( mode == 1 )
	{
		while( m_pCurrentFileIter && (m_pCurrentFileIter->iFlags & AGK_FILE_TYPE_WRITE) == 0 ) 
		{
			m_pCurrentFileIter = m_pCurrentFileIter->m_pNext;
		}
	}

	if ( !m_pCurrentFileIter ) return str;
	else
	{
		strcpy( str, m_pCurrentFileIter->m_sItem.GetStr() );
		return str;
	}
}

//****f* File/Directory/GetNextFile
// FUNCTION
//   Returns the name of the next file found in the current folder, which is set using <i>SetFolder</i>.
//   <i>GetFirstFile</i> must have been called first for this to work, any call to <i>SetFolder</i> or
//   <i>OpenToWrite</i> will require starting again with <i>GetFirstFile</i>.<br><br>
//   Returns an empty string if there are no more files in the current folder.
// SOURCE
char* agk::GetNextFile()
//****
{
	char *str = new char[ 256 ];
	*str = '\0';

	if ( !m_pCurrentFileIter ) return str;

	m_pCurrentFileIter = m_pCurrentFileIter->m_pNext;
	if ( m_iCurrentFileMode == 0 )
	{
		while( m_pCurrentFileIter && (m_pCurrentFileIter->iFlags & AGK_FILE_TYPE_READ) == 0 ) 
		{
			m_pCurrentFileIter = m_pCurrentFileIter->m_pNext;
		}
	}
	else if ( m_iCurrentFileMode == 1 )
	{
		while( m_pCurrentFileIter && (m_pCurrentFileIter->iFlags & AGK_FILE_TYPE_WRITE) == 0 ) 
		{
			m_pCurrentFileIter = m_pCurrentFileIter->m_pNext;
		}
	}

	if ( !m_pCurrentFileIter ) return str;
	else
	{
		strcpy( str, m_pCurrentFileIter->m_sItem.GetStr() );
		return str;
	}
}

//****f* File/Directory/GetFileCount
// FUNCTION
//   Returns the number of files in the current folder.
// INPUTS
//   mode -- 0 to count only files in the read folder, 1 to only count the write folder, 2 to count both
// SOURCE
int agk::GetFileCount()
//****
{
	return GetFileCount(2);
}
    
//****f* File/Directory/GetFileCount
// FUNCTION
//   Returns the number of files in the current folder.
// INPUTS
//   mode -- 0 to count only files in the read folder, 1 to only count the write folder, 2 to count both
// SOURCE
int agk::GetFileCount( int mode )
//****
{
    if ( m_bUpdateFileLists ) agk::ParseCurrentDirectory();
    
    cDirectoryItem *pFile = m_pCurrentFiles;
    int count = 0;
    while( pFile )
    {
		if ( mode == 0 )
		{
			if ( pFile->iFlags & AGK_FILE_TYPE_READ ) count++;
		}
		else if ( mode == 1 )
		{
			if ( pFile->iFlags & AGK_FILE_TYPE_WRITE ) count++;
		}
		else count++;

        pFile = pFile->m_pNext;
    }
    return count;
}

// Broadcast listener commands

//****f* Multiplayer/Broadcast/CreateBroadcastListener
// FUNCTION
//   Broadcasts are special network communications as they do not use a destination address and are instead
//   received by all devices on a network. Broadcast packets are not forwarded by routers so can only be used 
//   on the local area network, or more specifically the local subnet. This can be useful for discovering 
//   devices as one device can send a broadcast packet containing its IP address and another device can pick 
//   it up, read the IP and connect back to the first device to create a two-way connection.<br><br>
//
//   Warning, if the device listening for broadcasts is an iOS device then it may not be able to receive 
//   broadcast packets without permission from Apple. As of writing receiving is still allowed but sending
//   requires permission from Apple, this may change in future<br/><br/>
//
//   AGK networks are broadcast in this manner on port 45631 and send a packet containing the name of a network 
//   that has been hosted by another AGK device. By using a broadcast listener you can pick these messages up, 
//   extract the network names and display them to the user for them to choose which network they want to 
//   connect to.<br><br>
//
//   If the device is on an IPv6 network then these rules change slightly. <i>CreateBroadcastListener</i> must
//   be called with a multicast address, which begins with ff, for example ff02::1 and the broadcast listener
//   will only receive packets sent to this multicast address. If no address is specified then the broadcaster 
//   will only receive IPv4 broadcasts. If you pass the address "anyip6" then the broadcast listener will listen
//   on the AGK multicast address "FF02::41:474B" which is used for named network discovery on port 45631.<br><br>
//
//   Returns an ID you can use to interact with this broadcast listener.
// INPUTS
//   port -- The port that the messages are being broadcast on, in the case of AGK networks this will be port 45631.
// SOURCE
uint32_t agk::CreateBroadcastListener( uint32_t port )
//****
{
	if ( port < 1 || port > 65535 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to create broadcast listener, port must be between 1 and 65535" );
#endif
		return 0;
	}

	uint32_t ID = m_cBroadcastListenerList.GetFreeID();
	BroadcastListener *pListener = new BroadcastListener();
	pListener->SetListenPort( port );
	m_cBroadcastListenerList.AddItem( pListener, ID );
	return ID;
}

//****f* Multiplayer/Broadcast/CreateBroadcastListener
// FUNCTION
//   Broadcasts are special network communications as they do not use a destination address and are instead
//   received by all devices on a network. Broadcast packets are not forwarded by routers so can only be used 
//   on the local area network, or more specifically the local subnet. This can be useful for discovering 
//   devices as one device can send a broadcast packet containing its IP address and another device can pick 
//   it up, read the IP and connect back to the first device to create a two-way connection.<br><br>
//
//   Warning, if the device listening for broadcasts is an iOS device then it may not be able to receive 
//   broadcast packets without permission from Apple. As of writing receiving is still allowed but sending
//   requires permission from Apple, this may change in future<br/><br/>
//
//   AGK networks are broadcast in this manner on port 45631 and send a packet containing the name of a network 
//   that has been hosted by another AGK device. By using a broadcast listener you can pick these messages up, 
//   extract the network names and display them to the user for them to choose which network they want to 
//   connect to.<br><br>
//
//   If the device is on an IPv6 network then these rules change slightly. <i>CreateBroadcastListener</i> must
//   be called with a multicast address, which begins with ff, for example ff02::1 and the broadcast listener
//   will only receive packets sent to this multicast address. If no address is specified then the broadcaster 
//   will only receive IPv4 broadcasts. If you pass the address "anyip6" then the broadcast listener will listen
//   on the AGK multicast address "FF02::41:474B" which is used for named network discovery on port 45631.<br><br>
//
//   Returns an ID you can use to interact with this broadcast listener.
// INPUTS
//   szIP -- The multicast IP to listen for, only applies to IPv6 networks, if left empty then it will listen for IPv4 broadcasts.
//   port -- The port that the messages are being broadcast on, in the case of AGK networks this will be port 45631.
// SOURCE
uint32_t agk::CreateBroadcastListener( const char *szIP, uint32_t port )
//****
{
	if ( port < 1 || port > 65535 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to create broadcast listener, port must be between 1 and 65535" );
#endif
		return 0;
	}

	uint32_t ID = m_cBroadcastListenerList.GetFreeID();
	BroadcastListener *pListener = new BroadcastListener();
	if ( !pListener->SetListenPort( szIP, port ) )
	{
		agk::Error( "Failed to create broadcast listener" );
		return 0;
	}
	m_cBroadcastListenerList.AddItem( pListener, ID );
	return ID;
}

//****f* Multiplayer/Broadcast/GetBroadcastMessage
// FUNCTION
//   Checks a broadcast listener for any broadcasts. Returns 0 if nothing has been received. Returns
//   a message ID if something has been received, you can access the contents of this message using 
//   network message commands. The message must be deleted when you have finished reading from it.
// INPUTS
//   iID -- The ID of the broadcast listener to check.
// SOURCE
uint32_t agk::GetBroadcastMessage( uint32_t iID )
//****
{
	BroadcastListener *pListener = m_cBroadcastListenerList.GetItem( iID );
	if ( !pListener )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get broadcast message, Listener ID %d does not exist", iID );
		agk::Error( err );
#endif
		return 0;
	}

	if ( !pListener->ReceivedBroadcast() ) return 0;
	
	uint32_t fromPort;
	char fromIP[ 65 ];
	cNetworkMessage *pMsg = new cNetworkMessage();
	if ( !pListener->GetPacket( *pMsg, fromPort, fromIP ) ) 
	{
		delete pMsg;
		return 0;
	}
	pMsg->sFromIP.SetStr( fromIP );
	pMsg->iFromPort = fromPort;
	
	uint32_t iMsgID = m_cNetMessageList.GetFreeID();
	m_cNetMessageList.AddItem( pMsg, iMsgID );
	return iMsgID;
}

//****f* Multiplayer/Broadcast/DeleteBroadcastListener
// FUNCTION
//   Deletes a broadcast listener and frees up the port for something else to listen on it.
// INPUTS
//   iID -- The ID of the broadcast listener to delete.
// SOURCE
void agk::DeleteBroadcastListener( uint32_t iID )
//****
{
	BroadcastListener *pListener = m_cBroadcastListenerList.RemoveItem( iID );
	if ( pListener ) delete pListener;
}

// socket commands

//****f* Multiplayer/Sockets/ConnectSocket
// FUNCTION
//   Creates a socket and attempts to connect to the specified IP address. This will create a TCP
//   connection that you can then use to send and receive data.
//   This command will return immediately and connect in the background, you should use 
//   <i>GetSocketConnected</i> to check if the socket connects successfully or fails.
//   You should give a timeout value that is long enough for the socket to connect, typically 3000
//   milliseconds is a good value, but high latency connections might need longer. If the connection 
//   times out then this command will return 0.
//   The port number must match the listening port of the device you are connecting to.
//   Returns an ID you can use to reference this socket later.<br><br>
//
//   This works slightly differently when exported to HTML5, it uses a WebSocket which sends an HTTP 
//   style header and requires an HTTP style response to connect.
// INPUTS
//   szIP -- The IP address to connect to, this can be IPv4 or IPv6
//   port -- The TCP port to connect to, in the range 1025 to 65535
//   timeout -- The time in milliseconds to wait before aborting the connection attempt
// SOURCE
uint32_t agk::ConnectSocket( const char *szIP, int port, int timeout )
//****
{
	int socketID = m_cSocketList.GetFreeID();
	if ( ConnectSocket( socketID, szIP, port, timeout ) ) return socketID;
	else return 0;
}

//****f* Multiplayer/Sockets/ConnectSocket
// FUNCTION
//   Creates a socket and attempts to connect to the specified IP address. This will create a TCP
//   connection that you can then use to send and receive data.
//   This command will return immediately and connect in the background, you should use 
//   <i>GetSocketConnected</i> to check if the socket connects successfully or fails.
//   You should give a timeout value that is long enough for the socket to connect, typically 3000
//   milliseconds is a good value, but high latency connections might need longer. If the connection 
//   times out then this command will return 0.
//   The port number must match the listening port of the device you are connecting to.<br><br>
//
//   This works slightly differently when exported to HTML5, it uses a WebSocket which sends an HTTP 
//   style header and requires an HTTP style response to connect.
// INPUTS
//   socketID -- An ID to use to reference this socket later
//   szIP -- The IP address to connect to, this can be IPv4 or IPv6
//   port -- The TCP port to connect to, in the range 1025 to 65535
//   timeout -- The time in milliseconds to wait before aborting the connection attempt
// SOURCE
int agk::ConnectSocket( uint32_t socketID, const char *szIP, int port, int timeout )
//****
{
	if ( socketID < 1 )
	{
		agk::Error( "Failed to create socket, socket ID must be greater than 0" );
		return 0;
	}

	AGKSocket *pSocket = new AGKSocket();
	if ( !pSocket->ConnectASync( szIP, port, timeout ) )
	{
		delete pSocket;
		return 0;
	}
	
	m_cSocketList.AddItem( pSocket, socketID );

	return 1;
}

//****f* Multiplayer/Sockets/GetSocketConnected
// FUNCTION
//   Returns 1 if the specified socket is connected, 0 if it is still in the process of connecting. If the 
//   socket becomes disconnected or fails to connect then this will return -1.
// INPUTS
//   socketID -- The ID of the socket to check
// SOURCE
int agk::GetSocketConnected( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to get socket connected status, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	if ( pSocket->GetDisconnected() ) return -1;
	return pSocket->IsConnected() ? 1 : 0;
}

//****f* Multiplayer/Sockets/GetSocketExists
// FUNCTION
//   Returns 1 if the specified socket exists, 0 otherwise.
// INPUTS
//   socketID -- The ID of the socket to check
// SOURCE
int agk::GetSocketExists( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	return pSocket ? 1 : 0;
}

//****f* Multiplayer/Sockets/DeleteSocket
// FUNCTION
//   Deletes the socket ID so it can be used again. If the socket is currently connected then the 
//   connection is closed first.
// INPUTS
//   socketID -- The ID of the socket to delete
// SOURCE
void agk::DeleteSocket( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.RemoveItem( socketID );
	if ( pSocket ) delete pSocket;
}

AGKSocket* agk::GetSocketPtr( uint32_t socketID )
{
	return m_cSocketList.GetItem( socketID );
}

//****f* Multiplayer/Sockets/GetSocketRemoteIP
// FUNCTION
//   Returns the IP address of the computer or device at the other end of the connection. 
//   This could be an IPv4 or IPv6 address.
// INPUTS
//   socketID -- The ID of the socket to check
// SOURCE
char* agk::GetSocketRemoteIP( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket )
	{
		uString err;
		err.Format( "Failed to get socket remote IP, socket ID %d does not exist", socketID );
		agk::Error( err );

		char *str = new char[1];
		*str = 0;
		return str;
	}

	int length = (int) strlen( pSocket->GetRemoteIP() );
	char *str = new char[ length+1 ];
	strcpy( str, pSocket->GetRemoteIP() );
	return str;
}

//****f* Multiplayer/Sockets/FlushSocket
// FUNCTION
//   Immediately sends any waiting data to the remote host. If you do not call this then data will 
//   will wait forever in the buffer until you write more than 1400 bytes to the socket, at which 
//   point it will automatically be flushed.
//   Every time you call this command a new packet will be sent, so when you are sending multiple 
//   values you should not call it after each value, as that would waste network bandwidth. You 
//   should write all the values and then flush so they will be sent together.
//   If there is no data waiting to be sent this command does nothing.
//   Returns 1 if the socket was successfully flushed, 0 if the socket disconnected.
// INPUTS
//   socketID -- The ID of the socket to check
// SOURCE
int agk::FlushSocket( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket )
	{
		uString err;
		err.Format( "Failed to flush socket, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	return pSocket->Flush() ? 1 : 0;
}

//****f* Multiplayer/Sockets/GetSocketBytesAvailable
// FUNCTION
//   Returns the number of bytes available to be read. If this returns 0 then the read commands, like
//   <i>GetSocketInteger</i> will return no data.
// INPUTS
//   socketID -- The ID of the socket to check
// SOURCE
int agk::GetSocketBytesAvailable( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to get socket bytes available, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	return pSocket->GetBytes();
}

//****f* Multiplayer/Sockets/GetSocketByte
// FUNCTION
//   Will read a single byte from the socket connection and return it. If there is no data waiting to be 
//   read then this command will return immediately and return 0. You can check how much data there is to 
//   read by using <i>GetSocketBytesAvailable</i>.
// INPUTS
//   socketID -- The ID of the socket to read
// SOURCE
int agk::GetSocketByte( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to get socket byte, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	if ( pSocket->GetBytes() == 0 ) return 0;
	else return pSocket->RecvChar();
}

//****f* Multiplayer/Sockets/GetSocketInteger
// FUNCTION
//   Will read a 4 byte integer from the socket connection and return it. If there is less than 4 bytes of
//   data waiting to be read then this command will return immediately and return 0. You can check how much 
//   data there is to read by using <i>GetSocketBytesAvailable</i>.
// INPUTS
//   socketID -- The ID of the socket to read
// SOURCE
int agk::GetSocketInteger( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to get socket integer, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	if ( pSocket->GetBytes() < 4 ) return 0;
	else return pSocket->RecvInt();
}

//****f* Multiplayer/Sockets/GetSocketFloat
// FUNCTION
//   Will read a 4 byte float from the socket connection and return it. If there is less than 4 bytes of
//   data waiting to be read then this command will return immediately and return 0. You can check how much 
//   data there is to read by using <i>GetSocketBytesAvailable</i>.
// INPUTS
//   socketID -- The ID of the socket to read
// SOURCE
float agk::GetSocketFloat( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to get socket float, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	if ( pSocket->GetBytes() < 4 ) return 0;
	else return pSocket->RecvFloat();
}

//****f* Multiplayer/Sockets/GetSocketString
// FUNCTION
//   Will read a string from the socket connection and return it. If you are sending a string from a source 
//   other than AGK then the string must begin with a 4 byte length value followed by X bytes of string data, 
//   where X is the length value. The string should not be null terminated.
//   If there is less than 4 bytes of data waiting to be read then this command will return immediately and 
//   return an empty string. You can check how much data there is to read by using <i>GetSocketBytesAvailable</i>.
//   If there are 4 or more bytes waiting to be read then this command will wait until the entire string has 
//   been received before returning.
// INPUTS
//   socketID -- The ID of the socket to read
// SOURCE
char* agk::GetSocketString( uint32_t socketID )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to get socket string, socket ID %d does not exist", socketID );
		agk::Error( err );
		char *str = new char[1]; *str = 0;
		return str;
	}

	if ( pSocket->GetBytes() < 4 ) 
	{
		char *str = new char[1]; *str = 0;
		return str;
	}
	else 
	{
		uString s;
		pSocket->RecvString( s );
		char *str = new char[ s.GetLength()+1 ];
		strcpy( str, s.GetStr() );
		return str;
	}
}

//****f* Multiplayer/Sockets/SendSocketByte
// FUNCTION
//   Will send a single byte in the range -128 to 127 to the remote connection. Note that data is not sent 
//   immediately, you must call <i>FlushSocket</i> to send it.
//   Returns 1 if the byte was successfully written to the buffer, 0 if the socket disconnected.
// INPUTS
//   socketID -- The ID of the socket to write
//   value -- The value to send
// SOURCE
int agk::SendSocketByte( uint32_t socketID, int value )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to send socket byte, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	return pSocket->SendChar( (char)value ) ? 1 : 0;
}

//****f* Multiplayer/Sockets/SendSocketInteger
// FUNCTION
//   Will send a 4 byte integer to the remote connection. Note that data is not sent immediately, 
//   you must call <i>FlushSocket</i> to send it.
//   Returns 1 if the integer was successfully written to the buffer, 0 if the socket disconnected.
// INPUTS
//   socketID -- The ID of the socket to write
//   value -- The value to send
// SOURCE
int agk::SendSocketInteger( uint32_t socketID, int value )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to send socket integer, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	return pSocket->SendInt( value ) ? 1 : 0;
}

//****f* Multiplayer/Sockets/SendSocketFloat
// FUNCTION
//   Will send a 4 byte float to the remote connection. Note that data is not sent immediately, 
//   you must call <i>FlushSocket</i> to send it.
//   Returns 1 if the float was successfully written to the buffer, 0 if the socket disconnected.
// INPUTS
//   socketID -- The ID of the socket to write
//   value -- The value to send
// SOURCE
int agk::SendSocketFloat( uint32_t socketID, float value )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to send socket float, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	return pSocket->SendFloat( value ) ? 1 : 0;
}

//****f* Multiplayer/Sockets/SendSocketString
// FUNCTION
//   Will send a string to the remote connection. Note that data is not sent immediately, you 
//   must call <i>FlushSocket</i> to send it. If you are sending the string to a non-AGK app 
//   then the string is constructed of a 4 byte length value followed by X bytes of string data
//   where X is the length value. The string is not null terminated.
//   Returns 1 if the string was successfully written to the buffer, 0 if the socket disconnected.
// INPUTS
//   socketID -- The ID of the socket to write
//   value -- The value to send
// SOURCE
int agk::SendSocketString( uint32_t socketID, const char *value )
//****
{
	AGKSocket *pSocket = m_cSocketList.GetItem( socketID );
	if ( !pSocket ) 
	{
		uString err;
		err.Format( "Failed to send socket string, socket ID %d does not exist", socketID );
		agk::Error( err );
		return 0;
	}

	return pSocket->SendString( value ) ? 1 : 0;
}

// socket listener

//****f* Multiplayer/Socket Listener/CreateSocketListener
// FUNCTION
//   Creates a socket listener that listens on a specified port for incoming socket connections.
//   When a connection occurs it will be held in a queue until you retrieve it with 
//   <i>GetSocketListenerConnection</i>. If you want to reject a connection you must retrieve it 
//   and then delete it. The listener will continue accepting connections until it is deleted.
//   If your device has multiple network interfaces then you can specify which one to listen on 
//   by using the IP address parameter. To listen on all interfaces use an empty string as the 
//   IP address.<br><br>
//
//   If the device has both IPv4 and IPv6 addresses then the listener can only listen on one or 
//   the other, not both. To listen for both IPv4 and IPv6 connections you need to create two
//   listeners, one for the IPv4 connections and one for the IPv6 connections. Connections from
//   either will behave exactly the same after they are connected. To create an IPv6 listener
//   pass an IPv6 IP address to <i>CreateSocketListener</i>, or "anyip6" to listen on any 
//   suitable IPv6 address. If you pass an empty string or "anyip4" as the IP address then it 
//   will listen for IPv4 connections.<br><br>
//   
//   You can have multiple listeners active at the same time, but they must all use different 
//   ports or IPs.<br><br>
//
//   When choosing a port number you should avoid low values as these will frequently be used by 
//   other apps and services. If something is already listening on a port then your attempt to 
//   listen on it will fail.
//   Returns 0 if it failed to start listening.
// INPUTS
//   szIP -- The IP address of the interface to listen on, can be IPv4 or IPv6, or "anyip4", or "anyip6"
//   port -- The TCP port to listen on, in the range 1025 to 65535
// SOURCE
uint32_t agk::CreateSocketListener( const char *szIP, int port )
//****
{
	uint32_t listenerID = m_cSocketListenerList.GetFreeID();
	if ( CreateSocketListener( listenerID, szIP, port ) ) return listenerID;
	else return 0;
}

//****f* Multiplayer/Socket Listener/CreateSocketListener
// FUNCTION
//   Creates a socket listener that listens on a specified port for incoming socket connections.
//   When a connection occurs it will be held in a queue until you retrieve it with 
//   <i>GetSocketListenerConnection</i>. If you want to reject a connection you must retrieve it 
//   and then delete it. The listener will continue accepting connections until it is deleted.
//   If your device has multiple network interfaces then you can specify which one to listen on 
//   by using the IP address parameter. To listen on all interfaces use an empty string as the 
//   IP address.<br><br>
//
//   If the device has both IPv4 and IPv6 addresses then the listener can only listen on one or 
//   the other, not both. To listen for both IPv4 and IPv6 connections you need to create two
//   listeners, one for the IPv4 connections and one for the IPv6 connections. Connections from
//   either will behave exactly the same after they are connected. To create an IPv6 listener
//   pass an IPv6 IP address to <i>CreateSocketListener</i>, or "anyip6" to listen on any 
//   suitable IPv6 address. If you pass an empty string or "anyip4" as the IP address then it 
//   will listen for IPv4 connections.<br><br>
//   
//   You can have multiple listeners active at the same time, but they must all use different 
//   ports or IPs.<br><br>
//
//   When choosing a port number you should avoid low values as these will frequently be used by 
//   other apps and services. If something is already listening on a port then your attempt to 
//   listen on it will fail.
//   Returns 0 if it failed to start listening.
// INPUTS
//   listenerID -- An ID to use to reference this listener in the future
//   szIP -- The IP address of the interface to listen on, can be IPv4 or IPv6, or "anyip4", or "anyip6"
//   port -- The TCP port to listen on, in the range 1025 to 65535
// SOURCE
int agk::CreateSocketListener( uint32_t listenerID, const char *szIP, int port )
//****
{
	if ( listenerID < 1 )
	{
		agk::Error( "Failed to create socket listener, ID must be greater than 0" );
		return 0;
	}

	cNetworkListener *pListener = new cNetworkListener();
	if ( !pListener->AcceptConnections( szIP, port ) )
	{
		delete pListener;
		return 0;
	}

	m_cSocketListenerList.AddItem( pListener, listenerID );
	return 1;
}

//****f* Multiplayer/Socket Listener/GetSocketListenerConnection
// FUNCTION
//   Returns the ID of a socket that has connected to your device. The listener will accept connections 
//   in the background and add them to a queue, this command removes one of the sockets from the queue and
//   hands control of it to you. If you do not want to accept the connection you should delete it using
//   <i>DeleteSocket</i>. You should call GetSocketListenerConnection in a loop until it returns 0 to be 
//   sure you have dealt with all connected sockets. You can find out the IP address of the device that
//   connected to you by calling <i>GetSocketRemoteIP</i> on the returned socket.
// INPUTS
//   listenerID -- The ID of the listener to check
// SOURCE
uint32_t agk::GetSocketListenerConnection( uint32_t listenerID )
//****
{
	cNetworkListener *pListener = m_cSocketListenerList.GetItem( listenerID );
	if ( !pListener )
	{
		uString err;
		err.Format( "Failed to get socket listener connection, listener ID %d does not exist", listenerID );
		agk::Error( err );
		return 0;
	}

	AGKSocket *pSocket = pListener->GetNewConnection();
	if ( !pSocket ) return 0;

	uint32_t socketID = m_cSocketList.GetFreeID();
	m_cSocketList.AddItem( pSocket, socketID );
	return socketID;
}

//****f* Multiplayer/Socket Listener/DeleteSocketListener
// FUNCTION
//   Stops the socket listener from receiving connections and frees the ID to be used again. 
//   If any connections are still in the queue and have yet to be collected using
//   <i>GetSocketListenerConnection</i> then they will be closed and deleted.
// INPUTS
//   listenerID -- The ID of the listener to check
// SOURCE
void agk::DeleteSocketListener( uint32_t listenerID )
//****
{
	cNetworkListener *pListener = m_cSocketListenerList.RemoveItem( listenerID );
	if ( pListener ) delete pListener;
}

// Network commands

//****f* Multiplayer/Setup/HostNetwork
// FUNCTION
//   Creates an AGK network with this app as the controller, this app is added as the first client to the network.
//   AGK networks are identified by name and are automatically broadcast to anyone listening on the local area network,
//   meaning that other AGK apps on the LAN can pick up all broadcast networks, display their names to their users and
//   allow them to choose one to join. AGK apps outside the LAN need the IP address and port of the hoster to join the 
//   network, this port will need forwarding to the host through any intervening firewall. The port value must be between 
//   1025 and 65535, and will fail if another application is already listening on that port.<br><br>
//
//   Warning, if the device hosting the network is an iOS device then the broadcasting part of this process will fail unless
//   you get permission from Apple to send broadcast packets, see the following page to request permission 
//   https://developer.apple.com/contact/request/networking-multicast. If you do not have the permission then devices should 
//   still be able to join such a network if they have the IP address and port of the hosting device<br/><br/>
//
//   You must also specify a client name to use to identify your client, all client names must be unique. This name will 
//   be visible to all other clients. Clients will be added to the network automatically and can be counted using 
//   <i>GetNetworkNumClients</i>. You can call <i>IsNetworkActive</i> immediately after this command to check that the network
//   was setup successfully, once setup the network will not become inactive for a hoster.<br><br>
//
//   Once connected the app becomes a client of the network, any other clients that connect to it join the network. All 
//   clients are treated equally and have a list of local variables that they can read from and write to, all clients 
//   can also read any variables on other clients on a read only basis.<br><br>
//
//   Some ports are used by AGK for internal networking and should not be used by your application. Port 5689 is used
//   to manage apps broadcasted from the IDE. Port 45631 is used for named network connections. Port 45633 is used 
//   for file broadcasting. On IPv4 networks the network broadcast goes to all devices on the local subnet, on IPv6
//   networks the broadcast goes to the AGK multicast address "FF02::41:474B". If the device has both IPv4 and IPv6 IP
//   addresses then <i>HostNetwork</i> will accept connections from both IPv4 and IPv6 networks.<br><br>
//
//   If you specify 0 for the port then it will disable IPv4 connections, if you set portv6 to 0 then it will disable IPv6 
//   connections. At least one must be greater than 0 or an error will be generated. If you do not specify portv6 at all then
//   it will be set to 0. It should be safe to use the same port for both IPv4 and IPv6, but this hasn't been widely tested.<br/><br/>
//
//   Returns an ID you can use to interact with this network.<br><br>
//
//   Does not work when exported to HTML5
// INPUTS
//   szNetworkName -- The name to use in identifying this network.
//   szMyName -- The name to use in identifying this client.
//   port -- The port that other clients should use to connect to this network.
// SOURCE
uint32_t agk::HostNetwork( const char *szNetworkName, const char *szMyName, int port )
//****
{
	return HostNetwork( szNetworkName, szMyName, port, 0 );
}

//****f* Multiplayer/Setup/HostNetwork
// FUNCTION
//   Creates an AGK network with this app as the controller, this app is added as the first client to the network.
//   AGK networks are identified by name and are automatically broadcast to anyone listening on the local area network,
//   meaning that other AGK apps on the LAN can pick up all broadcast networks, display their names to their users and
//   allow them to choose one to join. AGK apps outside the LAN need the IP address and port of the hoster to join the 
//   network, this port will need forwarding to the host through any intervening firewall. The port value must be between 
//   1025 and 65535, and will fail if another application is already listening on that port.<br><br>
//
//   Warning, if the device hosting the network is an iOS device then the broadcasting part of this process will fail unless
//   you get permission from Apple to send broadcast packets, see the following page to request permission 
//   https://developer.apple.com/contact/request/networking-multicast. If you do not have the permission then devices should 
//   still be able to join such a network if they have the IP address and port of the hosting device<br/><br/>
//
//   You must also specify a client name to use to identify your client, all client names must be unique. This name will 
//   be visible to all other clients. Clients will be added to the network automatically and can be counted using 
//   <i>GetNetworkNumClients</i>. You can call <i>IsNetworkActive</i> immediately after this command to check that the network
//   was setup successfully, once setup the network will not become inactive for a hoster.<br><br>
//
//   Once connected the app becomes a client of the network, any other clients that connect to it join the network. All 
//   clients are treated equally and have a list of local variables that they can read from and write to, all clients 
//   can also read any variables on other clients on a read only basis.<br><br>
//
//   Some ports are used by AGK for internal networking and should not be used by your application. Ports 5689-5692 are 
//   used to manage apps broadcast from the IDE. Ports 45631 and 45632 are used for named network connections. On IPv4 
//   networks the network broadcast goes to all devices on the local subnet, on IPv6 networks the broadcast goes to the 
//   AGK multicast address "FF02::41:474B". If the device has both IPv4 and IPv6 IP addresses then <i>HostNetwork</i> 
//   will accept connections from both IPv4 and IPv6 networks.<br><br>
//
//   If you specify 0 for the port then it will disable IPv4 connections, if you set portv6 to 0 then it will disable IPv6 
//   connections. At least one must be greater than 0 or an error will be generated. If you do not specify portv6 at all then
//   it will be set to 0. It should be safe to use the same port for both IPv4 and IPv6, but this hasn't been widely tested.<br/><br/>
//
//   Returns an ID you can use to interact with this network.<br><br>
//
//   Does not work when exported to HTML5
// INPUTS
//   szNetworkName -- The name to use in identifying this network.
//   szMyName -- The name to use in identifying this client.
//   port -- The port that other clients should use to connect to this network when using IPv4, 0 to disable IPv4 connections.
//   portv6 -- The port that other clients should use to connect to this network when using IPv6, 0 to disable IPv6 connections.
// SOURCE
uint32_t agk::HostNetwork( const char *szNetworkName, const char *szMyName, int port, int portv6 )
//****
{
	if ( !szNetworkName ) return 0;
	if ( !szMyName ) return 0;

	if ( strlen( szMyName ) == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to host network, client name must be non-zero" );
#endif
		return 0;
	}

	if ( port <= 0 && portv6 <= 0 )
	{
		agk::Error( "Failed to host network, either port or portv6 must be greater than 0" );
	}

	// linux requires root access to bind to a port lower than 1025
	if ( port > 0 && (port < 1025 || port > 65535) )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to host network, port must be between 1025 and 65535" );
#endif
		return 0;
	}

	if ( portv6 > 0 && (portv6 < 1025 || portv6 > 65535) )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to host network, portv6 must be between 1025 and 65535" );
#endif
		return 0;
	}

	uint32_t ID = m_cNetworkList.GetFreeID();
	cNetwork *pNewNetwork = new cNetwork();
	m_cNetworkList.AddItem( pNewNetwork, ID );

	pNewNetwork->HostNetwork( szNetworkName, szMyName, port, portv6 );
	return ID;
}

//****f* Multiplayer/Setup/SetNetworkNoMoreClients
// FUNCTION
//   Stops anymore clients from connecting to this network, only applicable if you are hosting the network.
//   Also stops the broadcasting of the network to the LAN so it will no longer appear to those apps listening
//   to broadcasts.
// INPUTS
//   iNetID -- The ID of the network to modify.
// SOURCE
void agk::SetNetworkNoMoreClients( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to stop accepting network clients, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	pNetwork->NoMoreConnections();
}

//****f* Multiplayer/Setup/SetNetworkAllowClients
// FUNCTION
//   Restarts listening for new client connections, only applicable if you are hosting the network.
//   Also restarts the broadcasting of the network to the LAN so it will appear to those apps listening
//   to broadcasts. This only needs to be called if you have previously called <i>SetNetworkNoMoreClients</i>
//   and now want to allow connections again.
// INPUTS
//   iNetID -- The ID of the network to modify.
// SOURCE
void agk::SetNetworkAllowClients( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to restart accepting network clients, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	pNetwork->AllowConnections();
}

//****f* Multiplayer/Setup/JoinNetwork
// FUNCTION
//   Joins an AGK network hosted by another app. The network is specified by name, or by IP address and 
//   port number. For named networks the app will look for any AGK networks broadcast with that name 
//   and connect to it if found. Alternatively using an IP address and port number will attempt a direct
//   connection to the host. In the case of internet connections an IP and port is the only way 
//   to connect as broadcasts will not leave the local area network. IP addresses can be IPv4 or IPv6
//   depending on what IP addresses the host is using (it could have one or more of each).<br><br>
//
//   You may detect all the networks available for connecting to by setting up a broadcast listener and
//   listening for the broadcasts yourself, you could then display a list of discovered networks to the
//   user to let them decide which one to connect to.<br><br>
//
//   Warning, if the device listening for broadcasts is an iOS device then it may not be able to receive 
//   broadcast packets without permission from Apple. As of writing receiving is still allowed but sending
//   requires permission from Apple, this may change in future. See the following page for more details 
//   https://developer.apple.com/news/?id=0oi77447 <br/><br/>
//
//   This function does not connect immediately, it returns a network ID and continues to attempt to connect
//   in the background. You can detect when a connection is made by checking the <i>GetNetworkNumClients</i> is 
//   greater than 1, indicating that at least the local client and server client have been detected.
//   If <i>IsNetworkActive</i> returns 0 at any time then the connection to the server failed and the network 
//   should be closed, you may attempt to reconnect by opening a new network.<br><br>
//
//   Once connected the app becomes a client of the network, along with the host and any other clients
//   that have connected to it. All clients are treated equally and have a list of local variables that
//   they can read from and write to, all clients can also read any variables on other clients on a read 
//   only basis.<br><br>
//
//   You must identify your client with a client name that will be visible to other clients, the client name 
//   does not need to be unique.<br><br>
//
//   Returns a network ID to use when interacting with this network.<br><br>
//
//   Does not work when exported to HTML5
// INPUTS
//   szNetworkName -- The name of the network to connect to.
//   szMyName -- The name to use in identifying this client.
// SOURCE
uint32_t agk::JoinNetwork( const char *szNetworkName, const char *szMyName )
//****
{
	if ( !szNetworkName ) return 0;
	if ( !szMyName ) return 0;

	if ( strlen( szMyName ) == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to join network, client name must be non-zero" );
#endif
		return 0;
	}

	uint32_t ID = m_cNetworkList.GetFreeID();
	cNetwork *pNewNetwork = new cNetwork();
	m_cNetworkList.AddItem( pNewNetwork, ID );

	pNewNetwork->JoinNetwork( szNetworkName, szMyName );
	return ID;
}

//****f* Multiplayer/Setup/JoinNetwork
// FUNCTION
//   Joins an AGK network hosted by another app. The network is specified by name, or by IP address and 
//   port number. For named networks the app will look for any AGK networks broadcast with that name 
//   and connect to it if found. Alternatively using an IP address and port number will attempt a direct
//   connection to the host. In the case of internet connections an IP and port is the only way 
//   to connect as broadcasts will not leave the local area network. IP addresses can be IPv4 or IPv6
//   depending on what IP addresses the host is using (it could have one or more of each).<br><br>
//
//   You may detect all the networks available for connecting to by setting up a broadcast listener and
//   listening for the broadcasts yourself, you could then display a list of discovered networks to the
//   user to let them decide which one to connect to.<br><br>
//
//   Warning, if the device listening for broadcasts is an iOS device then it may not be able to receive 
//   broadcast packets without permission from Apple. As of writing receiving is still allowed but sending
//   requires permission from Apple, this may change in future. See the following page for more details 
//   https://developer.apple.com/news/?id=0oi77447 <br/><br/>
//
//   This function does not connect immediately, it returns a network ID and continues to attempt to connect
//   in the background. You can detect when a connection is made by checking the <i>GetNetworkNumClients</i> is 
//   greater than 1, indicating that at least the local client and server client have been detected.
//   If <i>IsNetworkActive</i> returns 0 at any time then the connection to the server failed and the network 
//   should be closed, you may attempt to reconnect by opening a new network.<br><br>
//
//   Once connected the app becomes a client of the network, along with the host and any other clients
//   that have connected to it. All clients are treated equally and have a list of local variables that
//   they can read from and write to, all clients can also read any variables on other clients on a read 
//   only basis.<br><br>
//
//   You must identify your client with a client name that will be visible to other clients, the client name 
//   does not need to be unique.<br><br>
//
//   Returns a network ID to use when interacting with this network.<br><br>
//
//   Does not work when exported to HTML5
// INPUTS
//   szIP -- The IP address of the host to connect to, can be IPv4 or IPv6
//   port -- The port to connect to.
//   szMyName -- The name to use in identifying this client.
// SOURCE
uint32_t agk::JoinNetwork( const char *szIP, uint32_t port, const char *szMyName )
//****
{
	if ( !szIP ) return 0;
	if ( !szMyName ) return 0;

	if ( strlen( szMyName ) == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to join network, client name must be non-zero" );
#endif
		return 0;
	}

	if ( port < 1 || port > 65535 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to join network, port must be between 1 and 65535" );
#endif
		return 0;
	}

	uint32_t ID = m_cNetworkList.GetFreeID();
	cNetwork *pNewNetwork = new cNetwork();
	m_cNetworkList.AddItem( pNewNetwork, ID );

	pNewNetwork->JoinNetwork( szIP, port, szMyName );
	return ID;
}

//****f* Multiplayer/Setup/IsNetworkActive
// FUNCTION
//   Checks that the network is active, in the case of joining a network this will return 0 if the connection failed
//   or for some reason the connection to the server broke. For a hoster this function will return 0 if it failed to 
//   listen on the specified port for clients, otherwise it will forever return 1 as it will not stop managing any 
//   connected clients, even if everyone disconnects.
// INPUTS
//   iNetID -- The ID of the network to check.
// SOURCE
uint32_t agk::IsNetworkActive( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to check network is active, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->IsActive() ? 1 : 0;
}

//****f* Multiplayer/Properties/GetDeviceIP
// FUNCTION
//   Returns the IPv4 address of the current device, this can be used by other devices to connect to this device.
//   To get the IPv6 address use <i>GetDeviceIPv6</i> instead.
// SOURCE
char* agk::GetDeviceIP()
//****
{
	uString sIP;
	if ( PlatformGetIP( sIP ) )
	{
		char *szIP = new char[ sIP.GetLength() + 1 ];
		strcpy( szIP, sIP.GetStr() );
		return szIP;
	}
	else 
	{
		char *str = new char[1];
		*str = 0;
		return str;
	}
}

//****f* Multiplayer/Properties/GetDeviceIPv6
// FUNCTION
//   Returns the IPv6 address of the current device, this can be used by other devices to connect to this device.
//   To get the IPv4 address use <i>GetDeviceIP</i> instead.
// SOURCE
char* agk::GetDeviceIPv6()
//****
{
	uString sIP;
	if ( PlatformGetIPv6( sIP ) )
	{
		char *szIP = new char[ sIP.GetLength() + 1 ];
		strcpy( szIP, sIP.GetStr() );
		return szIP;
	}
	else 
	{
		char *str = new char[1];
		*str = 0;
		return str;
	}
}
    
int agk::GetNetworkInterface()
{
    uString sIP;
    int iInterface = 0;
    PlatformGetIPv6( sIP, &iInterface );
    return iInterface;
}

//****f* Multiplayer/Setup/GetNetworkExists
// FUNCTION
//   Returns 1 if a network exists at the given ID, otherwise it returns 0.
// INPUTS
//   iNetID -- The ID of the network to check
// SOURCE
int agk::GetNetworkExists( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	return pNetwork ? 1 : 0;
}

//****f* Multiplayer/Setup/CloseNetwork
// FUNCTION
//   Disconnects from the specified network. The ID is freed and can no longer be used in other network commands.
// INPUTS
//   iNetID -- The ID of the network to disconnect from.
// SOURCE
void agk::CloseNetwork( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.RemoveItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to close network, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	//pNetwork->CloseNetwork();
	delete pNetwork;
}

//****f* Multiplayer/Setup/SetNetworkLatency
// FUNCTION
//   Sets how often the network sends updates and checks for variable updates from other clients in milliseconds.
//   The lower this value the more often this client will send and receive updates meaning shared variables are 
//   more likely to be up to date, but this will increase network traffic. In the case of connections across the 
//   internet this is particularly important as a large number of variables being updated frequently means that 
//   there may not be enough bandwidth. The default is 15 milliseconds which translates to roughly 67 updates 
//   every second to match closely a game frame rate of 60 fps. If you are updating a large number of variables 
//   over an internet connection it is recommended you increase this value towards 50 milliseconds resulting in 
//   20 updates per second or further.
// INPUTS
//   iNetID -- The ID of the network to disconnect from.
//   latency -- The latency to use in milliseconds
// SOURCE
void agk::SetNetworkLatency( uint32_t iNetID, uint32_t latency )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set network latency, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	pNetwork->SetLatency( latency );
}

//****f* Multiplayer/Properties/GetNetworkMyClientID
// FUNCTION
//   Each client is assigned a unique ID by the host when it connects. This function returns the ID that you have been
//   assigned. The host also assigns itself an ID which can be found using <i>GetNetworkServerID</i>.
// INPUTS
//   iNetID -- The ID of the network to check.
// SOURCE
uint32_t agk::GetNetworkMyClientID( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to network local client ID, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetMyID();
}

//****f* Multiplayer/Properties/GetNetworkNumClients
// FUNCTION
//   Returns the number of clients connected to the specified network. The host counts as a client as does 
//   the local client. Meaning that on a connected network there should be at least 2 clients.<br><br>
//   A host waiting for clients returns 1 if it is on its own. A client trying to connect returns 0 until
//   it connects and the host accepts the client, giving it a unique ID, it should then return 2.
// INPUTS
//   iNetID -- The ID of the network to check.
// SOURCE
uint32_t agk::GetNetworkNumClients( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get number of network clients, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetNumClients();
}

//****f* Multiplayer/Properties/GetNetworkFirstClient
// FUNCTION
//   Returns the Client ID of the first client in the client list. Use this function to start going through 
//   the list of clients and continue with <i>GetNetworkNextClient</i> until it returns 0. It is very important 
//   that once this command is called <i>GetNetworkNextClient</i> is called until it returns 0 as the background 
//   network code cannot continue until it knows you are finished with the client list.<Br><Br>
//
//   The local client will also be returned at some point, which can be detected by comparing the returned ID
//   with <i>GetNetworkMyClientID</i>. The host client will also be returned at some point which can be detected 
//   by comparing the returned ID with <i>GetNetworkServerID</i>.
// INPUTS
//   iNetID -- The ID of the network to check.
// SOURCE
uint32_t agk::GetNetworkFirstClient( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get first network client, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetFirstClient();
}

//****f* Multiplayer/Properties/GetNetworkNextClient
// FUNCTION
//   Returns the Client ID of the next client in the client list. Use this function to continue going through 
//   the list of clients started with <i>GetNetworkFirstClient</i>. It is very important that this command is 
//   called until it returns 0 as the background network code cannot continue until it knows you are finished 
//   with the client list.<br><br>
//
//   The local client will also be returned at some point, which can be detected by comparing the returned ID
//   with <i>GetNetworkMyClientID</i>. The host client will also be returned at some point which can be detected 
//   by comparing the returned ID with <i>GetNetworkServerID</i>.
// INPUTS
//   iNetID -- The ID of the network to check.
// SOURCE
uint32_t agk::GetNetworkNextClient( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get next network client, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetNextClient();
}

//****f* Multiplayer/Properties/KickNetworkClient
// FUNCTION
//   Kicks a client from the network. This does not happen immediately and the client may remain for a few frames
//   before it is finally kicked. The client will disconnect in the normal way, you must check <i>GetNetworkClientDisconnected</i>
//   to detect when the client has been kicked, and then call <i>DeleteNetworkClient</i> to finally get rid of it.
// INPUTS
//   iNetID -- The ID of the network.
//   client -- the ID of the client to kick.
// SOURCE
void agk::KickNetworkClient( uint32_t iNetID, uint32_t client )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to kick network client, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	pNetwork->KickClient( client );
}

//****f* Multiplayer/Properties/GetNetworkClientDisconnected
// FUNCTION
//   Checks whether the specified client has disconnected. Disconnected clients are not automatically removed 
//   from the client list, allowing you to handle their clean up properly. Once you have dealt with this client 
//   you must remove it from the client list by calling <i>DeleteNetworkClient</i>. The client may persist for a 
//   little while until the background network code gets around to actually deleting it so be prepared for this 
//   client to hang around for a few frames declaring that it is disconnected and make sure you only clean it 
//   up once. You can detect this by setting one of the <i>SetNetworkClientUserData</i> values to notify yourself that
//   it has been dealt with.
// INPUTS
//   iNetID -- The ID of the network to check.
//   client -- the ID of the client to check.
// SOURCE
uint32_t agk::GetNetworkClientDisconnected( uint32_t iNetID, uint32_t client )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to check disconnected network client, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetClientDisconnected( client );
}

//****f* Multiplayer/Properties/DeleteNetworkClient
// FUNCTION
//   Deletes a disconnected client from the client list. If this function is called on a client that is not
//   disconnected it will produce an error and not affect the client. Does not delete the client immediately,
//   the background code may take a few frames to get around to deleting it. Calling this command multiple 
//   times on a disconnected client should not cause a problem.
// INPUTS
//   iNetID -- The ID of the network to check.
//   client -- the ID of the client to delete.
// SOURCE
void agk::DeleteNetworkClient( uint32_t iNetID, uint32_t client )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to delete network client, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	pNetwork->DeleteDisconnectedClient( client );
}

//****f* Multiplayer/Properties/GetNetworkClientName
// FUNCTION
//   Returns the name the client used to identify itself when it connected to the host.
// INPUTS
//   iNetID -- The ID of the network to check.
//   client -- the ID of the client to check.
// SOURCE
char* agk::GetNetworkClientName( uint32_t iNetID, uint32_t client )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get network client name, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	uString sName;
	if ( pNetwork->GetClientName( client, sName ) )
	{
		char *szName = new char[ sName.GetLength() + 1 ];
		strcpy( szName, sName.GetStr() );
		return szName;
	}
	else 
	{
		char *str = new char[1];
		*str = '\0';
		return str;
	}
}

//****f* Multiplayer/Properties/GetNetworkClientIP
// FUNCTION
//   Returns the IP address being used by the specified client. This command only works on the server as clients do not connect directly to each other
// INPUTS
//   iNetID -- The ID of the network to check.
//   client -- the ID of the client to check.
// SOURCE
char* agk::GetNetworkClientIP( uint32_t iNetID, uint32_t client )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get network client IP, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	uString sIP;
	if ( pNetwork->GetClientIP( client, sIP ) )
	{
		char *szIP = new char[ sIP.GetLength() + 1 ];
		strcpy( szIP, sIP.GetStr() );
		return szIP;
	}
	else 
	{
		char *str = new char[1];
		*str = 0;
		return str;
	}
}

//****f* Multiplayer/Properties/GetNetworkClientPing
// FUNCTION
//   Returns the ping between the given client and the host. To get the total transit time of data from one client
//   to another you must add the two ping times for both clients together as all data goes via the host. If you use 
//   the host's client ID it will return 0 as the host has no ping to itself. The value returned is in seconds as a 
//   floating point value.
// INPUTS
//   iNetID -- The ID of the network to check.
//   client -- The ID of the client to check.
// SOURCE
float agk::GetNetworkClientPing( uint32_t iNetID, uint32_t client )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get network client ping, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetClientPing( client );
}

//****f* Multiplayer/Properties/GetNetworkServerID
// FUNCTION
//   Returns the client ID of the host's client. This is useful if you use the server to handle game setup variables
//   such as board size, game length, etc, as only the host client should have a copy of these such variables.
// INPUTS
//   iNetID -- The ID of the network to check.
// SOURCE
uint32_t agk::GetNetworkServerID( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get network server ID, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetServerID();
}

//****f* Multiplayer/Properties/GetNetworkServerIP
// FUNCTION
//   Returns the IP address being used by the server. This command only works on clients as the server can get its own 
//   IP using <i>GetDeviceIP</i> and <i>GetDeviceIPv6</i>.
// INPUTS
//   iNetID -- The ID of the network to check.
// SOURCE
char* agk::GetNetworkServerIP( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get network server IP, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	uString sIP;
	if ( pNetwork->GetServerIP( sIP ) )
	{
		char *szIP = new char[ sIP.GetLength() + 1 ];
		strcpy( szIP, sIP.GetStr() );
		return szIP;
	}
	else 
	{
		char *str = new char[1];
		*str = 0;
		return str;
	}
}

//****f* Multiplayer/Properties/SetNetworkLocalInteger
// FUNCTION
//   Sets a local integer variable for this client by name. Other clients can then read this variable by
//   using the same name when requesting its value. An integer variable may not have the same name as a
//   float variable. If the variable with that name does not exist it is created. 
// INPUTS
//   iNetID -- The ID of the network to check.
//   name -- The name of this variable.
//   i -- The value to set this variable to.
// SOURCE
void agk::SetNetworkLocalInteger( uint32_t iNetID, const char *name, int i )
//****
{
	SetNetworkLocalInteger( iNetID, name, i, 0 );
}

//****f* Multiplayer/Properties/SetNetworkLocalInteger
// FUNCTION
//   Sets a local integer variable for this client by name. Other clients can then read this variable by
//   using the same name when requesting its value. The mode parameter specifies how this variable should 
//   behave, with a value of 1 meaning that this variable will reset to 0 when read. For example if you 
//   wanted to send a click notification you could set a value of 1 to signify a click with a mode value 
//   of 1. When each client reads the variable, each will see the value 1, but if they try to read it again 
//   they will get the value 0. Each client only resets its own copy of the variable. A mode value of 0 
//   means it is a normal variable that will not change when read.<br><br>
//
//   If the variable with that name does not exist it is created. Once a variable is created in normal or 
//   resetting mode it cannot be changed and the mode parameter is ignored.
// INPUTS
//   iNetID -- The ID of the network to check.
//   name -- The name of this variable.
//   i -- The value to set this variable to.
//   mode -- The type of this variable, 0=normal, 1=resetting
// SOURCE
void agk::SetNetworkLocalInteger( uint32_t iNetID, const char *name, int i, int mode )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set network local integer, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	pNetwork->SetLocalVariableI( name, i, mode );
}

//****f* Multiplayer/Properties/SetNetworkLocalFloat
// FUNCTION
//   Sets a local float variable for this client by name. Other clients can then read this variable by
//   using the same name when requesting its value. A float variable may not have the same name as an 
//   integer variable. If the variable with that name does not exist it is created. 
// INPUTS
//   iNetID -- The ID of the network to check.
//   name -- The name of this variable.
//   f -- The value to set this variable to.
// SOURCE
void agk::SetNetworkLocalFloat( uint32_t iNetID, const char *name, float f )
//****
{
	SetNetworkLocalFloat( iNetID, name, f, 0 );
}

//****f* Multiplayer/Properties/SetNetworkLocalFloat
// FUNCTION
//   Sets a local float variable for this client by name. Other clients can then read this variable by
//   using the same name when requesting its value. The mode parameter specifies how this variable should 
//   behave, with a value of 1 meaning that this variable will reset to 0 when read. For example if you 
//   wanted to send a click notification you could set a value of 1 to signify a click with a mode value 
//   of 1. When each client reads the variable, each will see the value 1, but if they try to read it again 
//   they will get the value 0. Each client only resets its own copy of the variable. A mode value of 0 
//   means it is a normal variable that will not change when read.<br><br>
//
//   If the variable with that name does not exist it is created. Once a variable is created in normal or 
//   resetting mode it cannot be changed and the mode parameter is ignored.
// INPUTS
//   iNetID -- The ID of the network to check.
//   name -- The name of this variable.
//   f -- The value to set this variable to.
//   mode -- The type of this variable, 0=normal, 1=resetting
// SOURCE
void agk::SetNetworkLocalFloat( uint32_t iNetID, const char *name, float f, int mode )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set network local float, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	pNetwork->SetLocalVariableF( name, f, mode );
}

//****f* Multiplayer/Properties/GetNetworkClientInteger
// FUNCTION
//   Gets a copy of a remote client's integer variable by name. Can also be used on the client's own variables
//   if the clientID equals <i>GetNetworkMyClientID</i>. If the variable was set as a resetting variable it will
//   return to 0 once read, this does not affect other clients ability to read the original value. They will
//   each reset their own copy.<br><br>
//
//   If the specified client has not set a variable of the given name the value 0 is returned.
// INPUTS
//   iNetID -- The ID of the network to check.
//   client -- The ID of the client to check.
//   name -- The name of the variable to return.
// SOURCE
int agk::GetNetworkClientInteger( uint32_t iNetID, uint32_t client, const char *name )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get network client integer, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetClientVariableI( client, name );
}

//****f* Multiplayer/Properties/GetNetworkClientFloat
// FUNCTION
//   Gets a copy of a remote client's float variable by name. Can also be used on the client's own variables
//   if the clientID equals <i>GetNetworkMyClientID</i>. If the variable was set as a resetting variable it will
//   return to 0 once read, this does not affect other clients ability to read the original value. They will
//   each reset their own copy.<br><br>
//
//   If the specified client has not set a variable of the given name the value 0 is returned.
// INPUTS
//   iNetID -- The ID of the network to check.
//   client -- The ID of the client to check.
//   name -- The name of the variable to return.
// SOURCE
float agk::GetNetworkClientFloat( uint32_t iNetID, uint32_t client, const char *name )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get network client float, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetClientVariableF( client, name );
}

//****f* Multiplayer/Messages/CreateNetworkMessage
// FUNCTION
//   Creates a network message that can be sent to another network device. It returns an ID that can be used to
//   interact with the message. Messages created in this way can only be added to, not read from. Once passed to 
//   a network the message ID is destroyed and handled by the background network code.
// SOURCE
uint32_t agk::CreateNetworkMessage( )
//****
{
	uint32_t ID = m_cNetMessageList.GetFreeID();
	cNetworkMessage *pNewMsg = new cNetworkMessage();
	m_cNetMessageList.AddItem( pNewMsg, ID );
	return ID;
}

//****f* Multiplayer/Messages/CopyNetworkMessage
// FUNCTION
//   Creates a network message that is a copy of an existing message. It returns an ID that can be used to
//   interact with the message. Messages created in this way can read from the beginning or added to, and 
//   the source messsage can be either a message you have created, or one you have received. The new message 
//   becomes completely independent of the source message and can be sent using <i>SendNetworkMessage</i> 
//   without affecting the original.
// INPUTS
//  iFromMsgID -- The ID of the message to copy
// SOURCE
uint32_t agk::CopyNetworkMessage( uint32_t iFromMsgID )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iFromMsgID );
	if ( !pMsg )
	{
		uString err;
		err.Format( "Failed to copy network message, Message ID %d does not exist", iFromMsgID );
		agk::Error( err );
		return 0;
	}

	uint32_t ID = m_cNetMessageList.GetFreeID();
	cNetworkMessage *pNewMsg = new cNetworkMessage();
	pNewMsg->CopyMessage( pMsg );
	m_cNetMessageList.AddItem( pNewMsg, ID );
	return ID;
}

//****f* Multiplayer/Messages/AddNetworkMessageByte
// FUNCTION
//   Adds an unsigned byte to a previously created network message. This can be called on messages created by 
//   <i>CreateNetworkMessage</i> or on messages received from the network.
// INPUTS
//   iMsgID -- The ID of the message to modify.
//   value -- The value to add to the message.
// SOURCE
void agk::AddNetworkMessageByte( uint32_t iMsgID, uint32_t value )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to add message byte, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return;
	}

	pMsg->AddByte( value );
}

//****f* Multiplayer/Messages/AddNetworkMessageInteger
// FUNCTION
//   Adds an integer to a previously created network message. This can be called on messages created by 
//   <i>CreateNetworkMessage</i> or on messages received from the network.
// INPUTS
//   iMsgID -- The ID of the message to modify.
//   value -- The value to add to the message.
// SOURCE
void agk::AddNetworkMessageInteger( uint32_t iMsgID, int value )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to add message integer, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return;
	}

	pMsg->AddInt( value );
}

//****f* Multiplayer/Messages/AddNetworkMessageFloat
// FUNCTION
//   Adds a float to a previously created network message. This can be called on messages created by 
//   <i>CreateNetworkMessage</i> or on messages received from the network.
// INPUTS
//   iMsgID -- The ID of the message to modify.
//   value -- The value to add to the message.
// SOURCE
void agk::AddNetworkMessageFloat( uint32_t iMsgID, float value )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to add message float, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return;
	}

	pMsg->AddFloat( value );
}

//****f* Multiplayer/Messages/AddNetworkMessageString
// FUNCTION
//   Adds a string to a previously created network message. This can be called on messages created by 
//   <i>CreateNetworkMessage</i> or on messages received from the network.
// INPUTS
//   iMsgID -- The ID of the message to modify.
//   value -- The string to add to the message.
// SOURCE
void agk::AddNetworkMessageString( uint32_t iMsgID, const char *value )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to add message string, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return;
	}

	if ( !value ) pMsg->AddString( "" );
	else pMsg->AddString( value );
}

//****f* Multiplayer/Messages/GetNetworkMessageFromIP
// FUNCTION
//   Returns the IP that sent this message. Only applicable to messages received from UDP and broadcast listeners,
//   network messages will return an empty string for this function. It will also return an empty string for 
//   messages created using <i>CreateNetworkMessage</i>. This could be an IPv4 or IPv6 address.
// INPUTS
//   iMsgID -- The ID of the message to read.
// SOURCE
char* agk::GetNetworkMessageFromIP( uint32_t iMsgID )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get message IP, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	const char *IP = pMsg->sFromIP.GetStr();
	if ( !IP ) 
	{
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	char *szString = new char[ strlen(IP) + 1 ];
	strcpy( szString, IP );
	return szString;
}

//****f* Multiplayer/Messages/GetNetworkMessageFromPort
// FUNCTION
//   Returns the source port that was used by this message. Only applicable to messages received from UDP 
//   and broadcast listeners, network messages will return 0 for this function. It will also return 0 for 
//   messages created using <i>CreateNetworkMessage</i>. This will be in the range 0 to 65535.
// INPUTS
//   iMsgID -- The ID of the message to read.
// SOURCE
int agk::GetNetworkMessageFromPort( uint32_t iMsgID )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get message port, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return 0;
	}

	return pMsg->iFromPort;
}

//****f* Multiplayer/Messages/GetNetworkMessageFromClient
// FUNCTION
//   Returns the client ID that sent this message. Only applicable to messages received from networks,
//   broadcast listener and UDP messages will return 0 for this function. It will also return 0 for messages 
//   created using <i>CreateNetworkMessage</i>.
// INPUTS
//   iMsgID -- The ID of the message to read.
// SOURCE
uint32_t agk::GetNetworkMessageFromClient( uint32_t iMsgID )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get message IP, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return 0;
	}

	return pMsg->GetSenderID();
}

//****f* Multiplayer/Messages/GetNetworkMessageByte
// FUNCTION
//   Gets a single unsigned byte from the message and advances the message pointer to the next message item. 
//   Messages should be created and read according to known formats, e.g. string, int, string as there is no
//   immediate way for the receiver to know the format of a message. You could use an initial integer to specify a 
//   message type ID which you can use to identify the message format.
// INPUTS
//   iMsgID -- The ID of the message to read.
// SOURCE
uint32_t agk::GetNetworkMessageByte( uint32_t iMsgID )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get message byte, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return 0;
	}

	return pMsg->GetByte();
}

//****f* Multiplayer/Messages/GetNetworkMessageInteger
// FUNCTION
//   Gets a single integer from the message and advances the message pointer to the next message item. 
//   Messages should be created and read according to known formats, e.g. string, int, string as there is no
//   immediate way for the receiver to know the format of a message. You could use an initial integer to specify a 
//   message type ID which you can use to identify the message format.
// INPUTS
//   iMsgID -- The ID of the message to read.
// SOURCE
int agk::GetNetworkMessageInteger( uint32_t iMsgID )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get message integer, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return 0;
	}

	return pMsg->GetInt();
}

//****f* Multiplayer/Messages/GetNetworkMessageFloat
// FUNCTION
//   Gets a single float from the message and advances the message pointer to the next message item. 
//   Messages should be created and read according to known formats, e.g. string, int, string as there is no
//   immediate way for the receiver to know the format of a message. You could use an initial integer to specify a 
//   message type ID which you can use to identify the message format.
// INPUTS
//   iMsgID -- The ID of the message to read.
// SOURCE
float agk::GetNetworkMessageFloat( uint32_t iMsgID )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get message float, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return 0;
	}

	return pMsg->GetFloat();
}

//****f* Multiplayer/Messages/GetNetworkMessageString
// FUNCTION
//   Gets a single string from the message and advances the message pointer to the next message item. 
//   Messages should be created and read according to known formats, e.g. string, int, string as there is no
//   immediate way for the receiver to know the format of a message. You could use an initial integer to specify a 
//   message type ID which you can use to identify the message format.
// INPUTS
//   iMsgID -- The ID of the message to read.
// SOURCE
char* agk::GetNetworkMessageString( uint32_t iMsgID )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get message string, Message ID %d does not exist", iMsgID );
		agk::Error( err );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	uString sString;
	if ( pMsg->GetString( sString ) )
	{
		char *szString = new char[ sString.GetLength() + 1 ];
		strcpy( szString, sString.GetStr() );
		return szString;
	}
	else 
	{
		char *str = new char[1];
		*str = '\0';
		return str;
	}
}

//****f* Multiplayer/Messages/DeleteNetworkMessage
// FUNCTION
//   Deletes a network message, this should be called on messages received from network devices and messages that
//   have not been sent to a network device (if code decides to back out of sending a message). Messages that have 
//   been created and sent will be handled and deleted by the network code and should not be deleted using this command.
// INPUTS
//   iMsgID -- The ID of the message to read.
// SOURCE
void agk::DeleteNetworkMessage( uint32_t iMsgID )
//****
{
	cNetworkMessage *pMsg = m_cNetMessageList.RemoveItem( iMsgID );
	if ( pMsg ) delete pMsg;
}

//****f* Multiplayer/Messages/SendNetworkMessage
// FUNCTION
//   Sends a created network message to a given client on a given network. Use a client ID of 0 to send to
//   all connected clients (except the sender), otherwise if the client ID does not exist an error will be 
//   generated.
//
//   This function will delete the message ID given.
// INPUTS
//   iNetID -- The ID of the network to send the message over.
//   toClient -- The ID of the client to send the message to, 0 to send to all.
//   iMsgID -- The ID of the message to send.
// SOURCE
void agk::SendNetworkMessage( uint32_t iNetID, uint32_t toClient, uint32_t iMsgID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to send network message, network %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( iMsgID );
	if ( !pMsg )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to send network message, message %d does not exist", iMsgID );
		agk::Error( err );
#endif
		return;
	}

	pNetwork->SendMessage( toClient, pMsg );
	m_cNetMessageList.RemoveItem( iMsgID );
}

//****f* Multiplayer/Messages/GetNetworkMessage
// FUNCTION
//   Check the network for any messages sent to this client. If none are found it returns 0. If 
//   a message is found it returns a message ID you can use to read the message. You must delete
//   the message using <i>DeleteNetworkMessage</i> when you are done reading it. You should keep calling
//   <i>GetNetworkMessage</i> until it returns 0 to make sure you have received all the messages.
//   You can use the message reading commands to find out which client ID sent the message.
// INPUTS
//   iNetID -- The ID of the network to check for messages.
// SOURCE
uint32_t agk::GetNetworkMessage( uint32_t iNetID )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get network message, network %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	cNetworkMessage *pMsg = pNetwork->GetMessage();
	if ( !pMsg ) return 0;

	uint32_t iMsgID = m_cNetMessageList.GetFreeID();
	m_cNetMessageList.AddItem( pMsg, iMsgID );
	return iMsgID;
}

//****f* Multiplayer/Properties/SetNetworkClientUserData
// FUNCTION
//   Assigns a local value to one of 5 data slots in the client that can be used to keep track of items that 
//   belong to this client. For example if you create a sprite to represent the client in your game you could 
//   assign the sprite ID to one of these data slots so that when you go through the client list you can detect
//   which sprite you used for each client. This also allows you to clean up the sprite if the client is found 
//   to have disconnected. This value is entirely local and does not get transferred across the network.
// INPUTS
//   iNetID -- The ID of the network to store the value.
//   client -- The ID of the client on the network to store the value.
//   index -- The index (0 to 4) of the data slot to set.
//   value -- The integer value to set.
// SOURCE
void agk::SetNetworkClientUserData( uint32_t iNetID, uint32_t client, uint32_t index, int value )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set network client user data, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return;
	}

	pNetwork->SetClientUserData( client, index, value );
}

//****f* Multiplayer/Properties/GetNetworkClientUserData
// FUNCTION
//   Reads one of the local data slots assigned to the client set using <i>SetNetworkClientUserData</i>.
// INPUTS
//   iNetID -- The ID of the network to get the value from.
//   client -- The ID of the client on the network to get the value from.
//   index -- The index (0-4) of the data slot to read.
// SOURCE
int agk::GetNetworkClientUserData( uint32_t iNetID, uint32_t client, uint32_t index )
//****
{
	cNetwork *pNetwork = m_cNetworkList.GetItem( iNetID );
	if ( !pNetwork )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get network client user data, Network ID %d does not exist", iNetID );
		agk::Error( err );
#endif
		return 0;
	}

	return pNetwork->GetClientUserData( client, index );
}

//****f* Multiplayer/UDP/CreateUDPListener
// FUNCTION
//   Creates a UDP listener that will recieve UDP packets on the specified IP and port. The port value must
//   be in the range 1 to 65535, although values below 1024 are likely to be protected by the operating system.
//   If the port is already occupied then this command will fail and return 0. The IP address may be an IPv4 or 
//   IPv6 address, and can be used to bind to a single incomming network connection when a device has more than 
//   one IP. To bind to any IP address use the IP address "anyip4" or "anyip6". A single UDP listener can listen
//   on either an IPv4 or an IPv6 address, but not both at the same time. To listen on both you should create
//   two listeners, one for IPv4 and one for IPv6, in this case they may both use the same port. This command
//   will return the ID of the listener that you can use to reference it in future commands.
// INPUTS
//   ip -- The local IP address to bind to.
//   port -- The local port to bind to.
// SOURCE
uint32_t agk::CreateUDPListener( const char* ip, int port )
//****
{
	if ( port < 1 || port > 65535 )
	{
		agk::Error( "Failed to create UDP listener, port must be between 1 and 65535" );
		return 0;
	}

	uint32_t ID = m_cUDPListenerList.GetFreeID();
	UDPManager *pListener = new UDPManager( ip, port );
	if ( !pListener->IsValid() )
	{
		agk::Error( "Failed to create UDP listener" );
		return 0;
	}
	m_cUDPListenerList.AddItem( pListener, ID );
	return ID;
}

//****f* Multiplayer/UDP/CreateUDPListener
// FUNCTION
//   Creates a UDP listener that will recieve UDP packets on the specified IP and port. The port value must
//   be in the range 1 to 65535, although values below 1024 are likely to be protected by the operating system.
//   If the port is already occupied then this command will fail and return 0. The IP address may be an IPv4 or 
//   IPv6 address, and can be used to bind to a single incomming network connection when a device has more than 
//   one IP. To bind to any IP address use the IP address "anyip4" or "anyip6". A single UDP listener can listen
//   on either an IPv4 or an IPv6 address, but not both at the same time. To listen on both you should create
//   two listeners, one for IPv4 and one for IPv6, in this case they may both use the same port. This command
//   will return the ID of the listener that you can use to reference it in future commands.
// INPUTS
//   listenerID -- The ID to use to reference this listener in future.
//   ip -- The local IP address to bind to.
//   port -- The local port to bind to.
// SOURCE
int agk::CreateUDPListener( uint32_t listenerID, const char* ip, int port )
//****
{
	if ( port < 1 || port > 65535 )
	{
		agk::Error( "Failed to create UDP listener, port must be between 1 and 65535" );
		return 0;
	}

	UDPManager *pListener = m_cUDPListenerList.GetItem( listenerID );
	if ( pListener )
	{
		uString err; err.Format( "Failed to create UDP listener, a listener with ID %d already exists", listenerID );
		agk::Error( err );
		return 0;
	}

	pListener = new UDPManager( ip, port );
	if ( !pListener->IsValid() )
	{
		agk::Error( "Failed to create UDP listener" );
		return 0;
	}
	m_cUDPListenerList.AddItem( pListener, listenerID );
	return listenerID;
}

//****f* Multiplayer/UDP/SendUDPNetworkMessage
// FUNCTION
//   Sends a network message created with <i>CreateNetworkMessage</i> to the specified remote IP and port.
//   You must specify a UDP listener to use as the source IP and port. This function will delete the 
//   specified message ID.<br/><br/>
//
//   Warning, if the IP address is a broadcast or multicast address, e.g. 255.255.255.255 then this will 
//   fail to send on iOS devices. To send broadcast or multicast packets requires permission from Apple,
//   use the following page to request it https://developer.apple.com/contact/request/networking-multicast
// INPUTS
//   listenerID -- The ID of the listener to use as the source ip and port
//   messageID -- The ID of the network message to send
//   toIP -- The IP address to send the message to
//   toPort -- The port to send the message to
// SOURCE
void agk::SendUDPNetworkMessage( uint32_t listenerID, uint32_t messageID, const char* toIP, int toPort )
//****
{
	UDPManager *pListener = m_cUDPListenerList.GetItem( listenerID );
	if ( !pListener )
	{
		uString err; err.Format( "Failed to send UDP message, listener %d does not exist", listenerID );
		agk::Error( err );
		return;
	}

	cNetworkMessage *pMsg = m_cNetMessageList.GetItem( messageID );
	if ( !pMsg )
	{
		uString err; err.Format( "Failed to send UDP message, message %d does not exist", messageID );
		agk::Error( err );
		return;
	}
	
	pListener->SendPacket( toIP, toPort, pMsg );
	m_cNetMessageList.RemoveItem( messageID );
	delete pMsg;
}

//****f* Multiplayer/UDP/GetUDPNetworkMessage
// FUNCTION
//   Checks a UDP listener for any broadcasts. Returns 0 if nothing has been received. Returns
//   a message ID if something has been received, you can access the contents of this message using 
//   network message commands. The message must be deleted when you have finished reading from it.
// INPUTS
//   listenerID -- The ID of the listener to check for messages
// SOURCE
uint32_t agk::GetUDPNetworkMessage( uint32_t listenerID )
//****
{
	UDPManager *pListener = m_cUDPListenerList.GetItem( listenerID );
	if ( !pListener )
	{
		uString err; err.Format( "Failed to get UDP message, Listener ID %d does not exist", listenerID );
		agk::Error( err );
		return 0;
	}

	if ( !pListener->PacketReady() ) return 0;
	
	int fromPort;
	char fromIP[ 100 ];
	cNetworkMessage *pMsg = new cNetworkMessage();
	if ( !pListener->RecvPacket( fromIP, &fromPort, pMsg ) ) 
	{
		delete pMsg;
		return 0;
	}
	pMsg->sFromIP.SetStr( fromIP );
	pMsg->iFromPort = fromPort;
	
	uint32_t iMsgID = m_cNetMessageList.GetFreeID();
	m_cNetMessageList.AddItem( pMsg, iMsgID );
	return iMsgID;
}

//****f* Multiplayer/UDP/DeleteUDPListener
// FUNCTION
//   Deletes the specified UDP listenere and frees up the port it was using.
// INPUTS
//   listenerID -- The ID of the listener to delete
// SOURCE
void agk::DeleteUDPListener( uint32_t listenerID )
//****
{
	UDPManager *pListener = m_cUDPListenerList.RemoveItem( listenerID );
	if ( pListener ) delete pListener;
}


// HTTP commands
//****f* HTTP/General/CreateHTTPConnection
// FUNCTION
//   Creates an HTTP connection ready for use later. Returns the ID used to reference it later.
// SOURCE
uint32_t agk::CreateHTTPConnection()
//****
{
	uint32_t ID = m_cHTTPList.GetFreeID();
	cHTTPConnection *pHTTP = new cHTTPConnection();
	m_cHTTPList.AddItem( pHTTP, ID );
	return ID;
}

//****f* HTTP/General/DeleteHTTPConnection
// FUNCTION
//   Deletes a previously created HTTP connection.
// INPUTS
//   iHTTP -- The ID of the connection to delete.
// SOURCE
void agk::DeleteHTTPConnection( uint32_t iHTTP )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.RemoveItem( iHTTP );
	if ( pHttp ) delete pHttp;
}

//****f* HTTP/General/SetHTTPHost
// FUNCTION
//   Sets the domain of the host you want to connect to, for example to access www.thegamecreators.com/index.php you 
//   would use a host value of www.thegamecreators.com, do not include the http: that usually goes before it.
//   Note that trying to use a specific port with www.thegamecreators.com:8080 may be ignored on some platforms and
//   port 80 will be used in these cases.<br><br>
//
//   When exporting to HTML5 note that web browsers limit which servers you can connect to. By default you are 
//   limited to files hosted by the same server as your app. However if the server sends an Access-Control-Allow-Origin
//   header in its response that allows your app's server, then the browser will let you connect to it.
// INPUTS
//   iHTTP -- The ID of the connection to set.
//   szHost -- The domain to connect to.
//   iSecure -- Set to 1 to use an HTTPS secure connection, 0 to use a standard HTTP connection.
// SOURCE
uint32_t agk::SetHTTPHost( uint32_t iHTTP, const char *szHost, int iSecure )
//****
{
	return SetHTTPHost( iHTTP, szHost, iSecure, 0, 0 ) ? 1 : 0;
}

//****f* HTTP/General/SetHTTPHost
// FUNCTION
//   Sets the domain of the host you want to connect to, for example to access www.thegamecreators.com/index.php you 
//   would use a host value of www.thegamecreators.com, do not include the http: that usually goes before it.
//   Also allows you set an username and password if the server is using HTTP authentication.<br><br>
//
//   When exporting to HTML5 note that web browsers limit which servers you can connect to. By default you are 
//   limited to files hosted by the same server as your app. However if the server sends an Access-Control-Allow-Origin
//   header in its response that allows your app's server, then the browser will let you connect to it.
// INPUTS
//   iHTTP -- The ID of the connection to set.
//   szHost -- The domain to connect to.
//   iSecure -- Set to one to use an HTTPS secure connection, 0 to use a standard HTTP connection.
//   szUser -- The username to send to the server.
//   szPass -- The password to send to the server.
// SOURCE
uint32_t agk::SetHTTPHost( uint32_t iHTTP, const char *szHost, int iSecure, const char *szUser, const char *szPass )
//****
{
	if ( !szHost ) return 0;

	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set HTTP host, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return 0;
	}

	if ( strlen(szHost) == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Failed to set HTTP host, host must be non-zero" );
#endif
		return 0;
	}

	return pHttp->SetHost( szHost, iSecure, szUser, szPass ) ? 1 : 0;
}

//****f* HTTP/General/CloseHTTPConnection
// FUNCTION
//   Closes the connection to the server, further connections can be created if you call <i>SetHTTPHost</i> again.
// INPUTS
//   iHTTP -- The ID of the connection to close.
// SOURCE
void agk::CloseHTTPConnection( uint32_t iHTTP )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to close HTTP connection, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return;
	}

	pHttp->Close();
}

//****f* HTTP/General/SetHTTPTimeout
// FUNCTION
//   Sets the time in milliseconds that AGK will wait for a connection to be made before giving up.
// INPUTS
//   iHTTP -- The ID of the connection to set.
//   milliseconds -- The time in milliseconds to wait.
// SOURCE
void agk::SetHTTPTimeout( uint32_t iHTTP, int milliseconds )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set HTTP connection timeout, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return;
	}

	pHttp->SetTimeout( milliseconds );
}

//****f* HTTP/General/SetHTTPVerifyCertificate
// FUNCTION
//   Sets whether the device should verify the SSL certificate when making a secure connection. If the 
//   server you are connecting to is using a self signed certificate you will need to set this to 0 or 
//   the connection will fail.
//   In all other cases you must leave this at 1 to ensure a secure connection to the server.
//   Turning off verification will turn off protection against man in the middle attacks on SSL connections.
// INPUTS
//   iHTTP -- The ID of the connection to set.
//   mode -- 1 to verify, 0 to not verify.
// SOURCE
void agk::SetHTTPVerifyCertificate( uint32_t iHTTP, int mode )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set HTTP connection verification mode, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return;
	}

	pHttp->SetVerifyCertificate( mode );
}

//****f* HTTP/General/AddHTTPHeader
// FUNCTION
//   Adds the specified header to all future requests. If the header already exists then its value will be overwritten
//   by the new value. If the header is a standard header that is normally present then its value will be overwritten
//   by the value you give. If the header is a standard header that is normally present and the value you give is the 
//   empty string then the standard header will be removed. Do not add the colon to either field, it will be added 
//   automatically between them. Note that this command does not work in the HTML5 version.
// INPUTS
//   iHTTP -- The ID of the connection to change.
//   headerName -- The name of the header to set, e.g. "Content-Type"
//   headerValue -- The new value for the header
// SOURCE
void agk::AddHTTPHeader( uint32_t iHTTP, const char* headerName, const char* headerValue )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set HTTP header, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return;
	}

	pHttp->AddHeader( headerName, headerValue );
}

//****f* HTTP/General/RemoveHTTPHeader
// FUNCTION
//   Removes a header that you have previously added, if you have not used <i>AddHTTPHeader</i> to add
//   a header with the given name then this command does nothing. If the header name is a standard header
//   that is normally included then this command does not remove it, use <i>AddHTTPHeader</i> with an 
//   empty string instead to overwrite it. If the header name is a standard header that you have overwritten
//   then this command returns it to its normal value. Note that this command does not work in the HTML5 version.
// INPUTS
//   iHTTP -- The ID of the connection to change.
//   headerName -- The name of the header to remove
// SOURCE
void agk::RemoveHTTPHeader( uint32_t iHTTP, const char* headerName )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to set HTTP header, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return;
	}

	pHttp->RemoveHeader( headerName );
}

//****f* HTTP/General/SendHTTPRequest
// FUNCTION
//   Send a request to the server specified in SetHTTPHost(), for example if requesting http://www.thegamecreators.com/index.php szServerFile 
//   should be "index.php".<br><br>
//   This command waits for the server to respond and returns the server reply. If using tier 2 you must delete this reply when finished with it.<br><br>
//
//   Does not work when exported to HTML5
// INPUTS
//   iHTTP -- The ID of the connection to use.
//   szServerFile -- The file to request from the server, include everything after the domain part of the URL.
// SOURCE
char* agk::SendHTTPRequest( uint32_t iHTTP, const char *szServerFile )
//****
{
	return SendHTTPRequest( iHTTP, szServerFile, 0 );
}

//****f* HTTP/General/SendHTTPRequest
// FUNCTION
//   Send a request to the server specified in <i>SetHTTPHost</i>, for example if requesting http://www.thegamecreators.com/index.php szServerFile 
//   should be "index.php". Also allows you to send POST data to the server which can include variables or file data, e.g. "myvar=5&var2=test".
//   This command waits for the server to respond and returns the server reply. If using tier 2 you must delete this reply when finished with it.<br><br>
//
//   Does not work when exported to HTML5
// INPUTS
//   iHTTP -- The ID of the connection to use.
//   szServerFile -- The file to request from the server, include everything after the domain part of the URL.
//   szPostData -- The raw post data to send to the server, note that & and = are special characters that separate variables.
// SOURCE
char* agk::SendHTTPRequest( uint32_t iHTTP, const char *szServerFile, const char *szPostData )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to send HTTP request, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	char* str = pHttp->SendRequest( szServerFile, szPostData );
	if ( !str )
	{
		str = new char[1]; 
		*str = 0;
	}

	return str;
}

//****f* HTTP/General/SendHTTPRequestASync
// FUNCTION
//   Send a request to the server specified in <i>SetHTTPHost</i>, for example if requesting http://www.thegamecreators.com/index.php szServerFile 
//   should be "index.php".<br><br>
//   This command returns immediately and waits for the server to reply in the background. You can check the status of the reply with
//   <i>GetHTTPResponseReady</i> and when it is ready retrieve the response with <i>GetHTTPResponse</i>.
// INPUTS
//   iHTTP -- The ID of the connection to use.
//   szServerFile -- The file to request from the server, include everything after the domain part of the URL.
// SOURCE
int agk::SendHTTPRequestASync( uint32_t iHTTP, const char *szServerFile )
//****
{
	return SendHTTPRequestASync( iHTTP, szServerFile, 0 );
}

//****f* HTTP/General/SendHTTPRequestASync
// FUNCTION
//   Send a request to the server specified in SetHTTPHost(), for example if requesting http://www.thegamecreators.com/index.php szServerFile 
//   should be "index.php". Also allows you to send POST data to the server which can include variables or file data, e.g. "myvar=5&var2=test".
//   This command returns immediately and waits for the server to reply in the background. You can check the status of the reply with
//   <i>GetHTTPResponseReady</i> and when it is ready retrieve the response with <i>GetHTTPResponse</i>.
// INPUTS
//   iHTTP -- The ID of the connection to use.
//   szServerFile -- The file to request from the server, include everything after the domain part of the URL.
//   szPostData -- The raw post data to send to the server, note that & and = are special characters that separate variables.
// SOURCE
int agk::SendHTTPRequestASync( uint32_t iHTTP, const char *szServerFile, const char *szPostData )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to send HTTP async request, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return 0;
	}

	return pHttp->SendRequestASync( szServerFile, szPostData ) ? 1 : 0;
}

//****f* HTTP/General/SendHTTPFile
// FUNCTION
//   Send a file to the server specified in <i>SetHTTPHost</i>, for example if requesting http://www.thegamecreators.com/index.php szServerFile 
//   should be "index.php". Also allows you to send POST data to the server which can include variables or file data, e.g. "myvar=5&var2=test".
//   This command returns immediately and waits for the server to reply in the background. You can check the status of the reply with
//   <i>GetHTTPResponseReady</i> and when it is ready retrieve the response with <i>GetHTTPResponse</i>. You can check the progress of the upload
//   with <i>GetHTTPFileProgress</i>.<br><br>
//
//   Does not work when exported to HTML5
// INPUTS
//   iHTTP -- The ID of the connection to use.
//   szServerFile -- The file to request from the server, include everything after the domain part of the URL.
//   szPostData -- The raw post data to send to the server, note that & and = are special characters that separate variables.
//   szLocalFile -- The filename of the file you want to send to the server.
// SOURCE
int agk::SendHTTPFile( uint32_t iHTTP, const char *szServerFile, const char *szPostData, const char *szLocalFile )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to send HTTP file, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return 0;
	}

	return pHttp->SendFile( szServerFile, szPostData, szLocalFile ) ? 1 : 0;
}


//****f* HTTP/General/GetHTTPResponse
// FUNCTION
//   Returns the reply from the server from a previous sent <i>SendHTTPRequestASync</i> request. You must wait for <i>GetHTTPResponseReady</i> to 
//   return 1 before calling this command. In tier 2 you must delete the returned string with agk::DeleteString when you are done using it. Tier 2 has the 
//   additional command <i>GetHTTPResponseReadyC</i> which returns a const char that does not need deleting.
// INPUTS
//   iHTTP -- The ID of the connection to check.
// SOURCE
char* agk::GetHTTPResponse( uint32_t iHTTP )
//****
{
	const char* str = GetHTTPResponseC( iHTTP );

	// 120112 - ensure empty string returned if NULL (T1)
	if ( str==NULL ) str = "";

	char *str2 = new char[ strlen(str) + 1 ];
	strcpy( str2, str );
	return str2;
}

//****f* HTTP/General/GetHTTPResponseReady
// FUNCTION
//   Returns 1 if the request previously sent with <i>SendHTTPRequestASync</i> has completed. You can get the response with <i>GetHTTPResponse</i>.
//   Returns 0 if the request is still in progress, or -1 if the request failed.
// INPUTS
//   iHTTP -- The ID of the connection to check.
// SOURCE
int agk::GetHTTPResponseReady( uint32_t iHTTP )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get HTTP response ready, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return 0;
	}

	return pHttp->GetResponseReady();
}

const char* agk::GetHTTPResponseC( uint32_t iHTTP )
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get HTTP response, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return 0;
	}

	return pHttp->GetResponse();
}

//****f* HTTP/General/GetHTTPFile
// FUNCTION
//   Downloads an HTTP file from the server specified in <i>SetHTTPHost</i> and saves it to the location specified.
//   This command returns immediately and continues the file download in the background. You can check on the progress
//   of the download with <i>GetHTTPFileProgress</i> and <i>GetHTTPFileComplete</i>. The file will then be at the location you 
//   specified ready for use with AGK.
// INPUTS
//   iHTTP -- The ID of the connection to use.
//   szServerFile -- The file to request from the server, include everything after the domain part of the URL.
//   szLocalFile -- The location to save to file, this will be inside the write folder for the current device.
// SOURCE
int agk::GetHTTPFile( uint32_t iHTTP, const char *szServerFile, const char *szLocalFile )
//****
{
	return GetHTTPFile( iHTTP, szServerFile, szLocalFile, 0 );
}

//****f* HTTP/General/GetHTTPFile
// FUNCTION
//   Downloads an HTTP file from the server specified in <i>SetHTTPHost</i> and saves it to the location specified.
//   Also allows you to send POST data to the server which can include variables or file data, e.g. "myvar=5&var2=test".
//   This command returns immediately and continues the file download in the background. You can check on the progress
//   of the download with <i>GetHTTPFileProgress</i> and <i>GetHTTPFileComplete</i>. The file will then be at the location you 
//   specified ready for use with AGK.
// INPUTS
//   iHTTP -- The ID of the connection to use.
//   szServerFile -- The file to request from the server, include everything after the domain part of the URL.
//   szLocalFile -- The location to save to file, this will be inside the write folder for the current device.
//   szPostData -- The raw post data to send to the server, note that & and = are special characters that separate variables.
// SOURCE
int agk::GetHTTPFile( uint32_t iHTTP, const char *szServerFile, const char *szLocalFile, const char *szPostData )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to send HTTP async request, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return 0;
	}

	return pHttp->DownloadFile( szServerFile, szLocalFile, szPostData ) ? 1 : 0;
}

//****f* HTTP/General/GetHTTPFileComplete
// FUNCTION
//   Returns 1 if the file download previously started with <i>GetHTTPFile</i> has completed, 0 otherwise.
//   Even if this returns 1 to say the download is finished it may have failed, check <i>GetHTTPResponseReady</i>
//   for negative values before assuming the download was successful.
// INPUTS
//   iHTTP -- The ID of the connection to check.
// SOURCE
int agk::GetHTTPFileComplete( uint32_t iHTTP )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get HTTP response ready, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return 0;
	}

	return pHttp->DownloadComplete() ? 1 : 0;
}

//****f* HTTP/General/GetHTTPFileProgress
// FUNCTION
//   Returns the progress of the file download as a float value from 0 to 100. This should not be relied upon to work out 
//   when the download has finished and on some platforms may not produce an accurate representation of the download progress.<br><br>
//   Use <i>GetHTTPFileComplete</i> or <i>GetHTTPResponseReady</i> to work out if the download has completed.
// INPUTS
//   iHTTP -- The ID of the connection to check.
// SOURCE
float agk::GetHTTPFileProgress( uint32_t iHTTP )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get HTTP file progress, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return 0;
	}

	return pHttp->GetProgress();
}

//****f* HTTP/General/GetHTTPStatusCode
// FUNCTION
//   Returns the status code that was returned from the server in the response. You must wait for 
//   <i>GetHTTPResponseReady</i> to return a non-zero value before checking this command, otherwise 
//   it will return 0. Usually the status code is equal to 200 when the request was successful
// INPUTS
//   iHTTP -- The ID of the connection to check.
// SOURCE
int agk::GetHTTPStatusCode( uint32_t iHTTP )
//****
{
	cHTTPConnection *pHttp = m_cHTTPList.GetItem( iHTTP );
	if ( !pHttp )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Failed to get HTTP status code, HTTP ID %d does not exist", iHTTP );
		agk::Error( err );
#endif
		return 0;
	}

	return pHttp->GetStatusCode();
}


// Error reporting

//****f* Error/General/SetErrorMode
// FUNCTION
//   Sets the error mode for the AGK from ignore, report, or stop from AGK commands, e.g. sprite ID doesn't exist in
//   a command that accepts a sprite ID. Ignoring will make the AGK attempt to carry on, ignoring the entire command 
//   if necessary. Reporting will make the AGK report the error to an appropriate debug console and carry on. Stop
//   will force the AGK to report the error as before and then stop by throwing an exception, which must be caught or
//   the app will terminate. In the case of tier 1 the exception is caught by the interpreter and, if debugging,  
//   displayed in the IDE.
// INPUTS
//   mode -- 0=ignore, 1=report, 2=stop
// SOURCE
void agk::SetErrorMode( int mode )
//****
{
	m_iErrorMode = mode;
}

//****f* Error/General/GetErrorMode
// FUNCTION
//   Returns the current error mode for AGK. 0=ignore, 1=report, 2=stop
// SOURCE
int agk::GetErrorMode ( )
//****
{
	return m_iErrorMode;
}

int agk::GetLastError( uString &sOut )
{
	sOut.SetStr( m_sLastError );
	return sOut.GetLength();
}

//****f* Error/General/GetLastError
// FUNCTION
//   Returns a string describing the last error that occurred. This function will continue to return the same string 
//   until another error occurs. This does not include warnings.
// SOURCE
char* agk::GetLastError()
//****
{
	char *str = new char[ m_sLastError.GetLength() + 1 ];
	strcpy( str, m_sLastError.GetStr() );
	return str;
}

//****f* Error/General/GetErrorOccurred
// FUNCTION
//   Returns 1 if an error occurred since the last call to this command. 0 if not. This does not include warnings.
// SOURCE
int agk::GetErrorOccurred()
//****
{
	int result = m_bErrorOccurred ? 1 : 0;
	m_bErrorOccurred = false;
	return result;
}

//   Sets the warning callback to that given. This callback will be called whenever an AGK function registers
//   a warning. A warning is usually a problem that is outside the user's control, e.g. failure to connect to
//   a network client.<br><br>
//   This callback cannot be guaranteed to be on the same thread as the main app, particularly when
//   dealing with network commands. You can use a global AGK::cLock to protect shared resources.
//   The callback will always be called even if <i>SetErrorMode</i> is set to 0.
void agk::SetWarningCallback( void(*callback)(const char*) )
{
	m_fWarningCallback = callback;
}

//   Sets the error callback to that given. This callback will be called whenever an AGK function registers
//   an error. An error is usually the result of bad input, e.g. positioning a sprite that doesn't exist.
//   The app will attempt to continue by skipping the command that caused the error unless SetErrorMode() is
//   set to 2, in which case the app will throw an int exception.
//   This callback cannot be guaranteed to be on the same thread as the main app, particularly when
//   dealing with network commands. You can use a global AGK::cLock to protect shared resources.
//   The callback will always be called even if SetErrorMode() is set to 0.
void agk::SetErrorCallback( void(*callback)(const char*) )
{
	m_fErrorCallback = callback;
}

void agk::SetDebugCallback( void(*callback)(const char*, const char*) )
{
	m_fDebugCallback = callback;
}

void agk::DebugInfo( const char* type, const char* data )
{
	if ( m_fDebugCallback ) m_fDebugCallback( type, data );
}

void agk::PluginError( const char *szErr )
//***2
{
	{
		cAutoLock autolock( &m_kErrorLock );
		m_bErrorOccurred = true;
		m_sLastError.SetStr( szErr );

		if ( m_iErrorMode == 0 ) return;

		if ( m_fErrorCallback ) m_fErrorCallback( szErr );

		PlatformReportError( szErr );

		if ( m_iErrorMode == 1 ) return;
	}

	agk::Message( szErr );
}

void agk::Error( const char *msg )
{
	{
		cAutoLock autolock( &m_kErrorLock );
		m_bErrorOccurred = true;
		m_sLastError.SetStr( msg );

#ifdef _AGK_ERROR_CHECK
		if ( m_iErrorMode == 0 ) return;

		if ( m_fErrorCallback ) m_fErrorCallback( msg );

		PlatformReportError( msg );
		
		if ( m_iErrorMode == 1 ) return;
	}

//#ifndef AGK_ANDROID
	throw 1;
//#endif
#endif
}

void agk::Warning( const char* msg )
{

#ifdef _AGK_ERROR_CHECK
	if ( m_iErrorMode == 0 ) return;
	{
		cAutoLock autolock( &m_kErrorLock );
		if ( m_fWarningCallback ) m_fWarningCallback( msg );
		m_sLastError.SetStr( msg ); // 211011 - need to report warnings back to T1 player/viewer
		PlatformReportError( msg );
	}
#endif
}

//****f* Core/Misc/Message
// FUNCTION
//   Displays a message box containing the given text. Your app is not guaranteed to pause whilst the message is displayed.
// INPUTS
//   msg -- The message to display
// SOURCE
void agk::Message( const char* msg )
//****
{
	PlatformMessage( msg );
}
	
//input commands

//****f* Input-Raw/Existence/GetJoystickExists
// FUNCTION
//   Returns 1 if the current device has at least one physical joystick available as an input method. 
//   0 if it has no joystick physical joysticks. If you find that the platform has no physical joysticks
//   you can create virtual ones that appear on screen for use by touch screens or mice with 
//   <i>AddVirtualJoystick</i>. <i>GetJoystickExists</i> does not count virtual joysticks in its check.
//   On some platforms joystick detection is run on a background thread that may not complete for some time
//   after your app has started, to wait for the thread to complete use <i>CompleteRawJoystickDetection</i> to be
//   sure that any connected joysticks have been found.
// SOURCE
int agk::GetJoystickExists()
//****
{
	for ( uint32_t i = 0; i < AGK_NUM_JOYSTICKS; i++ )
	{
		if ( m_pJoystick[ i ] ) return 1;
	}
	
	return 0;
}

//****f* Input-Raw/Mouse/GetRawMouseX
// FUNCTION
//   Returns the X component of the current mouse position in screen coordinates. If no mouse exists it will always return 0.
// SOURCE
float agk::GetRawMouseX() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetX();
}

//****f* Input-Raw/Mouse/GetRawMouseY
// FUNCTION
//   Returns the Y component of the current mouse position in screen coordinates. If no mouse exists it will always return 0.
// SOURCE
float agk::GetRawMouseY() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetY();
}

//****f* Input-Raw/Mouse/GetRawMouseWheel
// FUNCTION
//   Returns the current position of the mouse wheel, can be positive or negative, starts at 0. If no mouse exists it will always return 0.
// SOURCE
float agk::GetRawMouseWheel() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetWheel();
}

//****f* Input-Raw/Mouse/GetRawMouseWheelDelta
// FUNCTION
//   Returns the difference between the current mouse wheel position and the previous mouse wheel position, can be positive or negative, 
//   updated once a frame. If no mouse exists it will always return 0.
// SOURCE
float agk::GetRawMouseWheelDelta() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetWheelDelta();
}

//****f* Input-Raw/Mouse/GetRawMouseLeftPressed
// FUNCTION
//   Returns 1 if the left mouse button has been pressed, then returns 0 whilst the button is held down. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseLeftPressed() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetLeftPressed() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseLeftState
// FUNCTION
//   Returns 1 if the left mouse button is currently down, 0 if not. If no mouse exists it will always return 0.
// SOURCE
int agk::GetRawMouseLeftState() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetLeftState() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseLeftReleased
// FUNCTION
//   Returns 1 if the left mouse button has been released, then returns 0 whilst the button is up. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseLeftReleased() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetLeftReleased() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseRightPressed
// FUNCTION
//   Returns 1 if the right mouse button has been pressed, then returns 0 whilst the button is held down. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseRightPressed() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetRightPressed() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseRightState
// FUNCTION
//   Returns 1 if the right mouse button is currently down, 0 if not. If no mouse exists it will always return 0.
// SOURCE
int agk::GetRawMouseRightState() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetRightState() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseRightReleased
// FUNCTION
//   Returns 1 if the right mouse button has been released, then returns 0 whilst the button is up. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseRightReleased() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetRightReleased() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseMiddlePressed
// FUNCTION
//   Returns 1 if the middle mouse button has been pressed, then returns 0 whilst the button is held down. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseMiddlePressed() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetMiddlePressed() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseMiddleState
// FUNCTION
//   Returns 1 if the middle mouse button is currently down, 0 if not. If no mouse exists it will always return 0.
// SOURCE
int agk::GetRawMouseMiddleState() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetMiddleState() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseMiddleReleased
// FUNCTION
//   Returns 1 if the middle mouse button has been released, then returns 0 whilst the button is up. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseMiddleReleased() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetMiddleReleased() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseFourthPressed
// FUNCTION
//   Returns 1 if the fourth mouse button has been pressed, then returns 0 whilst the button is held down. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseFourthPressed() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetFourthPressed() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseFourthState
// FUNCTION
//   Returns 1 if the fourth mouse button is currently down, 0 if not. If no mouse exists it will always return 0.
// SOURCE
int agk::GetRawMouseFourthState() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetFourthState() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseFourthReleased
// FUNCTION
//   Returns 1 if the fourth mouse button has been released, then returns 0 whilst the button is up. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseFourthReleased() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetFourthReleased() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseFifthPressed
// FUNCTION
//   Returns 1 if the fifth mouse button has been pressed, then returns 0 whilst the button is held down. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseFifthPressed() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetFifthPressed() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseFifthState
// FUNCTION
//   Returns 1 if the fifth mouse button is currently down, 0 if not. If no mouse exists it will always return 0.
// SOURCE
int agk::GetRawMouseFifthState() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetFifthState() ? 1 : 0;
}

//****f* Input-Raw/Mouse/GetRawMouseFifthReleased
// FUNCTION
//   Returns 1 if the fifth mouse button has been released, then returns 0 whilst the button is up. If no mouse exists 
//   it will always return 0.
// SOURCE
int agk::GetRawMouseFifthReleased() 
//****
{ 
	if ( !m_pMouse[ 0 ] ) return 0;
	return m_pMouse[ 0 ]->GetFifthReleased() ? 1 : 0;
}

/*
float agk::GetRawMouseX( uint32_t index ) 
{ 
	index--;
	if ( index > 3 ) return 0;
	if ( !m_pMouse[ index ] ) return 0;
	return m_pMouse[ index ]->GetX();
}

float agk::GetRawMouseY( uint32_t index ) 
{ 
	index--;
	if ( index > 3 ) return 0;
	if ( !m_pMouse[ index ] ) return 0;
	return m_pMouse[ index ]->GetY();
}

int agk::GetRawMouseLeftPressed( uint32_t index ) 
{ 
	index--;
	if ( index > 3 ) return 0;
	if ( !m_pMouse[ index ] ) return 0;
	return m_pMouse[ index ]->GetLeftPressed() ? 1 : 0;
}

int agk::GetRawMouseLeftState( uint32_t index ) 
{ 
	index--;
	if ( index > 3 ) return 0;
	if ( !m_pMouse[ index ] ) return 0;
	return m_pMouse[ index ]->GetLeftState() ? 1 : 0;
}

int agk::GetRawMouseLeftReleased( uint32_t index ) 
{ 
	index--;
	if ( index > 3 ) return 0;
	if ( !m_pMouse[ index ] ) return 0;
	return m_pMouse[ index ]->GetLeftReleased() ? 1 : 0;
}

int agk::GetRawMouseRightPressed( uint32_t index ) 
{ 
	index--;
	if ( index > 3 ) return 0;
	if ( !m_pMouse[ index ] ) return 0;
	return m_pMouse[ index ]->GetRightPressed() ? 1 : 0;
}

int agk::GetRawMouseRightState( uint32_t index ) 
{ 
	index--;
	if ( index > 3 ) return 0;
	if ( !m_pMouse[ index ] ) return 0;
	return m_pMouse[ index ]->GetRightState() ? 1 : 0;
}

int agk::GetRawMouseRightReleased( uint32_t index ) 
{ 
	index--;
	if ( index > 3 ) return 0;
	if ( !m_pMouse[ index ] ) return 0;
	return m_pMouse[ index ]->GetRightReleased() ? 1 : 0;
}
*/

void agk::FixOrientationByDefault ( void )
{
	if ( !agk::GetDeviceCanRotate() ) return;

	if ( !m_bOrientationSet ) 
	{
		// cannot have accelerometer feedback AND orientation changes, so fix orientation by default
		if ( m_iCurrentOrientationMode==0 )
		{
			m_iCurrentOrientationMode = agk::GetOrientation();
			switch ( m_iCurrentOrientationMode )
			{
				case 1 : agk::SetOrientationAllowed( 1,0,0,0 ); break;
				case 2 : agk::SetOrientationAllowed( 0,1,0,0 ); break;
				case 3 : agk::SetOrientationAllowed( 0,0,1,0 ); break;
				case 4 : agk::SetOrientationAllowed( 0,0,0,1 ); break;
			}
		}
	}
}

//****f* Input-Raw/Existence/GetAccelerometerExists
// FUNCTION
//   Returns 1 if the current device has an accelerometer that is currently supported by AGK, 0 if not.
// SOURCE
int agk::GetAccelerometerExists()
//****
{
	return m_iAccelerometerExists;
}

//****f* Input-Raw/Existence/GetGyroSensorExists
// FUNCTION
//   Returns 1 if the current device has a gyroscope that is currently supported by AGK, 0 if not.
// SOURCE
int agk::GetGyroSensorExists()
//****
{
	return m_iGyroSensorExists;
}

//****f* Input-Raw/Existence/GetProximitySensorExists
// FUNCTION
//   Returns 1 if the current device has a proximity sensor that is currently supported by AGK, 0 if not.
// SOURCE
int agk::GetProximitySensorExists()
//****
{
	return m_iProximitySensorExists;
}

//****f* Input-Raw/Existence/GetLightSensorExists
// FUNCTION
//   Returns 1 if the current device has an ambient light sensor that is currently supported by AGK, 0 if not.
// SOURCE
int agk::GetLightSensorExists()
//****
{
	return m_iLightSensorExists;
}

//****f* Input-Raw/Existence/GetMagneticSensorExists
// FUNCTION
//   Returns 1 if the current device has a magnetism sensor that is currently supported by AGK, 0 if not.
// SOURCE
int agk::GetMagneticSensorExists()
//****
{
	return m_iMagneticSensorExists;
}

//****f* Input-Raw/Existence/GetRotationVectorSensorExists
// FUNCTION
//   Returns 1 if the current device has a rotation vector sensor that is currently supported by AGK, 0 if not.
// SOURCE
int agk::GetRotationVectorSensorExists()
//****
{
	return m_iRotationSensorExists;
}


//****f* Input-Raw/Sensors/GetRawAccelX
// FUNCTION
//   If an accelerometer exists, returns the current accelerometer reading for the X direction in the range -1 to 1. 
//   This matches the screen coordinate system of positive being to the right.
//   If no accelerometer exists this will always return 0. You can use the <i>GetDirectionX</i> command to emulate 
//   a direction input.
//   If you have not used <i>SetOrientationAllowed</i> to select your desired orientation then this command will lock
//   the device in the current orientation to prevent the accelerometer rotating the screen. You should use 
//   <i>SetOrientationAllowed</i> if you want to enable screen rotation when using the accelerometer.
// SOURCE
float agk::GetRawAccelX() 
//****
{ 
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ACCEL;
	FixOrientationByDefault();
	switch ( agk::GetOrientation() )
	{
		case 1 : return m_fAccelX;
		case 2 : return -m_fAccelX;
		case 3 : return m_fAccelY;
		case 4 : return -m_fAccelY;
	}
	return 0.0f;
}

//****f* Input-Raw/Sensors/GetRawAccelY
// FUNCTION
//   If an accelerometer exists, returns the current accelerometer reading for the Y direction in the range -1 to 1. 
//   This matches the screen coordinate system of positive being down.
//   If no accelerometer exists this will always return 0. You can use the <i>GetDirectionY</i> command to emulate 
//   a direction input.
//   If you have not used <i>SetOrientationAllowed</i> to select your desired orientation then this command will lock
//   the device in the current orientation to prevent the accelerometer rotating the screen. You should use 
//   <i>SetOrientationAllowed</i> if you want to enable screen rotation when using the accelerometer.
// SOURCE
float agk::GetRawAccelY() 
//****
{ 
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ACCEL;
	FixOrientationByDefault();
	switch ( agk::GetOrientation() )
	{
		case 1 : return m_fAccelY;
		case 2 : return -m_fAccelY;
		case 3 : return -m_fAccelX;
		case 4 : return m_fAccelX;
	}
	return 0.0f;
}

//****f* Input-Raw/Sensors/GetRawAccelZ
// FUNCTION
//   If an accelerometer exists, returns the current accelerometer reading for the Z direction in the range -1 to 1. 
//   A positive Z value means the screen is facing upwards. If no accelerometer exists this will always return 0, 
//   there is no emulated command for the Z direction. 
//   If you have not used <i>SetOrientationAllowed</i> to select your desired orientation then this command will lock
//   the device in the current orientation to prevent the accelerometer rotating the screen. You should use 
//   <i>SetOrientationAllowed</i> if you want to enable screen rotation when using the accelerometer.
// SOURCE
float agk::GetRawAccelZ() 
//****
{ 
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ACCEL;
	FixOrientationByDefault();
	return m_fAccelZ; 
}

//****f* Input-Raw/Sensors/GetRawGyroVelocityX
// FUNCTION
//   If a gyroscope exists, returns the X component of the current device rotation speed.
//   If you have not used <i>SetOrientationAllowed</i> to select your desired orientation then this command will lock
//   the device in the current orientation to prevent the screen from rotating. You should use 
//   <i>SetOrientationAllowed</i> if you want to enable screen rotation when using the gyroscope.
// SOURCE
float agk::GetRawGyroVelocityX()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_GYRO;
    FixOrientationByDefault();
	switch ( agk::GetOrientation() )
	{
		case 1 : return m_fGyroX;
		case 2 : return -m_fGyroX;
		case 3 : return -m_fGyroY;
		case 4 : return m_fGyroY;
	}
	return 0.0f;
}

//****f* Input-Raw/Sensors/GetRawGyroVelocityY
// FUNCTION
//   If a gyroscope exists, returns the Y component of the current device rotation speed.
//   If you have not used <i>SetOrientationAllowed</i> to select your desired orientation then this command will lock
//   the device in the current orientation to prevent the screen from rotating. You should use 
//   <i>SetOrientationAllowed</i> if you want to enable screen rotation when using the gyroscope.
// SOURCE
float agk::GetRawGyroVelocityY()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_GYRO;
	FixOrientationByDefault();
	switch ( agk::GetOrientation() )
	{
		case 1 : return m_fGyroY;
		case 2 : return -m_fGyroY;
		case 3 : return m_fGyroX;
		case 4 : return -m_fGyroX;
	}
	return 0.0f;
}

//****f* Input-Raw/Sensors/GetRawGyroVelocityZ
// FUNCTION
//   If a gyroscope exists, returns the Z component of the current device rotation speed.
//   If you have not used <i>SetOrientationAllowed</i> to select your desired orientation then this command will lock
//   the device in the current orientation to prevent the screen from rotating. You should use 
//   <i>SetOrientationAllowed</i> if you want to enable screen rotation when using the gyroscope.
// SOURCE
float agk::GetRawGyroVelocityZ()
//****
{
    FixOrientationByDefault();
	return m_fGyroZ;
}

//****f* Input-Raw/Sensors/GetRawProximityDistance
// FUNCTION
//   If a proximity sensor exists, returns the distance of the device from any object currently in front of it, 
//   untested as no device supported it during testing.
// SOURCE
float agk::GetRawProximityDistance()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_PROX;
	return m_fProximityDist;
}

//****f* Input-Raw/Sensors/GetRawLightLevel
// FUNCTION
//   If an ambient light sensor exists, get the measurement of the surrounding light in lumels as a float.
// SOURCE
float agk::GetRawLightLevel()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_LIGHT;
	return m_fLightLevel;
}

//****f* Input-Raw/Sensors/GetRawMagneticX
// FUNCTION
//   If an magnetic sensor exists, returns the X component of any surrounding magnetic field.
//   On iOS it may take a few seconds to start displaying data other than 0, during this process
//   the device is using motion data to calibrate the magnetic sensor
// SOURCE
float agk::GetRawMagneticX()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_MAG;
	return m_fMagneticX;
}

//****f* Input-Raw/Sensors/GetRawMagneticY
// FUNCTION
//   If an magnetic sensor exists, returns the Y component of any surrounding magnetic field.
//   On iOS it may take a few seconds to start displaying data other than 0, during this process
//   the device is using motion data to calibrate the magnetic sensor
// SOURCE
float agk::GetRawMagneticY()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_MAG;
	return m_fMagneticY;
}

//****f* Input-Raw/Sensors/GetRawMagneticZ
// FUNCTION
//   If an magnetic sensor exists, returns the Z component of any surrounding magnetic field.
//   On iOS it may take a few seconds to start displaying data other than 0, during this process
//   the device is using motion data to calibrate the magnetic sensor
// SOURCE
float agk::GetRawMagneticZ()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_MAG;
	return m_fMagneticZ;
}

//****f* Input-Raw/Sensors/GetRawRotationVectorX
// FUNCTION
//   Returns the X component of the current device orientation as a quaternion. This can be applied to
//   objects with the SetObjectRotationQuat to mimic the device orientation with an object.
//   This command is designed for use with objects, if you want to orientate the camera use <i>GetRawRotationVectorX2</i>
// SOURCE
float agk::GetRawRotationVectorX()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ROT;
	return -m_fRotVecX;
}

//****f* Input-Raw/Sensors/GetRawRotationVectorY
// FUNCTION
//   Returns the Y component of the current device orientation as a quaternion. This can be applied to
//   objects with the SetObjectRotationQuat to mimic the device orientation with an object.
//   This command is designed for use with objects, if you want to orientate the camera use <i>GetRawRotationVectorY2</i>
// SOURCE
float agk::GetRawRotationVectorY()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ROT;
	return -m_fRotVecY;
}

//****f* Input-Raw/Sensors/GetRawRotationVectorZ
// FUNCTION
//   Returns the Z component of the current device orientation as a quaternion. This can be applied to
//   objects with the SetObjectRotationQuat to mimic the device orientation with an object.
//   This command is designed for use with objects, if you want to orientate the camera use <i>GetRawRotationVectorZ2</i>
// SOURCE
float agk::GetRawRotationVectorZ()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ROT;
    FixOrientationByDefault();
	return m_fRotVecZ;
}

//****f* Input-Raw/Sensors/GetRawRotationVectorW
// FUNCTION
//   Returns the W component of the current device orientation as a quaternion. This can be applied to
//   objects with the SetObjectRotationQuat to mimic the device orientation with an object.
//   This command is designed for use with objects, if you want to orientate the camera use <i>GetRawRotationVectorW2</i>
// SOURCE
float agk::GetRawRotationVectorW()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ROT;
    FixOrientationByDefault();
	return m_fRotVecW;
}
    
//****f* Input-Raw/Sensors/GetRawRotationVectorX2
// FUNCTION
//   Returns the X component of the current device orientation as a quaternion. This can be applied to
//   cameras with SetCameraRotationQuat to use the device like a virtual reality headset.
//   This command does internal calculations based on the SetOrientationAllowed values to produce the correct camera orientation for the current device orientation.
//   This command is designed for use with cameras, if you want to orientate an object use <i>GetRawRotationVectorX</i>
// SOURCE
float agk::GetRawRotationVectorX2()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ROT;
    FixOrientationByDefault();
    AGKQuaternion quat;
    switch ( agk::GetOrientation() )
    {
        case 1 : quat.Set(m_fRotVecW, -m_fRotVecX ,-m_fRotVecY, m_fRotVecZ); break;
        case 2 : quat.Set(m_fRotVecW, m_fRotVecX ,m_fRotVecY, m_fRotVecZ); break;
        case 3 : quat.Set(m_fRotVecW, m_fRotVecY ,-m_fRotVecX, m_fRotVecZ); break;
        case 4 : quat.Set(m_fRotVecW, -m_fRotVecY ,m_fRotVecX, m_fRotVecZ); break;
    }
    quat.AddGlobalRotation(0, 90);
    switch ( agk::GetOrientation() )
    {
        case 1 : break;
        case 2 : quat.AddGlobalRotation(1, 180); break;
        case 3 : quat.AddGlobalRotation(1, 90); break;
        case 4 : quat.AddGlobalRotation(1, -90); break;
    }
    return quat.x;
}

//****f* Input-Raw/Sensors/GetRawRotationVectorY2
// FUNCTION
//   Returns the Y component of the current device orientation as a quaternion. This can be applied to
//   cameras with SetCameraRotationQuat to use the device like a virtual reality headset.
//   This command does internal calculations based on the SetOrientationAllowed values to produce the correct camera orientation for the current device orientation.
//   This command is designed for use with cameras, if you want to orientate an object use <i>GetRawRotationVectorY</i>
// SOURCE
float agk::GetRawRotationVectorY2()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ROT;
    FixOrientationByDefault();
    AGKQuaternion quat;
    switch ( agk::GetOrientation() )
    {
        case 1 : quat.Set(m_fRotVecW, -m_fRotVecX ,-m_fRotVecY, m_fRotVecZ); break;
        case 2 : quat.Set(m_fRotVecW, m_fRotVecX ,m_fRotVecY, m_fRotVecZ); break;
        case 3 : quat.Set(m_fRotVecW, m_fRotVecY ,-m_fRotVecX, m_fRotVecZ); break;
        case 4 : quat.Set(m_fRotVecW, -m_fRotVecY ,m_fRotVecX, m_fRotVecZ); break;
    }
    quat.AddGlobalRotation(0, 90);
    switch ( agk::GetOrientation() )
    {
        case 1 : break;
        case 2 : quat.AddGlobalRotation(1, 180); break;
        case 3 : quat.AddGlobalRotation(1, 90); break;
        case 4 : quat.AddGlobalRotation(1, -90); break;
    }
    return quat.y;
}

//****f* Input-Raw/Sensors/GetRawRotationVectorZ2
// FUNCTION
//   Returns the Z component of the current device orientation as a quaternion. This can be applied to
//   cameras with SetCameraRotationQuat to use the device like a virtual reality headset.
//   This command does internal calculations based on the SetOrientationAllowed values to produce the correct camera orientation for the current device orientation.
//   This command is designed for use with cameras, if you want to orientate an object use <i>GetRawRotationVectorZ</i>
// SOURCE
float agk::GetRawRotationVectorZ2()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ROT;
    FixOrientationByDefault();
    AGKQuaternion quat;
    switch ( agk::GetOrientation() )
    {
        case 1 : quat.Set(m_fRotVecW, -m_fRotVecX ,-m_fRotVecY, m_fRotVecZ); break;
        case 2 : quat.Set(m_fRotVecW, m_fRotVecX ,m_fRotVecY, m_fRotVecZ); break;
        case 3 : quat.Set(m_fRotVecW, m_fRotVecY ,-m_fRotVecX, m_fRotVecZ); break;
        case 4 : quat.Set(m_fRotVecW, -m_fRotVecY ,m_fRotVecX, m_fRotVecZ); break;
    }
    quat.AddGlobalRotation(0, 90);
    switch ( agk::GetOrientation() )
    {
        case 1 : break;
        case 2 : quat.AddGlobalRotation(1, 180); break;
        case 3 : quat.AddGlobalRotation(1, 90); break;
        case 4 : quat.AddGlobalRotation(1, -90); break;
    }
    return quat.z;
}

//****f* Input-Raw/Sensors/GetRawRotationVectorW2
// FUNCTION
//   Returns the W component of the current device orientation as a quaternion. This can be applied to
//   cameras with SetCameraRotationQuat to use the device like a virtual reality headset.
//   This command does internal calculations based on the SetOrientationAllowed values to produce the correct camera orientation for the current device orientation.
//   This command is designed for use with cameras, if you want to orientate an object use <i>GetRawRotationVectorW</i>
// SOURCE
float agk::GetRawRotationVectorW2()
//****
{
	m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ROT;
    FixOrientationByDefault();
    AGKQuaternion quat;
    switch ( agk::GetOrientation() )
    {
        case 1 : quat.Set(m_fRotVecW, -m_fRotVecX ,-m_fRotVecY, m_fRotVecZ); break;
        case 2 : quat.Set(m_fRotVecW, m_fRotVecX ,m_fRotVecY, m_fRotVecZ); break;
        case 3 : quat.Set(m_fRotVecW, m_fRotVecY ,-m_fRotVecX, m_fRotVecZ); break;
        case 4 : quat.Set(m_fRotVecW, -m_fRotVecY ,m_fRotVecX, m_fRotVecZ); break;
    }
    quat.AddGlobalRotation(0, 90);
    switch ( agk::GetOrientation() )
    {
        case 1 : break;
        case 2 : quat.AddGlobalRotation(1, 180); break;
        case 3 : quat.AddGlobalRotation(1, 90); break;
        case 4 : quat.AddGlobalRotation(1, -90); break;
    }
    return quat.w;
}

// joystick

//****f* Input-Raw/Joysticks/CompleteRawJoystickDetection
// FUNCTION
//   Waits for the detection of physical joysticks to complete, on some systems this may take a few seconds so is run
//   in a separate thread along side the main application. If you do not use any of the real joystick commands (include 
//   the AGK joystick) you may ignore this command and let the joystick detection complete whenever it likes. However 
//   if you do wish to use joystick commands in your app you must call this command to make sure that the total number
//   of joysticks connected have been found. After this initial detection process plugging in additional joysticks will
//   not be detected.
// SOURCE
void agk::CompleteRawJoystickDetection()
//****
{
	PlatformCompleteInputInit();
}

//****f* Input-Raw/Joysticks/GetRawJoystickExists
// FUNCTION
//   Returns 1 if a joystick exists at the given index. Physical joysticks are detected at startup and placed in IDs 1-8 
//   incrementally. You should call <i>CompleteRawJoystickDetection</i> at some point before this command to make sure that all
//   present joysticks have been discovered. After the initial detection process plugging in additional joysticks will
//   not be detected (except on Android which will detect new joysticks). Unplugging a joystick will not delete its index 
//   and this command will still return 1. You can use <i>GetRawJoystickConnected</i> to detect when a previously detected 
//   joystick is disconnected. If a disconnected joystick is reattached the AGK will attempt to reconnect to it.<br><br>
//   An alternative version of this command exists <i>GetJoystickExists</i>, in which case it will return 1 if there are 
//   any raw joysticks attached.
// INPUTS
//   index -- The ID of the joystick to check.
// SOURCE
int agk::GetRawJoystickExists( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	return m_pJoystick[ index ] ? 1 : 0;
}

//****f* Input-Raw/Joysticks/GetRawJoystickConnected
// FUNCTION
//   Returns 1 if the specified joystick is connected, 0 if not. This only applies to joysticks that were plugged in when the app
//   started, plugging in a new joystick after the app has started will not be detected. Use <i>GetRawJoystickExists</i> to find
//   out which joysticks were detected at startup.
//   This command currently does not work on Mac.
// INPUTS
//   index -- The ID of the joystick to check.
// SOURCE
int agk::GetRawJoystickConnected( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
		return 0;
	}

	return m_pJoystick[ index ]->GetConnected();
}

//****f* Input-Raw/Joysticks/GetRawJoystickName
// FUNCTION
//   Returns the name of the joystick as discovered by the operating system, currently only works on Windows and Linux.
//   In Tier 2 the string is encoded in UTF-8, and must be deleted with agk::DeleteString when you are done with it.
// INPUTS
//   index -- The ID of the joystick to check.
// SOURCE
char* agk::GetRawJoystickName( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
		return 0;
	}

	const char* name = m_pJoystick[ index ]->GetName();
	char *str = new char[ strlen(name) + 1 ];
	strcpy( str, name );
	return str;
}

//****f* Input-Raw/Joysticks/GetRawJoystickX
// FUNCTION
//   Returns the current X value for the physical joystick at the given index. This will be in the range -1.0 to 1.0 with
//   0 being centered.
// INPUTS
//   index -- The ID of the joystick to check.
// SOURCE
float agk::GetRawJoystickX( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetX();
}

//****f* Input-Raw/Joysticks/GetRawJoystickY
// FUNCTION
//   Returns the current Y value for the physical joystick at the given index. This will be in the range -1.0 to 1.0 with
//   0 being centered.
// INPUTS
//   index -- The ID of the joystick to check.
// SOURCE
float agk::GetRawJoystickY( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetY();
}

//****f* Input-Raw/Joysticks/GetRawJoystickZ
// FUNCTION
//   Returns the current Z value (if applicable) for the physical joystick at the given index. This will be in the 
//   range -1.0 to 1.0 with 0 being centered.
// INPUTS
//   index -- The ID of the joystick to check.
// SOURCE
float agk::GetRawJoystickZ( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetZ();
}

//****f* Input-Raw/Joysticks/GetRawJoystickRX
// FUNCTION
//   Returns the current rotational X value (if applicable) for the physical joystick at the given index. This will be in the 
//   range -1.0 to 1.0 with 0 being centered. In reality some joystick devices use this value for a second analogue stick.
// INPUTS
//   index -- The ID of the joystick to check.
// SOURCE
float agk::GetRawJoystickRX( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetRX();
}

//****f* Input-Raw/Joysticks/GetRawJoystickRY
// FUNCTION
//   Returns the current rotational Y value (if applicable) for the physical joystick at the given index. This will be in the 
//   range -1.0 to 1.0 with 0 being centered. In reality some joystick devices use this value for a second analogue stick.
// INPUTS
//   index -- The ID of the joystick to check.
// SOURCE
float agk::GetRawJoystickRY( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetRY();
}

//****f* Input-Raw/Joysticks/GetRawJoystickRZ
// FUNCTION
//   Returns the current rotational Z value (if applicable) for the physical joystick at the given index. This will be in the 
//   range -1.0 to 1.0 with 0 being centered. In reality some joystick devices use this value for a second analogue stick.
// INPUTS
//   index -- The ID of the joystick to check.
// SOURCE
float agk::GetRawJoystickRZ( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetRZ();
}


//****f* Input-Raw/Joysticks/GetRawJoystickSlider
// FUNCTION
//   Returns the current value of the joystick slider, this can vary based on joystick type. Currently the 
//   slider index must be either 0 or 1. Sliders are typically used for additional axes.
// INPUTS
//   index -- The ID of the joystick to check.
//   slider -- The index of the slider to check.
// SOURCE
int agk::GetRawJoystickSlider( uint32_t index, uint32_t slider )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetSlider( slider );
}

//****f* Input-Raw/Joysticks/GetRawJoystickPOV
// FUNCTION
//   Returns the current value of the joystick POV, this can vary based on joystick type. Currently the 
//   POV index must be either 0, 1, 2, or 3
// INPUTS
//   index -- The ID of the joystick to check.
//   pov -- The index of the POV to check.
// SOURCE
int agk::GetRawJoystickPOV( uint32_t index, uint32_t pov )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetPOV( pov );
}

//****f* Input-Raw/Joysticks/GetRawJoystickButtonPressed
// FUNCTION
//   Returns 1 if the given button was pressed this frame, otherwise returns 0. Once the button has been
//   pressed this function returns to 0, to check the state of the button use <i>GetRawJoystickButtonState</i>.<br><br>
//   AGK supports up to 64 joystick buttons in the range 1-64.
// INPUTS
//   index -- The ID of the joystick to check.
//   button -- The ID of the button to check.
// SOURCE
int agk::GetRawJoystickButtonPressed( uint32_t index, uint32_t button )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	button--;
	if ( button >= AGK_MAX_JOYSTICK_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick button index, valid range is 1-64" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetButtonPressed( button ) ? 1 : 0;
}

//****f* Input-Raw/Joysticks/GetRawJoystickButtonState
// FUNCTION
//   Returns 1 if the given button is currently down, otherwise returns 0. To detect the instance that a button
//   is pressed or released use <i>GetRawJoystickButtonPressed</i> or <i>GetRawJoystickButtonReleased</i>.<br><br>
//   AGK supports up to 64 joystick buttons in the range 1-64.
// INPUTS
//   index -- The ID of the joystick to check.
//   button -- The ID of the button to check.
// SOURCE
int agk::GetRawJoystickButtonState( uint32_t index, uint32_t button )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	button--;
	if ( button >= AGK_MAX_JOYSTICK_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick button index, valid range is 1-64" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetButtonState( button ) ? 1 : 0;
}

//****f* Input-Raw/Joysticks/GetRawJoystickButtonReleased
// FUNCTION
//   Returns 1 if the given button was released this frame, otherwise returns 0. Once the button has been
//   released this function returns to 0, to check the state of the button use <i>GetRawJoystickButtonState</i>.<br><br>
//   AGK supports up to 64 joystick buttons in the range 1-64.
// INPUTS
//   index -- The ID of the joystick to check.
//   button -- The ID of the button to check.
// SOURCE
int agk::GetRawJoystickButtonReleased( uint32_t index, uint32_t button )
//****
{
	index--;
	if ( index >= AGK_NUM_JOYSTICKS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick index, valid range is 1-8" );
#endif
		return 0;
	}

	button--;
	if ( button >= AGK_MAX_JOYSTICK_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid joystick button index, valid range is 1-64" );
#endif
		return 0;
	}

	if ( !m_pJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Joystick %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pJoystick[ index ]->GetButtonReleased( button ) ? 1 : 0;
}

//****f* Input-Raw/Joysticks/SetRawJoystickDeadZone
// FUNCTION
//   Sets the dead zone for all real joysticks so that any X or Y value below the given threshold will return 0 instead.
//   This value must be between 0 and 1, by default it is set to 0.15.
// INPUTS
//   threshold -- The value below which 0 will be returned.
// SOURCE
void agk::SetRawJoystickDeadZone( float threshold )
//****
{
	cJoystick::SetDeadZone( threshold );
}

// virtual joystick

//****f* Input/Virtual Joystick/AddVirtualJoystick
// FUNCTION
//   Creates an on-screen joystick that can be controlled by a touch screen, mouse, or other pointer device.
//   These are separate to physical joysticks so you could have a virtual joystick with ID 1 and a real
//   joystick with ID 1. You may have up to 4 virtual joysticks on screen at the same time.<br><br>
//   If a virtual joystick is on screen and is clicked or touched the joystick will capture that event and 
//   <i>GetRawMouseLeftState</i> will return 0 (up), and a touch event will not be generated for that action.
// INPUTS
//   index -- The ID of the virtual joystick to create, must be in the range 1 to 4.
//   x -- The x position of the center of the joystick in screen coordinates.
//   y -- The y position of the center of the joystick in screen coordinates.
//   size -- The diameter of the joystick in screen coordinates.
// SOURCE
void agk::AddVirtualJoystick( uint32_t index, float x, float y, float size )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return;
	}

	if ( m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Cannot add virtual joystick %d, a virtual joystick already exists at that index", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualJoystick[ index ] = new cVirtualJoystick( x, y, size );
}

//****f* Input/Virtual Joystick/DeleteVirtualJoystick
// FUNCTION
//   Deletes a virtual joystick and removes it from screen. No further virtual joystick commands can be called
//   on this index unless it is recreated using <i>AddVirtualJoystick</i>.
// INPUTS
//   index -- The ID of the virtual joystick to delete.
// SOURCE
void agk::DeleteVirtualJoystick( uint32_t index )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return;
	}

	if ( m_pVirtualJoystick[ index ] ) delete m_pVirtualJoystick[ index ];
	m_pVirtualJoystick[ index ] = 0;
}

//****f* Input/Virtual Joystick/GetVirtualJoystickExists
// FUNCTION
//   Returns 1 if a virtual joystick exists at the given index. Must be in the range 1 to 4.
// INPUTS
//   index -- The ID of the virtual joystick to check.
// SOURCE
int agk::GetVirtualJoystickExists( uint32_t index )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return 0;
	}

	return m_pVirtualJoystick[ index ] ? 1 : 0;
}

//****f* Input/Virtual Joystick/GetVirtualJoystickX
// FUNCTION
//   Returns the X value of the virtual joystick at the given index. This will be in the range -1.0 to 1.0 
//   with 0 being centered. When the user is not interacting with the virtual joystick this will return 0.
// INPUTS
//   index -- The ID of the virtual joystick to check.
// SOURCE
float agk::GetVirtualJoystickX( uint32_t index )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return 0;
	}

	if ( !m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual joystick %d does not exist", index+1 );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pVirtualJoystick[ index ]->GetX();
}

//****f* Input/Virtual Joystick/GetVirtualJoystickY
// FUNCTION
//   Returns the Y value of the virtual joystick at the given index. This will be in the range -1.0 to 1.0 
//   with 0 being centered. When the user is not interacting with the virtual joystick this will return 0.
// INPUTS
//   index -- The ID of the virtual joystick to check.
// SOURCE
float agk::GetVirtualJoystickY( uint32_t index )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return 0;
	}

	if ( !m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual joystick %d does not exist", index+1 );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pVirtualJoystick[ index ]->GetY();
}

//****f* Input/Virtual Joystick/SetVirtualJoystickAlpha
// FUNCTION
//   Sets the transparency of the virtual joystick on screen. The virtual joystick is composed of two parts
//   the inner movable part, and the outer static part. Alpha1 sets the transparency of the outer part in
//   the range 0-255 with 255 being fully opaque. Alpha2 sets the transparency of the inner part in the 
//   range 0-255.
// INPUTS
//   index -- The ID of the virtual joystick to set.
//   alpha1 -- The alpha value of the outer part of the joystick.
//   alpha2 -- The alpha value of the inner part of the joystick.
// SOURCE
void agk::SetVirtualJoystickAlpha( uint32_t index, uint32_t alpha1, uint32_t alpha2 )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return;
	}

	if ( !m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual joystick %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualJoystick[ index ]->SetAlpha( alpha1, alpha2 );
}

//****f* Input/Virtual Joystick/SetVirtualJoystickPosition
// FUNCTION
//   Sets the position of the virtual joystick in screen coordinates. You can use <i>GetVirtualWidth</i> and 
//   <i>GetVirtualHeight</i> to find the current bounds of the screen. The joystick will be centered on the 
//   given x and y position. Moving a virtual joystick whilst it is in use will alter the current X and 
//   Y values being returned.
// INPUTS
//   index -- The ID of the virtual joystick to set.
//   x -- The x coordinate of the new position.
//   y -- The y coordinate of the new position.
// SOURCE
void agk::SetVirtualJoystickPosition( uint32_t index, float x, float y )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return;
	}

	if ( !m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual joystick %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualJoystick[ index ]->SetPosition( x, y );
}

//****f* Input/Virtual Joystick/SetVirtualJoystickSize
// FUNCTION
//   Sets the diameter of the virtual joystick in screen coordinates. Resizing a virtual joystick whilst
//   it is in use will alter the current X and Y values being returned.
// INPUTS
//   index -- The ID of the virtual joystick to set.
//   size -- The new diameter of the joystick in screen coordinates.
// SOURCE
void agk::SetVirtualJoystickSize( uint32_t index, float size )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return;
	}

	if ( !m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual joystick %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualJoystick[ index ]->SetSize( size );
}

//****f* Input/Virtual Joystick/SetVirtualJoystickActive
// FUNCTION
//   Sets whether the joystick will capture mouse and touch events. If set to 0 it will not capture input 
//   and will not update its X and Y values, they will return to 0. This will not affect the virtual
//   joystick's visibility, use <i>SetVirtualJoystickVisible</i> to change if it is visible.
// INPUTS
//   index -- The ID of the virtual joystick to set.
//   active -- 1 to allow input, 0 to deactivate it.
// SOURCE
void agk::SetVirtualJoystickActive( uint32_t index, int active )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return;
	}

	if ( !m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual joystick %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualJoystick[ index ]->SetActive( active != 0 );
}

//****f* Input/Virtual Joystick/SetVirtualJoystickVisible
// FUNCTION
//   Sets whether the joystick is visible on screen, this does not affect its ability to accept input,
//   use <i>SetVirtualJoystickActive</i> to affect if a virtual joystick will accept input. An invisible
//   joystick can still be active.
// INPUTS
//   index -- The ID of the virtual joystick to set.
//   visible -- 1 to display the joystick, 0 to hide it.
// SOURCE
void agk::SetVirtualJoystickVisible( uint32_t index, int visible )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return;
	}

	if ( !m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual joystick %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualJoystick[ index ]->SetVisible( visible != 0 );
}

//****f* Input/Virtual Joystick/SetVirtualJoystickImageInner
// FUNCTION
//   Sets the image used by the inner (moveable) portion of the joystick. You can use an image ID of 0 to return it to the default image.
// INPUTS
//   index -- The ID of the virtual joystick to set.
//   imageID -- The image ID to use for this joystick.
// SOURCE
void agk::SetVirtualJoystickImageInner( uint32_t index, uint32_t imageID )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return;
	}

	if ( !m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual joystick %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	cImage *pImage = 0;
	if ( imageID > 0 )
	{
		pImage = m_cImageList.GetItem( imageID );
		if ( pImage == 0 )
		{
#ifdef _AGK_ERROR_CHECK
			uString err;
			err.Format( "Failed to set joystick inner image, image %d does not exist", imageID );
			agk::Error( err );
#endif
			return;
		}
	}

	m_pVirtualJoystick[ index ]->SetInnerImage( pImage );
}

//****f* Input/Virtual Joystick/SetVirtualJoystickImageOuter
// FUNCTION
//   Sets the image used by the outer (fixed) portion of the joystick. You can use an image ID of 0 to return it to the default image.
// INPUTS
//   index -- The ID of the virtual joystick to set.
//   imageID -- The image ID to use for this joystick.
// SOURCE
void agk::SetVirtualJoystickImageOuter( uint32_t index, uint32_t imageID )
//****
{
	index--;
	if ( index > 3 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual joystick index, valid range is 1-4" );
#endif
		return;
	}

	if ( !m_pVirtualJoystick[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual joystick %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	cImage *pImage = 0;
	if ( imageID > 0 )
	{
		pImage = m_cImageList.GetItem( imageID );
		if ( pImage == 0 )
		{
#ifdef _AGK_ERROR_CHECK
			uString err;
			err.Format( "Failed to set joystick outer image, image %d does not exist", imageID );
			agk::Error( err );
#endif
			return;
		}
	}

	m_pVirtualJoystick[ index ]->SetOuterImage( pImage );
}

//****f* Input/Virtual Joystick/SetVirtualJoystickDeadZone
// FUNCTION
//   Sets the dead zone for all virtual joysticks so that any X or Y value below the given threshold will return 0 instead.
//   This value must be between 0 and 1, by default it is set to 0.15.
// INPUTS
//   threshold -- The value below which 0 will be returned.
// SOURCE
void agk::SetVirtualJoystickDeadZone( float threshold )
//****
{
	cVirtualJoystick::SetDeadZone( threshold );
}


// virtual buttons

//****f* Input/Virtual Button/AddVirtualButton
// FUNCTION
//   Creates an on-screen button that can be controlled by a touch screen, mouse, or other pointer device.
//   These are separate to physical joystick buttons or keyboard keys so you could have a virtual button 
//   with ID 1 and a real joystick button with ID 1. You may have up to 100 virtual buttons on screen at 
//   the same time. If a virtual button is on screen and is clicked or touched the button will capture 
//   that event and <i>GetRawMouseLeftState</i> will return 0 (up), and a touch event will not be generated for 
//   that action.
// INPUTS
//   index -- The ID of the virtual button to create, must be in the range 1 to 100.
//   x -- The x position of the center of the button in screen coordinates.
//   y -- The y position of the center of the button in screen coordinates.
//   size -- The diameter of the button in screen coordinates.
// SOURCE
void agk::AddVirtualButton( uint32_t index, float x, float y, float size )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Cannot add virtual button %d, a virtual button already exists at that index", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualButton[ index ] = new cVirtualButton( x, y, size );
}

//****f* Input/Virtual Button/DeleteVirtualButton
// FUNCTION
//   Deletes the virtual button at the given index. No further virtual button commands can be called on this 
//   index unless it is recreated using <i>AddVirtualButton</i>.
// INPUTS
//   index -- The ID of the virtual button to delete.
// SOURCE
void agk::DeleteVirtualButton( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( m_pVirtualButton[ index ] ) delete m_pVirtualButton[ index ];
	m_pVirtualButton[ index ] = 0;
}

//****f* Input/Virtual Button/GetVirtualButtonExists
// FUNCTION
//   Returns 1 if a virtual button exists at the given index. 0 otherwise.
// INPUTS
//   index -- The ID of the virtual button to check.
// SOURCE
int agk::GetVirtualButtonExists( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return 0;
	}

	return m_pVirtualButton[ index ] ? 1 : 0;
}

//****f* Input/Virtual Button/GetVirtualButtonPressed
// FUNCTION
//   Returns 1 if a virtual button was pressed this frame, after the initial press this function will return
//   to 0. Use <i>GetVirtualButtonState</i> to check if a virtual button is up or down.
// INPUTS
//   index -- The ID of the virtual button to check.
// SOURCE
int agk::GetVirtualButtonPressed( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return 0;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pVirtualButton[ index ]->GetPressed() ? 1 : 0;
}

//****f* Input/Virtual Button/GetVirtualButtonReleased
// FUNCTION
//   Returns 1 if a virtual button was released this frame, after the initial release this function will return
//   to 0. Use <i>GetVirtualButtonState</i> to check if a virtual button is up or down.
// INPUTS
//   index -- The ID of the virtual button to check.
// SOURCE
int agk::GetVirtualButtonReleased( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return 0;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pVirtualButton[ index ]->GetReleased() ? 1 : 0;
}

//****f* Input/Virtual Button/GetVirtualButtonState
// FUNCTION
//   Returns 1 if a virtual button is currently down, 0 if it is up. Use <i>GetVirtualButtonPressed</i> or 
//   <i>GetVirtualButtonReleased</i> to check for the instance a button is pressed or released.
// INPUTS
//   index -- The ID of the virtual button to check.
// SOURCE
int agk::GetVirtualButtonState( uint32_t index )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return 0;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return 0;
	}

	return m_pVirtualButton[ index ]->GetState() ? 1 : 0;
}

//****f* Input/Virtual Button/SetVirtualButtonColor
// FUNCTION
//   Sets the color of the virtual button at the given index. By default buttons are greyscale so that
//   they can accept various colors. Colors should be specified in the range 0-255.
// INPUTS
//   index -- The ID of the virtual button to set.
//   red -- The red component of the new color.
//   green -- The green component of the new color.
//   blue -- The blue component of the new color.
// SOURCE
void agk::SetVirtualButtonColor( uint32_t index, uint32_t red, uint32_t green, uint32_t blue )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualButton[ index ]->SetColor( red, green, blue );
}

//****f* Input/Virtual Button/SetVirtualButtonAlpha
// FUNCTION
//   Sets the transparency of the virtual button at the given index. The alpha value should be in the range 0-255
//   where 255 is fully opaque.
// INPUTS
//   index -- The ID of the virtual button to set.
//   alpha -- The new alpha value for this button.
// SOURCE
void agk::SetVirtualButtonAlpha( uint32_t index, uint32_t alpha )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualButton[ index ]->SetAlpha( alpha );
}

//****f* Input/Virtual Button/SetVirtualButtonPosition
// FUNCTION
//   Sets the position of the virtual button in screen coordinates. You can use <i>GetVirtualWidth</i> and 
//   <i>GetVirtualHeight</i> to find the current bounds of the screen. The button will be centered on the 
//   given x and y position.
// INPUTS
//   index -- The ID of the virtual button to set.
//   x -- The x coordinate of the new position in screen coordinates.
//   y -- The y coordinate of the new position in screen coordinates.
// SOURCE
void agk::SetVirtualButtonPosition( uint32_t index, float x, float y )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualButton[ index ]->SetPosition( x, y );
}

//****f* Input/Virtual Button/SetVirtualButtonSize
// FUNCTION
//   Sets the diameter of the virtual button in screen coordinates. 
// INPUTS
//   index -- The ID of the virtual button to set.
//   size -- The new diameter of the button in screen coordinates.
// SOURCE
void agk::SetVirtualButtonSize( uint32_t index, float size )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualButton[ index ]->SetSize( size );
}

//****f* Input/Virtual Button/SetVirtualButtonSize
// FUNCTION
//   Sets the size of the virtual button in screen coordinates. 
// INPUTS
//   index -- The ID of the virtual button to set.
//   sizeX -- The new X size of the button in screen coordinates.
//   sizeY -- The new Y size of the button in screen coordinates.
// SOURCE
void agk::SetVirtualButtonSize( uint32_t index, float sizeX, float sizeY )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualButton[ index ]->SetSize( sizeX, sizeY );
}

//****f* Input/Virtual Button/SetVirtualButtonActive
// FUNCTION
//   Sets whether the virtual will capture mouse and touch events. If set to 0 it will not capture input 
//   and will not update its pressed state, it will return to 0 (up). This will not affect the virtual
//   button's visibility, use <i>SetVirtualButtonVisible</i> to change if it is visible.
// INPUTS
//   index -- The ID of the virtual button to set.
//   active -- 1 to accept input, 0 to deactivate it.
// SOURCE
void agk::SetVirtualButtonActive( uint32_t index, int active )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualButton[ index ]->SetActive( active != 0 );
}

//****f* Input/Virtual Button/SetVirtualButtonVisible
// FUNCTION
//   Sets whether the virtual is visible on screen, this does not affect its ability to accept input,
//   use <i>SetVirtualButtonActive</i> to affect if a virtual button will accept input. An invisible
//   button can still be active.
// INPUTS
//   index -- The ID of the virtual button to set.
//   visible -- 1 to show the button, 0 to hide it.
// SOURCE
void agk::SetVirtualButtonVisible( uint32_t index, int visible )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualButton[ index ]->SetVisible( visible != 0 );
}

//****f* Input/Virtual Button/SetVirtualButtonImageUp
// FUNCTION
//   Sets the image used by the button when it is not being pressed. You can use an image ID of 0 to return it to the default image.
// INPUTS
//   index -- The ID of the virtual button to set.
//   imageID -- The image ID to use for this button.
// SOURCE
void agk::SetVirtualButtonImageUp( uint32_t index, uint32_t imageID )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	cImage *pImage = 0;
	if ( imageID > 0 )
	{
		pImage = m_cImageList.GetItem( imageID );
		if ( pImage == 0 )
		{
#ifdef _AGK_ERROR_CHECK
			uString err;
			err.Format( "Failed to set button up image, image %d does not exist", imageID );
			agk::Error( err );
#endif
			return;
		}
	}

	m_pVirtualButton[ index ]->SetUpImage( pImage );
}

//****f* Input/Virtual Button/SetVirtualButtonImageDown
// FUNCTION
//   Sets the image used by the button when it is pressed. You can use an image ID of 0 to return it to the default image.
// INPUTS
//   index -- The ID of the virtual button to set.
//   imageID -- The image ID to use for this button.
// SOURCE
void agk::SetVirtualButtonImageDown( uint32_t index, uint32_t imageID )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	cImage *pImage = 0;
	if ( imageID > 0 )
	{
		pImage = m_cImageList.GetItem( imageID );
		if ( pImage == 0 )
		{
#ifdef _AGK_ERROR_CHECK
			uString err;
			err.Format( "Failed to set button down image, image %d does not exist", imageID );
			agk::Error( err );
#endif
			return;
		}
	}

	m_pVirtualButton[ index ]->SetDownImage( pImage );
}

//****f* Input/Virtual Button/SetVirtualButtonText
// FUNCTION
//   Sets the text displayed in the center of the button.
// INPUTS
//   index -- The ID of the virtual button to set.
//   str -- The text to display.
// SOURCE
void agk::SetVirtualButtonText( uint32_t index, const char *str )
//****
{
	index--;
	if ( index >= AGK_MAX_VIRTUAL_BUTTONS ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid virtual button index, valid range is 1-100" );
#endif
		return;
	}

	if ( !m_pVirtualButton[ index ] )
	{
#ifdef _AGK_ERROR_CHECK
		uString err;
		err.Format( "Virtual button %d does not exist", index+1 );
		agk::Error( err );
#endif
		return;
	}

	m_pVirtualButton[ index ]->SetText( str );
}

// keyboard

//****f* Input-Raw/Keyboard/GetRawKeyPressed
// FUNCTION
//   Returns 1 if the key code given was pressed this frame, then returns 0 whilst the key is held down.
//   This only applies to platforms with a full sized keyboard such as PC and Mac, otherwise all keys 
//   will return 0. You can check if a keyboard exists by checking <i>GetKeyboardExists</i> returns 1.
//   Key codes are in the range 0 to 255, anything out of range will return 0.
//   Check out the scan codes page in the guides section of the help files to see which key matches 
//   which key code
// INPUTS
//   key -- The key code of the key to check.
// SOURCE
int agk::GetRawKeyPressed( uint32_t key )
//****
{
	if ( key > AGK_MAX_KEYS-1 ) return 0;
	if ( !m_iPrevKeyDown[ key ] && m_iKeyDown[ key ] ) return 1;
	return 0;
}

//****f* Input-Raw/Keyboard/GetRawKeyState
// FUNCTION
//   Returns 1 if the key code given is currently down. 0 if it is up. This only applies to platforms 
//   with a full sized keyboard such as PC and Mac, otherwise all keys will return 0. You can check
//   if a keyboard exists by checking <i>GetKeyboardExists</i> returns 1.
//   Key codes are in the range 0 to 255, anything out of range will return 0.
//   Check out the scan codes page in the guides section of the help files to see which key matches 
//   which key code
// INPUTS
//   key -- The key code of the key to check.
// SOURCE
int agk::GetRawKeyState( uint32_t key )
//****
{
	if ( key > AGK_MAX_KEYS-1 ) return 0;
	return m_iKeyDown[ key ];
}

//****f* Input-Raw/Keyboard/GetRawKeyReleased
// FUNCTION
//   Returns 1 if the key code given was released this frame, then returns 0 whilst the key is up.
//   This only applies to platforms with a full sized keyboard such as PC and Mac, otherwise all keys 
//   will return 0. You can check if a keyboard exists by checking <i>GetKeyboardExists</i> returns 1.
//   Key codes are in the range 0 to 255, anything out of range will return 0.
//   Check out the scan codes page in the guides section of the help files to see which key matches 
//   which key code
// INPUTS
//   key -- The key code of the key to check.
// SOURCE
int agk::GetRawKeyReleased( uint32_t key )
//****
{
	if ( key > AGK_MAX_KEYS-1 ) return 0;
	if ( m_iPrevKeyDown[ key ] && !m_iKeyDown[ key ] ) return 1;
	return 0;
}

//****f* Input-Raw/Keyboard/GetRawLastKey
// FUNCTION
//   Returns the key code of the last key pressed. This only applies to platforms with a full sized
//   keyboard such as PC, Mac, and Linux. You can check if a keyboard exists by using <i>GetKeyboardExists</i>.
//   This function continue to return the last key pressed even when the key has been released.
//   Check out the scan codes page in the guides section of the help files to see which key matches 
//   which key code
// SOURCE
int agk::GetRawLastKey( )
//****
{
	return m_iLastKey;
}

//****f* Input-Raw/Keyboard/GetCharBuffer
// FUNCTION
//   Returns a string of all the characters pressed since the last time this command was called,
//   after this command is called the buffer is cleared. This only works on devices with a physical 
//   keyboard. The buffer is limited to 1024 characters, after which additional characters will be 
//   ignored. In Tier 2 the string is encoded in UTF-8, and must be deleted with agk::DeleteString 
//   when you are done with it.
// SOURCE
char* agk::GetCharBuffer()
//****
{
	int length = m_sCharBuffer.GetLength();
	char *str = new char[ length + 1 ];
	if ( length > 0 ) strcpy( str, m_sCharBuffer.GetStr() );
	str[ length ] = 0;

	m_sCharBuffer.ClearTemp();
	return str;
}

//****f* Input-Raw/Keyboard/GetCharBufferLength
// FUNCTION
//   Returns the current length of the char buffer wihtout modifying it. Note that this is the length 
//   in characters, not bytes, which may be different when the string contains unicode characters.
// SOURCE
int agk::GetCharBufferLength()
//****
{
	return m_sCharBuffer.GetLength();
}

//   AGK input

//****f* Input/Accelerometer/GetDirectionX
// FUNCTION
//   Returns the current direction value in the X direction. The direction is an emulated value that will
//   use an accelerometer where available or keyboard arrow keys if not.
// SOURCE
float agk::GetDirectionX()
//****
{
	if ( GetAccelerometerExists() == 1 ) FixOrientationByDefault();

	if ( GetAccelerometerExists() == 1 )
	{
		m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ACCEL;
		switch ( agk::GetOrientation() )
		{
			case 1 : return m_fAccelX;
			case 2 : return -m_fAccelX;
			case 3 : return m_fAccelY;
			case 4 : return -m_fAccelY;
		}
	}
	else if ( GetKeyboardExists() == 1 )
	{
		return m_fFakeAccelX;
	}

	return 0;
}

//****f* Input/Accelerometer/GetDirectionY
// FUNCTION
//   Returns the current direction value in the Y direction. The direction is an emulated value that will
//   use an accelerometer where available or keyboard arrow keys if not.
// SOURCE
float agk::GetDirectionY()
//****
{
	if ( GetAccelerometerExists() == 1 ) FixOrientationByDefault();

	if ( GetAccelerometerExists() == 1 )
	{
		m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ACCEL;
		switch ( agk::GetOrientation() )
		{
			case 1 : return m_fAccelY;
			case 2 : return -m_fAccelY;
			case 3 : return -m_fAccelX;
			case 4 : return m_fAccelX;
		}
	}
	else if ( GetKeyboardExists() == 1 )
	{
		return m_fFakeAccelY;
	}

	return 0;
}

//****f* Input/Accelerometer/GetDirectionAngle
// FUNCTION
//   Returns the current direction angle with respect to x=0, y=-1 (up). The angle will be in the range 0-360.
//   The direction is an emulated value that will use an accelerometer where available or keyboard arrow keys 
//   if not.
// SOURCE
float agk::GetDirectionAngle()
//****
{
	if ( GetAccelerometerExists() == 1 ) FixOrientationByDefault();

	float x = 0;
	if ( GetAccelerometerExists() == 1 )
	{
		m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ACCEL;
		switch ( agk::GetOrientation() )
		{
			case 1 : x = m_fAccelX; break;
			case 2 : x = -m_fAccelX; break;
			case 3 : x = m_fAccelY; break;
			case 4 : x = -m_fAccelY; break;
		}
	}
	else if ( GetKeyboardExists() == 1 ) x = m_fFakeAccelX;

	float y = 0;
	if ( GetAccelerometerExists() == 1 )
	{
		m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ACCEL;
		switch ( agk::GetOrientation() )
		{
			case 1 : y = m_fAccelY; break;
			case 2 : y = -m_fAccelY; break;
			case 3 : y = -m_fAccelX; break;
			case 4 : y = m_fAccelX; break;
		}
	}
	else if ( GetKeyboardExists() == 1 ) y = m_fFakeAccelY;

	if ( x == 0 && y == 0 ) return 0;
	return agk::ATanFull( x, y );
}

//****f* Input/Accelerometer/GetDirectionSpeed
// FUNCTION
//   Returns the current direction speed as an absolute value between 0 and 1.4, this is used with <i>GetDirectionAngle</i>
//   to determine the extent of the direction. The direction is an emulated value that will use an accelerometer where 
//   available or keyboard arrow keys if not.
// SOURCE
float agk::GetDirectionSpeed()
//****
{
	if ( GetAccelerometerExists() == 1 ) FixOrientationByDefault();

	float x = 0;
	if ( GetAccelerometerExists() == 1 )
	{
		m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ACCEL;
		switch ( agk::GetOrientation() )
		{
			case 1 : x = m_fAccelX; break;
			case 2 : x = -m_fAccelX; break;
			case 3 : x = m_fAccelY; break;
			case 4 : x = -m_fAccelY; break;
		}
	}
	else if ( GetKeyboardExists() == 1 ) x = m_fFakeAccelX;

	float y = 0;
	if ( GetAccelerometerExists() == 1 )
	{
		m_bSensorFlags |= AGK_SENSOR_ACTIVATE_ACCEL;
		switch ( agk::GetOrientation() )
		{
			case 1 : y = m_fAccelY; break;
			case 2 : y = -m_fAccelY; break;
			case 3 : y = -m_fAccelX; break;
			case 4 : y = m_fAccelX; break;
		}
	}
	else if ( GetKeyboardExists() == 1 ) y = m_fFakeAccelY;

	if ( x == 0 && y == 0 ) return 0;
	return agk::Sqrt( x*x + y*y );
}

//****f* Input/Pointer/GetPointerPressed
// FUNCTION
//   This is an emulated input method that uses whatever device inputs are available to produce a screen 
//   pointer. If the device has a mouse then this will return 1 if the left mouse button is pressed, 0 
//   if not. Otherwise the AGK will check for a touch screen and, if found, return 1 if one or more touch 
//   events exist. On devices that have neither mice nor touch screens the AGK will attempt to create 
//   some form of screen pointer controlled by analog sticks or similar. <br><br>
//   There are three commands for getting the state of the pointer press, <i>GetPointerPressed</i> returns 1 the 
//   instant the pointer is pressed and then returns 0, <i>GetPointerReleased</i> returns 1 the instant the pointer
//   is released and then returns 0, <i>GetPointerState</i> returns 1 the entire time the pointer is in the pressed 
//   state.
// SOURCE
int agk::GetPointerPressed()
//****
{
	if ( m_iPointerDown && !m_iLastPointerDown ) return 1;
	else return 0;
}

//****f* Input/Pointer/GetPointerReleased
// FUNCTION
//   This is an emulated input method that uses whatever device inputs are available to produce a screen 
//   pointer. If the device has a mouse then this will return 1 if the left mouse button is released, 0 
//   if not. Otherwise the AGK will check for a touch screen and, if found, return 1 if one or more touch 
//   events are released. On devices that have neither mice nor touch screens the AGK will attempt to create 
//   some form of screen pointer controlled by analog sticks or similar.<br><br>
//   There are three commands for getting the state of the pointer press, <i>GetPointerPressed</i> returns 1 the 
//   instant the pointer is pressed and then returns 0, <i>GetPointerReleased</i> returns 1 the instant the pointer
//   is released and then returns 0, <i>GetPointerState</i> returns 1 the entire time the pointer is in the pressed 
//   state.
// SOURCE
int agk::GetPointerReleased()
//****
{
	if ( !m_iPointerDown && m_iLastPointerDown ) return 1;
	else return 0;
}

//****f* Input/Pointer/GetPointerState
// FUNCTION
//   This is an emulated input method that uses whatever device inputs are available to produce a screen 
//   pointer. If the device has a mouse then this will return 1 if the left mouse button is currently down, 0 
//   if not. Otherwise the AGK will check for a touch screen and, if found, return 1 if one or more touch 
//   events are currently being pressed. On devices that have neither mice nor touch screens the AGK will 
//   attempt to create some form of screen pointer controlled by analog sticks or similar. <br><br>
//   There are three commands for getting the state of the pointer press, <i>GetPointerPressed</i> returns 1 the 
//   instant the pointer is pressed and then returns 0, <i>GetPointerReleased</i> returns 1 the instant the pointer
//   is released and then returns 0, <i>GetPointerState</i> returns 1 the entire time the pointer is in the pressed 
//   state.
// SOURCE
int agk::GetPointerState()
//****
{
	return m_iPointerDown;
}

//****f* Input/Pointer/GetPointerX
// FUNCTION
//   This is an emulated input method that uses whatever device inputs are available to produce a screen 
//   pointer. If the device has a mouse then this returns the current X position of the mouse. Otherwise
//   the AGK will check for a touch screen and, if found, will return the X position of the most recent 
//   touch event. If no events are taking place it is the last X position recorded by a touch event.
//   On devices that have neither mice nor touch screens the AGK will attempt to create some form of 
//   screen pointer controlled by analog sticks or similar.<br><br>
//   This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert 
//   it to world coordinates using <i>ScreenToWorldX</i>.
// SOURCE
float agk::GetPointerX()
//****
{
	return m_fPointerX;
	/*
	if ( GetMouseExists() == 1 )
	{
		return agk::GetRawMouseX();
	}
	else if ( GetMultiTouchExists() )
	{
		return cTouch::GetAnyX();
	}
	else return 0;
	*/
}

//****f* Input/Pointer/GetPointerY
// FUNCTION
//   This is an emulated input method that uses whatever device inputs are available to produce a screen 
//   pointer. If the device has a mouse then this returns the current Y position of the mouse. Otherwise
//   the AGK will check for a touch screen and, if found, will return the Y position of the most recent 
//   touch event. If no events are taking place it is the last Y position recorded by a touch event.
//   On devices that have neither mice nor touch screens the AGK will attempt to create some form of 
//   screen pointer controlled by analog sticks or similar.<br><br>
//   This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert 
//   it to world coordinates using <i>ScreenToWorldY</i>.
// SOURCE
float agk::GetPointerY()
//****
{
	return m_fPointerY;
	/*
	if ( GetMouseExists() == 1 )
	{
		return agk::GetRawMouseY();
	}
	else if ( GetMultiTouchExists() )
	{
		return cTouch::GetAnyY();
	}
	else return 0;
	*/
}

//****f* Input/Joystick/GetJoystickX
// FUNCTION
//   The AGK joystick is an emulated input method that uses whatever device inputs are available to produce a joystick
//   style input in the range -1 to 1. If a physical joystick is attached to the system then that will be used,
//   otherwise if a full sized keyboard is found the keys W,A,S,D will be used as the four directions for the 
//   joystick. If neither of these exist then a virtual joystick will be created on screen that can be controlled
//   with either a touch screen or mouse. The virtual joystick used will be index 1, if it already exists its values
//   will be fed into this emulated joystick command. You may position this virtual joystick at a position of your
//   choice on screen using <i>SetJoystickScreenPosition</i>. Every platform is guaranteed to have a method of generating 
//   an AGK joystick X value.
// SOURCE
float agk::GetJoystickX()
//****
{
	float value = 0;

	if ( agk::GetRawJoystickExists( 1 ) == 1 )
	{
		value = agk::GetRawJoystickX( 1 );
	}
	else if ( agk::GetKeyboardExists() == 1 )
	{
		value = m_fFakeJoystickX;
	}
	else if ( agk::GetVirtualJoystickExists( 1 ) == 1 )
	{
		value = agk::GetVirtualJoystickX( 1 );
	}
	else
	{
		float size = 1;
		if ( agk::GetDisplayAspect() > 1 ) size = m_iDisplayHeight / 4.0f;
		else size = m_iDisplayWidth / 4.0f;
		
		agk::AddVirtualJoystick( 1, size*0.6f, m_iDisplayHeight - (size*0.6f*agk::GetStretchValue()), size );
		value = agk::GetVirtualJoystickX( 1 );
	}

	if ( agk::Abs(value) < m_fJoystickDeadZone ) return 0;
	else return value;
}

//****f* Input/Joystick/GetJoystickY
// FUNCTION
//   The AGK joystick is an emulated input method that uses whatever device inputs are available to produce a joystick
//   style input in the range -1 to 1. If a physical joystick is attached to the system then that will be used,
//   otherwise if a full sized keyboard is found the keys W,A,S,D will be used as the four directions for the 
//   joystick. If neither of these exist then a virtual joystick will be created on screen that can be controlled
//   with either a touch screen or mouse. The virtual joystick used will be index 1, if it already exists its values
//   will be fed into this emulated joystick command. You may position this virtual joystick at a position of your
//   choice on screen using <i>SetJoystickScreenPosition</i>. Every platform is guaranteed to have a method of generating 
//   an AGK joystick Y value.
// SOURCE
float agk::GetJoystickY()
//****
{
	float value = 0;

	if ( agk::GetRawJoystickExists( 1 ) == 1 )
	{
		value = agk::GetRawJoystickY( 1 );
	}
	else if ( agk::GetKeyboardExists() == 1 )
	{
		value = m_fFakeJoystickY;
	}
	else if ( agk::GetVirtualJoystickExists( 1 ) == 1 )
	{
		value = agk::GetVirtualJoystickY( 1 );
	}
	else
	{
		float size = 1;
		if ( agk::GetDisplayAspect() > 1 ) size = m_iDisplayHeight / 4.0f;
		else size = m_iDisplayWidth / 4.0f;

		agk::AddVirtualJoystick( 1, size*0.6f, m_iDisplayHeight - (size*0.6f*agk::GetStretchValue()), size );
		value = agk::GetVirtualJoystickY( 1 );
	}

	if ( agk::Abs(value) < m_fJoystickDeadZone ) return 0;
	else return value;
}

//****f* Input/Joystick/SetJoystickDeadZone
// FUNCTION
//   Sets the dead zone for the universal joysticks so that any X or Y value below the given threshold will return 0 instead.
//   This value must be between 0 and 1, by default it is set to 0.15.
// INPUTS
//   threshold -- The value below which 0 will be returned.
// SOURCE
void agk::SetJoystickDeadZone( float threshold )
//****
{
	m_fJoystickDeadZone = threshold;
}


//****f* Input/Joystick/SetJoystickScreenPosition
// FUNCTION
//   The AGK joystick is an emulated input method that uses whatever device inputs are available to produce a joystick
//   style input in the range -1 to 1. This command positions a virtual joystick on screen only if it is necessary to 
//   emulate this input. For example if a real joystick or keyboard are available then this command has no noticeable effect.
//   It is recommended that you always call this command anyway if you intend to use <i>GetJoystickX</i> or <i>GetJoystickY</i>
//   just incase a virtual joystick is needed. Any virtual joystick will be centered on the given X and Y position.
// INPUTS
//   x -- The X coordinate of the new position in screen coordinates.
//   y -- The Y coordinate of the new position in screen coordinates.
//   size -- The diameter of the joystick in screen coordinates.
// SOURCE
void agk::SetJoystickScreenPosition( float x, float y, float size )
//****
{
	if ( agk::GetRawJoystickExists( 1 ) == 1 )
	{
		return;
	}
	else if ( agk::GetKeyboardExists() == 1 )
	{
		return;
	}
	else if ( agk::GetVirtualJoystickExists( 1 ) == 1 )
	{
		agk::SetVirtualJoystickPosition( 1, x, y );
		agk::SetVirtualJoystickSize( 1, size );
	}
	else 
	{
		agk::AddVirtualJoystick( 1, x, y, size );
	}
}

//****f* Input/Button/GetButtonPressed
// FUNCTION
//   This function returns 1 if the specified button has just been pressed, then returns 0 while the button is held down. 
//   The AGK buttons are an emulated input method that uses whatever device inputs are available to produce 5 buttons. 
//   If a real joystick is found then the first 5 buttons from that will be used for the AGK button commands. 
//   Otherwise the AGK looks for a full-size keyboard and if found will use the following keys in the following order 
//   Space, E, R, Q, Control, to represent buttons 1 to 5 respectively. If neither a joystick nor keyboard is found
//   then a virtual button is created that will appear on screen and can be pressed with either touch screen inputs or a 
//   mouse. Every platform is guaranteed to have a method of activating the AGK buttons.
// INPUTS
//   index -- The ID of the button to check, must be in the range 1 to 5 inclusive.
// SOURCE
int agk::GetButtonPressed( uint32_t index )
//****
{
	if ( index == 0 || index > 5 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid AGK button index, valid range is 1-5" );
#endif
		return 0;
	}

	if ( agk::GetRawJoystickExists( 1 ) == 1 )
	{
		return agk::GetRawJoystickButtonPressed( 1, index );
	}
	else if ( agk::GetKeyboardExists() == 1 )
	{
		uint32_t button = 0;
		switch( index )
		{
			case 1: button = AGK_KEY_SPACE; break;
			case 2: button = AGK_KEY_E; break;
			case 3: button = AGK_KEY_R; break;
			case 4: button = AGK_KEY_Q; break;
			case 5: button = AGK_KEY_CONTROL; break;
		}

		if ( !m_iPrevKeyDown[ button ] && m_iKeyDown[ button ] ) return 1;
		return 0;
	}
	else if ( agk::GetVirtualButtonExists( index ) == 1 )
	{
		return agk::GetVirtualButtonPressed( index );
	}
	else
	{
		// create virtual button
		float size = m_iDisplayHeight/5.0f;
		agk::AddVirtualButton( index, m_iDisplayWidth - size*0.7f, m_iDisplayHeight - ((index-1)*size) - size*0.5f, size );
		return agk::GetVirtualButtonPressed( index );
	}
}

//****f* Input/Button/GetButtonState
// FUNCTION
//   This function returns 1 if the specified button is currently being held down.<br><br> 
//   The AGK buttons are an emulated input method that uses whatever device inputs are available to produce 5 buttons. 
//   If a real joystick is found then the first 5 buttons from that will be used for the AGK button commands. 
//   Otherwise the AGK looks for a full-size keyboard and if found will use the following keys in the following order 
//   Space, E, R, Q, Control, to represent buttons 1 to 5 respectively. If neither a joystick nor keyboard is found
//   then a virtual button is created that will appear on screen and can be pressed with either touch screen inputs or a 
//   mouse. Every platform is guaranteed to have a method of activating the AGK buttons.
// INPUTS
//   index -- The ID of the button to check, must be in the range 1 to 5 inclusive.
// SOURCE
int agk::GetButtonState( uint32_t index )
//****
{
	if ( index == 0 || index > 5 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid AGK button index, valid range is 1-5" );
#endif
		return 0;
	}

	if ( agk::GetRawJoystickExists( 1 ) == 1 )
	{
		return agk::GetRawJoystickButtonState( 1, index );
	}
	else if ( agk::GetKeyboardExists() == 1 )
	{
		uint32_t button = 0;
		switch( index )
		{
			case 1: button = AGK_KEY_SPACE; break;
			case 2: button = AGK_KEY_E; break;
			case 3: button = AGK_KEY_R; break;
			case 4: button = AGK_KEY_Q; break;
			case 5: button = AGK_KEY_CONTROL; break;
		}

		return m_iKeyDown[ button ];
	}
	else if ( agk::GetVirtualButtonExists( index ) == 1 )
	{
		return agk::GetVirtualButtonState( index );
	}
	else
	{
		// create virtual button
		float size = m_iDisplayHeight/5.0f;
		agk::AddVirtualButton( index, m_iDisplayWidth - size*0.7f, m_iDisplayHeight - ((index-1)*size) - size*0.5f, size );
		return agk::GetVirtualButtonState( index );
	}
}

//****f* Input/Button/GetButtonReleased
// FUNCTION
//   This function returns 1 if the specified button has just been released, then returns 0 whilst the button is up. 
//   The AGK buttons are an emulated input method that uses whatever device inputs are available to produce 5 buttons. 
//   If a real joystick is found then the first 5 buttons from that will be used for the AGK button commands. 
//   Otherwise the AGK looks for a full-size keyboard and if found will use the following keys in the following order 
//   Space, E, R, Q, Control, to represent buttons 1 to 5 respectively. If neither a joystick nor keyboard is found
//   then a virtual button is created that will appear on screen and can be pressed with either touch screen inputs or a 
//   mouse. Every platform is guaranteed to have a method of activating the AGK buttons.
// INPUTS
//   index -- The ID of the button to check, must be in the range 1 to 5 inclusive.
// SOURCE
int agk::GetButtonReleased( uint32_t index )
//****
{
	if ( index == 0 || index > 5 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid AGK button index, valid range is 1-5" );
#endif
		return 0;
	}

	if ( agk::GetRawJoystickExists( 1 ) == 1 )
	{
		return agk::GetRawJoystickButtonReleased( 1, index );
	}
	else if ( agk::GetKeyboardExists() == 1 )
	{
		uint32_t button = 0;
		switch( index )
		{
			case 1: button = AGK_KEY_SPACE; break;
			case 2: button = AGK_KEY_E; break;
			case 3: button = AGK_KEY_R; break;
			case 4: button = AGK_KEY_Q; break;
			case 5: button = AGK_KEY_CONTROL; break;
		}

		return m_iKeyDown[ button ];
	}
	else if ( agk::GetVirtualButtonExists( index ) == 1 )
	{
		return agk::GetVirtualButtonState( index );
	}
	else
	{
		// create virtual button
		float size = m_iDisplayHeight/5.0f;
		agk::AddVirtualButton( index, m_iDisplayWidth - size*0.7f, m_iDisplayHeight - ((index-1)*size) - size*0.5f, size );
		return agk::GetVirtualButtonState( index );
	}
}

//****f* Input/Button/SetButtonScreenPosition
// FUNCTION
//   This function positions a virtual button at the given position only if it is necessary for this device, for example
//   if a real joystick or keyboard are present then this command will have no noticeable effect. It is recommended you
//   call this command anyway, just in case a virtual button is needed.<br><br>
//   The AGK buttons are an emulated input method that uses whatever device inputs are available to produce 5 buttons. 
//   If a real joystick is found then the first 5 buttons from that will be used for the AGK button commands. 
//   Otherwise the AGK looks for a full-size keyboard and if found will use the following keys in the following order 
//   Space, E, R, Q, Control, to represent buttons 1 to 5 respectively. If neither a joystick nor keyboard is found
//   then a virtual button is created that will appear on screen and can be pressed with either touch screen inputs or a 
//   mouse. Every platform is guaranteed to have a method of activating the AGK buttons.
//   If a virtual button is created it will be centered on the given X,Y position.
// INPUTS
//   index -- The ID of the button to position, must be in the range 1 to 5 inclusive.
//   x -- The X coordinate of the button position in screen coordinates.
//   y -- The Y coordinate of the button position in screen coordinates.
//   size -- The diameter of the button position in screen coordinates.
// SOURCE
void agk::SetButtonScreenPosition( uint32_t index, float x, float y, float size )
//****
{
	if ( index == 0 || index > 5 ) 
	{
#ifdef _AGK_ERROR_CHECK
		agk::Error( "Invalid AGK button index, valid range is 1-5" );
#endif
		return;
	}

	if ( agk::GetRawJoystickExists( 1 ) == 1 )
	{
		return;
	}
	else if ( agk::GetKeyboardExists() == 1 )
	{
		return;
	}
	else if ( agk::GetVirtualButtonExists( index ) == 1 )
	{
		agk::SetVirtualButtonPosition( index, x, y );
		agk::SetVirtualButtonSize( index, size );
	}
	else
	{
		// create virtual button
		agk::AddVirtualButton( index, x, y, size );
	}
}

// text input

//****f* Input/Text Input/StartTextInput
// FUNCTION
//   This command pops up a text entry prompt over your app whilst your app continues in the background.
//   Accepted characters are ASCII values in the range 32 to 126 inclusive, unless you have activated the new 
//   default fonts with <i>UseNewDefaultFonts</i>, in which case any Unicode characters can be used. If a virtual keyboard is required
//   for text entry on this device then it will be displayed over your app. You cannot assume that any part of 
//   your app will be visible whilst text entry is in progress, although your code will continue running.
//   When the user has finished entering text <i>GetTextInputCompleted</i> will return 1 and <i>GetTextInputCancelled</i>
//   will let you know if they completed the text entry or cancelled it. On keyboard based devices cancelling 
//   is done with the escape key whilst completing is done with the enter key. If successful you can get the 
//   inputted text with <i>GetTextInput</i>.
// SOURCE
void agk::StartTextInput( )
//****
{
	if ( m_bInputStarted ) return;
	
	PlatformStartTextInput( "" );

	m_bInputStartedPrev = true;
	m_bInputStarted = true;
	m_bInputCancelled = false;
}
    
//****f* Input/Text Input/StartTextInput
// FUNCTION
//   This command pops up a text entry prompt over your app whilst your app continues in the background.
//   Accepted characters are ASCII values in the range 32 to 126 inclusive, unless you have activated the new 
//   default fonts with <i>UseNewDefaultFonts</i>, in which case any Unicode characters can be used. If a virtual keyboard is required
//   for text entry on this device then it will be displayed over your app. You cannot assume that any part of 
//   your app will be visible whilst text entry is in progress, although your code will continue running.
//   When the user has finished entering text <i>GetTextInputCompleted</i> will return 1 and <i>GetTextInputCancelled</i>
//   will let you know if they completed the text entry or cancelled it. On keyboard based devices cancelling 
//   is done with the escape key whilst completing is done with the enter key. If successful you can get the 
//   inputted text with <i>GetTextInput</i>.
// INPUTS
//   initial -- The initial string to display to the user that they can edit.
// SOURCE
void agk::StartTextInput( const char* initial )
//****
{
    if ( m_bInputStarted ) return;
    
	m_sCurrInput.SetStr( initial );
    
    PlatformStartTextInput( initial );

	m_bInputStartedPrev = true;
    m_bInputStarted = true;
    m_bInputCancelled = false;
}

//****f* Input/Text Input/StopTextInput
// FUNCTION
//   This command stops and hides any text entry prompt previously started with StartTextInput command.
// SOURCE
void agk::StopTextInput( )
//****
{
	// end any text entry
	PlatformStopTextInput();
	m_bInputStarted = false;
}

//****f* Input/Text Input/GetTextInputState
// FUNCTION
//   Returns 0 if the user is currently inputting text, 1 if not.
// SOURCE
int agk::GetTextInputState()
//****
{
	return !m_bInputStarted ? 1 : 0;
}

//****f* Input/Text Input/GetTextInputCompleted
// FUNCTION
//   Returns 1 for the frame that the user completed inputting text (successfully or not). After completion
//   this command will return to 0. At this point you can check if the user cancelled the input by using
//   <i>GetTextInputCancelled</i>.
// SOURCE
int agk::GetTextInputCompleted()
//****
{
	return m_bInputStartedPrev && !m_bInputStarted ? 1 : 0;
}

//****f* Input/Text Input/GetTextInputCancelled
// FUNCTION
//   Returns 1 if the user cancelled the text input, 0 if not. This commands value is not defined until 
//   <i>GetTextInputCompleted</i> returns 1.
// SOURCE
int agk::GetTextInputCancelled()
//****
{
	return m_bInputCancelled ? 1 : 0;
}

//****f* Input/Text Input/GetTextInput
// FUNCTION
//   Returns the string that the user input. It will contain characters encoded with UTF-8, some devices
//   may also allow newline characters to be returned. This commands value is not defined until 
//   <i>GetTextInputCompleted</i> returns 1.
// SOURCE
char* agk::GetTextInput()
//****
{
	char *str = new char[ m_sCurrInput.GetLength() + 1 ];
	strcpy( str, m_sCurrInput.GetStr() );
	return str;
}

int agk::GetTextInput( uString &out )
{
	out.SetStr( m_sCurrInput );
	return out.GetLength();
}

uint32_t agk::GetPrevChar()
{
	return m_iLastChar;
}

//****f* Input/Text Input/GetLastChar
// FUNCTION
//   Returns the unicode value of the last character input
// SOURCE
uint32_t agk::GetLastChar()
//****
{
	return m_iCurrChar;
}

//****f* Input/Text Input/SetCursorBlinkTime
// FUNCTION
//   Sets the time in seconds between the cursor appearing and disappearing in the fullscreen edit box
// INPUTS
//   seconds -- The time in seconds.
// SOURCE
void agk::SetCursorBlinkTime( float seconds )
//****
{
	if ( seconds < 0 ) seconds = 0;
	m_fCursorBlinkDelay = seconds;
}

//****f* Input/Text Input/SetTextInputMaxChars
// FUNCTION
//   Sets the maximum number of characters that can be entered in the fullscreen edit box. Use 0 for unlimited.
// INPUTS
//   max -- The maximum number of characters.
// SOURCE
void agk::SetTextInputMaxChars( int max )
//****
{
	if ( max < 0 ) max = 0;
	m_iInputMaxChars = max;
}

void agk::SetTextInputLabel( const char* str )
{
	m_sInputLabel.SetStr( str );
}

// edit boxes

//****f* Input/Edit Box/CreateEditBox
// FUNCTION
//   Create an edit box with a specified ID that can be positioned anywhere on screen.
// INPUTS
//   index -- The ID to use for this edit box.
// SOURCE
void agk::CreateEditBox( uint32_t index )
//****
{
	if ( m_cEditBoxList.GetItem( index ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add edit box " );
		errStr.AppendUInt( index ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cEditBox *pEditBox = new cEditBox();
	pEditBox->SetID( index );
	m_cEditBoxList.AddItem( pEditBox, index );
	m_cSpriteMgrFront.AddEditBox( pEditBox );
}

//****f* Input/Edit Box/CreateEditBox
// FUNCTION
//   Create an edit box that can be positioned anywhere on screen. It returns the ID used to reference this 
//   edit box later.
// SOURCE
uint32_t agk::CreateEditBox()
//****
{
	uint32_t iID = m_cEditBoxList.GetFreeID( MAX_EDITBOXES );
	
	if ( iID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add edit box " );
		errStr.Append( " - no free ID found" );
		Error( errStr );
#endif
		return 0;
	}

	agk::CreateEditBox( iID );
	return iID;
}

//****f* Input/Edit Box/GetEditBoxExists
// FUNCTION
//   Returns 1 if an edit box with the given ID exists, 0 otherwise.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
int agk::GetEditBoxExists( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	return pEditBox ? 1 : 0;
}

//****f* Input/Edit Box/DeleteEditBox
// FUNCTION
//   Deletes any edit box at the given ID.
// INPUTS
//   index -- The ID of the edit box to delete.
// SOURCE
void agk::DeleteEditBox( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.RemoveItem( index );
	if ( pEditBox ) 
	{
		m_cSpriteMgrFront.RemoveEditBox( pEditBox );
		delete pEditBox;
	}
}

//****f* Input/Edit Box/GetEditBoxHasFocus
// FUNCTION
//   Returns 1 if the edit box has been clicked on and is accepting input.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
int agk::GetEditBoxHasFocus( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->HasFocus() ? 1 : 0;
}

//****f* Input/Edit Box/GetCurrentEditBox
// FUNCTION
//   Returns the ID of the currently active edit box, only one edit box may focus at a time. If no
//   edit box currently has focus it returns 0.
// SOURCE
uint32_t agk::GetCurrentEditBox()
//****
{
	if ( m_cEditBoxList.GetCount() == 0 ) return 0;

	cEditBox *pEditBox = m_cEditBoxList.GetFirst();
	while ( pEditBox )
	{
		if ( pEditBox->HasFocus() ) return pEditBox->GetID();
		pEditBox = m_cEditBoxList.GetNext();
	}

	return 0;
}

//****f* Input/Edit Box/SetEditBoxPosition
// FUNCTION
//   Sets the position in world coordinates of the edit box using it's top left corner. This sets the position of the actual 
//   text entry box, its border will extend to the left and above this point.
// INPUTS
//   index -- The ID of the edit box to modify.
//   x -- The X value of the position.
//   y -- The Y value of the position.
// SOURCE
void agk::SetEditBoxPosition( uint32_t index, float x, float y )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetPosition( x, y );
}

//****f* Input/Edit Box/SetEditBoxSize
// FUNCTION
//   Sets the size of the edit box in world coordinates. This sets the size of the actual text entry box, its border 
//   will extend beyond these values. SetEditBoxSize will make the text smaller if it is too tall for the new edit box height.
// INPUTS
//   index -- The ID of the edit box to modify.
//   width -- The width of the new size.
//   height -- The height of the new size.
// SOURCE
void agk::SetEditBoxSize( uint32_t index, float width, float height )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetSize( width, height );
}

//****f* Input/Edit Box/SetEditBoxDepth
// FUNCTION
//   Sets the depth of the edit box so it may appear behind or infront of other sprites and text objects.
// INPUTS
//   index -- The ID of the edit box to modify.
//   depth -- The depth in the range 0 (front) to 10000 (back).
// SOURCE
void agk::SetEditBoxDepth( uint32_t index, int depth )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetDepth( depth );
}

//****f* Input/Edit Box/SetEditBoxBorderSize
// FUNCTION
//   Sets the size of the border in world coordinates that will surround the text entry box. For example a value of
//   2 would add a 2 pixel border around the entry box.
// INPUTS
//   index -- The ID of the edit box to modify.
//   size -- The size of the border.
// SOURCE
void agk::SetEditBoxBorderSize( uint32_t index, float size )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetBorderSize( size );
}

//****f* Input/Edit Box/SetEditBoxBorderColor
// FUNCTION
//   Sets the color of any border present. You can also use an image by using SetEditBoxBorderImage().
// INPUTS
//   index -- The ID of the edit box to modify.
//   red -- The red component of the color (0 to 255).
//   green -- The green component of the color (0 to 255).
//   blue -- The blue component of the color (0 to 255).
//   alpha -- The alpha component of the color (0 to 255). 255 is fully opaque.
// SOURCE
void agk::SetEditBoxBorderColor( uint32_t index, uint32_t red, uint32_t green, uint32_t blue, uint32_t alpha )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetBorderColor( red, green, blue, alpha );
}

//****f* Input/Edit Box/SetEditBoxBackgroundColor
// FUNCTION
//   Sets the color of the main text entry box.
// INPUTS
//   index -- The ID of the edit box to modify.
//   red -- The red component of the color (0 to 255).
//   green -- The green component of the color (0 to 255).
//   blue -- The blue component of the color (0 to 255).
//   alpha -- The alpha component of the color (0 to 255). 255 is fully opaque.
// SOURCE
void agk::SetEditBoxBackgroundColor( uint32_t index, uint32_t red, uint32_t green, uint32_t blue, uint32_t alpha )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetBackgroundColor( red, green, blue, alpha );
}

//****f* Input/Edit Box/SetEditBoxText
// FUNCTION
//   Sets the text which is currently being displayed in the edit box.
// INPUTS
//   index -- The ID of the edit box to modify.
//   str -- The new text to display.
// SOURCE
void agk::SetEditBoxText( uint32_t index, const char *str )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetText( str );
}

//****f* Input/Edit Box/SetEditBoxTextColor
// FUNCTION
//   Sets the color of the text being input.
// INPUTS
//   index -- The ID of the edit box to modify.
//   red -- The red component of the color (0 to 255).
//   green -- The green component of the color (0 to 255).
//   blue -- The blue component of the color (0 to 255).
// SOURCE
void agk::SetEditBoxTextColor( uint32_t index, uint32_t red, uint32_t green, uint32_t blue )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetTextColor( red, green, blue );
}

//****f* Input/Edit Box/SetEditBoxCursorColor
// FUNCTION
//   Sets the color of the flashing cursor in this edit box.
// INPUTS
//   index -- The ID of the edit box to modify.
//   red -- The red component of the color (0 to 255).
//   green -- The green component of the color (0 to 255).
//   blue -- The blue component of the color (0 to 255).
// SOURCE
void agk::SetEditBoxCursorColor( uint32_t index, uint32_t red, uint32_t green, uint32_t blue )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetCursorColor( red, green, blue );
}

//****f* Input/Edit Box/SetEditBoxFontImage
// FUNCTION
//   Sets the font image to use for this edit box, must have been previously loaded with LoadImage(). Use 0 to return
//   the edit box to its default font.
// INPUTS
//   index -- The ID of the edit box to modify.
//   image -- The ID of the image to use, 0 for default font.
// SOURCE
void agk::SetEditBoxFontImage( uint32_t index, uint32_t image )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	cImage* pImage = 0;
	if ( image > 0 )
	{
		pImage = m_cImageList.GetItem( image );
		if ( !pImage )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set edit box font - Image ", 50 );  errStr.AppendInt( image );  errStr.Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}

	pEditBox->SetFontImage( pImage );
}
    
//****f* Input/Edit Box/SetEditBoxExtendedFontImage
// FUNCTION
//   Sets the extended font image to use for this edit box, must have been previously loaded with LoadImage(). Use 0 to remove
//   the extended font image. If you do not set this image the edit box will not accept extended characters such as    etc.
// INPUTS
//   index -- The ID of the edit box to modify.
//   image -- The ID of the image to use, 0 to use no image.
// SOURCE
void agk::SetEditBoxExtendedFontImage( uint32_t index, uint32_t image )
//****
{
    cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
    if ( !pEditBox )
    {
#ifdef _AGK_ERROR_CHECK
        uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
        Error( errStr );
#endif
        return;
    }
    
    cImage* pImage = 0;
    if ( image > 0 )
    {
        pImage = m_cImageList.GetItem( image );
        if ( !pImage )
        {
#ifdef _AGK_ERROR_CHECK
            uString errStr( "Failed to set edit box extended font - Image ", 50 );  errStr.AppendInt( image );  errStr.Append( " does not exist" );
            Error( errStr );
#endif
            return;
        }
    }
    
    pEditBox->SetExtendedFontImage( pImage );
}

//****f* Input/Edit Box/SetEditBoxFont
// FUNCTION
//   Sets the font to use for this edit box, must have been previously loaded with <i>LoadFont</i>. Use 0 to return
//   the edit box to its default font.
// INPUTS
//   index -- The ID of the edit box to modify.
//   fontID -- The ID of the font to use, 0 for default font.
// SOURCE
void agk::SetEditBoxFont( uint32_t index, uint32_t fontID )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	AGKFont* pFont = 0;
	if ( fontID > 0 )
	{
		pFont = m_cFontList.GetItem( fontID );
		if ( !pFont )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set edit box font - Font ", 50 );  errStr.AppendInt( fontID );  errStr.Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}

	pEditBox->SetFont( pFont );
}

//****f* Input/Edit Box/SetEditBoxTextSize
// FUNCTION
//   Sets the height in world coordinates of the text in this edit box. By default it is set to the edit box's height minus 2.
//   SetEditBoxTextSize will not allow the text height to be set greater than the height of the edit box.
// INPUTS
//   index -- The ID of the edit box to modify.
//   size -- The new size of font to use.
// SOURCE
void agk::SetEditBoxTextSize( uint32_t index, float size )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetTextSize( size );
}

//****f* Input/Edit Box/SetEditBoxCursorPosition
// FUNCTION
//   Sets the cursor to the specified position in the text, i.e. position 0 is left of the first character,
//   position 1 is left of the second character, and so on. If the position value is out of range it will 
//   be clamped to the nearest character. The current cursor position is guaranteed to be in view of the 
//   user, so this can be used to left or right justify text by setting the cursor to the far left or right
//   of the text.
// INPUTS
//   index -- The ID of the edit box to modify.
//   pos -- The new position of the cursor
// SOURCE
void agk::SetEditBoxCursorPosition( uint32_t index, int pos )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetCursorPosition( pos );
}

//****f* Input/Edit Box/SetEditBoxFocus
// FUNCTION
//   Toggles the focus status of this edit box, when focus is set to 1 the cursor starts flashing and any key presses
//   will add text to the edit box. When set to 0 the cursor disappears and text will not be added.
// INPUTS
//   index -- The ID of the edit box to modify.
//   focus -- The new state of the edit box, 1 for active, 0 for inactive.
// SOURCE
void agk::SetEditBoxFocus( uint32_t index, int focus )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetFocus( focus > 0 );
}

//****f* Input/Edit Box/SetEditBoxActive
// FUNCTION
//   Toggles the active status of this edit box, when active is set to 1 the edit box can be clicked on, gain focus
//   and be changed, when set to 0 the edit box cannot be changed nor gain focus.
// INPUTS
//   index -- The ID of the edit box to modify.
//   active -- The new state of the edit box, 1 for active, 0 for inactive.
// SOURCE
void agk::SetEditBoxActive( uint32_t index, int active )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetActive( active > 0 );
}

//****f* Input/Edit Box/SetEditBoxVisible
// FUNCTION
//   Toggles the visible status of this edit box, when visible is set to 1 the edit box can be clicked on, gain focus
//   and be changed, when set to 0 the edit box is not shown, cannot be changed, nor gain focus.
// INPUTS
//   index -- The ID of the edit box to modify.
//   visible -- The new state of the edit box, 1 for visible, 0 for invisible.
// SOURCE
void agk::SetEditBoxVisible( uint32_t index, int visible )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetVisible( visible > 0 );
}

//****f* Input/Edit Box/SetEditBoxBorderImage
// FUNCTION
//   Sets an image to use for the border, this can be used together with the border color. Use 0 to remove 
//   the border image.
// INPUTS
//   index -- The ID of the edit box to modify.
//   image -- The ID of the image to use.
// SOURCE
void agk::SetEditBoxBorderImage( uint32_t index, uint32_t image )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	cImage* pImage = 0;
	if ( image > 0 )
	{
		pImage = m_cImageList.GetItem( image );
		if ( !pEditBox )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set edit box border - Image ", 50 );  errStr.AppendInt( image );  errStr.Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}

	pEditBox->SetBorderImage( pImage );
}

//****f* Input/Edit Box/SetEditBoxBackgroundImage
// FUNCTION
//   Sets an image to use for the background, this can be used together with the background color. Use 0 to remove 
//   the background image.
// INPUTS
//   index -- The ID of the edit box to modify.
//   image -- The ID of the image to use.
// SOURCE
void agk::SetEditBoxBackgroundImage( uint32_t index, uint32_t image )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	cImage* pImage = 0;
	if ( image > 0 )
	{
		pImage = m_cImageList.GetItem( image );
		if ( !pEditBox )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set edit box background - Image ", 50 );  errStr.AppendInt( image );  errStr.Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}

	pEditBox->SetBackgroundImage( pImage );
}

//****f* Input/Edit Box/SetEditBoxCursorBlinkTime
// FUNCTION
//   Sets the time in seconds between the cursor being visible and invisible in the text entry box.
// INPUTS
//   index -- The ID of the edit box to modify.
//   time -- The time in seconds.
// SOURCE
void agk::SetEditBoxCursorBlinkTime( uint32_t index, float time )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetCursorBlinkTime( time );
}

//****f* Input/Edit Box/SetEditBoxCursorWidth
// FUNCTION
//   Sets the width in world coordinates of the text input cursor, by default this is set to 1.5
//   Note that functions that change the text size or edit box size may overwrite this value.
// INPUTS
//   index -- The ID of the edit box to modify.
//   width -- The new width of the cursor.
// SOURCE
void agk::SetEditBoxCursorWidth( uint32_t index, float width )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetCursorWidth( width );
}

//****f* Input/Edit Box/SetEditBoxMaxChars
// FUNCTION
//   Sets the maximum number of characters that can be entered in this edit box. Use 0 for unlimited.
// INPUTS
//   index -- The ID of the edit box to modify.
//   max -- The maximum number of characters.
// SOURCE
void agk::SetEditBoxMaxChars( uint32_t index, uint32_t max )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetMaxChars( max );
}

//****f* Input/Edit Box/SetEditBoxMaxLines
// FUNCTION
//   Sets the maximum number of lines that can be entered into this multiline edit box. Use 0 for unlimited.
// INPUTS
//   index -- The ID of the edit box to modify.
//   max -- The maximum number of lines.
// SOURCE
void agk::SetEditBoxMaxLines( uint32_t index, uint32_t max )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetMaxLines( max );
}

//****f* Input/Edit Box/SetEditBoxMultiLine
// FUNCTION
//   Sets whether the edit box will wrap text to a new line when it reaches the edge of the edit box.
//   The default is for multiline to be 0 so text is one continuous line in the box.
// INPUTS
//   index -- The ID of the edit box to modify.
//   multiline -- 1 to enable multiline, 0 to disable.
// SOURCE
void agk::SetEditBoxMultiLine( uint32_t index, int multiline )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetMultiLine( multiline > 0 );
}

//****f* Input/Edit Box/SetEditBoxScissor
// FUNCTION
//   Clips the edit box to the specified world coordinates when drawn. 
// INPUTS
//   index -- The ID of the edit box to modify.
//   x -- The x coordinate of the top left corner of the box to use as a clip boundary.
//   y -- The y coordinate of the top left corner of the box to use as a clip boundary.
//   x2 -- The x coordinate of the bottom right corner of the box to use as a clip boundary.
//   y2 -- The y coordinate of the bottom right corner of the box to use as a clip boundary.
// SOURCE
void agk::SetEditBoxScissor( uint32_t index, float x, float y, float x2, float y2 )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetScissor( x, y, x2, y2 );
}

//****f* Input/Edit Box/SetEditBoxPasswordMode
// FUNCTION
//   Sets whether the edit box display stars instead of the text input. Using <i>GetEditBoxText</i> will still return
//   the actual characters entered by the user.
// INPUTS
//   index -- The ID of the edit box to modify.
//   mode -- 1 to display stars, 0 to display the normal input.
// SOURCE
void agk::SetEditBoxPasswordMode( uint32_t index, int mode )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->SetPasswordMode( mode );
}
    
//****f* Input/Edit Box/SetEditBoxUseAlternateInput
// FUNCTION
//   Sets whether the edit box will use an alternate text input method if the edit box would be hidden by a
//   virtual keyboard. This only applies to mobile platforms like iOS and Android and the alternate input
//   method is usually a smaller edit box placed just above the keyboard. The edit box will still update
//   in real time as if it is being typed into directly, but since it is covered by the keyboard the user will
//   not see it. By default this is turned on. If you wish you can turn it off and move the edit box into view
//   when GetEditBoxHasFocus returns 1, be sure to move it back again when GetEditBoxHasFocus returns 0.
// INPUTS
//   index -- The ID of the edit box to modify.
//   mode -- 1 to use alternate input (default), 0 to use the normal input.
// SOURCE
void agk::SetEditBoxUseAlternateInput( uint32_t index, int mode )
//****
{
    cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
    if ( !pEditBox )
    {
#ifdef _AGK_ERROR_CHECK
        uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
        Error( errStr );
#endif
        return;
    }
    
    pEditBox->SetUseAlternateInput( mode );
}

//****f* Input/Edit Box/SetEditBoxWrapMode
// FUNCTION
//   When SetEditBoxMultiLine is set to 0 this command sets whether the single line of text will scroll to the
//   right or wrap to a new line when it over flows the edit box width. The use will still not be allowed to enter
//   new line characters themselves.
// INPUTS
//   index -- The ID of the edit box to modify.
//   mode -- 0 to scroll to the right (default), 1 to wrap to a new line.
// SOURCE
void agk::SetEditBoxWrapMode( uint32_t index, int mode )
//****
{
    cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
    if ( !pEditBox )
    {
#ifdef _AGK_ERROR_CHECK
        uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
        Error( errStr );
#endif
        return;
    }
    
    pEditBox->SetWrapMode( mode );
}

//****f* Input/Edit Box/SetEditBoxInputType
// FUNCTION
//   Sets the type of keyboard that will appear on mobile devices when editing this edit box. Where possible a keyboard 
//   of that type will be displayed, for example a keyboard with numbers only.
// INPUTS
//   index -- The ID of the edit box to modify.
//   inputType -- 0 for normal text, 1 for numbers only.
// SOURCE
void agk::SetEditBoxInputType( uint32_t index, int inputType )
//****
{
    cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
    if ( !pEditBox )
    {
#ifdef _AGK_ERROR_CHECK
        uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
        Error( errStr );
#endif
        return;
    }
    
    pEditBox->SetInputType( inputType );
}

//****f* Input/Edit Box/FixEditBoxToScreen
// FUNCTION
//   By default sprites and edit boxes are created in world coordinates and <i>SetViewOffset</i> can be used to 
//   move around the world. Use this command to instead fix the edit box to the screen so it will move with the 
//   viewport when the viewport is moved around. You can still reposition an edit box that is fixed to the screen, 
//   it only affects what happens when the viewport is moved.
// INPUTS
//   index -- The ID of the edit box to modify.
//   fix -- 0=to move when the view port moves, 1=stay fixed to the screen no matter where the viewport is moved to.
// SOURCE
void agk::FixEditBoxToScreen( uint32_t index, int fix )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	pEditBox->FixToScreen( fix > 0 );
}

//****f* Input/Edit Box/GetEditBoxText
// FUNCTION
//   Returns the text currently being displayed in the edit box.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
char* agk::GetEditBoxText( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		char *str = new char[1];
		*str = '\0';
		return str;
	}

	return pEditBox->GetText();
}

//****f* Input/Edit Box/GetEditBoxX
// FUNCTION
//   Returns the current X position of the edit box. This is the top left corner of the actual text entry box, any
//   border will extend to the left of this point.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
float agk::GetEditBoxX( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->GetX();
}

//****f* Input/Edit Box/GetEditBoxY
// FUNCTION
//   Returns the current Y position of the edit box. This is the top left corner of the actual text entry box, any
//   border will extend above this point.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
float agk::GetEditBoxY( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->GetY();
}

//****f* Input/Edit Box/GetEditBoxWidth
// FUNCTION
//   Returns the current width of the edit box. This is the width of the actual text entry box, any
//   border will extend beyond this value.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
float agk::GetEditBoxWidth( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->GetWidth();
}

//****f* Input/Edit Box/GetEditBoxHeight
// FUNCTION
//   Returns the current height of the edit box. This is the height of the actual text entry box, any
//   border will extend beyond this value.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
float agk::GetEditBoxHeight( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->GetHeight();
}

//****f* Input/Edit Box/GetEditBoxChanged
// FUNCTION
//   Returns 1 if the edit box has just lost focus, meaning the text may have changed and is not likely to 
//   change again in the short term.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
int agk::GetEditBoxChanged( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->GetTextChanged();
}

//****f* Input/Edit Box/GetEditBoxActive
// FUNCTION
//   Returns 1 if the edit box is enabled and can be clicked on, 0 if the edit box is disabled and cannot be changed.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
int agk::GetEditBoxActive( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->GetActive();
}

//****f* Input/Edit Box/GetEditBoxDepth
// FUNCTION
//   Returns the current depth of the edit box with 0 being the front of the screen and 10000 being the back.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
int agk::GetEditBoxDepth(uint32_t index)
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem(index);
	if (!pEditBox)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr("Edit box ", 50);  errStr.AppendInt(index);  errStr.Append(" does not exist");
		Error(errStr);
#endif
		return 0;
	}

	return pEditBox->GetDepth();
}

//****f* Input/Edit Box/GetEditBoxVisible
// FUNCTION
//   Returns 1 if the edit box is visible and can be clicked on, 0 if the edit box is invisible and cannot be changed.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
int agk::GetEditBoxVisible( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->GetVisible();
}

//****f* Input/Edit Box/GetEditBoxLines
// FUNCTION
//   Returns the number of lines of text the user has entered into the edit box.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
int agk::GetEditBoxLines( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->GetLines();
}

//****f* Input/Edit Box/GetEditBoxCursorPosition
// FUNCTION
//   Gets the cursor to the specified position in the text, i.e. position 0 is left of the first character,
//   position 1 is left of the second character, and so on.
// INPUTS
//   index -- The ID of the edit box to check.
// SOURCE
int agk::GetEditBoxCursorPosition( uint32_t index )
//****
{
	cEditBox *pEditBox = m_cEditBoxList.GetItem( index );
	if ( !pEditBox )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Edit box ", 50 );  errStr.AppendInt( index );  errStr.Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pEditBox->GetCursorPosition();
}
	
// benchmarking

//****f* Benchmarking/General/GetManagedSpriteDrawnCount
// FUNCTION
//   Returns the number of sprites that were actually sent for rendering to the GPU last frame, the more that get drawn the 
//   slower the app will run.
// SOURCE
uint32_t agk::GetManagedSpriteDrawnCount()
//****
{
	return m_cSpriteMgrFront.GetDrawnCount();
}

//****f* Benchmarking/General/GetManagedSpriteCount
// FUNCTION
//   Returns the number of sprites that are being managed by the internal sprite manager. It is responsible for updating
//   sprite animation and calculating which sprites are visible and need to be sent for drawing. It also sorts the sprites
//   when necessary for correct transparency drawing. <br><br>
//   As long as not too many sprites are sent for drawing the sprite manager should be able to handle several hundred sprites.
// SOURCE
uint32_t agk::GetManagedSpriteCount()
//****
{
	return m_cSpriteMgrFront.GetTotalCount();
}

//****f* Benchmarking/General/GetManagedSpriteSortedCount
// FUNCTION
//   Returns the number of sprites that the internal sprite manager had to sort into their correct positions since the last 
//   frame. Sprites only need resorting if they change depth or texture during the current frame. 
// SOURCE
uint32_t agk::GetManagedSpriteSortedCount()
//****
{
	return m_cSpriteMgrFront.GetSortedCount();
}

//****f* Benchmarking/General/GetPixelsDrawn
// FUNCTION
//   Returns an estimate of the number of pixels that were drawn to the screen last frame. Generally the lower this value the 
//   better the performance. The number of pixels drawn can be greater than the number of pixels in the screen since 
//   overlapping sprites might draw the same pixel twice.
// SOURCE
uint32_t agk::GetPixelsDrawn()
//****
{
	return cSprite::g_iPixelsDrawn;
}

//****f* Benchmarking/General/GetManagedSpriteDrawCalls
// FUNCTION
//   Returns the number of OpenGL draw calls used to draw all managed sprites. Generally the lower this number the 
//   better the performance. AGK attempts to batch sprites into as few draw calls as possible, it does this by looking for
//   sprites with the same texture and drawing them at the same time.
// SOURCE
uint32_t agk::GetManagedSpriteDrawCalls()
//****
{
	return m_cSpriteMgrFront.GetDrawCalls();
}

//****f* Benchmarking/General/GetParticleDrawnPointCount
// FUNCTION
//   As of version 108 this command will always return 0 as all particles are drawn with quads. 
//   Use <i>GetParticleDrawnQuadCount</i> instead.
// SOURCE
uint32_t agk::GetParticleDrawnPointCount()
//****
{
	return 0;
}

//****f* Benchmarking/General/GetParticleDrawnQuadCount
// FUNCTION
//   Returns the number of individual particles that were drawn last frame using a quad method. The higher this number 
//   the more work the engine is doing handling particles.
// SOURCE
uint32_t agk::GetParticleDrawnQuadCount()
//****
{
	return cParticleEmitter::m_iQuadParticlesDrawn;
}

//****f* Benchmarking/General/GetUpdateTime
// FUNCTION
//   Returns the number of seconds and fractions of seconds spent updating everything in the world except physics. This includes
//   sprite animation, emulating input, and handling sounds.
// SOURCE
float agk::GetUpdateTime() 
//****
{ 
	return m_fUpdateTime; 
}

//****f* Benchmarking/General/GetPhysicsTime
// FUNCTION
//   Returns the number of seconds and fractions of seconds spent updating the physics simulation.
// SOURCE
float agk::GetPhysicsTime() 
//****
{ 
	return m_fPhysicsTime; 
}

//****f* Benchmarking/General/GetDrawingSetupTime
// FUNCTION
//   Returns the number of seconds and fractions of seconds spent setting up the world ready for 2D drawing. This includes calculating 
//   what is visible, transforming sprites into their screen positions and sending vertices to the GPU. 
// SOURCE
float agk::GetDrawingSetupTime() 
//****
{ 
	return m_fDrawingSetupTime; 
}

//****f* Benchmarking/General/GetDrawing3DSetupTime
// FUNCTION
//   Returns the number of seconds and fractions of seconds spent setting up the world ready for 3D drawing. This includes calculating 
//   what is visible, transforming objects into their screen positions and sending vertices to the GPU. 
// SOURCE
float agk::GetDrawing3DSetupTime() 
//****
{ 
	return m_f3DDrawingSetupTime; 
}

//****f* Benchmarking/General/GetDrawingTime
// FUNCTION
//   Returns the time spent swapping the backbuffer and (if necessary) waiting for the GPU to catch up ready for the next frame.
// SOURCE
float agk::GetDrawingTime() 
//****
{ 
	return m_fDrawingTime; 
}

//****f* Benchmarking/General/GetLoadedImages
// FUNCTION
//   Returns the number of images currently loaded into the app.
// SOURCE
uint32_t agk::GetLoadedImages()
//****
{
	int imageCount = 0;
	cImage *pImage = m_cImageList.GetFirst();
	while ( pImage )
	{
		if ( !pImage->HasParent() ) 
		{
			imageCount++;
		}

		pImage = m_cImageList.GetNext();
	}
	return imageCount;
}

//****f* Benchmarking/General/GetUnassignedImages
// FUNCTION
//   Returns the number of images currently loaded into the app but are not assigned to a sprite or text object.
//   This is useful for debugging to check you have deleted all unused images when switching from a menu to a 
//   level, or from one level to another.
// SOURCE
uint32_t agk::GetUnassignedImages()
//****
{
	int imageCount = 0;
	cImage *pImage = m_cImageList.GetFirst();
	while ( pImage )
	{
		if ( !pImage->HasParent() 
		  && (!pImage->m_pCurrentSprites || pImage->m_pCurrentSprites->GetCount() == 0) 
		  && (!pImage->m_pCurrentTextObjects || pImage->m_pCurrentTextObjects->GetCount() == 0)
		  && pImage != cText::GetDefaultFontImage()
		  && pImage != cText::GetDefaultFontExtImage() ) 
		{
			imageCount++;
		}

		pImage = m_cImageList.GetNext();
	}
	return imageCount;
}

//****f* Benchmarking/General/GetUnassignedImageFileName
// FUNCTION
//   Returns the filename of the specified unassigned image.
// INPUTS
//   index -- The index of the unassigned image, between 1 and the value returned by GetUnassignedImages
// SOURCE
char* agk::GetUnassignedImageFileName( uint32_t index )
//****
{
	int imageCount = 0;
	cImage *pImage = m_cImageList.GetFirst();
	while ( pImage )
	{
		if ( !pImage->HasParent() 
		  && (!pImage->m_pCurrentSprites || pImage->m_pCurrentSprites->GetCount() == 0) 
		  && (!pImage->m_pCurrentTextObjects || pImage->m_pCurrentTextObjects->GetCount() == 0)
		  && pImage != cText::GetDefaultFontImage()
		  && pImage != cText::GetDefaultFontExtImage() ) 
		{
			imageCount++;
		}

		if ( imageCount == index )
		{
			char *str = new char[strlen(pImage->GetPath())+1];
			strcpy( str, pImage->GetPath() );
			return str;
		}
		pImage = m_cImageList.GetNext();
	}

	char *str = new char[1];
	str[0] = 0;
	return str;
}

//****f* Benchmarking/General/GetImageMemoryUsage
// FUNCTION
//   Returns the amount of memory in megabytes currently being used by all loaded images (including images used by fonts).
//   This can help track down problems with GPU memory which can cause a crash if it runs out. Every image you load will
//   be placed in GPU memory, even if you don't use it, so loading too many large images could use up all the memory.
// SOURCE
float agk::GetImageMemoryUsage()
//****
{
	float total = 0;
	cImage *pImage = cImage::g_pAllImages;
	while( pImage )
	{
		if ( !pImage->HasParent() )
		{
			if ( pImage->m_iImageMode == 2 ) total += (pImage->GetTotalWidth() * pImage->GetHeight()) / 1048576.0f;
			else total += (pImage->GetTotalWidth() * pImage->GetHeight() * 4) / 1048576.0f;
		}

		pImage = pImage->m_pNextImage;
	}

	return total;
}

// date/time commands

//****f* Time/General/GetLeapYear
// FUNCTION
//   Returns 1 if the given year is a leap year, otherwise 0.
// INPUTS
//   year -- The year to check.
// SOURCE
int agk::GetLeapYear( int year )
//****
{
	int bLeap = 0;
	if ( year % 4 == 0 )
	{
		if ( year % 100 != 0 ) bLeap = 1;
		else
		{
			if ( year % 400 == 0 ) bLeap = 1;
		}
	}

	return bLeap;
}

int64_t agk::GetUnixFromDate64( int year, int month, int days, int hours, int minutes, int seconds )
{
	if ( year > 9999 ) year = 9999; // flexible
	if ( year < -9999 ) year = -9999; // flexible
	if ( month < 1 ) month = 1; // fixed, values outside this range will crash
	if ( month > 12 ) month = 12; // fixed, values outside this range will crash
	if ( days < 1 ) days = 1; // flexible
	if ( days > 31 ) days = 31; // flexible

	if ( year < 1970 )
	{
		// negative
		int64_t daycount = 0;
		int i;
		for ( i = 1969; i > year; i-- )
		{
			if ( GetLeapYear(i) ) daycount -= 366;
			else daycount -= 365;
		}

		for ( i = 11; i >= month; i-- )
		{
			if ( i == 1 && GetLeapYear(i) ) daycount -= 29;
			else daycount -= m_pMonthDays[ i ];
		}

		if ( i == 1 && GetLeapYear(year) ) days = 29 - days;
		else days = m_pMonthDays[ i ] - days;
		daycount -= days;

		//if ( hours == 0 && minutes == 0 && seconds == 0 ) daycount--;
		int64_t unixtime = daycount * 86400;

		int seconds2 = hours*3600 + minutes*60 + seconds;
		unixtime -= (86400 - seconds2);
		return unixtime;
	}
	else
	{
		// positive
		int64_t daycount = 0;
		int i;
		for ( i = 1970; i < year; i++ )
		{
			if ( GetLeapYear(i) ) daycount += 366;
			else daycount += 365;
		}

		for ( i = 0; i < month-1; i++ )
		{
			if ( i == 1 && GetLeapYear(year) ) daycount += 29;
			else daycount += m_pMonthDays[ i ];
		}

		daycount += days-1;

		int64_t unixtime = daycount * 86400;
		unixtime += hours*3600 + minutes*60 + seconds;
		return unixtime;
	}
}

int agk::GetYearFromUnix64( int64_t unixtime, int* daysinyear )
{
	int64_t days = (int) (unixtime / 86400);
	int64_t daycount = 0;
	int64_t lastcount = 0;
	int i;
	int year = 0;

	if ( unixtime < 0 )
	{
		if ( unixtime % 86400 != 0 ) days--;

		for ( i = 1969; daycount > days; i-- )
		{
			lastcount = daycount;
			if ( GetLeapYear(i) ) daycount -= 366;
			else daycount -= 365;
		}

		year = i+1;

		if ( daysinyear ) 
		{
			int64_t days2 = (days - lastcount);
			if ( GetLeapYear(year) ) days2 = 366 + days2;
			else days2 = 365 + days2;
			*daysinyear = (int)days2;
		}
	}
	else
	{
		for ( i = 1970; daycount <= days; i++ )
		{
			lastcount = daycount;
			if ( GetLeapYear(i) ) daycount += 366;
			else daycount += 365;
		}

		year = i-1;
		if ( daysinyear ) *daysinyear = (int)(days - lastcount);
	}

	return year;
}

int agk::GetMonthFromUnix64( int64_t unixtime )
{
	int daysinyear = 0;
	int year = GetYearFromUnix64( unixtime, &daysinyear );
	int daycount = 0;
	int leap = GetLeapYear(year);

	int i;
	for( i = 0; daycount <= daysinyear; i++ )
	{
		// feb has 29 days in a leap year
		if ( i == 1 && leap > 0 ) daycount += 29;
		else daycount += m_pMonthDays[ i ];
	}

	return i; // month as 1-12
}

int agk::GetDayFromUnix64( int64_t unixtime )
{
	int daysinyear = 0;
	int year = GetYearFromUnix64( unixtime, &daysinyear );
	int daycount = 0;
	int leap = GetLeapYear(year);

	int i, lastcount = 0;
	for( i = 0; daycount <= daysinyear; i++ )
	{
		lastcount = daycount;
		// feb has 29 days in a leap year
		if ( i == 1 && leap > 0 ) daycount += 29;
		else daycount += m_pMonthDays[ i ];
	}

	int days = daysinyear - lastcount;
	return days + 1;
}

int agk::GetHoursFromUnix64( int64_t unixtime )
{
	if ( unixtime < 0 ) unixtime = 86400 + (unixtime % 86400);
	int64_t a = unixtime / 3600;
	return (int) (a % 24);
}

int agk::GetMinutesFromUnix64( int64_t unixtime )
{
	if ( unixtime < 0 ) unixtime = 86400 + (unixtime % 86400);
	int64_t a = unixtime / 60;
	return (int) (a % 60);
}

int agk::GetSecondsFromUnix64( int64_t unixtime )
{
	if ( unixtime < 0 ) unixtime = 86400 + (unixtime % 86400);
	return (int) (unixtime % 60);
}

//****f* Time/General/GetUnixFromDate
// FUNCTION
//   Converts a given date and time into its unix time equivalent, unix time is the number of seconds since 1st Jan 1970.
//   If not using 64 bit values then the unix time value is limited to 1901 to 2038 for the year.
// INPUTS
//   year -- The year portion of the date.
//   month -- The month portion of the date, in the range 1 to 12.
//   days -- The day portion of the date, in the range 1 to 31.
//   hours -- The hours portion of the date, in the range 0 to 23.
//   minutes -- The minutes portion of the date, in the range 0 to 59.
//   seconds -- The seconds portion of the date, in the range 0 to 59.
// SOURCE
int agk::GetUnixFromDate( int year, int month, int days, int hours, int minutes, int seconds )
//****
{
	if ( year > 9999 ) year = 9999; // flexible
	if ( year < -9999 ) year = -9999; // flexible
	if ( month < 1 ) month = 1; // fixed, values outside this range will crash
	if ( month > 12 ) month = 12; // fixed, values outside this range will crash
	if ( days < 1 ) days = 1; // flexible
	if ( days > 31 ) days = 31; // flexible

	if ( year < 1970 )
	{
		// negative
		int daycount = 0;
		int i;
		for ( i = 1969; i > year; i-- )
		{
			if ( GetLeapYear(i) ) daycount -= 366;
			else daycount -= 365;
		}

		for ( i = 11; i >= month; i-- )
		{
			if ( i == 1 && GetLeapYear(year) ) daycount -= 29;
			else daycount -= m_pMonthDays[ i ];
		}

		if ( i == 1 && GetLeapYear(i) ) days = 29 - days;
		else days = m_pMonthDays[ i ] - days;
		daycount -= days;

		//if ( hours == 0 && minutes == 0 && seconds == 0 ) daycount--;
		int unixtime = daycount * 86400;

		int seconds2 = hours*3600 + minutes*60 + seconds;
		unixtime -= (86400 - seconds2);
		return unixtime;
	}
	else
	{
		// positive
		int daycount = 0;
		int i;
		for ( i = 1970; i < year; i++ )
		{
			if ( GetLeapYear(i) ) daycount += 366;
			else daycount += 365;
		}

		for ( i = 0; i < month-1; i++ )
		{
			if ( i == 1 && GetLeapYear(year) ) daycount += 29;
			else daycount += m_pMonthDays[ i ];
		}

		daycount += days-1;

		int unixtime = daycount * 86400;
		unixtime += hours*3600 + minutes*60 + seconds;
		return unixtime;
	}
}

int agk::GetYearFromUnix32( int unixtime, int* daysinyear )
{
	int days = (int) (unixtime / 86400);
	int daycount = 0;
	int lastcount = 0;
	int i;
	int year = 0;

	if ( unixtime < 0 )
	{
		if ( unixtime % 86400 != 0 ) days--;

		for ( i = 1969; daycount > days; i-- )
		{
			lastcount = daycount;
			if ( GetLeapYear(i) ) daycount -= 366;
			else daycount -= 365;
		}

		year = i+1;

		if ( daysinyear ) 
		{
			int days2 = (days - lastcount);
			if ( GetLeapYear(year) ) days2 = 366 + days2;
			else days2 = 365 + days2;
			*daysinyear = days2;
		}
	}
	else
	{
		for ( i = 1970; daycount <= days; i++ )
		{
			lastcount = daycount;
			if ( GetLeapYear(i) ) daycount += 366;
			else daycount += 365;
		}

		year = i-1;
		if ( daysinyear ) *daysinyear = days - lastcount;
	}

	return year;
}

//****f* Time/General/GetYearFromUnix
// FUNCTION
//   Returns the year of a given unix time value. Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.
//   If not using 64 bit values then the unix time value is limited to 1901 to 2038 for the year.
// INPUTS
//   unixtime -- A unix time value.
// SOURCE
int agk::GetYearFromUnix( int unixtime )
//****
{
	int daysinyear = 0;
	return GetYearFromUnix32 ( unixtime, &daysinyear );
}

//****f* Time/General/GetMonthFromUnix
// FUNCTION
//   Returns the month of a given unix time value (1 to 12). Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.
// INPUTS
//   unixtime -- A unix time value.
// SOURCE
int agk::GetMonthFromUnix( int unixtime )
//****
{
	int daysinyear = 0;
	int year = GetYearFromUnix32( unixtime, &daysinyear );
	int daycount = 0;
	int leap = GetLeapYear(year);

	int i;
	for( i = 0; daycount <= daysinyear; i++ )
	{
		// feb has 29 days in a leap year
		if ( i == 1 && leap > 0 ) daycount += 29;
		else daycount += m_pMonthDays[ i ];
	}

	return i; // month as 1-12
}

//****f* Time/General/GetDaysFromUnix
// FUNCTION
//   Returns the days of a given unix time value (1 to 31). Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.
// INPUTS
//   unixtime -- A unix time value.
// SOURCE
int agk::GetDaysFromUnix( int unixtime )
//****
{
	int daysinyear = 0;
	int year = GetYearFromUnix32( unixtime, &daysinyear );
	int daycount = 0;
	int leap = GetLeapYear(year);

	int i, lastcount = 0;
	for( i = 0; daycount <= daysinyear; i++ )
	{
		lastcount = daycount;
		// feb has 29 days in a leap year
		if ( i == 1 && leap > 0 ) daycount += 29;
		else daycount += m_pMonthDays[ i ];
	}

	int days = daysinyear - lastcount;
	return days + 1;
}

//****f* Time/General/GetHoursFromUnix
// FUNCTION
//   Returns the hours of a given unix time value (0 to 23). Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.
// INPUTS
//   unixtime -- A unix time value.
// SOURCE
int agk::GetHoursFromUnix( int unixtime )
//****
{
	if ( unixtime < 0 ) unixtime = 86400 + (unixtime % 86400);
	int a = unixtime / 3600;
	return (int) (a % 24);
}

//****f* Time/General/GetMinutesFromUnix
// FUNCTION
//   Returns the minutes of a given unix time value (0 to 59). Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.
// INPUTS
//   unixtime -- A unix time value.
// SOURCE
int agk::GetMinutesFromUnix( int unixtime )
//****
{
	if ( unixtime < 0 ) unixtime = 86400 + (unixtime % 86400);
	int a = unixtime / 60;
	return (int) (a % 60);
}

//****f* Time/General/GetSecondsFromUnix
// FUNCTION
//   Returns the seconds of a given unix time value (0 to 59). Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.
// INPUTS
//   unixtime -- A unix time value.
// SOURCE
int agk::GetSecondsFromUnix( int unixtime )
//****
{
	if ( unixtime < 0 ) unixtime = 86400 + (unixtime % 86400);
	return unixtime % 60;
}


// advert commands

//****f* Advert/Inneractive/SetInneractiveDetails
// FUNCTION
//   Sets your Inneractive account details to be used by <i>CreateAdvert</i>. Not all platforms support all ad providers so
//   setting as many account details as possible will allow AGK to select a suitable ad for this platform.<br><br>
//   Inneractive is currently supported by iOS, Android, Windows, and Mac.
// INPUTS
//   szCode -- Your account code provided by Inneractive.
// SOURCE
void agk::SetInneractiveDetails( const char* szCode )
//****
{
	if ( !szCode || strlen(szCode) == 0 ) 
	{
		m_sInneractiveCode.SetStr("");
		return;
	}
	m_sInneractiveCode.SetStr( szCode );
}

//****f* Advert/AdMob/SetAdMobDetails
// FUNCTION
//   Sets your AdMob account details to be used by banner ads and interstitial (fullscreen) ads. Note that this only 
//   supports one or the other, you can either set a banner ad unit ID, or an interstitial ad unit ID, but not both 
//   at the same time.<br><br>
//   After calling this command an attempt will be made to cache an interstitial so you can display it 
//   immediately later. You can check the progress of this by using <i>GetFullscreenAdvertLoadedAdMob</i>.<br><br>
//   AdMob ads are currently supported by iOS and Android.
// INPUTS
//   szID -- Ad unit ID as provided by AdMob.
// SOURCE
void agk::SetAdMobDetails ( const char* szID )
//****    
{
	// admob setup
    if ( !szID || strlen(szID) == 0 ) 
	{
		m_sAdMobCode.SetStr("");
		return;
	}
	m_sAdMobCode.SetStr( szID );

	// assume they will use full screen ads and cache one immediately to avoid delays later
	agk::PlatformAdMobCacheFullscreen();
}

//****f* Advert/AdMob/SetAdMobRewardAdDetails
// FUNCTION
//   Sets your AdMob account details to be used by reward video ads. After calling this command an attempt will be made 
//   to cache a reward video so you can display it immediately later. You can check the progress of this by using 
//   <i>GetRewardAdLoadedAdMob</i>.<br><br>
//   AdMob reward videos are currently supported by iOS and Android.
// INPUTS
//   szID -- Ad unit ID as provided by AdMob (not the App ID).
// SOURCE
void agk::SetAdMobRewardAdDetails ( const char* szID )
//****    
{
	// admob setup
    if ( !szID || strlen(szID) == 0 ) 
	{
		m_sAdMobRewardAdCode.SetStr("");
		return;
	}
	m_sAdMobRewardAdCode.SetStr( szID );

	// cache reward ad immediately to avoid delays later
	agk::PlatformAdMobCacheRewardAd();
}

//****f* Advert/Chartboost/SetChartboostDetails
// FUNCTION
//   Sets your Chartboost account details to be used by interstitial (fullscreen) ads and reward video ads.
//   After calling this command an attempt will be made to cache an interstitial so you can display it 
//   immediately later. You can check the progress of this by using <i>GetFullscreenAdvertLoadedChartboost</i>.
//   Note that this command will not automatically cache a reward video ad, you must do that manually with 
//   <i>CacheRewardAdChartboost</i>.<br><br>
//   Chartboost ads are currently supported by Android and iOS.
// INPUTS
//   szKey1 -- App ID
//   szKey2 -- App Signature
// SOURCE
void agk::SetChartboostDetails ( const char* szKey1, const char* szKey2 )
//****    
{
	// chartboost setup
    if ( !szKey1 || strlen(szKey1) == 0 ) 
		m_sChartboostCode1.SetStr("");
	else
		m_sChartboostCode1.SetStr( szKey1 );

	if ( !szKey2 || strlen(szKey2) == 0 ) 
		m_sChartboostCode2.SetStr("");
	else
		m_sChartboostCode2.SetStr( szKey2 );

	agk::PlatformChartboostSetup();
}

//****f* Advert/AdMob/SetAmazonAdDetails
// FUNCTION
//   The Amazon Ads network no longer exists
// INPUTS
//   szKey -- Ad unit ID as provided by Amazon.
// SOURCE
void agk::SetAmazonAdDetails ( const char* szKey )
//****    
{
    
}
    
//****f* Advert/AdMob/SetAmazonAdTesting
// FUNCTION
//   The Amazon Ads network no longer exists
// INPUTS
//   mode -- 0=show paying ads, 1=show test ads
// SOURCE
void agk::SetAmazonAdTesting ( int mode )
//****
{
    
}

//****f* Advert/AdMob/SetAdMobTesting
// FUNCTION
//   Sets whether the AdMob ads will be test ads or paying ads. This should be called before <i>SetAdMobDetails</i>
//   to ensure all ads are test ads. By default paying ads will be shown.
//   Note that if you display paying ads when testing you must not click on them or your AdMob account may be suspended.
// INPUTS
//   mode -- 0 = show paying ads, 1 = show test ads
// SOURCE
void agk::SetAdMobTesting ( int mode )
//****
{
    agk::PlatformAdMobSetTesting(mode);
}

//****f* Advert/AdMob/SetAdMobChildRating
// FUNCTION
//   Sets the content rating for AdMob ads if your app is targeted at children. This must be called 
//   before <i>SetAdMobDetails</i>
// INPUTS
//   rating -- 0 = normal ads, 1 = child safe ads
// SOURCE
void agk::SetAdMobChildRating ( int rating )
//****
{
    agk::PlatformAdMobSetChildRating( rating );
}

//****f* Advert/AdMob/ShowFullscreenAdvertAdMob
// FUNCTION
//   Creates a fullscreen (interstitial) advert for revenue generation using AdMob. Before calling this function you must 
//   have set your ad account details with <i>SetAdMobDetails</i>.
//   Both iOS and Android use caching to preload ads before displaying them. If an ad has been loaded when you call this 
//   command then it will be displayed immediately, otherwise it will attempt to load an ad for next time you call this command. 
//   Failure to load an ad may be because the ad provider has run out of ads to show to users in a particular country. You can 
//   check if an ad is waiting to be displayed with <i>GetFullscreenAdvertLoadedAdMob</i>.
//   Your app will be paused when the advert is displayed, and will resume when the advert is dismissed.
// SOURCE
void agk::ShowFullscreenAdvertAdMob()
//****
{
    if ( agk::PlatformHasAdMob() )
	{
		agk::PlatformAdMobFullscreen();
	}
}

//****f* Advert/Chartboost/ShowFullscreenAdvertChartboost
// FUNCTION
//   Creates a fullscreen (interstitial) advert for revenue generation using Chartboost. Before calling this function you must 
//   have set your ad account details with <i>SetChartboostDetails</i>.
//   Both iOS and Android use caching to preload ads before displaying them. If an ad has been loaded when you call this 
//   command then it will be displayed immediately, otherwise it will attempt to load an ad for next time you call this command. 
//   Failure to load an ad may be because the ad provider has run out of ads to show to users in a particular country. You can 
//   check if an ad is waiting to be displayed with <i>GetFullscreenAdvertLoadedChartboost</i>.
//   Your app will be paused when the advert is displayed, and will resume when the advert is dismissed.
// SOURCE
void agk::ShowFullscreenAdvertChartboost()
//****
{
    if ( m_sChartboostCode1.GetLength() > 0 )
	{
		agk::PlatformChartboostFullscreen();
	}
}

//****f* Advert/Amazon/ShowFullscreenAdvertAmazon
// FUNCTION
//   The Amazon Ads network no longer exists
// SOURCE
void agk::ShowFullscreenAdvertAmazon()
//****
{
   
}

//****f* Advert/AdMob/GetFullscreenAdvertLoadedAdMob
// FUNCTION
//   Returns 1 if there is an AdMob interstitial ad preloaded and ready to be displayed, otherwise 0. If so you can 
//   display it with <i>ShowFullscreenAdvertAdMob</i>. Adverts are preloaded as soon as you set your AdMob details 
//   and after every fullscreen advert is dismissed by the user. If this command continues to return 0 then ad 
//   loading may have failed due to the provider running out of ads and AGK will stop trying to load them. In this
//   case you should try your other ad providers instead. If you find all your ad providers are returning 0 then 
//   you can try calling <i>ShowFullscreenAdvertAdMob</i> anyway, it will not display anything as there is nothing 
//   loaded, but it will restart the loading process to see if any new adverts have become available. 
// SOURCE
int agk::GetFullscreenAdvertLoadedAdMob()
//****
{
	return agk::PlatformAdMobGetFullscreenLoaded();
}

//****f* Advert/AdMob/GetFullscreenAdvertLoadedChartboost
// FUNCTION
//   Returns 1 if there is an Chartboost interstitial ad preloaded and ready to be displayed, otherwise 0. If so you can 
//   display it with <i>ShowFullscreenAdvertChartboost</i>. Adverts are preloaded as soon as you set your Chartboost 
//   details and after every fullscreen advert is dismissed by the user. If this command continues to return 0 then ad 
//   loading may have failed due to the provider running out of ads and AGK will stop trying to load them. In this
//   case you should try your other ad providers instead. If you find all your ad providers are returning 0 then 
//   you can try calling <i>ShowFullscreenAdvertChartboost</i> anyway, it will not display anything as there is nothing 
//   loaded, but it will restart the loading process to see if any new adverts have become available. 
// SOURCE
int agk::GetFullscreenAdvertLoadedChartboost()
//****
{
	return agk::PlatformChartboostGetFullscreenLoaded();
}

//****f* Advert/AdMob/GetFullscreenAdvertLoadedAmazon
// FUNCTION
//   The Amazon Ads network no longer exists
// SOURCE
int agk::GetFullscreenAdvertLoadedAmazon()
//****
{
	return 0;
}

//****f* Advert/AdMob/ShowRewardAdAdMob
// FUNCTION
//   Creates a fullscreen reward video advert for revenue generation using AdMob. Before calling this function you must 
//   have set your ad account details with <i>SetAdMobRewardAdDetails</i>.
//   Both iOS and Android use caching to preload ads before displaying them. If an ad has been loaded when you call this 
//   command then it will be displayed immediately, otherwise it will attempt to load an ad for next time you call this command. 
//   Failure to load an ad may be because the ad provider has run out of ads to show to users in a particular country. You can 
//   check if an ad is waiting to be displayed with <i>GetRewardAdLoadedAdMob</i>.
//   Your app will be paused when the advert is displayed, and will resume when the advert is dismissed.
//   Check <i>GetRewardAdRewardedAdMob</i> to see if the user completed watching the reward ad and should be rewarded. It will
//   be set to 0 when you call this command, and then set to 1 when they have finished watching
// SOURCE
void agk::ShowRewardAdAdMob()
//****
{
	if ( agk::PlatformHasAdMob() && m_sAdMobRewardAdCode.GetLength() > 0 )
	{
		agk::PlatformAdMobRewardAd();
	}
}

//****f* Advert/AdMob/GetRewardAdLoadedAdMob
// FUNCTION
//   Returns 1 if there is an AdMob reward ad preloaded and ready to be displayed, otherwise 0. If so you can 
//   display it with <i>ShowRewardAdAdMob</i>. Adverts are preloaded as soon as you set your AdMob reward details 
//   and after every reward advert is dismissed by the user. If this command continues to return 0 then ad 
//   loading may have failed due to the provider running out of ads and AGK will stop trying to load them. In this
//   case you should try your other ad providers instead. If you find all your ad providers are returning 0 then 
//   you can try calling <i>ShowRewardAdAdMob</i> anyway, it will not display anything as there is nothing 
//   loaded, but it will restart the loading process to see if any new adverts have become available. 
// SOURCE
int agk::GetRewardAdLoadedAdMob()
//****
{
	return agk::PlatformAdMobGetRewardAdLoaded();
}

//****f* Advert/AdMob/GetRewardAdRewardedAdMob
// FUNCTION
//   Returns 1 if the previously displayed reward ad resulted in a reward that should be given to the user, for example
//   some in-game coins. When <i>ShowRewardAdAdMob</i> is called this is set to 0 and only set to 1 if the user completed
//   the reward video, otherwise it will stay at 0. After you have given the user a reward you can set it back to 0 by
//   using <i>ResetRewardAdMob</i>.
// SOURCE
int agk::GetRewardAdRewardedAdMob()
//****
{
	return agk::PlatformAdMobGetRewardAdRewarded();
}

//****f* Advert/AdMob/GetRewardAdValueAdMob
// FUNCTION
//   Returns the value of the currently loaded reward ad, this will return 0 if the reward value is unknown.
//   If no reward ad is currently loaded then this value is undefined, it might be 0 or it might be the 
//   value of a previous ad.
//   You should ask the user if they want to view the reward ad before showing it, along with the reward they 
//   will get for doing so. You can use this value function to determine an appropriate reward.
//   This value will remain unchanged if <i>ResetRewardAdMob</i> is called
// SOURCE
int agk::GetRewardAdValueAdMob()
//****
{
	return agk::PlatformAdMobGetRewardAdValue();
}

//****f* Advert/AdMob/ResetRewardAdMob
// FUNCTION
//   Sets the AdMob rewarded value to 0. You can use this after detecting the reward event and acting on so that you don't 
//   reward the user more than once.
// SOURCE
void agk::ResetRewardAdMob()
//****
{
	agk::PlatformAdMobResetRewardAd();
}

//****f* Advert/AdMob/ShowRewardAdChartboost
// FUNCTION
//   Creates a fullscreen reward video advert for revenue generation using Chartboost. Before calling this function you must 
//   have set your ad account details with <i>SetChartboostDetails</i>.
//   Both iOS and Android use caching to preload ads before displaying them. If an ad has been loaded when you call this 
//   command then it will be displayed immediately, otherwise it will attempt to load an ad for next time you call this command. 
//   For Chartboost you must start the caching process manually with <i>CacheRewardAdChartboost</i>, you only need to call this 
//   once. After a reward video ad has been displayed a new one will be cached automatically.
//   Failure to load an ad may be because the ad provider has run out of ads to show to users in a particular country. You can 
//   check if an ad is waiting to be displayed with <i>GetRewardAdLoadedChartboost</i>.
//   Your app will be paused when the advert is displayed, and will resume when the advert is dismissed.
//   Check <i>GetRewardAdRewardedChartboost</i> to see if the user completed watching the reward ad and should be rewarded. It will
//   be set to 0 when you call this command, and then set to 1 when they have finished watching
// SOURCE
void agk::ShowRewardAdChartboost()
//****
{
	agk::PlatformChartboostRewardAd();
}

//****f* Advert/AdMob/CacheRewardAdChartboost
// FUNCTION
//   Caches a fullscreen reward video advert for display later using Chartboost. Before calling this function you must 
//   have set your ad account details with <i>SetChartboostDetails</i>.
//   Both iOS and Android use caching to preload ads before displaying them. If an ad has already been cached then this will do nothing.
//   Unlike AdMob, reward videos will not automatically start caching with Chartboost unless you call this command. This is because 
//   Chartboost uses the same details for both interstitials and reward videos so AGK can't know in advance which you are using. Since 
//   video ads can use a lot of mobile data their caching process will not be started automatically.
//   You only need to call this once, after a reward video ad has been displayed a new one will be cached automatically.
//   Failure to load an ad may be because the ad provider has run out of ads to show to users in a particular country. You can 
//   check if an ad is waiting to be displayed with <i>GetRewardAdLoadedChartboost</i>.
// SOURCE
void agk::CacheRewardAdChartboost()
//****
{
	agk::PlatformChartboostCacheRewardAd();
}

//****f* Advert/AdMob/GetRewardAdLoadedChartboost
// FUNCTION
//   Returns 1 if there is a Chartboost reward ad preloaded and ready to be displayed, otherwise 0. If so you can 
//   display it with <i>ShowRewardAdChartboost</i>. Adverts are preloaded after calling <i>CacheRewardAdChartboost</i>
//   and after every reward advert is dismissed by the user. If this command continues to return 0 then ad 
//   loading may have failed due to the provider running out of ads and AGK will stop trying to load them. In this
//   case you should try your other ad providers instead. If you find all your ad providers are returning 0 then 
//   you can try calling <i>CacheRewardAdChartboost</i> again, to restart the loading process to see if any new 
//   adverts have become available. 
// SOURCE
int agk::GetRewardAdLoadedChartboost()
//****
{
	return agk::PlatformChartboostGetRewardAdLoaded();
}

//****f* Advert/AdMob/GetRewardAdRewardedChartboost
// FUNCTION
//   Returns 1 if the previously displayed reward ad resulted in a reward that should be given to the user, for example
//   some in-game coins. When <i>ShowRewardAdAdMob</i> is called this is set to 0 and only set to 1 if the user completed
//   the reward video, otherwise it will stay at 0. After you have given the user a reward you can set it back to 0 by
//   using <i>ResetRewardAdMob</i>.
// SOURCE
int agk::GetRewardAdRewardedChartboost()
//****
{
	return agk::PlatformChartboostGetRewardAdRewarded();
}

//****f* Advert/AdMob/ResetRewardChartboost
// FUNCTION
//   Sets the Chartboost rewarded value to 0. You can use this after detecting the reward event and acting on so that you don't 
//   reward the user more than once.
// SOURCE
void agk::ResetRewardChartboost()
//****
{
	agk::PlatformChartboostResetRewardAd();
}

//****f* Advert/General/CreateFullscreenAdvert
// FUNCTION
//   This command is deprecated, you should use <i>ShowFullscreenAdvertAdMob</i> or <i>ShowFullscreenAdvertChartboost</i>
// SOURCE
void agk::CreateFullscreenAdvert()
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "CreateFullscreenAdvert() has been removed from AppGameKit and no longer does anything. You should use ShowFullscreenAdvertAdMob() or ShowFullscreenAdvertChartboost() instead" );
		warned = 1;
	}
}

//****f* Advert/General/CreateAdvert
// FUNCTION
//   Creates an advert for revenue generation. Before calling this function you must have set your ad account details
//   with one of the other commands such as <i>SetAdMobDetails</i>. Not all platforms support all ad providers so
//   setting as many account details as possible will allow AGK to select a suitable ad for this platform.<br><br>
//   This advert will typically be a 320x50 banner displayed somewhere around the edge of your app.
//   Creating an ad when one already exists will replace the existing ad.
//   The type parameter can be used to select the size of the banner, 0=Banner(320x50), 1=LargeBanner, 2=MediumRectangle,
//   3=FullBanner, 4=Leaderboard, 5=SmartBanner, 6=FluidBanner
// INPUTS
//   type -- The size of the banner to create
//   horz -- The horizontal position of the ad, 0=left, 1=center, 2=right
//   vert -- The vertical postion of the ad, 0=top, 1=center, 2=bottom
//   test -- Set to 1 to receive a non paying test ad, 0 to receive a real ad.
// SOURCE
void agk::CreateAdvert( int type, int horz, int vert, int test )
//****
{
    CreateAdvertEx( type, horz, vert, test, 0, 0 );
}
    
//****f* Advert/General/CreateAdvertEx
// FUNCTION
//   Creates an advert for revenue generation. Before calling this function you must have set your ad account details
//   with one of the other commands such as <i>SetAdMobDetails</i>. Not all platforms support all ad providers so
//   setting as many account details as possible will allow AGK to select a suitable ad for this platform.<br><br>
//   This advert will typically be a 320x50 banner displayed somewhere around the edge of your app.
//   Creating an ad when one already exists will replace the existing ad.
//   This is an extended version of the CreateAdvert command that takes optional offset values for positioning the ad.
//   The type parameter can be used to select the size of the banner: 0=Banner(320x50), 1=LargeBanner, 2=MediumRectangle,
//   3=FullBanner, 4=Leaderboard, 5=SmartBanner, 6=FluidBanner
// INPUTS
//   type -- The size of the banner to create
//   horz -- The horizontal position of the ad, 0=left, 1=center, 2=right
//   vert -- The vertical position of the ad, 0=top, 1=center, 2=bottom
//   test -- Set to 1 to receive a non-paying test ad, 0 to receive a real ad.
//   offsetx -- when horz is equal to 0 or 2 this value offsets the ad from the specified edge
//   offsety -- when vert is equal to 0 or 2 this value offsets the ad from the specified edge
// SOURCE
void agk::CreateAdvertEx( int type, int horz, int vert, int test, float offsetx, float offsety )
//****
{
	if ( agk::PlatformHasAdMob() && m_sAdMobCode.GetLength() > 0 )
    {
        // create admob ad
        
        agk::DeleteAdvert();
        m_iAdHorz = horz;
        m_iAdVert = vert;
        m_iAdTest = test;
        m_fAdOffsetX = offsetx;
        m_fAdOffsetY = offsety;
		m_iAdType = type;
        
        agk::PlatformAdMobSetupRelative(m_sAdMobCode, horz, vert, offsetx, offsety, type);
    }
    else 
    {
        // create inneractive ad
        
        if ( agk::PlatformHasAdMob() ) agk::PlatformAdMobDestroy();
        
    	// check if an ad request is already in progress
        if ( m_iInneractiveStage > 0 && m_iInneractiveStage < 5 ) return;
        if ( m_sInneractiveCode.GetLength() == 0 )
        {
            agk::Warning( "Failed to create ad, no ad provider details set" );
            return;
        }
            
        m_iInneractiveStage = 1;

        m_iAdHorz = horz;
        m_iAdVert = vert;
        m_iAdTest = test;
        m_fAdOffsetX = offsetx;
        m_fAdOffsetY = offsety;
		m_iAdType = type;

        //if ( m_pAdSprite ) 
        //{
            //m_pAdSprite->SetVisible( false );
            //m_pAdSprite->SetImage( 0 );
        //}
        //if ( m_pAdImage ) delete m_pAdImage;
        //m_pAdImage = 0;

        if ( !m_pAdSprite && test > 0 ) 
        {
            m_pAdSprite = new cSprite();
            m_pAdSprite->SetImage( 0 );
            if ( m_fAdWidth > 0 ) m_pAdSprite->SetSize( m_fAdWidth, m_fAdWidth*50.0f/320.0f );
            else m_pAdSprite->SetSize( 320, 50 );
            m_pAdSprite->SetDepth( 0 );
            if ( m_fAdX >= 0 && m_fAdY >= 0 ) m_pAdSprite->SetPosition( m_fAdX, m_fAdY );
            else
            {
                float x = m_fAdOffsetX;
                switch( m_iAdHorz )
                {
                    case 0: break;
                    case 1: x = (GetVirtualWidth()-m_pAdSprite->GetWidth())/2; break;
                    case 2: x = (GetVirtualWidth()-m_pAdSprite->GetWidth() - m_fAdOffsetX); break;
                    default: break;
                }

                float y = m_fAdOffsetY;
                switch( m_iAdVert )
                {
                    case 0: break;
                    case 1: y = (GetVirtualHeight()-m_pAdSprite->GetHeight())/2; break;
                    case 2: y = (GetVirtualHeight()-m_pAdSprite->GetHeight() - m_fAdOffsetY); break;
                    default: break;
                }

                m_pAdSprite->SetPosition( x, y );
            }

            m_pAdSprite->SetTransparency( 0 );
            m_pAdSprite->FixToScreen(1);
        }

        if ( !pHTTPInneractive ) 
        {
            pHTTPInneractive = new cHTTPConnection();
        }

        pHTTPInneractive->SetHost( "m2m1.inner-active.mobi", 0 );

        uString sPost;
        sPost.Format( "simpleM2M/clientRequestAd?aid=%s&v=Sm2m-2.1.0", m_sInneractiveCode.GetStr() );
        if ( m_sAdClientID.GetLength() > 0 ) 
        {
            sPost.Append( "&cid=" );
            sPost.Append( m_sAdClientID.GetStr() );
        }
        
        if ( test > 0 )
        {
            sPost.Append( "&test=true" );
        }

        sPost.Append( "&po=" );
        sPost.AppendInt( PlatformGetAdPortal() );

        sPost.Append( "&w=" );
        sPost.AppendInt( GetDeviceWidth() );

        sPost.Append( "&h=" );
        sPost.AppendInt( GetDeviceHeight() );

        bool result = pHTTPInneractive->SendRequestASync( sPost, "" );
        if ( !result ) 
        {
            agk::Warning( "Failed to get advert from Inneractive server" ); 
            delete pHTTPInneractive;
            m_iInneractiveStage = 0;
            return;
        }
    }
}

//****f* Advert/General/SetAdvertPosition
// FUNCTION
//   Positions the advert created with <i>CreateAdvert</i> somewhere on screen and attempts to scale it
//   to a certain width. Since the advert will have its own aspect ratio the height will be calculated
//   from the width. This is not guaranteed to work on all advert providers, currently only Inneractive 
//   can scale and move ads to an absolute position.
// INPUTS
//   x -- The x position of the top left corner of the ad
//   y -- The y position of the top left corner of the ad
//   width -- The desired width of the ad, it will be scaled to this width
// SOURCE
void agk::SetAdvertPosition( float x, float y, float width )
//****
{
    // only handle inneractive
	m_fAdX = x;
	m_fAdY = y;
	m_fAdWidth = width;

	if ( !m_pAdSprite ) return;
	
	if ( m_pAdSprite->GetImagePtr() ) m_pAdSprite->SetSize( m_fAdWidth, -1 );
	else m_pAdSprite->SetSize( m_fAdWidth, m_fAdWidth * 50.0f/320.0f );
	m_pAdSprite->SetPosition( m_fAdX, m_fAdY );
}
    
//****f* Advert/General/SetAdvertLocation
// FUNCTION
//   Positions the advert created with <i>CreateAdvert</i> somewhere on screen and attempts to scale it
//   to a certain width. Since the advert will have its own aspect ratio the height will be calculated
//   from the width. This provides rough positioning by letting you choose between left, centered, or 
//   right justify for the horizontal and vertical positions. This is not guaranteed to work on all 
//   advert providers, currently only Inneractive can scale ads to a specific width.
// INPUTS
//   horz -- The horizontal position of the ad, 0=left, 1=center, 2=right
//   vert -- The vertical postion of the ad, 0=top, 1=center, 2=bottom
//   width -- The desired width of the ad, it will be scaled to this width
// SOURCE
void agk::SetAdvertLocation( int horz, int vert, float width )
//****
{
    SetAdvertLocationEx( horz, vert, 0, 0, width );
}

//****f* Advert/General/SetAdvertLocationEx
// FUNCTION
//   Positions the advert created with <i>CreateAdvert</i> somewhere on screen and attempts to scale it
//   to a certain width. Since the advert will have its own aspect ratio the height will be calculated
//   from the width. This provides rough positioning by letting you choose between left, centered, or 
//   right justify for the horizontal and vertical positions. This is not guaranteed to work on all 
//   advert providers, currently only Inneractive can scale ads to a specific width.
// INPUTS
//   horz -- The horizontal position of the ad, 0=left, 1=center, 2=right
//   vert -- The vertical postion of the ad, 0=top, 1=center, 2=bottom
//   offsetx -- when horz is equal to 0 or 2 this value offsets the ad from the specified edge
//   offsety -- when vert is equal to 0 or 2 this value offsets the ad from the specified edge
//   width -- The desired width of the ad, it will be scaled to this width
// SOURCE
void agk::SetAdvertLocationEx( int horz, int vert, float offsetx, float offsety, float width )
//****
{
	m_iAdHorz = horz;
	m_iAdVert = vert;
	m_fAdWidth = width;
	m_fAdX = -1;
	m_fAdY = -1;
    m_fAdOffsetX = offsetx;
    m_fAdOffsetY = offsety;

	if ( agk::PlatformHasAdMob() ) agk::PlatformAdMobPosition( horz, vert, offsetx, offsety );
    
	if ( m_pAdSprite ) 
    {
        // inneractive
        if ( m_pAdSprite->GetImagePtr() ) m_pAdSprite->SetSize( m_fAdWidth, -1 );
        else m_pAdSprite->SetSize( m_fAdWidth, m_fAdWidth * 50.0f/320.0f );

        float x = m_fAdOffsetX;
        switch( horz )
        {
            case 0: break;
            case 1: x = (GetVirtualWidth()-m_fAdWidth)/2; break;
            case 2: x = (GetVirtualWidth()-m_fAdWidth) - m_fAdOffsetX; break;
            default: break;
        }

        float y = m_fAdOffsetY;
        switch( vert )
        {
            case 0: break;
            case 1: y = (GetVirtualHeight()-m_pAdSprite->GetHeight())/2; break;
            case 2: y = (GetVirtualHeight()-m_pAdSprite->GetHeight()) - m_fAdOffsetY; break;
            default: break;
        }

        m_pAdSprite->SetPosition( x, y );
    }
}

//****f* Advert/General/SetAdvertVisible
// FUNCTION
//   Set the visibility of any advert.
// INPUTS
//   iVisible -- 1 will display the advert and 0 will hide it.
// SOURCE
void agk::SetAdvertVisible ( int iVisible )
//****    
{
    m_iAdVisible = iVisible;
    
	if ( m_pAdSprite ) 
    {
        m_pAdSprite->SetVisible(iVisible>0);
        m_pAdSprite->SetActive(iVisible>0);
    }

	// visibility for admob
    if ( agk::PlatformHasAdMob() && m_sAdMobCode.GetLength() > 0 ) PlatformSetAdMobVisible(iVisible);
}

//****f* Advert/General/RequestAdvertRefresh
// FUNCTION
//   Call this command to request a new advert. Usually adverts will be provided automatically.
//   You may only want to do this when switching to new screens within your application
// SOURCE
void agk::RequestAdvertRefresh()
//****
{
	// refresh for inneractuve
    if ( m_iInneractiveStage == 5 ) m_fAdStartTime = 0;

	// refresh for admob
    if ( agk::PlatformHasAdMob() ) PlatformAdMobRequestNewAd();
}

//****f* Advert/General/DeleteAdvert
// FUNCTION
//   Clears a previously displayed ad.
// SOURCE
void agk::DeleteAdvert()
//****
{
	// delete inneractive
	if ( m_pAdSprite ) delete m_pAdSprite;
	m_pAdSprite = 0;
	if ( m_pAdImage ) delete m_pAdImage;
	m_pAdImage = 0;
	m_iInneractiveStage = 0;

	// delete admob
	if ( agk::PlatformHasAdMob() ) PlatformAdMobDestroy();
}

void agk::UpdateAd()
{
	// check if an ad exists
	switch( m_iInneractiveStage ) 
	{
		case 0: 
		{
			if ( !m_pAdSprite ) break;

			// ad is active but an error occurred trying to refresh, try again every 2 minutes
			if ( agk::Timer() - m_fAdStartTime > 120 )
			{
				m_fAdStartTime = agk::Timer();
				CreateAdvertEx( m_iAdType, m_iAdHorz, m_iAdVert, m_iAdTest, m_fAdOffsetX, m_fAdOffsetY );
			}

			break;
		}
		case 1: 
		{
            if ( !pHTTPInneractive ) 
			{
				m_iInneractiveStage = 0;
				return;
			}

			if ( !pHTTPInneractive->GetResponseReady() ) return;
			const char *reply = pHTTPInneractive->GetResponse();
			uString sReply( reply );
            
			// parse XML response
			int pos = sReply.FindStr( "Error=\"" );
			if ( pos < 0 )
			{
				// no error field found, must exist
                agk::Warning( "Failed to display ad, no error string found" );
				m_iInneractiveStage = 0;
				return;
			}

			const char *error = reply + pos + 7;
			if ( strncmp( error, "OK", 2 ) != 0 && strncmp( error, "House Ad", 8 ) != 0 )
			{
				// not a paying or test ad, must be a failed request
                agk::Warning( "Failed to display ad, invalid ad request sent" );
				m_iInneractiveStage = 0;
				return;
			}

			pos = sReply.FindStr( "Client Id=\"" );
			if ( pos < 0 )
			{
				// no client ID field found, must exist
                agk::Warning( "Failed to display ad, no client ID received" );
				m_iInneractiveStage = 0;
				return;
			}

			const char *clientID = reply + pos + 11;
			pos = (int)strcspn( clientID, "\"" );
			if ( pos >= (int)strlen( clientID ) )
			{
				// no client ID field found, must exist
                agk::Warning( "Failed to display ad, no end to client ID found" );
				m_iInneractiveStage = 0;
				return;
			}

			m_sAdClientID.SetStr("");
			m_sAdClientID.AppendN( clientID, pos );

			// get URL
			pos = sReply.FindStr( "<tns:URL>" );
			if ( pos < 0 ) 
			{
				// no forwarding url found, must exist
                agk::Warning( "Failed to display ad, no URL found" );
				m_iInneractiveStage = 0;
				return;
			}

			int pos2 = sReply.FindStr( "</tns:URL>" );
			if ( pos2 < 0 || pos2-(pos+9) == 0 ) 
			{
				// no end to the forwarding url found, must exist
                agk::Warning( "Failed to display ad, no end to URL string found" );
				m_iInneractiveStage = 0;
				return;
			}
            
            sReply.SubString( m_sInneractiveURL, pos+9, pos2-(pos+9) );
			m_sInneractiveURL.Trim( "\n\r " );
			m_sInneractiveURL.ReplaceStr( "&amp;", "&" );
            
			// get image
			pos = sReply.FindStr( "<tns:Image>" );
			if ( pos < 0 ) 
			{
				// no image found, must exist
                agk::Warning( "Failed to display ad, no image found" );
				m_iInneractiveStage = 0;
				return;
			}

			pos2 = sReply.FindStr( "</tns:Image>" );
			if ( pos2 < 0 || pos2-(pos+11) == 0 ) 
			{
				// no end to image found, must exist
                agk::Warning( "Failed to display ad, no end to image found" );
				m_iInneractiveStage = 0;
				return;
			}

			uString temp;
			sReply.SubString( temp, pos+11, pos2-(pos+11) );
			temp.Trim( "\n\r " );

			temp.SubString( m_sInneractiveImage, 7 );
			m_sInneractiveImage.ReplaceStr( "&amp;", "&" );

			uString sHost;
			pos = m_sInneractiveImage.Find( '/' );
			m_sInneractiveImage.SubString( sHost, 0, pos );

			uString sURL;
			m_sInneractiveImage.SubString( sURL, pos+1 );
            
			pHTTPInneractive->SetHost( sHost, 0 );
			bool result = pHTTPInneractive->DownloadFile( sURL, "/InneractiveAdvert" );
			if ( !result )
			{
				delete pHTTPInneractive;
				m_iInneractiveStage = 0;
				return;
			}

			m_iInneractiveStage = 2;

			break;
		}

		case 2:
		{
			if ( !pHTTPInneractive ) 
			{
				m_iInneractiveStage = 0;
				return;
			}

			if ( !pHTTPInneractive->DownloadComplete() ) return;

			const char *szType = pHTTPInneractive->GetContentType();
			if ( strncmp( szType, "image/", 6 ) != 0 )
			{
				m_iInneractiveStage = 0;
				return;
			}

			szType += 6;

			uString sFilename( "/InneractiveAdvert." );
			sFilename.Append( szType );

			cFile pRead, pWrite;
			pRead.OpenToRead( "/InneractiveAdvert" );
			pWrite.OpenToWrite( sFilename );

			char buf[ 1000 ];
			while ( !pRead.IsEOF() )
			{
				int written = pRead.ReadData( buf, 1000 );
				if ( written > 0 ) pWrite.WriteData( buf, written );
			}

			pRead.Close();
			pWrite.Close();

			
			cImage *pNewImage = new cImage();

			pNewImage->Load( sFilename );
			            
            if ( pNewImage->GetWidth() / (float)pNewImage->GetHeight() < 5.3f )
            {
                // image too large for a 320x50 banner space
                delete pNewImage;
                m_iInneractiveStage = 0;
				return;
            }
            
            if ( m_pAdSprite ) m_pAdSprite->SetImage( 0 );
			if ( m_pAdImage ) delete m_pAdImage;
            m_pAdImage = pNewImage;

			if ( !m_pAdSprite ) 
			{
				m_pAdSprite = new cSprite();
				m_pAdSprite->SetImage( m_pAdImage );
				if ( m_fAdWidth > 0 ) m_pAdSprite->SetSize( m_fAdWidth, -1 );
				else m_pAdSprite->SetSize( -1, -1 );
				m_pAdSprite->SetDepth( 0 );
				if ( m_fAdX >= 0 && m_fAdY >= 0 ) m_pAdSprite->SetPosition( m_fAdX, m_fAdY );
				else
				{
					float x = m_fAdOffsetX;
					switch( m_iAdHorz )
					{
						case 0: break;
						case 1: x = (GetVirtualWidth()-m_pAdSprite->GetWidth())/2; break;
						case 2: x = (GetVirtualWidth()-m_pAdSprite->GetWidth() - m_fAdOffsetX); break;
						default: break;
					}

					float y = m_fAdOffsetY;
					switch( m_iAdVert )
					{
						case 0: break;
						case 1: y = (GetVirtualHeight()-m_pAdSprite->GetHeight())/2; break;
						case 2: y = (GetVirtualHeight()-m_pAdSprite->GetHeight() - m_fAdOffsetY); break;
						default: break;
					}

					m_pAdSprite->SetPosition( x, y );
				}

				m_pAdSprite->SetTransparency( 0 );
				m_pAdSprite->FixToScreen(1);
			}
			else
			{
				m_pAdSprite->SetImage( m_pAdImage );
				m_pAdSprite->SetSize( m_pAdSprite->GetWidth(), -1 );
				m_pAdSprite->SetVisible( m_iAdVisible>0 );
			}

			m_fAdStartTime = agk::Timer();
			m_iInneractiveStage = 5;

			break;
		}

		case 5:
		{
			// update advert after some time
			if ( agk::Timer() - m_fAdStartTime > 120 )
			{
				CreateAdvertEx( m_iAdType, m_iAdHorz, m_iAdVert, m_iAdTest, m_fAdOffsetX, m_fAdOffsetY );
				/*
				if ( !pHTTPInneractive ) 
				{
					pHTTPInneractive = new cHTTPConnection();
				}

				pHTTPInneractive->SetHost( "m2m1.inner-active.mobi", 0 );

				uString sPost;
				sPost.Format( "aid=%s&v=Sm2m-1.5.3&po=659&test=true", m_sInneractiveCode.GetStr() );
				if ( m_sAdClientID.GetLength() > 0 ) 
				{
					sPost.Append( "&cid=" );
					sPost.Append( m_sAdClientID.GetStr() );
				}

				bool result = pHTTPInneractive->SendRequestASync( "simpleM2M/clientRequestAd", sPost );
				if ( !result ) 
				{
					agk::Warning( "Failed to get advert from Inneractive server" ); 
					delete pHTTPInneractive;
					m_iInneractiveStage = 5;
					m_fAdStartTime = agk::Timer();
					return;
				}

				m_iInneractiveStage = 1;
				*/
			}

			break;
		}
	}

	if ( m_pAdSprite ) m_pAdSprite->Update( agk::GetFrameTime() );
}

void agk::DrawAd()
{
	if ( m_pAdSprite ) m_pAdSprite->Draw();
}

//****f* File/Zip/CreateZip
// FUNCTION
//   Creates a zip file at the specified location and opens it ready for files to be added. Files cannot be read or extracted
//   from a zip file using this command. Use <i>ExtractZip</i> to retrieve files from it.<br><br>
//   The file path is relative to the current directory set using <i>SetFolder</i> unless you start the path with a forward 
//   slash, in which case the path will be relative to the root of the write directory on the current platform.
// INPUTS
//   zipID -- The ID used to reference this zip file.
//   filename -- The file name and path for this new zip file.
// SOURCE
void agk::CreateZip( uint32_t zipID, const char* filename )
//****
{
	if ( m_cZipFileList.GetItem( zipID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create zip file " );
		errStr.AppendUInt( zipID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	ZipFile *pZipFile = new ZipFile();
	pZipFile->Create( filename );
	m_cZipFileList.AddItem( pZipFile, zipID );
}

//****f* File/Zip/CreateZip
// FUNCTION
//   Creates a zip file at the specified location and opens it ready for files to be added. Files cannot be read or extracted
//   from a zip file using this command. Use <i>ExtractZip</i> to retrieve files from it.<br><br>
//   The file path is relative to the current directory set using <i>SetFolder</i> unless you start the path with a forward 
//   slash, in which case the path will be relative to the root of the write directory on the current platform.
// INPUTS
//   zipID -- The ID used to reference this zip file.
//   filename -- The file name and path for this new zip file.
// SOURCE
uint32_t agk::CreateZip( const char* filename )
//****
{
	uint32_t zipID = m_cZipFileList.GetFreeID();
	if ( zipID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create zip file - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateZip( zipID, filename );
	return zipID;
}

//****f* File/Zip/AddZipEntry
// FUNCTION
//   Adds a local file into the zip file. The path variable is the path to the local file, the zipPath variable
//   is the path that will be used inside the zip file, this is the only way to add folders to the zip file (by
//   adding a file with a zipPath such as "folder1/myfile.txt").<br><br>
//   The local file path is relative to the current directory set using <i>SetFolder</i> unless you start the 
//   path with a forward slash, in which case the path will be relative to the root of the write directory on the 
//   current platform.
// INPUTS
//   zipID -- The ID of the zip file to add to.
//   path -- The path of the file to add.
//   zipPath -- The path for the file inside the zip.
// SOURCE
void agk::AddZipEntry( uint32_t zipID, const char* path, const char* zipPath )
//****
{
	ZipFile *pZipFile = m_cZipFileList.GetItem( zipID );
	if ( !pZipFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to add zip file entry to ID " );
		errStr.AppendUInt( zipID ).Append( " - ID does not exist" );
		Error( errStr );
#endif
		return;
	}

	pZipFile->AddEntry( path, zipPath );
}

//****f* File/Zip/CloseZip
// FUNCTION
//   Closes a zip file opened with <i>CreateZip</i>. This finalizes the zip and allows it to be opened for extraction.
// INPUTS
//   zipID -- The ID of the zip file to close.
// SOURCE
void agk::CloseZip( uint32_t zipID )
//****
{
	ZipFile *pZipFile = m_cZipFileList.RemoveItem( zipID );
	if ( !pZipFile )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to close zip file " );
		errStr.AppendUInt( zipID ).Append( " - ID does not exist" );
		Error( errStr );
#endif
		return;
	}

	pZipFile->Close();
	delete pZipFile;
}

//****f* File/Zip/ExtractZip
// FUNCTION
//   Extracts a zip file to a specified directory. Any folders created inside the zip file will be created
//   in the extraction process.<br><br>
//   The local file path is relative to the current directory set using <i>SetFolder</i> unless you start the 
//   path with a forward slash, in which case the path will be relative to the root of the write directory on the 
//   current platform.
// INPUTS
//   zipfilename -- The path to the zip file to extract.
//   path -- The path to place the newly extracted zip files.
// SOURCE
void agk::ExtractZip( const char* zipfilename, const char* path )
//****
{
	ZipFile::ExtractAll( zipfilename, path , NULL, NULL );
}

//****f* File/Zip/ExtractZip
// FUNCTION
//   Extracts a zip file to a specified directory. Any folders created inside the zip file will be created
//   in the extraction process. If the zip file is password protected specify the password to extract it.
//   If you specify a wrong password, the extracted files from the zip archive will be empty.<br><br>
//   The local file path is relative to the current directory set using <i>SetFolder</i> unless you start the 
//   path with a forward slash, in which case the path will be relative to the root of the write directory on the 
//   current platform.
// INPUTS
//   zipfilename -- The path to the zip file to extract.
//   path -- The path to place the newly extracted zip files.
//   password -- The password that was used to create the zip file.
// SOURCE
void agk::ExtractZip(const char* zipfilename, const char* path, const char* password)
//****
{
	//PE:
	ZipFile::ExtractAll(zipfilename, path, password, NULL);
}

//****f* File/Zip/ExtractZipASync
// FUNCTION
//   This command does the same as <i>ExtractZip</i> except it returns immediately and the zip extraction is 
//   done on a thread in the background. You can use <i>GetZipExtractProgress</i> and <i>GetZipExtractComplete</i>
//   to check on its progress. If you call this command whilst a zip extraction is already in progress then 
//   nothing will happen. If the specified zip has no password then use an empty string.
// INPUTS
//   zipfilename -- The path to the zip file to extract.
//   path -- The path to place the newly extracted zip files.
//   password -- The password that was used to create the zip file.
// SOURCE
void agk::ExtractZipASync(const char* zipfilename, const char* path, const char* password)
//****
{
	if ( g_ZipExtracter.IsRunning() ) return;

	g_ZipExtracter.m_sFilename.SetStr( zipfilename );
	g_ZipExtracter.m_sExtractPath.SetStr( path );
	g_ZipExtracter.m_sPassword.SetStr( password );

	g_ZipExtracter.m_fProgress = 0;
	g_ZipExtracter.Start();
}

//****f* File/Zip/GetZipExtractProgress
// FUNCTION
//   Returns a value between 0 and 100 to represent the progress of the zip extraction started with <i>ExtractZipASync</i>.
// SOURCE
float agk::GetZipExtractProgress()
//****
{
	return g_ZipExtracter.m_fProgress;
}

//****f* File/Zip/GetZipExtractComplete
// FUNCTION
//   Returns 0 if a zip extraction started with <i>ExtractZipASync</i> is in progress, or 1 if it has finished. It does 
//   not give an indication of if the extraction was successful, only that it has finished.
// SOURCE
int agk::GetZipExtractComplete()
//****
{
	return g_ZipExtracter.IsRunning() ? 0 : 1;
}

//****f* File/Zip/CancelZipExtract
// FUNCTION
//   Stops any asynchronous zip extraction that is currently in progress, it may take a moment to finish the current file
//   and then it will stop. Once it finishes <i>GetZipExtractComplete</i> will return 1 and <i>GetZipExtractProgress</i>
//   will remain at whatever value it was currently at.
// SOURCE
void agk::CancelZipExtract()
//****
{
	g_ZipExtracter.Stop();
}


//
// V108
//

//****f* Error/General/Log
// FUNCTION
//   Displays the specified text to the appropriate device log or output window.
// INPUTS
//   szMessage -- the text message to send to the log/output area
// SOURCE
void agk::Log( const char *szMessage )
//****
{
	// report as message
	agk::DebugInfo( "Log", szMessage );
}

// These functions are implemented in the app project itself, not in the engine
// as they rely on things such as the delegate implementation, e.t.c.
// Paul, if we can move them to the engine at some point, it would be better.
    
// internally called by AGK
void agk::SocialPluginsSetup ( void )
{
    PlatformSocialPluginsSetup();    
}

// internally called by AGK
void agk::SocialPluginsDestroy ( void )
{
    PlatformSocialPluginsDestroy();    
}

//****f* Extras/Ratings/RateApp
// FUNCTION
//   Displays a dialog box asking the user to rate the app on the App Store.
//   Currently this command is only supported on iOS.
// INPUTS
//   szID -- This is the ID of your app. You can obtain this from iTunes Connect.
// SOURCE
void agk::RateApp ( const char* szID )
//****
{
#ifdef AGK_IOS
	PlatformRateApp(szID, 0, 0);
#endif
}
    
//****f* Extras/Ratings/RateApp
// FUNCTION
//   Displays a dialog box asking the user to rate the app on the App Store.
//   Currently this command is only supported on iOS.
// INPUTS
//   szID -- This is the ID of your app. You can obtain this from iTunes Connect.
//   szTitle -- The string to use as the title of the dialog box, normally this is "Rate AppName"
// SOURCE
void agk::RateApp ( const char* szID, const char* szTitle )
//****
{
#ifdef AGK_IOS
    PlatformRateApp(szID, szTitle, 0);
#endif
}

//****f* Extras/Ratings/RateApp
// FUNCTION
//   Displays a dialog box asking the user to rate the app on the App Store.
//   Currently this command is only supported on iOS.
// INPUTS
//   szID -- This is the ID of your app. You can obtain this from iTunes Connect.
//   szTitle -- The string to use as the title of the dialog box, normally this is "Rate AppName"
//   szMessage -- The string to use as the message of the dialog box
// SOURCE
void agk::RateApp ( const char* szID, const char* szTitle, const char* szMessage )
//****
{
#ifdef AGK_IOS
    PlatformRateApp(szID, szTitle, szMessage);
#endif
}

//****f* Extras/Ratings/RequestAppReview
// FUNCTION
//   iOS 10.3+ and Android 5.0+ have the ability for the user to review your app from within the
//   app itself, this command will tell iOS or Android to start this process. Note that it is not guaranteed
//   to display anything when you call this command, and it should not be called in response to
//   a button press or other user interaction. You should call it when there is a lull in the app
//   such as the end of a level. If you want to start the review process in response to a user 
//   action, such as a button press, then you should use the OpenBrowser command to open the AppStore.
// SOURCE
void agk::RequestAppReview()
//****
{
#ifdef AGK_IOS
    if ([SKStoreReviewController respondsToSelector:@selector(requestReview)])
    {
        [SKStoreReviewController requestReview];
    }
#endif

#ifdef AGK_ANDROID
	PlatformRateApp("","","");
#endif
}

void agk::InAppPurchaseReset()
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
	PlatformInAppPurchaseReset();
#endif
}

//****f* Extras/In App Purchase/InAppPurchaseSetKeys
// FUNCTION
//   This command is only used by Ouya where you need to provide your public key in base64.
//   This must be called before <i>InAppPurchaseSetup</i>
// INPUTS
//   szData1 -- Public Key
//   szData2 -- Developer UUID (Ouya only)
// SOURCE
void agk::InAppPurchaseSetKeys ( const char* szData1, const char* szData2 )
//****
{
	PlatformInAppPurchaseSetKeys(szData1, szData2);
}

//****f* Extras/In App Purchase/InAppPurchaseSetTitle
// FUNCTION
//   Sets the name of your application so that it can be displayed on any dialogs
//   that get displayed when using the in app purchase commands.
//   Currently this command is only supported on iOS and Android.
// INPUTS
//   szTitle -- Name of your application
// SOURCE
void agk::InAppPurchaseSetTitle ( const char* szTitle )
//****
{
    PlatformInAppPurchaseSetTitle(szTitle);
}

//****f* Extras/In App Purchase/InAppPurchaseAddProductID
// FUNCTION
//   Use this command to add any product IDs into the list e.g. com.yourcompany.yourproduct.iap.
//   The first product ID you add becomes 0, the second is 1 etc.
//   You must also specify the type of product this is, non-consumable(0), consumable(0), or 
//   subscription(2). Previously consumable products were added as type=1 but they are now 
//   added as type=0 and <i>InAppPurchaseResetPurchase</i> is used to reset a consumable to a
//   purchasable state.<br/><br/>
//   Consumable products are like coins that can be bought again and again, whereas 
//   non-consumable products are one off purchases like unlocking the full version of an app.
//   In Google Play consumable and non-consumable products are added the same way.
//   Currently this command is only supported on iOS, Google Play, and Amazon.
//   This must be called before InAppPurchaseSetup, after that no further products can be added.
// INPUTS
//   szID -- The product ID as specified in iTunes Connect or the Google Play developer console
//   type -- The type of product this is, non consumable(0), consumable(0), or subscription(2)
// SOURCE
void agk::InAppPurchaseAddProductID ( const char* szID, int type )
//****
{
	if ( type == 1 )
	{
		static int warned = 0;
		if ( !warned ) Message( "Using InAppPurchaseAddProductID with type=1 is no longer supported. Use type=0 for consumables and then call InAppPurchaseResetPurchase to consume it" );
		warned = 1;
		return;
	}

    PlatformInAppPurchaseAddProductID(szID, type);
}

//****f* Extras/In App Purchase/InAppPurchaseSetup
// FUNCTION
//   After setting the in app purchase title and adding product IDs call InAppPurchaseSetup
//   to finalise the process. After this point you can attempt to purchase unlockable content.
//   Currently this command is only supported on iOS and Android.
// SOURCE
void agk::InAppPurchaseSetup()
//****
{
    PlatformInAppPurchaseSetup();
}

//****f* Extras/In App Purchase/GetInAppPurchaseAvailable
// FUNCTION
//   Returns 1 if the extra content has been purchased and is therefore available. Returns 0
//   if the content is not available. It is recommended that you use the newer 
//   <i>GetInAppPurchaseAvailable2</i> to get a more detailed response.
//   Currently this command is only supported on iOS and Android.
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
int agk::GetInAppPurchaseAvailable ( int iID )
//****
{
    return PlatformGetInAppPurchaseAvailable(iID);
}

//****f* Extras/In App Purchase/GetInAppPurchaseAvailable2
// FUNCTION
//   A more detailed version of <i>GetInAppPurchaseAvailable</i> that gives the purchase state<br/>
//   Returns 0 if the product is not purchased<br/>
//   Returns 1 if the product is queued for purchased<br/>
//   Returns 2 if the product purchase is in progress<br/>
//   Returns 3 if the product purchase is pending (subject to payment clearance)<br/>
//   Returns 4 if the product is purchased<br/>
//   You should only reward the user once the product reaches state 4 (purchased).
//   Currently this command is only supported on iOS and Android.
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
int agk::GetInAppPurchaseAvailable2 ( int iID )
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
    return PlatformGetInAppPurchaseAvailable2(iID);
#else 
	return 0;
#endif
}

//****f* Extras/In App Purchase/InAppPurchaseActivate
// FUNCTION
//   Call this when you want to start the process of purchasing a product.
//   Currently this command is only supported on iOS and Android.
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
void agk::InAppPurchaseActivate ( int iID )
//****
{
    PlatformInAppPurchaseActivate(iID);
}

//****f* Extras/In App Purchase/InAppPurchaseActivateWithPlan
// FUNCTION
//   Call this when you want to start the process of purchasing a product with a specific plan.
//   Subscriptions can have multiple purchase plans which you can enumerate with <i>GetInAppPurchaseSubNumPlans</i>.
//   To start a purchase with a specific plan get the plan token with <i>GetInAppPurchaseSubPlanToken</i> and then 
//   pass it to this command.
//   Currently this command is only supported on iOS and Android.
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
void agk::InAppPurchaseActivateWithPlan( int iID, const char* planToken )
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
    PlatformInAppPurchaseActivateWithPlan(iID, planToken);
#endif
}

//****f* Extras/In App Purchase/InAppPurchaseResetPurchase
// FUNCTION
//   Call this command to reset the purchase state of an individual product. On Android this must be called 
//   for consumable products after you have dealt with a purchase to allow it to be purchased again.
//   If you call this command on a non-consumable purchase then that purchase will be reset to an unpurchased 
//   state and the user will have to pay for it again, this should only be used during testing.
//   Subscriptions cannot be reset and must be cancelled by the user through their Google Play account<br/>
//   <br/>
//   On iOS this command is not necessary as it automatically allows consumable items to be purchased multiple 
//   times, however this command could still be useful to reset the <i>GetInAppPurchaseAvailable2</i> state to 0 
//   so you know it has been dealt with. Reseting a non-consumable purchase on iOS will reset the state to 0
//   but iOS will still remember the purchase and not charge the user again.<br/>
//   <br/>
//   Use <i>GetInAppPurchaseToken</i> to get the token required to reset a purchase. Currently this command is 
//   only supported on Android and iOS.
// INPUTS
//   token -- The most recent token from GetInAppPurchaseToken for this product
// SOURCE
void agk::InAppPurchaseResetPurchase( const char* token )
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
    PlatformInAppPurchaseResetPurchase(token);
#endif
}

//****f* Extras/In App Purchase/InAppPurchaseRedeemOffer
// FUNCTION
//   Call this command to show the redeem offer dialog provided by the device (if any).
//   This currently only applies to iOS, and will only work on iOS 14 or above, otherwise it will do nothing.<br/>
//   Android displays this option automatically when a user starts a purchase.
// SOURCE
void agk::InAppPurchaseRedeemOffer()
//****
{
#if defined(AGK_IOS)
    PlatformInAppPurchaseRedeemOffer();
#endif
}
    
//****f* Extras/In App Purchase/GetInAppPurchaseLocalPrice
// FUNCTION
//   Returns the current price of the specified in app purchase product in the local currency,
//   this will be a string with the currency symbol included where possible.
//   It may take a few seconds after calling <i>InAppPurchaseSetup</i> for this data to become 
//   available, so if you get an empty string try again later.
//   When calling this from Tier 2 you must delete the returned string when you are done with
//   it.
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
char* agk::GetInAppPurchaseLocalPrice ( int iID )
//****
{
    return PlatformGetInAppPurchaseLocalPrice(iID);
}
    
//****f* Extras/In App Purchase/GetInAppPurchaseDescription
// FUNCTION
//   Returns the description for the specified product, as defined by the current platform store.
//   It may take a few seconds after calling <i>InAppPurchaseSetup</i> for this data to become 
//   available, so if you get an empty string try again later.
//   When calling this from Tier 2 you must delete the returned string when you are done with
//   it.
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
char* agk::GetInAppPurchaseDescription ( int iID )
//****
{
    return PlatformGetInAppPurchaseDescription(iID);
}

//****f* Extras/In App Purchase/GetInAppPurchaseIsRenewing
// FUNCTION
//   This command returns 1 if the product is a subscription and it is set to auto-renew, 0 if it 
//   is a subscription that will not auto-renew, or -1 if the renew status could not be determined.
//   This command will only work on Android. iOS requires that you process the app receipt with 
//   <i>GetAppReceipt</i> to detect renewal status.
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
int agk::GetInAppPurchaseIsRenewing( int iID )
//****
{
#ifdef AGK_ANDROID
	return PlatformGetInAppPurchaseIsRenewing( iID );
#else
    return -1;
#endif
}

//****f* Extras/In App Purchase/GetInAppPurchaseState
// FUNCTION
//   This command is deprecated and always returns 1 since multiple purchases can now be ongoing at
//   the same time. Use <i>GetInAppPurchaseAvailable2</i> to check the purchase state.
// SOURCE
int agk::GetInAppPurchaseState()
//****
{
    return 1;
}

//****f* Extras/In App Purchase/InAppPurchaseRestore
// FUNCTION
//   Restores any managed purchases made on this platform. For example if a user purchased at item then
//   reinstalled the app the app would return 0 for GetInAppPurchaseAvailable unless it was purchased again
//   or restored using this command.<br/>
//   <br/>
//   Even though purchasing again wouldn't charge the user again for non-consumable items, using this restore 
//   command is a better user experience. Apple require you to have a button that calls this function 
//   somewhere in your app.<br/>
//   <br/>
//   After calling this command you can call <i>GetInAppPurchaseAvailable2</i> to check for purchases, it 
//   may take some time for the purchase state to update, so check <i>GetInAppPurchaseAvailable2</i> regularly.
//   This command is supported by both iOS and Android
// SOURCE
void agk::InAppPurchaseRestore()
//****
{
	PlatformInAppPurchaseRestore();
}

//****f* Extras/In App Purchase/GetInAppPurchaseSignature
// FUNCTION
//   Returns the signature for the last purchase of the given item, this can be checked against your public 
//   key to confirm the purchase was valid. It is recommended that you pass this signature to a server to do 
//   the check so that the check cannot be bypassed.<br/><br/>
//   This has been deprecated on iOS, you should use the <i>GetAppReceipt</i> command instead that will return
//   a list of all purchases related to the app.
// INPUTS
//   iID -- The ID of the product to check. e.g. your first product ID is 0, your second is 1 etc.
// SOURCE
char* agk::GetInAppPurchaseSignature(int iID)
//****
{
	return PlatformGetInAppPurchaseSignature(iID);
}

//****f* Extras/In App Purchase/GetInAppPurchaseToken
// FUNCTION
//   On Android this returns a unique token for the last purchase of the given item, this can be sent to your 
//   server to check the validity of the purchase with Google, and to distinguish between different instances 
//   of a consumable purchase. You should only reward the user once per token for consumable purchases, it is 
//   recommended that you store a list of past tokens on a server so you can detect any token reuse, which 
//   could be used to cheat your system. Once you have rewarded the user for a consumable purchase you must call 
//   <i>InAppPurchaseResetPurchase</i> with the most recent token to allow it to be purchased again.<br/>
//   <br/>
//   On iOS this returns a transaction ID that changes with every purchase the user makes. It can't be used 
//   to check with Apple if a transaction was genuine but it can be used to distinguish between multiple 
//   purchases of a consumable item. You can pass this token to <i>InAppPurchaseResetPurchase</i> to reset
//   the purchase state to 0 but on iOS this is not required.<br/>
//   <br/>
//   This only works on Android and iOS, other platforms will return an empty string
// INPUTS
//   iID -- The ID of the product to check. e.g. your first product ID is 0, your second is 1 etc.
// SOURCE
char* agk::GetInAppPurchaseToken(int iID)
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
	return PlatformGetInAppPurchaseToken(iID);
#else
	char* str = new char[1]; *str = 0;
	return str;
#endif
}

//****f* Extras/In App Purchase/GetInAppPurchaseSubNumPlans
// FUNCTION
//   
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
int agk::GetInAppPurchaseSubNumPlans( int iID )
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
	return PlatformGetInAppPurchaseSubNumPlans(iID);
#else
	return 0;
#endif
}

//****f* Extras/In App Purchase/GetInAppPurchaseSubPlanNumPeriods
// FUNCTION
//   
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
int agk::GetInAppPurchaseSubPlanNumPeriods( int iID, int planIndex )
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
	return PlatformGetInAppPurchaseSubPlanNumPeriods(iID, planIndex);
#else
	return 0;
#endif
}

//****f* Extras/In App Purchase/GetInAppPurchaseSubPlanPrice
// FUNCTION
//   
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
char* agk::GetInAppPurchaseSubPlanPrice( int iID, int planIndex, int periodIndex )
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
	return PlatformGetInAppPurchaseSubPlanPrice(iID, planIndex, periodIndex);
#else
	char* str = new char[1]; *str = 0;
	return str;
#endif
}

//****f* Extras/In App Purchase/GetInAppPurchaseSubPlanDuration
// FUNCTION
//   
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
int agk::GetInAppPurchaseSubPlanDuration( int iID, int planIndex, int periodIndex )
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
	return PlatformGetInAppPurchaseSubPlanDuration(iID, planIndex, periodIndex);
#else
	return 0;
#endif
}

//****f* Extras/In App Purchase/GetInAppPurchaseSubPlanDurationUnit
// FUNCTION
//   
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
char* agk::GetInAppPurchaseSubPlanDurationUnit( int iID, int planIndex, int periodIndex )
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
	return PlatformGetInAppPurchaseSubPlanDurationUnit(iID, planIndex, periodIndex);
#else
	char* str = new char[1]; *str = 0;
	return str;
#endif
}

//****f* Extras/In App Purchase/GetInAppPurchaseSubPlanPaymentType
// FUNCTION
//   
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
int agk::GetInAppPurchaseSubPlanPaymentType( int iID, int planIndex, int periodIndex )
//****
{
#if defined(AGK_ANDROID) || defined(AGK_IOS)
	return PlatformGetInAppPurchaseSubPlanPaymentType(iID, planIndex, periodIndex);
#else
	return 0;
#endif
}

//****f* Extras/In App Purchase/GetInAppPurchaseSubPlanTags
// FUNCTION
//   
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
char* agk::GetInAppPurchaseSubPlanTags( int iID, int planIndex )
//****
{
	#if defined(AGK_ANDROID) || defined(AGK_IOS)
	return PlatformGetInAppPurchaseSubPlanTags(iID, planIndex);
#else
	char* str = new char[1]; *str = 0;
	return str;
#endif
}

//****f* Extras/In App Purchase/GetInAppPurchaseSubPlanToken
// FUNCTION
//   
// INPUTS
//   iID -- this ID corresponds to the product IDs that have been added e.g. your first product
//         ID is 0, your second is 1 etc.
// SOURCE
char* agk::GetInAppPurchaseSubPlanToken( int iID, int planIndex )
//****
{
	#if defined(AGK_ANDROID) || defined(AGK_IOS)
	return PlatformGetInAppPurchaseSubPlanToken(iID, planIndex);
#else
	char* str = new char[1]; *str = 0;
	return str;
#endif
}

//****f* Extras/In App Purchase/GetAppReceipt
// FUNCTION
//   Returns the app receipt that contains a list of all purchases as a base64 encoded string.
//   This can be sent to a server you control to validate the purchases, including the purchase of the app itself.
//   Only available on iOS, other platforms will return an empty string.
// SOURCE
char* agk::GetAppReceipt()
//****
{
#if defined(AGK_IOS)
    return PlatformGetAppReceipt();
#else
    char* str = new char[1];
    *str = 0;
    return str;
#endif
}

void agk::TwitterSetup ( const char* szKey, const char* szSecret )
//****    
{
    PlatformTwitterSetup(szKey,szSecret);
}

void agk::TwitterMessage ( const char* szMessage )
//****
{
    PlatformTwitterMessage(szMessage);
}

//****f* Extras/Facebook/FacebookSetup
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// INPUTS
//   szID -- your Facebook app ID.
// SOURCE
void agk::FacebookSetup ( const char* szID )
//****
{
    PlatformFacebookSetup(szID);
}

//****f* Extras/Facebook/GetFacebookLoggedIn
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
int agk::GetFacebookLoggedIn()
//****
{
    return PlatformGetFacebookLoggedIn();
}

//****f* Extras/Facebook/FacebookGetUserID
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
char* agk::FacebookGetUserID()
//****
{
	return agk::PlatformFacebookGetUserID();
}

//****f* Extras/Facebook/FacebookGetUserName
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
char* agk::FacebookGetUserName()
//****
{
	return agk::PlatformFacebookGetUserName();
}

//****f* Extras/Facebook/FacebookGetAccessToken
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
char* agk::FacebookGetAccessToken()
//****
{
	return agk::PlatformFacebookGetAccessToken();
}

//****f* Extras/Facebook/FacebookLogin
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
void agk::FacebookLogin()
//****
{
    PlatformFacebookLogin();
}

//****f* Extras/Facebook/FacebookLogout
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
void agk::FacebookLogout()
//****
{
    PlatformFacebookLogout();
}

//****f* Extras/Facebook/FacebookPostOnMyWall
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything. You can use <i>ShareText</i> or <i>ShareImage</i>
//   give the user the option of how to share their information.
// SOURCE
void agk::FacebookPostOnMyWall ( const char* szLink, const char* szPicture, const char* szName, const char* szCaption, const char* szDescription )
//****
{
    PlatformFacebookPostOnMyWall(szLink, szPicture, szName, szCaption, szDescription);
}

//****f* Extras/Facebook/FacebookPostOnFriendsWall
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
void agk::FacebookPostOnFriendsWall ( const char* szID, const char* szLink, const char* szPicture, const char* szName, const char* szCaption, const char* szDescription )
//****
{
    PlatformFacebookPostOnFriendsWall(szID, szLink, szPicture, szName, szCaption, szDescription);
}

//****f* Extras/Facebook/FacebookInviteFriend
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
void agk::FacebookInviteFriend ( const char* szID, const char* szMessage )
//****
{
    PlatformFacebookInviteFriend(szID, szMessage);
}

//****f* Extras/Facebook/FacebookShowLikeButton
// FUNCTION
//   This command is not currently supported
// INPUTS
//   szURL   -- URL that you want to like.
//   iX      -- x position of like button.
//   iY      -- y position of like button.
//   iWidth  -- width of like button.
//   iHeight -- height of like button.
// SOURCE
void agk::FacebookShowLikeButton ( const char* szURL, int iX, int iY, int iWidth, int iHeight )
//****
{
	PlatformFacebookShowLikeButton(szURL, iX, iY, iWidth, iHeight);
}

//****f* Extras/Facebook/FacebookDestroyLikeButton
// FUNCTION
//   This command is not currently supported
// SOURCE
void agk::FacebookDestroyLikeButton()
//****
{
	PlatformFacebookDestroyLikeButton();
}

//****f* Extras/Facebook/FacebookGetFriends
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
void agk::FacebookGetFriends()
//****
{
    PlatformFacebookGetFriends();
}

//****f* Extras/Facebook/FacebookGetFriendsState
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
int agk::FacebookGetFriendsState()
//****
{
    return PlatformFacebookGetFriendsState();
}

//****f* Extras/Facebook/FacebookGetFriendsCount
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
int agk::FacebookGetFriendsCount()
//****
{
    return PlatformFacebookGetFriendsCount();
}

//****f* Extras/Facebook/FacebookGetFriendsName
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
char* agk::FacebookGetFriendsName ( int iIndex )
//****
{
    return PlatformFacebookGetFriendsName(iIndex);
}

//****f* Extras/Facebook/FacebookGetFriendsID
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
char* agk::FacebookGetFriendsID ( int iIndex )
//****
{
    return PlatformFacebookGetFriendsID(iIndex);
}

//****f* Extras/Facebook/FacebookDownloadFriendsPhoto
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
void agk::FacebookDownloadFriendsPhoto ( int iIndex )
//****
{
    PlatformFacebookDownloadFriendsPhoto(iIndex);
}

//****f* Extras/Facebook/GetFacebookDownloadState
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
int agk::GetFacebookDownloadState()
//****
{
    return PlatformGetFacebookDownloadState();
}

//****f* Extras/Facebook/GetFacebookDownloadFile
// FUNCTION
//   The Facebook SDK has been removed from AppGameKit, this command no longer does anything
// SOURCE
char* agk::GetFacebookDownloadFile()
//****
{
    return PlatformGetFacebookDownloadFile();
}

void agk::NotificationCreate ( const char* szDateTime, const char* szMessage, const char* szData )
//****
{
	static int warned = 0;
	if ( !warned )
	{
		// mike - 301121 - we don't need this message popping up
		//agk::Message( "NotificationCreate() has been removed from AppGameKit and no longer does anything. You should use SetLocalNotification() instead" );
		warned = 1;
	}
}

int agk::GetNotification()
//****
{
    return 0;
}

char* agk::GetNotificationData()
//****
{
	char *str = new char[1]; *str = 0;
    return str;
}

void agk::NotificationReset()
//****
{
    
}

// local notifications

//****f* Extras/LocalNotifications/SetLocalNotification
// FUNCTION
//   Creates a local notification that will appear at some point in the future. Notifications are referenced 
//   by ID and can be overwritten by creating a new notification with the same ID as the notification you 
//   want to overwrite. If a notification triggers whilst the app is open then the notification will not 
//   appear and it will silently disappear from the list of scheduled notifications. If the app is not open
//   then a notification will display to the user and tapping on it will open up your app. If you set the
//   deeplink parameter then that URL will be sent to the app when the notification is tapped. The URL can be 
//   retrieved by using the <i>GetURLSchemeText</i> command.
//   The datetime parameter should be specified in unix time, which is measured in seconds since 1st Jan 1970,
//   you can use the command <i>GetUnixTime</i> to return the current date and time then modify it as needed.
//   If the date and time is in the past then the notification will be ignored, it will not overwrite any 
//   existing notification.
//   The ID must be in the range 1 to 100 inclusive.
// INPUTS
//   iID -- The ID to use to reference this notification in future
//   datetime -- The date and time to show this notification in unix time
//   szMessage -- The message to display in the notification
//   szDeepLink -- The URL to send to the app if the notification is tapped
// SOURCE
void agk::SetLocalNotification( int iID, int datetime, const char *szMessage, const char *szDeepLink )
//****
{
	if ( iID < 1 || iID > 100 )
	{
		agk::Error( "Local notification ID must be in the range 1 to 100" );
		return;
	}

	if ( datetime < agk::GetUnixTime() ) return;

	// save notification details otherwise we can't retrieve them
	uString filename("/agk_notification_",25);
	filename.AppendInt( iID );
	cFile agkFile;
	agkFile.OpenToWrite( filename, false );
	agkFile.WriteInteger( datetime );
	agkFile.WriteString2( szMessage );
	agkFile.Close();

	PlatformCreateLocalNotification( iID, datetime, szMessage, szDeepLink );
}

//****f* Extras/LocalNotifications/SetLocalNotification
// FUNCTION
//   Creates a local notification that will appear at some point in the future. Notifications are referenced 
//   by ID and can be overwritten by creating a new notification with the same ID as the notification you 
//   want to overwrite. If a notification triggers whilst the app is open then the notification will not 
//   appear and it will silently disappear from the list of scheduled notifications. If the app is not open
//   then a notification will display to the user and tapping on it will open up your app. If you set the
//   deeplink parameter then that URL will be sent to the app when the notification is tapped. The URL can be 
//   retrieved by using the <i>GetURLSchemeText</i> command.
//   The datetime parameter should be specified in unix time, which is measured in seconds since 1st Jan 1970,
//   you can use the command <i>GetUnixTime</i> to return the current date and time then modify it as needed.
//   If the date and time is in the past then the notification will be ignored, it will not overwrite any 
//   existing notification.
//   The ID must be in the range 1 to 100 inclusive.
// INPUTS
//   iID -- The ID to use to reference this notification in future
//   datetime -- The date and time to show this notification in unix time
//   szMessage -- The message to display in the notification
// SOURCE
void agk::SetLocalNotification( int iID, int datetime, const char *szMessage )
//****
{
	SetLocalNotification( iID, datetime, szMessage, "" );
}

//****f* Extras/LocalNotifications/CancelLocalNotification
// FUNCTION
//   Cancels a notification that was scheduled by this application
// INPUTS
//   iID -- The ID of the notification to cancel
// SOURCE
void agk::CancelLocalNotification( int iID )
//****
{
	if ( iID < 1 || iID > 100 )
	{
		agk::Error( "Local notification ID must be in the range 1 to 100" );
		return;
	}

	uString filename("/agk_notification_",25);
	filename.AppendInt( iID );

	if ( cFile::ExistsWrite( filename ) ) cFile::DeleteFile( filename );

	PlatformCancelLocalNotification( iID );
}

//****f* Extras/LocalNotifications/GetLocalNotificationExists
// FUNCTION
//   Returns 1 if a notification with this ID is waiting to be displayed, otherwise 0.
//   Notifications are refreshed every 5 seconds, so this may continue to return 1 
//   shortly after a notification has fired.
// INPUTS
//   iID -- The ID of the notification to check
// SOURCE
int agk::GetLocalNotificationExists( int iID )
//****
{
	if ( iID < 1 || iID > 100 )
	{
		agk::Error( "Local notification ID must be in the range 1 to 100" );
		return 0;
	}

	uString filename("/agk_notification_",25);
	filename.AppendInt( iID );

	return cFile::ExistsWrite( filename ) ? 1 : 0;
}

//****f* Extras/LocalNotifications/GetLocalNotificationTime
// FUNCTION
//   Returns the date and time that the specified notification is due to display. The returned time
//   will be in unix timestamp format, which is measured by the number of seconds since 1st Jan 1970.
//   If no notification exists at the specified ID then 0 is returned
// INPUTS
//   iID -- The ID of the notification to check
// SOURCE
int agk::GetLocalNotificationTime( int iID )
//****
{
	if ( iID < 1 || iID > 100 )
	{
		agk::Error( "Local notification ID must be in the range 1 to 100" );
		return 0;
	}

	uString filename("/agk_notification_",25);
	filename.AppendInt( iID );

	if ( cFile::ExistsWrite( filename ) )
	{
		cFile agkFile;
		agkFile.OpenToRead( filename );
		int datetime = agkFile.ReadInteger();
		agkFile.Close();
		return datetime;
	}
	else return 0;
}

//****f* Extras/LocalNotifications/GetLocalNotificationMessage
// FUNCTION
//   Returns the message that the specified notification will display. If no notification exists 
//   at the specified ID then an empty string will be returned
// INPUTS
//   iID -- The ID of the notification to check
// SOURCE
char* agk::GetLocalNotificationMessage( int iID )
//****
{
	if ( iID < 1 || iID > 100 )
	{
		agk::Error( "Local notification ID must be in the range 1 to 100" );
		char *str = new char[1]; *str = 0;
		return str;
	}

	uString filename("/agk_notification_",25);
	filename.AppendInt( iID );

	if ( cFile::ExistsWrite( filename ) )
	{
		cFile agkFile;
		agkFile.OpenToRead( filename );
		int datetime = agkFile.ReadInteger();
		uString sMsg;
		agkFile.ReadString2( sMsg );
		agkFile.Close();

		char *str = new char[ sMsg.GetLength()+1 ];
		strcpy( str, sMsg.GetStr() );
		return str;
	}
	else 
	{
		char *str = new char[1]; *str = 0;
		return str;
	}
}

// called by the system to check if a notification has passed and needs deleting
void agk::CheckLocalNotifications()
{
	// only check the files every 5 seconds
	static float lastTime = -5;
	float currTime = agk::Timer();
	if ( currTime - lastTime > 0 && currTime - lastTime < 5 ) return;
	lastTime = currTime;
	
	char filename[ 25 ];
	char num[ 5 ];
	strcpy( filename, "/agk_notification_" );

	for ( int i = 1; i <= 100; i++ )
	{
		sprintf( num, "%d", i );
		filename[18] = 0;
		strcat( filename, num );
		if ( cFile::ExistsWrite( filename ) )
		{
			cFile agkFile;
			agkFile.OpenToRead( filename );
			int datetime = agkFile.ReadInteger();
			agkFile.Close();
			if ( datetime < agk::GetUnixTime() ) agk::DeleteFile( filename );
		}
	}
}

// drawing commands

//****f* Core/Drawing/MakeColor
// FUNCTION
//   Creates a compound color value from color components that can then be used with 2D drawing commands.
// INPUTS
//   red -- The red component of the color.
//   green -- The green component of the color.
//   blue -- The blue component of the color.
// SOURCE
uint32_t agk::MakeColor( uint32_t red, uint32_t green, uint32_t blue )
//****
{
	uint32_t color = 0xff00 | blue;
	color <<= 8;
	color |= green; 
	color <<= 8;
	color |= red;
	return color;
}

//****f* Core/Drawing/MakeColor
// FUNCTION
//   Creates a compound color value from color components that can then be used with 2D drawing commands.
// INPUTS
//   red -- The red component of the color.
//   green -- The green component of the color.
//   blue -- The blue component of the color.
//   alpha -- The alpha component of the color between 0 for transparent 255 for opaque
// SOURCE
uint32_t agk::MakeColor( uint32_t red, uint32_t green, uint32_t blue, uint32_t alpha )
//****
{
	uint32_t color = alpha << 8;
	color |= blue; 
	color <<= 8;
	color |= green; 
	color <<= 8;
	color |= red;
	return color;
}

//****f* Core/Drawing/GetColorRed
// FUNCTION
//   Returns the red component of a compound color value created with <i>MakeColor</i>
// INPUTS
//   color -- The color value to decompose.
// SOURCE
uint32_t agk::GetColorRed( uint32_t color )
//****
{
	return color & 0xff;
}

//****f* Core/Drawing/GetColorGreen
// FUNCTION
//   Returns the green component of a compound color value created with <i>MakeColor</i>
// INPUTS
//   color -- The color value to decompose.
// SOURCE
uint32_t agk::GetColorGreen( uint32_t color )
//****
{
	return (color >> 8) & 0xff;
}

//****f* Core/Drawing/GetColorBlue
// FUNCTION
//   Returns the blue component of a compound color value created with <i>MakeColor</i>
// INPUTS
//   color -- The color value to decompose.
// SOURCE
uint32_t agk::GetColorBlue( uint32_t color )
//****
{
	return (color >> 16) & 0xff;
}

//****f* Core/Drawing/GetColorAlpha
// FUNCTION
//   Returns the alpha component of a compound color value created with <i>MakeColor</i>
// INPUTS
//   color -- The color value to decompose.
// SOURCE
uint32_t agk::GetColorAlpha( uint32_t color )
//****
{
	return (color >> 24) & 0xff;
}

void agk::DrawLineInternal( float x, float y, float x2, float y2, uint32_t color1, uint32_t color2 )
{
	uint32_t iLineFloats = m_linesVertexLayout.m_iVertexSize/4;

	if ( m_iNumLineVertices+2 > m_iLineArraySize )
	{
		uint32_t newSize = m_iLineArraySize + m_iLineArraySize/2;
		float* newLines = new float[ newSize * iLineFloats ];

		if ( m_iNumLineVertices > 0 ) memcpy( newLines, m_pLineVertexData, m_iNumLineVertices * iLineFloats * sizeof(float) );

		delete [] m_pLineVertexData;
		m_pLineVertexData = newLines;
		m_iLineArraySize = newSize;
	}

	float diffX = agk::m_iDisplayWidth / (float) agk::Round(agk::m_fTargetViewportWidth);
	float diffY = agk::m_iDisplayHeight / (float) agk::Round(agk::m_fTargetViewportHeight);

	float onePixel = diffX*diffX + diffY*diffY;
	float lineLength = (x2-x)*(x2-x) + (y2-y)*(y2-y);
	if ( lineLength < onePixel )
	{
		x2 = x + diffX;
		y2 = y;// + diffY;
	}

	float *pLineVertexPtr = m_pLineVertexData + (m_iNumLineVertices * iLineFloats);

	// vertex 1
	pLineVertexPtr[0] = x;
	pLineVertexPtr[1] = y;
	pLineVertexPtr[2] = 0;
	pLineVertexPtr[3] = (color1 & 0xff) / 255.0f;
	pLineVertexPtr[4] = ((color1 >> 8) & 0xff) / 255.0f;
	pLineVertexPtr[5] = ((color1 >> 16) & 0xff) / 255.0f;
	pLineVertexPtr[6] = (color1 >> 24) / 255.0f;

	// vertex 2
	pLineVertexPtr[7] = x2;
	pLineVertexPtr[8] = y2;
	pLineVertexPtr[9] = 0;
	pLineVertexPtr[10] = (color2 & 0xff) / 255.0f;
	pLineVertexPtr[11] = ((color2 >> 8) & 0xff) / 255.0f;
	pLineVertexPtr[12] = ((color2 >> 16) & 0xff) / 255.0f;
	pLineVertexPtr[13] = (color2 >> 24) / 255.0f;

	m_iNumLineVertices += 2;
}

//****f* Core/Drawing/DrawLine
// FUNCTION
//   Draws a 2D line from one point on the screen to another with a chosen color.
//   Lines appear above all other drawing except the Print command and can be used
//   with the GetImage function to create new images.
//   The XY coordinates are in screen coordinates so are not affected by the 
//   SetViewOffset command.
// INPUTS
//   x -- The X component of the start position of the line.
//   y -- The Y component of the start position of the line.
//   x2 -- The X component of the end position of the line.
//   y2 -- The Y component of the end position of the line.
//   red -- The red component of the line color.
//   green -- The green component of the line color.
//   blue -- The blue component of the line color.
// SOURCE
void agk::DrawLine( float x, float y, float x2, float y2, uint32_t red, uint32_t green, uint32_t blue )
//****
{
	uint32_t color = MakeColor( red, green, blue );
	DrawLine( x, y, x2, y2, color, color );
}

//****f* Core/Drawing/DrawLine
// FUNCTION
//   Draws a 2D line from one point on the screen to another with a chosen color gradient.
//   The color values should be created with <i>MakeColor</i>.
//   Lines appear above all other drawing except the Print command and can be used
//   with the GetImage function to create new images.
//   The XY coordinates are in screen coordinates so are not affected by the 
//   SetViewOffset command.
// INPUTS
//   x -- The X component of the start position of the line.
//   y -- The Y component of the start position of the line.
//   x2 -- The X component of the end position of the line.
//   y2 -- The Y component of the end position of the line.
//   color1 -- The color to use at the start of the line.
//   color2 -- The color to use at the end of the line.
// SOURCE
void agk::DrawLine( float x, float y, float x2, float y2, uint32_t color1, uint32_t color2 )
//****
{
	float VwDw = agk::Round(agk::m_fTargetViewportWidth) / (float) agk::m_iDisplayWidth;
	float VhDh = agk::Round(agk::m_fTargetViewportHeight) / (float) agk::m_iDisplayHeight;

	if ( AGKFrameBuffer::g_pCurrFrameBuffer )
	{
		VwDw = AGKFrameBuffer::g_pCurrFrameBuffer->GetWidth() / (float)(agk::m_iDisplayExtraX*2 + agk::m_iDisplayWidth);
		VhDh = AGKFrameBuffer::g_pCurrFrameBuffer->GetHeight() / (float)(agk::m_iDisplayExtraY*2 + agk::m_iDisplayHeight);
	}
	
	float px = agk::Round( x*VwDw ) + 0.5f;
	float py = agk::Round( y*VhDh ) + 0.5f;
	
	float px2 = agk::Round( x2*VwDw ) + 0.5f;
	float py2 = agk::Round( y2*VhDh ) + 0.5f;
	
	if ( px2 == px && py2 == py )
	{
		px -= 0.5f;
		px2 += 0.5f;
	}
	else
	{
		float diffX = px2-px;
		float diffY = py2-py;
		float lineLength = sqrt(diffX*diffX + diffY*diffY);
		diffX = 0.5f*diffX / lineLength;
		diffY = 0.5f*diffY / lineLength;
		
		px -= diffX;
		py -= diffY;
		px2 += diffX;
		py2 += diffY;
	}

	x = px / VwDw;
	y = py / VhDh;
	x2 = px2 / VwDw;
	y2 = py2 / VhDh;

	DrawLineInternal( x, y, x2, y2, color1, color2 );
}

//****f* Core/Drawing/DrawBox
// FUNCTION
//   Draws a 2D box from one point on the screen to another with a chosen color using lines.
//   Lines appear above all other drawing except the Print command and can be used
//   with the GetImage function or <i>SetRenderToImage</i> to create new images.
//   The XY coordinates are in screen coordinates so are not affected by the 
//   SetViewOffset command.
//   Colors can be created using the MakeColor command or by using the bitwise
//   operators like so, mycolor = (blue << 16) || (green << 8) || red
// INPUTS
//   x -- The X component of the top left corner of the box.
//   y -- The Y component of the top left corner of the box.
//   x2 -- The X component of the bottom right corner of the box.
//   y2 -- The Y component of the bottom right corner of the box.
//   color1 -- The color to use in the top left corner.
//   color2 -- The color to use in the top right corner.
//   color3 -- The color to use in the bottom left corner.
//   color4 -- The color to use in the bottom right corner.
//   filled -- 1 to draw a filled box, 0 to draw an empty box.
// SOURCE
void agk::DrawBox( float x, float y, float x2, float y2, uint32_t color1, uint32_t color2, uint32_t color3, uint32_t color4, int filled )
//****
{
	if ( y == y2 || x == x2 ) return;

	if ( y2 < y )
	{
		float temp = y2;
		y2 = y;
		y = temp;
	}

	if ( x2 < x )
	{
		float temp = x2;
		x2 = x;
		x = temp;
	}

	// adjust corners onto whole pixels
	float VwDw = agk::Round(agk::m_fTargetViewportWidth) / (float) agk::m_iDisplayWidth;
	float VhDh = agk::Round(agk::m_fTargetViewportHeight) / (float) agk::m_iDisplayHeight;

	if ( AGKFrameBuffer::g_pCurrFrameBuffer )
	{
		VwDw = AGKFrameBuffer::g_pCurrFrameBuffer->GetWidth() / (float)(agk::m_iDisplayExtraX*2 + agk::m_iDisplayWidth);
		VhDh = AGKFrameBuffer::g_pCurrFrameBuffer->GetHeight() / (float)(agk::m_iDisplayExtraY*2 + agk::m_iDisplayHeight);
	}
	
	int xi = agk::Round( x*VwDw );
	int yi = agk::Round( y*VhDh );
	x = (xi+0.5f) / VwDw;
	y = (yi+0.5f) / VhDh;

	int x2i = agk::Round( x2*VwDw );
	int y2i = agk::Round( y2*VhDh );
	x2 = (x2i+0.5f) / VwDw;
	y2 = (y2i+0.5f) / VhDh;

	float pixX = agk::m_iDisplayWidth / (float) agk::Round(agk::m_fTargetViewportWidth);
	float pixY = agk::m_iDisplayHeight / (float) agk::Round(agk::m_fTargetViewportHeight);
	pixX /= 2.01f;
	pixY /= 2.01f;

	if ( filled == 1 )
	{
		int red1 = GetColorRed( color1 );
		int green1 = GetColorGreen( color1 );
		int blue1 = GetColorBlue( color1 );
		int alpha1 = GetColorAlpha( color1 );
		
		int red2 = GetColorRed( color2 );
		int green2 = GetColorGreen( color2 );
		int blue2 = GetColorBlue( color2 );
		int alpha2 = GetColorAlpha( color2 );

		int red3 = GetColorRed( color3 );
		int green3 = GetColorGreen( color3 );
		int blue3 = GetColorBlue( color3 );
		int alpha3 = GetColorAlpha( color3 );

		int red4 = GetColorRed( color4 );
		int green4 = GetColorGreen( color4 );
		int blue4 = GetColorBlue( color4 );
		int alpha4 = GetColorAlpha( color4 );
		
		float diffY = agk::m_iDisplayHeight / (float) agk::Round(agk::m_fTargetViewportHeight);
		if ( AGKFrameBuffer::g_pCurrFrameBuffer )
		{
			diffY = (agk::m_iDisplayExtraY*2 + agk::m_iDisplayHeight) / (float)AGKFrameBuffer::g_pCurrFrameBuffer->GetHeight();
		}

		float i = y;
		int count = 0;
		while ( i <= y2 )
		{
			float interp = (i - y)/(y2 - y);
			
			uint32_t redA = agk::Floor( red1 + interp*(red3 - red1) );
			uint32_t greenA = agk::Floor( green1 + interp*(green3 - green1) );
			uint32_t blueA = agk::Floor( blue1 + interp*(blue3 - blue1) );
			uint32_t alphaA = agk::Floor( alpha1 + interp*(alpha3 - alpha1) );

			uint32_t redB = agk::Floor( red2 + interp*(red4 - red2) );
			uint32_t greenB = agk::Floor( green2 + interp*(green4 - green2) );
			uint32_t blueB = agk::Floor( blue2 + interp*(blue4 - blue2) );
			uint32_t alphaB = agk::Floor( alpha2 + interp*(alpha4 - alpha2) );

			DrawLineInternal( x-pixX, i, x2+pixX, i, MakeColor(redA,greenA,blueA,alphaA), MakeColor(redB,greenB,blueB,alphaB) );

			count++;
			i = y + count*diffY;
		}
	}
	else
	{
		DrawLineInternal( x-pixX, y, x2+pixX, y, color1, color2 );
		DrawLineInternal( x2, y-pixY, x2, y2+pixY, color2, color4 );
		DrawLineInternal( x2+pixX, y2, x-pixX, y2, color4, color3 );
		DrawLineInternal( x, y2+pixY, x, y-pixY, color3, color1 );
	}
}

//****f* Core/Drawing/DrawEllipse
// FUNCTION
//   Draws a 2D ellipse centered on the coordinates given with a chosen color or gradient.
//   2D shapes appear above all other drawing except the Print command and can be used
//   with the GetImage function to create new images.
//   The XY coordinates are in screen coordinates so are not affected by the 
//   SetViewOffset command.
// INPUTS
//   x -- The X component of the center of the ellipse.
//   y -- The Y component of the center of the ellipse.
//   radiusx -- The radius of the ellipse in the X direction.
//   radiusy -- The radius of the ellipse in the Y direction.
//   color1 -- The color at the top of the ellipse.
//   color2 -- The color at the bottom of the ellipse.
//   filled -- 1=filled, 0=empty.
// SOURCE
void agk::DrawEllipse( float x, float y, float radiusx, float radiusy, uint32_t color1, uint32_t color2, int filled )
//****
{
	if ( radiusx <= 0 || radiusy <= 0 ) return;

	float diffX = agk::m_iDisplayWidth / (float) agk::Round(agk::m_fTargetViewportWidth);
	float diffY = agk::m_iDisplayHeight / (float) agk::Round(agk::m_fTargetViewportHeight);
	if ( AGKFrameBuffer::g_pCurrFrameBuffer )
	{
		diffX = (agk::m_iDisplayExtraX*2 + agk::m_iDisplayWidth) / (float)AGKFrameBuffer::g_pCurrFrameBuffer->GetWidth();
		diffY = (agk::m_iDisplayExtraY*2 + agk::m_iDisplayHeight) / (float)AGKFrameBuffer::g_pCurrFrameBuffer->GetHeight();
	}

	// shift the center onto a whole pixel
	int xi = agk::Round( x/diffX );
	int yi = agk::Round( y/diffY );
	x = (xi+0.5f) * diffX;
	y = (yi+0.5f) * diffY;

	radiusx /= diffX;
	radiusy /= diffY;

	float fTwoASqr = 2 * radiusx*radiusx;
	float fTwoBSqr = 2 * radiusy*radiusy;
	float fX = (float) agk::Floor( radiusx );
	float fY = 0;
	float fChangeX = radiusy*radiusy*(1 - 2*radiusx);
	float fChangeY = radiusx*radiusx;
	float fEllipseError = 0;
	float fStoppingX = fTwoBSqr*radiusx;
	float fStoppingY = 0;

	if ( filled == 0 )
	{
		int red1 = GetColorRed( color1 );
		int green1 = GetColorGreen( color1 );
		int blue1 = GetColorBlue( color1 );
		int alpha1 = GetColorAlpha( color1 );
		
		int red2 = GetColorRed( color2 );
		int green2 = GetColorGreen( color2 );
		int blue2 = GetColorBlue( color2 );
		int alpha2 = GetColorAlpha( color2 );

		while ( fStoppingX >= fStoppingY )
		{
			uint32_t colorA = color1;
			uint32_t colorB = color2;

			if ( color1 != color2 )
			{
				float interpA = 0.5f - (fY*0.5f/radiusy);
				float interpB = fY*0.5f/radiusy + 0.5f;
			
				uint32_t redA = agk::Floor( red1 + interpA*(red2 - red1) );
				uint32_t greenA = agk::Floor( green1 + interpA*(green2 - green1) );
				uint32_t blueA = agk::Floor( blue1 + interpA*(blue2 - blue1) );
				uint32_t alphaA = agk::Floor( alpha1 + interpA*(alpha2 - alpha1) );
				colorA = agk::MakeColor(redA,greenA,blueA,alphaA);

				uint32_t redB = agk::Floor( red1 + interpB*(red2 - red1) );
				uint32_t greenB = agk::Floor( green1 + interpB*(green2 - green1) );
				uint32_t blueB = agk::Floor( blue1 + interpB*(blue2 - blue1) );
				uint32_t alphaB = agk::Floor( alpha1 + interpB*(alpha2 - alpha1) );
				colorB = agk::MakeColor(redB,greenB,blueB,alphaB);
			}

			float fX2 = fX*diffX;
			float fY2 = fY*diffY;
			DrawLineInternal( x+fX2, y+fY2, x+fX2, y+fY2, colorB, colorB );
			DrawLineInternal( x-fX2, y+fY2, x-fX2, y+fY2, colorB, colorB );
			DrawLineInternal( x+fX2, y-fY2, x+fX2, y-fY2, colorA, colorA );
			DrawLineInternal( x-fX2, y-fY2, x-fX2, y-fY2, colorA, colorA );
			fY += 1;
			fStoppingY += fTwoASqr;
			fEllipseError += fChangeY;
			fChangeY += fTwoASqr;
			if ( 2*fEllipseError + fChangeX > 0 )
			{
				fX -= 1;
				fStoppingX -= fTwoBSqr;
				fEllipseError += fChangeX;
				fChangeX += fTwoBSqr;
			}
		}

		fX = 0;
		fY = (float) agk::Floor( radiusy );
		fChangeX = radiusy*radiusy;
		fChangeY = radiusx*radiusx*(1 - 2*radiusy);
		fEllipseError = 0;
		fStoppingX = 0;
		fStoppingY = fTwoASqr*radiusy;

		while ( fStoppingX <= fStoppingY )
		{
			uint32_t colorA = color1;
			uint32_t colorB = color2;

			if ( color1 != color2 )
			{
				float interpA = 0.5f - (fY*0.5f/radiusy);
				float interpB = fY*0.5f/radiusy + 0.5f;
			
				uint32_t redA = agk::Floor( red1 + interpA*(red2 - red1) );
				uint32_t greenA = agk::Floor( green1 + interpA*(green2 - green1) );
				uint32_t blueA = agk::Floor( blue1 + interpA*(blue2 - blue1) );
				uint32_t alphaA = agk::Floor( alpha1 + interpA*(alpha2 - alpha1) );
				colorA = agk::MakeColor(redA,greenA,blueA,alphaA);

				uint32_t redB = agk::Floor( red1 + interpB*(red2 - red1) );
				uint32_t greenB = agk::Floor( green1 + interpB*(green2 - green1) );
				uint32_t blueB = agk::Floor( blue1 + interpB*(blue2 - blue1) );
				uint32_t alphaB = agk::Floor( alpha1 + interpB*(alpha2 - alpha1) );
				colorB = agk::MakeColor(redB,greenB,blueB,alphaB);
			}

			float fX2 = fX*diffX;
			float fY2 = fY*diffY;
			DrawLineInternal( x+fX2, y+fY2, x+fX2, y+fY2, colorB, colorB );
			DrawLineInternal( x-fX2, y+fY2, x-fX2, y+fY2, colorB, colorB );
			DrawLineInternal( x+fX2, y-fY2, x+fX2, y-fY2, colorA, colorA );
			DrawLineInternal( x-fX2, y-fY2, x-fX2, y-fY2, colorA, colorA );
			fX += 1;
			fStoppingX += fTwoBSqr;
			fEllipseError += fChangeX;
			fChangeX += fTwoBSqr;
			if ( 2*fEllipseError + fChangeY > 0 )
			{
				fY -= 1;
				fStoppingY -= fTwoASqr;
				fEllipseError += fChangeY;
				fChangeY += fTwoASqr;
			}
		}
	}
	else
	{
		int red1 = GetColorRed( color1 );
		int green1 = GetColorGreen( color1 );
		int blue1 = GetColorBlue( color1 );
		int alpha1 = GetColorAlpha( color1 );
		
		int red2 = GetColorRed( color2 );
		int green2 = GetColorGreen( color2 );
		int blue2 = GetColorBlue( color2 );
		int alpha2 = GetColorAlpha( color2 );

		while ( fStoppingX >= fStoppingY )
		{
			uint32_t colorA = color1;
			uint32_t colorB = color2;

			if ( color1 != color2 )
			{
				float interpA = 0.5f - (fY*0.5f/radiusy);
				float interpB = fY*0.5f/radiusy + 0.5f;
			
				uint32_t redA = agk::Floor( red1 + interpA*(red2 - red1) );
				uint32_t greenA = agk::Floor( green1 + interpA*(green2 - green1) );
				uint32_t blueA = agk::Floor( blue1 + interpA*(blue2 - blue1) );
				uint32_t alphaA = agk::Floor( alpha1 + interpA*(alpha2 - alpha1) );
				colorA = agk::MakeColor(redA,greenA,blueA,alphaA);

				uint32_t redB = agk::Floor( red1 + interpB*(red2 - red1) );
				uint32_t greenB = agk::Floor( green1 + interpB*(green2 - green1) );
				uint32_t blueB = agk::Floor( blue1 + interpB*(blue2 - blue1) );
				uint32_t alphaB = agk::Floor( alpha1 + interpB*(alpha2 - alpha1) );
				colorB = agk::MakeColor(redB,greenB,blueB,alphaB);
			}

			float fX2 = fX*diffX;
			float fY2 = fY*diffY;
			DrawLineInternal( x-fX2, y+fY2, x+fX2+diffX, y+fY2, colorB, colorB );
			DrawLineInternal( x-fX2, y-fY2, x+fX2+diffX, y-fY2, colorA, colorA );
			fY += 1;
			fStoppingY += fTwoASqr;
			fEllipseError += fChangeY;
			fChangeY += fTwoASqr;
			if ( 2*fEllipseError + fChangeX > 0 )
			{
				fX -= 1;
				fStoppingX -= fTwoBSqr;
				fEllipseError += fChangeX;
				fChangeX += fTwoBSqr;
			}
		}

		fX = 0;
		fY = (float) agk::Floor( radiusy );	
		fChangeX = radiusy*radiusy;
		fChangeY = radiusx*radiusx*(1 - 2*radiusy);
		fEllipseError = 0;
		fStoppingX = 0;
		fStoppingY = fTwoASqr*radiusy;

		while ( fStoppingX <= fStoppingY )
		{
			uint32_t colorA = color1;
			uint32_t colorB = color2;

			if ( color1 != color2 )
			{
				float interpA = 0.5f - (fY*0.5f/radiusy);
				float interpB = fY*0.5f/radiusy + 0.5f;
			
				uint32_t redA = agk::Floor( red1 + interpA*(red2 - red1) );
				uint32_t greenA = agk::Floor( green1 + interpA*(green2 - green1) );
				uint32_t blueA = agk::Floor( blue1 + interpA*(blue2 - blue1) );
				uint32_t alphaA = agk::Floor( alpha1 + interpA*(alpha2 - alpha1) );
				colorA = agk::MakeColor(redA,greenA,blueA,alphaA);

				uint32_t redB = agk::Floor( red1 + interpB*(red2 - red1) );
				uint32_t greenB = agk::Floor( green1 + interpB*(green2 - green1) );
				uint32_t blueB = agk::Floor( blue1 + interpB*(blue2 - blue1) );
				uint32_t alphaB = agk::Floor( alpha1 + interpB*(alpha2 - alpha1) );
				colorB = agk::MakeColor(redB,greenB,blueB,alphaB);
			}

			float fX2 = fX*diffX;
			float fY2 = fY*diffY;
			DrawLineInternal( x+fX2, y-fY2, x+fX2, y+fY2+diffY, colorA, colorB );
			DrawLineInternal( x-fX2, y-fY2, x-fX2, y+fY2+diffY, colorA, colorB );
			fX += 1;
			fStoppingX += fTwoBSqr;
			fEllipseError += fChangeX;
			fChangeX += fTwoBSqr;
			if ( 2*fEllipseError + fChangeY > 0 )
			{
				fY -= 1;
				fStoppingY -= fTwoASqr;
				fEllipseError += fChangeY;
				fChangeY += fTwoASqr;
			}
		}

		/*
		float offset = 0.4f;
		float fRXSqr = (radiusx + offset) * (radiusx + offset);
		float fRYSqr = (radiusy + offset) * (radiusy + offset);

		// fxy = ((ry+offset)^2 * x^2) + ((rx+offset)^2 * y^2) - ((rx+offset)^2 * (ry+offset)^2)
		// fxy > 0 = outside
		// fxy < 0 = inside
		// start with x = fX, y = 0
		float fxy = fRXSqr * (fX*fX - fRYSqr); // simplified

		// filled 
		while ( fY <= radiusy )
		{
			uint32_t colorA = color1;
			uint32_t colorB = color2;

			if ( color1 != color2 )
			{
				float interpA = 0.5f - (fY*0.5f/radiusy);
				float interpB = fY*0.5f/radiusy + 0.5f;
			
				uint32_t redA = agk::Floor( red1 + interpA*(red2 - red1) );
				uint32_t greenA = agk::Floor( green1 + interpA*(green2 - green1) );
				uint32_t blueA = agk::Floor( blue1 + interpA*(blue2 - blue1) );
				uint32_t alphaA = agk::Floor( alpha1 + interpA*(alpha2 - alpha1) );
				colorA = agk::MakeColor(redA,greenA,blueA,alphaA);

				uint32_t redB = agk::Floor( red1 + interpB*(red2 - red1) );
				uint32_t greenB = agk::Floor( green1 + interpB*(green2 - green1) );
				uint32_t blueB = agk::Floor( blue1 + interpB*(blue2 - blue1) );
				uint32_t alphaB = agk::Floor( alpha1 + interpB*(alpha2 - alpha1) );
				colorB = agk::MakeColor(redB,greenB,blueB,alphaB);
			}

			float fX2 = fX*diffX;
			float fY2 = fY*diffY;
			DrawLineInternal( x-fX2, y+fY2, x+fX2+1, y+fY2, colorB, colorB );
			DrawLineInternal( x-fX2, y-fY2, x+fX2+1, y-fY2, colorA, colorA );

			// every y step subtract old ((rx+offset)^2 * y^2) term and add ((rx+offset)^2 * (y+1)^2)
			fxy += fRXSqr * (2*fY + 1); // simplified
			fY += 1;
			
			while( fxy > 0 && fX > 0 )
			{
				// subtract an x step ((ry+offset)^2 * fX^2) and add ((ry+offset)^2 * (fX-1)^2)
				fxy -= fRYSqr * (2*fX - 1); // simplified
				fX--;
			}
		}
		*/
	}
}

// Memblock commands

//****f* Memblock/General/CreateMemblock
// FUNCTION
//   Creates a section of memory of the given size for read or write access. The contents of the memory is undefined 
//   until you write to it. Returns an ID that you can use to reference this memblock in other commands.
// INPUTS
//   size -- The size of the memblock in bytes.
// SOURCE
uint32_t agk::CreateMemblock( uint32_t size )
//****
{
	uint32_t memID = m_cMemblockList.GetFreeID();
	if ( memID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create memblock - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateMemblock( memID, size );
	return memID;
}

//****f* Memblock/General/CreateMemblock
// FUNCTION
//   Creates a section of memory of the given size for read or write access. A memblock must not already exist with your chosen memID.
// INPUTS
//   memID -- The ID of the memblock you want to use.
//   size -- The size of the memblock in bytes. max 100,000,000.
// SOURCE
void agk::CreateMemblock( uint32_t memID, uint32_t size )
//****
{
	if ( size > 100000000 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create memblock %d with size %d, max size is 100,000,000 bytes", memID, size );
		Error( errStr );
#endif
		return;
	}

	if ( memID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create memblock %d, ID must be greater than 0", memID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cMemblockList.GetItem( memID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create memblock " );
		errStr.AppendUInt( memID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cMemblock *pMem = new cMemblock();
	pMem->m_iID = memID;
	pMem->m_iSize = size;
	pMem->m_pData = new unsigned char[ size ];
	for ( uint32_t i = 0; i < size; i++ ) pMem->m_pData[ i ] = 0;		
	m_cMemblockList.AddItem( pMem, memID );
}

//****f* Memblock/General/GetMemblockExists
// FUNCTION
//   Returns 1 if a memblock with the given ID exists, 0 if not.
// INPUTS
//   memID -- The ID of the memblock to check.
// SOURCE
int agk::GetMemblockExists( uint32_t memID )
//****
{
	if ( m_cMemblockList.GetItem( memID ) ) return 1;
	else return 0;
}

//****f* Memblock/General/DeleteMemblock
// FUNCTION
//   Deletes the memblock at the given ID. If the memblock does not exist or has already been deleted then
//   this command does nothing.
// INPUTS
//   memID -- The ID of the memblock to delete.
// SOURCE
void agk::DeleteMemblock( uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.RemoveItem( memID );
	if ( pMem ) delete pMem;
}

unsigned char* agk::GetMemblockPtr( uint32_t memID )
//***2
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( pMem ) return pMem->m_pData;
	else return 0;
}

//****f* Memblock/General/CopyMemblock
// FUNCTION
//   Copies a portion of one memblock to another. Both memblocks must exist and can be of different sizes.
// INPUTS
//   memSrcID -- The ID of the memblock to copy from.
//   memDstID -- The ID of the memblock to copy to.
//   srcOffset -- The offset in the source memblock to start copying from.
//   dstOffset -- The offset of the destination memblock to copy to.
//   size -- The number of bytes to copy.
// SOURCE
void agk::CopyMemblock( uint32_t memSrcID, uint32_t memDstID, uint32_t srcOffset, uint32_t dstOffset, uint32_t size )
//****
{
	cMemblock *pMemSrc = m_cMemblockList.GetItem( memSrcID );
	if ( !pMemSrc )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to copy memblock, source memblock " );
		errStr.AppendUInt( memSrcID ).Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	cMemblock *pMemDst = m_cMemblockList.GetItem( memDstID );
	if ( !pMemDst )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to copy memblock, destination memblock " );
		errStr.AppendUInt( memDstID ).Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( srcOffset+size > pMemSrc->m_iSize )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to copy memblock, source memblock " );
		errStr.AppendUInt( memSrcID ).Append( " does not have enough data for given offset and size values" );
		Error( errStr );
#endif
		return;		
	}

	if ( dstOffset+size > pMemDst->m_iSize )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to copy memblock, destination memblock " );
		errStr.AppendUInt( memDstID ).Append( " does not have enough space for given offset and size values" );
		Error( errStr );
#endif
		return;		
	}

	memcpy( pMemDst->m_pData+dstOffset, pMemSrc->m_pData+srcOffset, size );
}

//****f* Memblock/General/GetMemblockSHA1
// FUNCTION
//   Hashes the memblock with SHA1 and returns the resulting hash
// INPUTS
//   memID -- The ID of the memblock to hash
// SOURCE
char* agk::GetMemblockSHA1( uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get memblock hash, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		char* str = new char[1]; *str = 0;
		return str;
	}

	SHA1 sha;
	sha.Input( pMem->m_pData, pMem->m_iSize );

	uint32_t result[ 5 ];
	sha.Result( &(result[0]) );

	char *strout = new char[ 41 ];
	sprintf( strout, "%08X%08X%08X%08X%08X", result[ 0 ], result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] );

	return strout;
}

//****f* Memblock/General/GetMemblockSHA256
// FUNCTION
//   Hashes the memblock with SHA256 and returns the resulting hash
// INPUTS
//   memID -- The ID of the memblock to hash
// SOURCE
char* agk::GetMemblockSHA256( uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get memblock hash, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		char* str = new char[1]; *str = 0;
		return str;
	}

	unsigned char digest[SHA256::DIGEST_SIZE];
    memset(digest,0,SHA256::DIGEST_SIZE);
 
    SHA256 ctx = SHA256();
    ctx.init();
    ctx.update( pMem->m_pData, pMem->m_iSize );
    ctx.final( digest );
 
    char *buf = new char[2*SHA256::DIGEST_SIZE+1];
    buf[2*SHA256::DIGEST_SIZE] = 0;
    for (int i = 0; i < SHA256::DIGEST_SIZE; i++)
        sprintf(buf+i*2, "%02x", digest[i]);
	
	return buf;
}

//****f* Memblock/General/GetMemblockSize
// FUNCTION
//   Returns the size of the given memblock in bytes.
// INPUTS
//   memID -- The ID of the memblock to check.
// SOURCE
int agk::GetMemblockSize( uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get memblock size, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}
	
	return pMem->m_iSize;
}

//****f* Memblock/General/GetMemblockByte
// FUNCTION
//   Returns the byte value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. The returned value will be an unsigned byte between 0 and 255.
// INPUTS
//   memID -- The ID of the memblock to check.
//   offset -- The offset from the start of the memblock of the value to return, between 0 and size.
// SOURCE
int agk::GetMemblockByte( uint32_t memID, uint32_t offset )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get memblock byte, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( offset >= pMem->m_iSize )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get byte from memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
	}
	
	unsigned char result = pMem->m_pData[ offset ];
	return result;
}

//****f* Memblock/General/GetMemblockByteSigned
// FUNCTION
//   Returns the byte value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. The returned value will be a signed byte between -128 and 127.
// INPUTS
//   memID -- The ID of the memblock to check.
//   offset -- The offset from the start of the memblock of the value to return, between 0 and size.
// SOURCE
int agk::GetMemblockByteSigned( uint32_t memID, uint32_t offset )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get memblock byte, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( offset >= pMem->m_iSize )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get byte from memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
	}
	
	char result = (char) pMem->m_pData[ offset ];
	return result;
}

//****f* Memblock/General/GetMemblockShort
// FUNCTION
//   Returns the short (2 byte) value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. For best performance the offset should be a multiple of 2 because reading short values 
//   that are not aligned to 2 byte boundaries incurs a hardware performance penalty.
//   Short values are stored in little endian format so writing a short of 23 at offset 0 and then reading it back in bytes
//   would return the byte at offset 0 as 23 and the byte at offset 1 as 0.
//   The returned value will be a signed short between -32768 and 32767.
// INPUTS
//   memID -- The ID of the memblock to check.
//   offset -- The offset from the start of the memblock of the value to return, between 0 and size.
// SOURCE
int agk::GetMemblockShort( uint32_t memID, uint32_t offset )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get memblock short, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( offset >= pMem->m_iSize - 1 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get short from memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
		return 0;
	}
	
	short result = *((short*)(pMem->m_pData + offset));
	return result;
}

//****f* Memblock/General/GetMemblockInt
// FUNCTION
//   Returns the int (4 byte) value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. For best performance the offset should be a multiple of 4 because reading integer values 
//   that are not aligned to 4 byte boundaries incurs a hardware performance penalty.
//   Int values are stored in little endian format so writing an int of 23 at offset 0 and then reading it back in bytes
//   would return the byte at offset 0 as 23, the byte at offset 1 as 0, the byte at offset 2 as 0, and the byte at offset 3 as 0.
//   The returned value will be a signed integer between -2,147,483,648 and 2,147,483,647.
// INPUTS
//   memID -- The ID of the memblock to check.
//   offset -- The offset from the start of the memblock of the value to return, between 0 and size.
// SOURCE
int agk::GetMemblockInt( uint32_t memID, uint32_t offset )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get memblock int, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( offset >= pMem->m_iSize - 3 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get int from memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
		return 0;
	}
	
	int result = *((int*)(pMem->m_pData + offset));
	return result;
}

//****f* Memblock/General/GetMemblockFloat
// FUNCTION
//   Returns the float (4 byte) value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. For best performance the offset should be a multiple of 4 because reading float values 
//   that are not aligned to 4 byte boundaries incurs a hardware performance penalty.
//   Float values are stored in IEEE 754 format so writing an float and then reading it back in bytes would return 
//   various components of the float format.
// INPUTS
//   memID -- The ID of the memblock to check.
//   offset -- The offset from the start of the memblock of the value to return, between 0 and size.
// SOURCE
float agk::GetMemblockFloat( uint32_t memID, uint32_t offset )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get memblock float, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( offset >= pMem->m_iSize - 3 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get float from memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
		return 0;
	}
	
	if ( offset % 4 != 0 )
	{
		// can't use unaligned floats on ARM
		float f;
		memcpy( &f, pMem->m_pData + offset, 4 );
		return f;
	}
	else
	{
		return *((float*)(pMem->m_pData + offset));
	}
}

//****f* Memblock/General/GetMemblockString
// FUNCTION
//   Returns a given number of bytes at the given offset and interprets them as a string. The offset plus length must be less than 
//   the size of the memblock. The first value is at offset 0. The string will be null terminated even if no null terminator is 
//   found in the memblock. If a null terminator occurs before length is reached then all the bytes will still be read, but only 
//   the characters up to the first null terminator will be accessible in AGK.
//   If you are using tier 2 you must delete the pointer returned from this function.
// INPUTS
//   memID -- The ID of the memblock to check.
//   offset -- The offset from the start of the memblock of the value to return, between 0 and size.
//   length -- The number of bytes to read
// SOURCE
char* agk::GetMemblockString( uint32_t memID, uint32_t offset, uint32_t length )
//****
{
	char *str = new char[1];
	*str = 0;

	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get memblock string, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return str;
	}

	if ( length < 1 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get string from memblock %d, length must be greater than 0", memID );
		Error( errStr );
#endif		
		return str;
	}

	if ( offset+length > pMem->m_iSize )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get string from memblock %d, offset %d plus length %d is greater than memblock size %d", memID, offset, length, pMem->m_iSize );
		Error( errStr );
#endif		
		return str;
	}
	
	delete [] str;
	str = new char[ length + 1 ];
	memcpy( str, pMem->m_pData+offset, length );
	str[ length ] = 0;
	
	return str;
}

//****f* Memblock/General/SetMemblockByte
// FUNCTION
//   Writes a single byte value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. The given value will be truncated to the range 0 and 255.
// INPUTS
//   memID -- The ID of the memblock to modify.
//   offset -- The offset from the start of the memblock to write to, between 0 and size.
//   value -- The value to write.
// SOURCE
void agk::SetMemblockByte( uint32_t memID, uint32_t offset, int value )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to write memblock byte, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( offset >= pMem->m_iSize )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to write byte to memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
		return;
	}

	if ( value > 255 ) value = 255;
	if ( value < 0 ) value = 0;
	
	pMem->m_pData[ offset ] = value;
}

//****f* Memblock/General/SetMemblockByteSigned
// FUNCTION
//   Writes a single byte value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. The given value will be truncated to the range -128 and 127.
// INPUTS
//   memID -- The ID of the memblock to modify.
//   offset -- The offset from the start of the memblock to write to, between 0 and size.
//   value -- The value to write.
// SOURCE
void agk::SetMemblockByteSigned( uint32_t memID, uint32_t offset, int value )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to write memblock byte, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( offset >= pMem->m_iSize )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to write byte to memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
		return;
	}

	if ( value > 127 ) value = 127;
	if ( value < -128 ) value = -128;
	
	pMem->m_pData[ offset ] = (unsigned char) value;
}

//****f* Memblock/General/SetMemblockShort
// FUNCTION
//   Writes a short (2 byte) value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. For best performance the offset should be a multiple of 2 because writing short values 
//   that are not aligned to 2 byte boundaries incurs a hardware performance penalty.
//   Short values are stored in little endian format so writing a short of 23 at offset 0 and then reading it back in bytes
//   would return the byte at offset 0 as 23 and the byte at offset 1 as 0.
//   The given value will be truncated to the range -32768 and 32767.
// INPUTS
//   memID -- The ID of the memblock to modify.
//   offset -- The offset from the start of the memblock to write to, between 0 and size.
//   value -- The value to write.
// SOURCE
void agk::SetMemblockShort( uint32_t memID, uint32_t offset, int value )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to write memblock short, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( offset >= pMem->m_iSize - 1 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to write short to memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
		return;
	}

	if ( value > 32767 ) value = 32767;
	if ( value < -32768 ) value = -32768;
	
	*((short*)(pMem->m_pData + offset)) = value;
}

//****f* Memblock/General/SetMemblockInt
// FUNCTION
//   Writes an int (4 byte) value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. For best performance the offset should be a multiple of 4 because writing integer values 
//   that are not aligned to 4 byte boundaries incurs a hardware performance penalty.
//   Int values are stored in little endian format so writing an int of 23 at offset 0 and then reading it back in bytes
//   would return the byte at offset 0 as 23, the byte at offset 1 as 0, the byte at offset 2 as 0, and the byte at offset 3 as 0.
// INPUTS
//   memID -- The ID of the memblock to modify.
//   offset -- The offset from the start of the memblock to write to, between 0 and size.
//   value -- The value to write.
// SOURCE
void agk::SetMemblockInt( uint32_t memID, uint32_t offset, int value )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to write memblock int, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( offset >= pMem->m_iSize - 3 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to write int to memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
		return;
	}

	*((int*)(pMem->m_pData + offset)) = value;
}

//****f* Memblock/General/SetMemblockFloat
// FUNCTION
//   Write a float (4 byte) value at the given offset. The offset must be less than the size of the memblock. The
//   first value is at offset 0. For best performance the offset should be a multiple of 4 because writing float values 
//   that are not aligned to 4 byte boundaries incurs a hardware performance penalty.
//   Float values are stored in IEEE 754 format so writing an float and then reading it back in bytes would return 
//   various components of the float format.
// INPUTS
//   memID -- The ID of the memblock to modify.
//   offset -- The offset from the start of the memblock to write to, between 0 and size.
//   value -- The value to write.
// SOURCE
void agk::SetMemblockFloat( uint32_t memID, uint32_t offset, float value )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to write memblock float, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( offset >= pMem->m_iSize - 3 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to write float to memblock %d, offset %d is greater than memblock size %d", memID, offset, pMem->m_iSize );
		Error( errStr );
#endif		
		return;
	}

	if ( offset % 4 != 0 )
	{
		// can't use unaligned floats on ARM
		memcpy( pMem->m_pData + offset, &value, 4 );
	}
	else
	{
		*((float*)(pMem->m_pData + offset)) = value;
	}
}

//****f* Memblock/General/SetMemblockString
// FUNCTION
//   Writes a string to a memblock as raw bytes. The first null terminator found will end the string and a single null 
//   terminator will be written to the memblock data. To read the string out of the memblock again you will need to 
//   know its length, so it is recommended that you also write a string length value before the string data to help 
//   read the string back later.
//   The offset plus the length of the string, plus 1 for the null terminator, must be less than the memblock size.
// INPUTS
//   memID -- The ID of the memblock to modify.
//   offset -- The offset from the start of the memblock to write to, between 0 and size.
//   value -- The string to write.
// SOURCE
void agk::SetMemblockString( uint32_t memID, uint32_t offset, const char* value )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to write memblock string, memblock " );
		errStr.AppendUInt( memID ).Append( " does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( !value || strlen(value) == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to write string to memblock %d, string is invalid or has zero length", memID );
		Error( errStr );
#endif		
		return;
	}

	uint32_t length = (uint32_t)strlen(value) + 1;

	if ( offset+length > pMem->m_iSize )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to write float to memblock %d, offset %d plus length %d plus 1 is greater than memblock size %d", memID, offset, length, pMem->m_iSize );
		Error( errStr );
#endif		
		return;
	}

	memcpy( pMem->m_pData+offset, value, length );
}

//****f* Memblock/Image/CreateMemblockFromImage
// FUNCTION
//   Creates a memblock from a loaded image, atlas sub images are not supported. A memblock at the given ID must not exist, the
//   image must exist and is unaffected by this command. The first 4 bytes of the memblock store the image width, the next 4 bytes
//   store the image height, the next 4 bytes store the bit depth, currently this will always be 32. After that the raw image data
//   begins in the format RGBA, with each component stored in a single byte, so each pixel takes up 4 bytes. The size of the image 
//   data can be calculated by width*height*4 bytes (for now bit depth can be assumed to be 32 bits = 4 bytes).
//   Note that due to little endian format reading the image data with bytes will return offset 0=R, 1=G, 2=B, 3=A, but reading 
//   them all as a single integer will produce a value with A as the most significant byte, followed by B, then G, then R as 
//   the least significant byte.
//   The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in the
//   image being stored as a sequence of rows ending in the bottom right corner.
// INPUTS
//   memID -- The ID of the memblock to create.
//   imageID -- The ID of the image to read.
// SOURCE
void agk::CreateMemblockFromImage( uint32_t memID, uint32_t imageID )
//****
{
	if ( m_cMemblockList.GetItem( memID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create memblock %d from image %d, memblock already exists", memID, imageID );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = m_cImageList.GetItem( imageID );
	if ( !pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create memblock %d from image %d, image does not exist", memID, imageID );
		Error( errStr );
#endif
		return;
	}

	if ( pImage->HasParent() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create memblock from image %d, atlas sub images are not supported", imageID );
		Error( errStr );
#endif
		return;
	}

	unsigned char *pData = 0;
	int size = pImage->GetRawData( &pData );
	if ( size == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create memblock %d from image %d, failed to get image data", memID, imageID );
		Error( errStr );
#endif
		return;
	}

	cMemblock *pMem = new cMemblock();
	pMem->m_iID = memID;
	pMem->m_iSize = size + 12;
	pMem->m_pData = new unsigned char[ pMem->m_iSize ];
	m_cMemblockList.AddItem( pMem, memID );
	
	// add image width, height, and bit depth
	((int*)pMem->m_pData)[ 0 ] = pImage->GetWidth();
	((int*)pMem->m_pData)[ 1 ] = pImage->GetHeight();
	((int*)pMem->m_pData)[ 2 ] = 32;
	memcpy( pMem->m_pData + 12, pData, size );

	delete [] pData;
}

//****f* Memblock/Image/CreateMemblockFromImage
// FUNCTION
//   Creates a memblock from a loaded image, atlas sub images are not supported. The image must exist and is unaffected by this 
//   command. The first 4 bytes of the memlbock store the image width, the next 4 bytes store the image height, the next 4 bytes 
//   store the bit depth, currently this will always be 32. After that the raw image data begins in the format RGBA, with each 
//   component stored in a single byte, so each pixel takes up 4 bytes. The size of the image data can be calculated by 
//   width*height*4 bytes (for now bit depth can be assumed to be 32 bits = 4 bytes).
//   Note that due to little endian format reading the image data with bytes will return offsets 0=R, 1=G, 2=B, 3=A, but reading 
//   them all as a single integer will produce a value with A as the most significant byte, followed by B, then G, then R as 
//   the least significant byte.
//   The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in the
//   image being stored as a sequence of rows ending in the bottom right corner.
//   Returns an ID that can be used to reference this memblock in other commands.
// INPUTS
//   imageID -- The ID of the image to read.
// SOURCE
uint32_t agk::CreateMemblockFromImage( uint32_t imageID )
//****
{
	uint32_t memID = m_cMemblockList.GetFreeID();
	if ( memID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create memblock from image - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateMemblockFromImage( memID, imageID );
	return memID;
}

//****f* Memblock/Image/CreateImageFromMemblock
// FUNCTION
//   Creates an image from a memblock. The memblock must exist, if the image exists it will be overwritten, if not it will
//   be created. The first 4 bytes of the memlbock store the image width, the next 4 bytes store the image height, the next 4 bytes 
//   store the bit depth, currently this must be 32. After that the raw image data begins in the format RGBA, with each 
//   component stored in a single byte, so each pixel takes up 4 bytes. The size of the image data can be calculated by 
//   width*height*4 bytes (for now bit depth can be assumed to be 32 bits = 4 bytes).
//   Note that due to little endian format writing the image data with bytes will result in offsets 0=R, 1=G, 2=B, 3=A, but writing 
//   them all as a single integer will be interpreted as a value with A as the most significant byte, followed by B, then G, then R as 
//   the least significant byte.
//   The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in the
//   image being stored as a sequence of rows ending in the bottom right corner.
//   This command uses a lot of GPU bandwidth so it is not recommended that this command be called every frame on large images.
// INPUTS
//   imageID -- The ID of the image to create or modify.
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
void agk::CreateImageFromMemblock( uint32_t imageID, uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create image %d from memblock %d, memblock does not exist", imageID, memID );
		Error( errStr );
#endif
		return;
	}

	int width = ((int*)pMem->m_pData)[ 0 ];
	int height = ((int*)pMem->m_pData)[ 1 ];
//	int bitdepth = 32;

	if ( width <= 0 || height <= 0 ) 
	{
		agk::Error( "Failed to create image from memblock, width and height must be greater than 0" );
		return;
	}

	cImage *pImage = m_cImageList.GetItem( imageID );
	if ( !pImage )
	{
		pImage = new cImage( );
		pImage->m_iID = imageID;
		m_cImageList.AddItem( pImage, imageID );
	}
	else
	{
		if ( pImage->HasParent() )
		{
			agk::Error( "Failed to create image from memblock, image ID is being used as a sub image" );
			return;
		}

		while ( pImage->m_pBoundingPoints ) 
		{
			Point2D *pPoint = pImage->m_pBoundingPoints;
			pImage->m_pBoundingPoints = pImage->m_pBoundingPoints->pNext;
			delete pPoint;
		}
	}
	
	pImage->LoadFromData( width, height, (unsigned int*)(pMem->m_pData+12) );
}

//****f* Memblock/Image/CreateImageFromMemblock
// FUNCTION
//   Creates an image from a memblock. The memblock must exist, the image is created in a free ID which is returned.
//   The first 4 bytes of the memlbock store the image width, the next 4 bytes store the image height, the next 4 bytes 
//   store the bit depth, currently this must be 32. After that the raw image data begins in the format RGBA, with each 
//   component stored in a single byte, so each pixel takes up 4 bytes. The size of the image data can be calculated by 
//   width*height*4 bytes (for now bit depth can be assumed to be 32 bits = 4 bytes).
//   Note that due to little endian format writing the image data with bytes will result in offsets 0=R, 1=G, 2=B, 3=A, but writing 
//   them all as a single integer will be interpreted as a value with A as the most significant byte, followed by B, then G, then R as 
//   the least significant byte.
//   The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in the
//   image being stored as a sequence of rows ending in the bottom right corner.
//   Returns the ID of the new image.
//   This command uses a lot of GPU bandwidth so it is not recommended that this command be called every frame on large images.
// INPUTS
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
uint32_t agk::CreateImageFromMemblock( uint32_t memID )
//****
{
	uint32_t imageID = m_cImageList.GetFreeID();
	if ( imageID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create image from memblock - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateImageFromMemblock( imageID, memID );
	return imageID;
}

//****f* Memblock/Image/CreateImageFromPNGMemblock
// FUNCTION
//   Creates an image from a memblock. The memblock must exist, if the image exists it will be overwritten, if not it will
//   be created. 
//   The memblock must contain a valid PNG file such as one loaded with <i>CreateMemblockFromFile</i>(memID, "image.png")
// INPUTS
//   imageID -- The ID of the image to create.
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
void agk::CreateImageFromPNGMemblock( uint32_t imageID, uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create image %d from PNG memblock %d, memblock does not exist", imageID, memID );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = m_cImageList.GetItem( imageID );
	if ( !pImage )
	{
		pImage = new cImage( );
		pImage->m_iID = imageID;
		m_cImageList.AddItem( pImage, imageID );
	}
	else
	{
		if ( pImage->HasParent() )
		{
			agk::Error( "Failed to create image from PNG memblock, image ID is being used as a sub image" );
			return;
		}

		while ( pImage->m_pBoundingPoints ) 
		{
			Point2D *pPoint = pImage->m_pBoundingPoints;
			pImage->m_pBoundingPoints = pImage->m_pBoundingPoints->pNext;
			delete pPoint;
		}
	}
	
	pImage->LoadPNGFromMemory( (uint32_t*) (pMem->m_pData), 0, 0, false );
}

//****f* Memblock/Image/CreateImageFromPNGMemblock
// FUNCTION
//   Creates an image from a memblock. The memblock must exist, the image is created in a free ID which is returned.
//   The memblock must contain a valid PNG file such as one loaded with <i>CreateMemblockFromFile</i>(memID, "image.png")
// INPUTS
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
uint32_t agk::CreateImageFromPNGMemblock( uint32_t memID )
//****
{
	uint32_t imageID = m_cImageList.GetFreeID();
	if ( imageID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create image from PNG memblock - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateImageFromPNGMemblock( imageID, memID );
	return imageID;
}


//****f* Memblock/Sound/CreateMemblockFromSound
// FUNCTION
//   Creates a memblock from a loaded sound file. A memblock at the given ID must not exist, the sound file must have been loaded 
//   with LoadSound and is unaffected by this command. The first 2 bytes of the memlbock store the number of channels (1 or 2 supported), 
//   the next 2 bytes store the bits per sample (8 or 16 supported), the next 4 bytes store the samples per second, for example 44100.
//   The next 4 bytes are the number of frames in the sound data, the size of the sound data in bytes can be calculated from this
//   with the formula numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame contains 2 samples, one for each channel. 
//   In a mono sound a frame contains 1 sample.
//   The rest of the memblock is raw sound data, for example in an 8bit stereo sound with 3 frames the raw data would look like this.
//   byte offset 0 = Frame 1, left channel data
//   byte offset 1 = Frame 1, right channel data
//   byte offset 2 = Frame 2, left channel data
//   byte offset 3 = Frame 2, right channel data
//   byte offset 4 = Frame 3, left channel data
//   byte offset 5 = Frame 3, right channel data
//   The duration of the sound can be calculated with the following formula, numFrames/samplesPerSecond.
//   This command does not work with sound instance IDs, only sound file IDs.
// INPUTS
//   memID -- The ID of the memblock to create.
//   soundID -- The ID of the sound file to read.
// SOURCE
void agk::CreateMemblockFromSound( uint32_t memID, uint32_t soundID )
//****
{
	if ( m_cMemblockList.GetItem( memID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create memblock %d from sound %d, memblock already exists", memID, soundID );
		Error( errStr );
#endif
		return;
	}

	cSoundMgr::cSoundFile *pSound = cSoundMgr::GetFile( soundID );
	if ( !pSound )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create memblock %d from sound file %d, sound does not exist", memID, soundID );
		Error( errStr );
#endif
		return;
	}

	cMemblock *pMem = new cMemblock();
	pMem->m_iID = memID;
	pMem->m_iSize = pSound->m_uDataSize + 12;
	pMem->m_pData = new unsigned char[ pMem->m_iSize ];
	m_cMemblockList.AddItem( pMem, memID );
	
	((short*)pMem->m_pData)[ 0 ] = pSound->m_fmt.nChannels;
	((short*)pMem->m_pData)[ 1 ] = pSound->m_fmt.wBitsPerSample;
	((int*)pMem->m_pData)[ 1 ] = pSound->m_fmt.nSamplesPerSec;
	((int*)pMem->m_pData)[ 2 ] = pSound->m_uDataSize / (pSound->m_fmt.wBitsPerSample*pSound->m_fmt.nChannels/8);
	memcpy( pMem->m_pData + 12, pSound->m_pRawData, pSound->m_uDataSize );
}

//****f* Memblock/Sound/CreateMemblockFromSound
// FUNCTION
//   Creates a memblock from a loaded sound file. The sound file must have been loaded with LoadSound and is unaffected 
//   by this command. The first 2 bytes of the memlbock store the number of channels (1 or 2 supported), the next 2 bytes 
//   store the bits per sample (8 or 16 supported), the next 4 bytes store the samples per second, for example 44100.
//   The next 4 bytes are the number of frames in the sound data, the size of the sound data in bytes can be calculated from this
//   with the formula numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame contains 2 samples, one for each channel. 
//   In a mono sound a frame contains 1 sample.
//   The rest of the memblock is raw sound data, for example in an 8bit stereo sound with 3 frames the raw data would look like this.
//   byte offset 0 = Frame 1, left channel data
//   byte offset 1 = Frame 1, right channel data
//   byte offset 2 = Frame 2, left channel data
//   byte offset 3 = Frame 2, right channel data
//   byte offset 4 = Frame 3, left channel data
//   byte offset 5 = Frame 3, right channel data
//   The duration of the sound can be calculated with the following formula, numFrames/samplesPerSecond.
//   This command does not work with sound instance IDs, only sound file IDs.
//   Returns an ID that can be used to reference this memblock in other commands.
// INPUTS
//   soundID -- The ID of the sound to read.
// SOURCE
uint32_t agk::CreateMemblockFromSound( uint32_t soundID )
//****
{
	uint32_t memID = m_cMemblockList.GetFreeID();
	if ( memID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create memblock from sound - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateMemblockFromSound( memID, soundID );
	return memID;
}

//****f* Memblock/Sound/CreateSoundFromMemblock
// FUNCTION
//   Creates an sound from a memblock. The memblock must exist, if the sound file exists it will be overwritten, 
//   if not it will be created. This will not affect any sound instances already playing, only future ones.
//   The first 2 bytes of the memlbock store the number of channels (1 or 2 supported), the next 2 bytes store 
//   the bits per sample (8 or 16 supported), the next 4 bytes store the samples per second, for example 44100.
//   The next 4 bytes are the number of frames in the sound data, the size of the sound data in bytes can be 
//   calculated from this with the formula numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame 
//   contains 2 samples, one for each channel. In a mono sound a frame contains 1 sample.
//   The rest of the memblock is raw sound data, for example in an 8bit stereo sound with 3 frames the raw data 
//   would look like this.
//   byte offset 0 = Frame 1, left channel data
//   byte offset 1 = Frame 1, right channel data
//   byte offset 2 = Frame 2, left channel data
//   byte offset 3 = Frame 2, right channel data
//   byte offset 4 = Frame 3, left channel data
//   byte offset 5 = Frame 3, right channel data
// INPUTS
//   soundID -- The ID of the sound to create or modify.
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
void agk::CreateSoundFromMemblock( uint32_t soundID, uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create sound %d from memblock %d, memblock does not exist", soundID, memID );
		Error( errStr );
#endif
		return;
	}

	unsigned char *pData = pMem->m_pData;

	if ( ((short*)pData)[0] != 1 && ((short*)pData)[0] != 2 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create sound %d from memblock %d, channels must be equal to 1 or 2", soundID, memID );
		Error( errStr );
#endif
		return;		
	}

	if ( ((short*)pData)[1] != 8 && ((short*)pData)[1] != 16 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create sound %d from memblock %d, BitsPerSample must be equal to 8 or 16", soundID, memID );
		Error( errStr );
#endif
		return;		
	}

	if ( ((int*)pData)[1] <= 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create sound %d from memblock %d, SamplesPerSecond must be positive", soundID, memID );
		Error( errStr );
#endif
		return;		
	}

	cSoundMgr::cSoundFile *pSound = cSoundMgr::GetFile( soundID );
	if ( !pSound )
	{
		cSoundMgr::AddFile( soundID, pMem->m_pData, pMem->m_iSize );
	}
	else
	{
		if ( ((int*)pData)[2] * ((short*)pData)[0] * (((short*)pData)[1]/8) > (int) pMem->m_iSize )
		{
#ifdef _AGK_ERROR_CHECK
			uString str;
			str.Format( "Could not update sound file %d from memblock %d - not enough data", soundID, memID );
			agk::Error( str );
#endif
			return;		
		}

		pSound->m_fmt.wFormatTag = 1;
		pSound->m_fmt.nChannels = ((short*)pData)[0];
		pSound->m_fmt.nSamplesPerSec = ((int*)pData)[1];
		pSound->m_fmt.wBitsPerSample = ((short*)pData)[1];
		pSound->m_fmt.nBlockAlign = pSound->m_fmt.nChannels*(pSound->m_fmt.wBitsPerSample/8);
		pSound->m_fmt.nAvgBytesPerSec = pSound->m_fmt.nSamplesPerSec*pSound->m_fmt.nBlockAlign;
		pSound->m_fmt.cbSize = 0;

		if ( pSound->m_pRawData ) delete [] pSound->m_pRawData;
		pSound->m_uDataSize = ((int*)pData)[2] * pSound->m_fmt.nBlockAlign;
		pSound->m_pRawData = new unsigned char[ pSound->m_uDataSize ];

		// raw sound data
		memcpy( pSound->m_pRawData, pData+12, pSound->m_uDataSize );
	}
}

//****f* Memblock/Sound/CreateSoundFromMemblock
// FUNCTION
//   Creates an sound from a memblock. The memblock must exist, this creates a new sound and returns the ID. 
//   This will not affect any sound instances already playing, only future ones.
//   The first 2 bytes of the memlbock store the number of channels (1 or 2 supported), the next 2 bytes store 
//   the bits per sample (8 or 16 supported), the next 4 bytes store the samples per second, for example 44100.
//   The next 4 bytes are the number of frames in the sound data, the size of the sound data in bytes can be 
//   calculated from this with the formula numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame 
//   contains 2 samples, one for each channel. In a mono sound a frame contains 1 sample.
//   The rest of the memblock is raw sound data, for example in an 8bit stereo sound with 3 frames the raw data 
//   would look like this.
//   byte offset 0 = Frame 1, left channel data
//   byte offset 1 = Frame 1, right channel data
//   byte offset 2 = Frame 2, left channel data
//   byte offset 3 = Frame 2, right channel data
//   byte offset 4 = Frame 3, left channel data
//   byte offset 5 = Frame 3, right channel data
//   Returns the ID of the new sound.
// INPUTS
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
uint32_t agk::CreateSoundFromMemblock( uint32_t memID )
//****
{
	uint32_t soundID = cSoundMgr::GetFreeID();
	if ( soundID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create sound from memblock - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateSoundFromMemblock( soundID, memID );
	return soundID;
}

//****f* Memblock/Sound/CreateSoundFromOGGMemblock
// FUNCTION
//   Creates an sound from a memblock. The memblock must exist, if the sound file exists it will be overwritten, 
//   if not it will be created. This will not affect any sound instances already playing, only future ones.
//   The memblock must contain a valid OGG file such as one loaded with <i>CreateMemblockFromFile</i>(memID, "sound.ogg")
// INPUTS
//   soundID -- The ID of the sound to create or modify.
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
void agk::CreateSoundFromOGGMemblock( uint32_t soundID, uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create sound %d from OGG memblock %d, memblock does not exist", soundID, memID );
		Error( errStr );
#endif
		return;
	}

	cSoundMgr::AddOGGMem( soundID, pMem->m_pData, pMem->m_iSize, -1 );
}

//****f* Memblock/Sound/CreateSoundFromOGGMemblock
// FUNCTION
//   Creates an sound from a memblock. The memblock must exist, this creates a new sound and returns the ID. 
//   This will not affect any sound instances already playing, only future ones.
//   The memblock must contain a valid OGG file such as one loaded with <i>CreateMemblockFromFile</i>(memID, "sound.ogg")
// INPUTS
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
uint32_t agk::CreateSoundFromOGGMemblock( uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create sound from OGG memblock %d, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	return cSoundMgr::AddOGGMem( pMem->m_pData, pMem->m_iSize, -1 );
}

//****f* Memblock/Sound/CreateMusicFromOGGMemblock
// FUNCTION
//   Creates a music entity from a memblock. The memblock must exist, the music ID must not already exist.
//   The memblock must contain a valid OGG file such as one loaded with <i>CreateMemblockFromFile</i>(memID, "music.ogg")
// INPUTS
//   musicID -- The ID of the music to create.
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
void agk::CreateMusicFromOGGMemblock( uint32_t musicID, uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create music %d from OGG memblock %d, memblock does not exist", musicID, memID );
		Error( errStr );
#endif
		return;
	}

	if ( musicID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load music %d, ID must be greater than 0", musicID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cMusicOGGList.GetItem( musicID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load music " );
		errStr.AppendUInt( musicID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	AGKMusicOGG *pMusic = new AGKMusicOGG();
	if ( !pMusic->LoadMem( pMem->m_pData, pMem->m_iSize ) ) 
	{
		delete pMusic;
		return;
	}
	else 
	{
		m_cMusicOGGList.AddItem( pMusic, musicID );
	}
}

//****f* Memblock/Sound/CreateMusicFromOGGMemblock
// FUNCTION
//   Creates a music entity from a memblock. The memblock must exist. This will create a new music ID and return it
//   The memblock must contain a valid OGG file such as one loaded with <i>CreateMemblockFromFile</i>(memID, "music.ogg")
// INPUTS
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
uint32_t agk::CreateMusicFromOGGMemblock( uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create music from OGG memblock %d, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	uint32_t musicID = m_cMusicOGGList.GetFreeID();
	if ( musicID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create OGG music from memblock - No free music IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	AGKMusicOGG *pMusic = new AGKMusicOGG();
	if ( !pMusic->LoadMem( pMem->m_pData, pMem->m_iSize ) ) 
	{
		delete pMusic;
		return 0;
	}
	else 
	{
		m_cMusicOGGList.AddItem( pMusic, musicID );
		return musicID;
	}
}

//****f* Memblock/File/CreateMemblockFromFile
// FUNCTION
//   Creates a memblock from a file without any processing of the file data, the memblock will be a 
//   byte for byte copy of the file. A memblock at the given ID must not exist. You can use relative
//   paths in the file name to read from sub folders or use <i>SetFolder</i> to browse there first.
//   You can use absolute paths by adding a forward slash to the beginning of the filename, in this
//   case the folder set with <i>SetFolder</i> is ignored. For example /media/file.txt will read
//   it from the media folder even if <i>SetFolder</i> was used to browse to /media/somefolder
// INPUTS
//   memID -- The ID of the memblock to create.
//   filename -- The name of the file to read, if it doesn't exist this will fail.
// SOURCE
void agk::CreateMemblockFromFile( uint32_t memID, const char* filename )
//****
{
	if ( m_cMemblockList.GetItem( memID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create memblock %d from file %s, memblock already exists", memID, filename );
		Error( errStr );
#endif
		return;
	}

	cFile oFile;
	if ( !oFile.OpenToRead( filename ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create memblock %d from file %s, file does not exist", memID, filename );
		Error( errStr );
#endif
		return;		
	}

	cMemblock *pMem = new cMemblock();
	pMem->m_iID = memID;
	pMem->m_iSize = oFile.GetSize();
	pMem->m_pData = new unsigned char[ pMem->m_iSize ];
	oFile.ReadData( (char*)pMem->m_pData, pMem->m_iSize );
	m_cMemblockList.AddItem( pMem, memID );

	oFile.Close();
}

//****f* Memblock/File/CreateMemblockFromFile
// FUNCTION
//   Creates a memblock from a file without any processing of the file data, the memblock will be a 
//   byte for byte copy of the file. Returns an ID that can be used to reference this memblock later.
//   You can use relative paths in the file name to read from sub folders or use <i>SetFolder</i> 
//   to browse there first. You can use absolute paths by adding a forward slash to the beginning of 
//   the filename, in this case the folder set with <i>SetFolder</i> is ignored. For example 
//   /media/file.txt will read it from the media folder even if <i>SetFolder</i> was used to 
//   browse to /media/somefolder
// INPUTS
//   filename -- The name of the file to read, if it doesn't exist this will fail.
// SOURCE
uint32_t agk::CreateMemblockFromFile( const char* filename )
//****
{
	uint32_t memID = m_cMemblockList.GetFreeID();
	if ( memID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create memblock from file - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateMemblockFromFile( memID, filename );
	return memID;
}

//****f* Memblock/File/CreateFileFromMemblock
// FUNCTION
//   Creates a file from a memblock without any processing of the memblock data, the file will be a 
//   byte for byte copy of the memblock data.
//   You can use relative paths in the file name to write to sub folders or use <i>SetFolder</i> 
//   to browse there first. You can use absolute paths by adding a forward slash to the beginning of 
//   the filename, in this case the folder set with <i>SetFolder</i> is ignored. For example 
//   /media/file.txt will place it in the media folder even if <i>SetFolder</i> was used to 
//   browse to /media/somefolder
// INPUTS
//   filename -- The name of the file to create, if it already exists it will be overwritten.
//   memID -- The ID of the memblock to read, the memblock is unaffected by this command.
// SOURCE
void agk::CreateFileFromMemblock( const char* filename, uint32_t memID )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create file %s from memblock %d, memblock does not exist", filename, memID );
		Error( errStr );
#endif
		return;
	}

	cFile oFile;
	if ( !oFile.OpenToWrite( filename ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create file %s from memblock %d, could not open file for writing", filename, memID );
		Error( errStr );
#endif
		return;
	}

	oFile.WriteData( (char*)pMem->m_pData, pMem->m_iSize );
	oFile.Close();
}


//****f* Memblock/Mesh/CreateMemblockFromObjectMesh
// FUNCTION
//   Creates a memblock from an object mesh. An object can contain one or more meshes, mesh indices 
//   are in the range 1 to <i>GetObjectNumMeshes</i> inclusive.
//   The mesh is copied into the memblock so any changes to the memblock do not immediately affect
//   the mesh, you must use one of the other commands such as <i>SetObjectMeshFromMemblock</i> to
//   copy the memblock back into a mesh.
//   The first 4 bytes of the memblock represent the number of vertices in the mesh. The second 4 
//   bytes represent the number of indices in the mesh, this may be 0 in which case every three 
//   vertices represents a polygon, and no vertices can be shared. If the number of indices is 
//   greater than 0 then every three indices represent a polygon and vertices may be shared between 
//   polygons. Indices start at 0 so index 0 references the first vertex in the list.
//   The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and 
//   UV data are all potential attributes, so a vertex containing all three would have 3 attributes.
//   A vertex must have a position attribute, everything else is optional.
//   The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from 
//   the attribute data but is given for convenience.
//   The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.
//   The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.
//   After those 6 values, starting at offset 24, is the vertex attribute data. The vertex 
//   attribute data describes how the vertex data is laid out, for example if it has normals, UV 
//   data, etc. For each attribute there is a 1 byte data type, 1 byte component count, 1 byte 
//   normalize flag, 1 byte string length, and X bytes of string data for the attribute name.
//   The data type will be 0 for floats (used for almost everything, e.g. position, normals, etc) or
//   1 for unsigned bytes (used for vertex colors). The component count is the number of values per 
//   attribute, e.g. position has 3 components, x,y,z, UV data has 2 components, and vertex colors 
//   have 4 components. Note that any unsigned byte data type must have 4 components even if some 
//   are unused. The normalize flag is only used for unsigned byte data types and will convert 
//   values in the range 0-255 into 0.0-1.0 for use in a shader. Usually the normalize flag will be 
//   1 for color attributes and 0 for everything else. The string length byte will always be a 
//   multiple of 4 to simplify alignment issues, the string itself might have slightly less 
//   characters and be padded with null terminators, but read all the bytes specified and you will 
//   get the correct length string. The attribute name string will be used by the shader to recognise
//   what the vertex data is, the attribute names recognised by AGK are "position", "normal", 
//   "tangent", "binormal", "color", "uv", "uv1", "boneweights", and "boneindices", however you may 
//   add attributes with any name you like as long as you write a matching shader that has the same 
//   names. If you are not using your own shader and instead rely on AGK to draw the object then you 
//   must stick to the above attribute names.
//   Following the attribute data is the raw vertex data, which usually starts with the "position" 
//   attribute. It will be a 4 byte float for the X position, a 4 byte float for the Y position, and
//   a 4 byte float for the Z position. This continues for each attribute specified in the attribute 
//   data. Note that color data will always be 4 bytes in total, 1 unsigned byte for each color 
//   channel. You can access individual vertices by using the vertex size provided above and the 
//   vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).
//   Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex 
//   in the vertex data. Every three indices represents a polygon.
//   If you plan on making regular changes to the mesh you should keep the memblock around after 
//   using <i>SetObjectMeshFromMemblock</i> instead of regenerating from the object it everytime you
//   want to make a change. Then call <i>SetObjectMeshFromMemblock</i> again when you want to push
//   your new changes onto the object.
// INPUTS
//   memID -- The ID of the new memblock
//   objID -- The ID of the object containing the mesh to read
//   meshIndex -- The index of the mesh to copy into a memblock
// SOURCE
void agk::CreateMemblockFromObjectMesh( uint32_t memID, uint32_t objID, uint32_t meshIndex )
//****
{
	if ( memID == 0 )
	{
		uString errStr("Failed to create memblock, ID must be greater than 0");
		Error( errStr );
		return;
	}

	if ( m_cMemblockList.GetItem( memID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create memblock %d from object %d, memblock already exists", memID, objID );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pFromObject = m_cObject3DList.GetItem( objID );
	if ( !pFromObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create mesh memblock from object %d, object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pFromObject->GetNumMeshes() )
	{
		uString errStr;
		errStr.Format( "Failed to create memblock from object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
		return;
	}

	cMesh *pMesh = pFromObject->GetMesh( meshIndex-1 );
	if ( !pMesh ) return;

	cMemblock *pMem = new cMemblock();
	pMem->m_iID = memID;

	pMesh->GetVerticesFromMemblock( pMem->m_iSize, &pMem->m_pData );

	m_cMemblockList.AddItem( pMem, memID );
}

//****f* Memblock/Mesh/CreateMemblockFromObjectMesh
// FUNCTION
//   Creates a memblock from an object mesh. An object can contain one or more meshes, mesh indices 
//   are in the range 1 to <i>GetObjectNumMeshes</i> inclusive.
//   The mesh is copied into the memblock so any changes to the memblock do not immediately affect
//   the mesh, you must use one of the other commands such as <i>SetObjectMeshFromMemblock</i> to
//   copy the memblock back into a mesh.
//   The first 4 bytes of the memblock represent the number of vertices in the mesh. The second 4 
//   bytes represent the number of indices in the mesh, this may be 0 in which case every three 
//   vertices represents a polygon, and no vertices can be shared. If the number of indices is 
//   greater than 0 then every three indices represent a polygon and vertices may be shared between 
//   polygons. Indices start at 0 so index 0 references the first vertex in the list.
//   The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and 
//   UV data are all potential attributes, so a vertex containing all three would have 3 attributes.
//   A vertex must have a position attribute, everything else is optional.
//   The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from 
//   the attribute data but is given for convenience.
//   The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.
//   The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.
//   After those 6 values, starting at offset 24, is the vertex attribute data. The vertex 
//   attribute data describes how the vertex data is laid out, for example if it has normals, UV 
//   data, etc. For each attribute there is a 1 byte data type, 1 byte component count, 1 byte 
//   normalize flag, 1 byte string length, and X bytes of string data for the attribute name.
//   The data type will be 0 for floats (used for almost everything, e.g. position, normals, etc) or
//   1 for unsigned bytes (used for vertex colors). The component count is the number of values per 
//   attribute, e.g. position has 3 components, x,y,z, UV data has 2 components, and vertex colors 
//   have 4 components. Note that any unsigned byte data type must have 4 components even if some 
//   are unused. The normalize flag is only used for unsigned byte data types and will convert 
//   values in the range 0-255 into 0.0-1.0 for use in a shader. Usually the normalize flag will be 
//   1 for color attributes and 0 for everything else. The string length byte will always be a 
//   multiple of 4 to simplify alignment issues, the string itself might have slightly less 
//   characters and be padded with null terminators, but read all the bytes specified and you will 
//   get the correct length string. The attribute name string will be used by the shader to recognise
//   what the vertex data is, the attribute names recognised by AGK are "position", "normal", 
//   "tangent", "binormal", "color", "uv", "uv1", "boneweights", and "boneindices", however you may 
//   add attributes with any name you like as long as you write a matching shader that has the same 
//   names. If you are not using your own shader and instead rely on AGK to draw the object then you 
//   must stick to the above attribute names.
//   Following the attribute data is the raw vertex data, which usually starts with the "position" 
//   attribute. It will be a 4 byte float for the X position, a 4 byte float for the Y position, and
//   a 4 byte float for the Z position. This continues for each attribute specified in the attribute 
//   data. Note that color data will always be 4 bytes in total, 1 unsigned byte for each color 
//   channel. You can access individual vertices by using the vertex size provided above and the 
//   vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).
//   Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex 
//   in the vertex data. Every three indices represents a polygon.
//   If you plan on making regular changes to the mesh you should keep the memblock around after 
//   using <i>SetObjectMeshFromMemblock</i> instead of regenerating from the object it everytime you
//   want to make a change. Then call <i>SetObjectMeshFromMemblock</i> again when you want to push
//   your new changes onto the object.
// INPUTS
//   objID -- The ID of the object containing the mesh to read
//   meshIndex -- The index of the mesh to copy into a memblock
// SOURCE
uint32_t agk::CreateMemblockFromObjectMesh( uint32_t objID, uint32_t meshIndex )
//****
{
	uint32_t memID = m_cMemblockList.GetFreeID();
	if ( memID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create memblock from object mesh - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateMemblockFromObjectMesh( memID, objID, meshIndex );
	return memID;
}

//****f* Memblock/Mesh/CreateObjectFromMeshMemblock
// FUNCTION
//   Creates an object with a single mesh constructed from the given memblock.
//   Any subsequent changes to the memblock will not affect the mesh, you should call
//   <i>SetObjectMeshFromMemblock</i> to modify an existing mesh.
//   The first 4 bytes of the memblock represent the number of vertices in the mesh. The second 4 
//   bytes represent the number of indices in the mesh, this may be 0 in which case every three 
//   vertices represents a polygon, and no vertices can be shared. If the number of indices is 
//   greater than 0 then every three indices represent a polygon and vertices may be shared between 
//   polygons. Indices start at 0 so index 0 references the first vertex in the list.
//   The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and 
//   UV data are all potential attributes, so a vertex containing all three would have 3 attributes.
//   A vertex must have a position attribute, everything else is optional.
//   The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from 
//   the attribute data but is given for convenience.
//   The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.
//   The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.
//   After those 6 values, starting at offset 24, is the vertex attribute data. The vertex 
//   attribute data describes how the vertex data is laid out, for example if it has normals, UV 
//   data, etc. For each attribute there is a 1 byte data type, 1 byte component count, 1 byte 
//   normalize flag, 1 byte string length, and X bytes of string data for the attribute name.
//   The data type will be 0 for floats (used for almost everything, e.g. position, normals, etc) or
//   1 for unsigned bytes (used for vertex colors). The component count is the number of values per 
//   attribute, e.g. position has 3 components, x,y,z, UV data has 2 components, and vertex colors 
//   have 4 components. Note that any unsigned byte data type must have 4 components even if some 
//   are unused. The normalize flag is only used for unsigned byte data types and will convert 
//   values in the range 0-255 into 0.0-1.0 for use in a shader. Usually the normalize flag will be 
//   1 for color attributes and 0 for everything else. The string length byte must always be a 
//   multiple of 4 for alignment reasons, the string itself might have slightly less characters but 
//   always round up to the nearest multiple of 4 for the string length value. e.g. a string of length 
//   5 should have a string length value of 8. Note that a string of 4 characters has a null terminator
//   on the end which makes it length 5, so even though it has a multiple of 4 characters already it 
//   must use a length value of 8 due to the null terminator. 
//   The attribute name string will be used by the shader to recognise what the vertex data is, 
//   the attribute names recognised by AGK are "position", "normal", "tangent", "binormal", "color", 
//   "uv", "uv1", "boneweights", and "boneindices", however you may add attributes with any name you 
//   like as long as you write a matching shader that has the same names. If you are not using your 
//   own shader and instead rely on AGK to draw the object then you must stick to the above attribute 
//   names.
//   Following the attribute data is the raw vertex data, which usually starts with the "position" 
//   attribute. It will be a 4 byte float for the X position, a 4 byte float for the Y position, and
//   a 4 byte float for the Z position. This continues for each attribute specified in the attribute 
//   data. Note that color data will always be 4 bytes in total, 1 unsigned byte for each color 
//   channel. You can access individual vertices by using the vertex size provided above and the 
//   vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).
//   Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex 
//   in the vertex data. Every three indices represents a polygon.
// INPUTS
//   objID -- The ID of the object to create
//   memID -- The index of the memblock to use to create the object mesh
// SOURCE
void agk::CreateObjectFromMeshMemblock( uint32_t objID, uint32_t memID )
//****
{
	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create object " );
		errStr.AppendUInt( objID ).Append( " from mesh memblock - object ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to create object %d from memblock %d, memblock does not exist", objID, memID );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;

	cMesh *pMesh = new cMesh( pObject );
	pMesh->SetVerticesFromMemblock( pMem->m_iSize, pMem->m_pData );
		
	pObject->CreateFromMeshes( 1, &pMesh );
	m_cObjectMgr.AddObject( pObject );
	m_cObject3DList.AddItem( pObject, objID );
}

//****f* Memblock/Mesh/CreateObjectFromMeshMemblock
// FUNCTION
//   Creates an object with a single mesh constructed from the given memblock.
//   Any subsequent changes to the memblock will not affect the mesh, you should call
//   <i>SetObjectMeshFromMemblock</i> to modify an existing mesh.
//   The first 4 bytes of the memblock represent the number of vertices in the mesh. The second 4 
//   bytes represent the number of indices in the mesh, this may be 0 in which case every three 
//   vertices represents a polygon, and no vertices can be shared. If the number of indices is 
//   greater than 0 then every three indices represent a polygon and vertices may be shared between 
//   polygons. Indices start at 0 so index 0 references the first vertex in the list.
//   The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and 
//   UV data are all potential attributes, so a vertex containing all three would have 3 attributes.
//   A vertex must have a position attribute, everything else is optional.
//   The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from 
//   the attribute data but is given for convenience.
//   The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.
//   The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.
//   After those 6 values, starting at offset 24, is the vertex attribute data. The vertex 
//   attribute data describes how the vertex data is laid out, for example if it has normals, UV 
//   data, etc. For each attribute there is a 1 byte data type, 1 byte component count, 1 byte 
//   normalize flag, 1 byte string length, and X bytes of string data for the attribute name.
//   The data type will be 0 for floats (used for almost everything, e.g. position, normals, etc) or
//   1 for unsigned bytes (used for vertex colors). The component count is the number of values per 
//   attribute, e.g. position has 3 components, x,y,z, UV data has 2 components, and vertex colors 
//   have 4 components. Note that any unsigned byte data type must have 4 components even if some 
//   are unused. The normalize flag is only used for unsigned byte data types and will convert 
//   values in the range 0-255 into 0.0-1.0 for use in a shader. Usually the normalize flag will be 
//   1 for color attributes and 0 for everything else. The string length byte must always be a 
//   multiple of 4 for alignment reasons, the string itself might have slightly less characters but 
//   always round up to the nearest multiple of 4 for the string length value. e.g. a string of length 
//   5 should have a string length value of 8. Note that a string of 4 characters has a null terminator
//   on the end which makes it length 5, so even though it has a multiple of 4 characters already it 
//   must use a length value of 8 due to the null terminator. 
//   The attribute name string will be used by the shader to recognise what the vertex data is, 
//   the attribute names recognised by AGK are "position", "normal", "tangent", "binormal", "color", 
//   "uv", "uv1", "boneweights", and "boneindices", however you may add attributes with any name you 
//   like as long as you write a matching shader that has the same names. If you are not using your 
//   own shader and instead rely on AGK to draw the object then you must stick to the above attribute 
//   names.
//   Following the attribute data is the raw vertex data, which usually starts with the "position" 
//   attribute. It will be a 4 byte float for the X position, a 4 byte float for the Y position, and
//   a 4 byte float for the Z position. This continues for each attribute specified in the attribute 
//   data. Note that color data will always be 4 bytes in total, 1 unsigned byte for each color 
//   channel. You can access individual vertices by using the vertex size provided above and the 
//   vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).
//   Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex 
//   in the vertex data. Every three indices represents a polygon.
// INPUTS
//   memID -- The index of the memblock to use to create the object mesh
// SOURCE
uint32_t agk::CreateObjectFromMeshMemblock( uint32_t memID )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create object mesh from memblock - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateObjectFromMeshMemblock( objID, memID );
	return objID;
}

//****f* Memblock/Mesh/SetObjectMeshFromMemblock
// FUNCTION
//   Changes an object's mesh based on the memblock provided. The memblock need not have the same
//   number of attributes or vertices as the original mesh, but it will improve performance if it does.
//   The first 4 bytes of the memblock represent the number of vertices in the mesh. The second 4 
//   bytes represent the number of indices in the mesh, this may be 0 in which case every three 
//   vertices represents a polygon, and no vertices can be shared. If the number of indices is 
//   greater than 0 then every three indices represent a polygon and vertices may be shared between 
//   polygons. Indices start at 0 so index 0 references the first vertex in the list.
//   The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and 
//   UV data are all potential attributes, so a vertex containing all three would have 3 attributes.
//   A vertex must have a position attribute, everything else is optional.
//   The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from 
//   the attribute data but is given for convenience.
//   The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.
//   The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.
//   After those 6 values, starting at offset 24, is the vertex attribute data. The vertex 
//   attribute data describes how the vertex data is laid out, for example if it has normals, UV 
//   data, etc. For each attribute there is a 1 byte data type, 1 byte component count, 1 byte 
//   normalize flag, 1 byte string length, and X bytes of string data for the attribute name.
//   The data type will be 0 for floats (used for almost everything, e.g. position, normals, etc) or
//   1 for unsigned bytes (used for vertex colors). The component count is the number of values per 
//   attribute, e.g. position has 3 components, x,y,z, UV data has 2 components, and vertex colors 
//   have 4 components. Note that any unsigned byte data type must have 4 components even if some 
//   are unused. The normalize flag is only used for unsigned byte data types and will convert 
//   values in the range 0-255 into 0.0-1.0 for use in a shader. Usually the normalize flag will be 
//   1 for color attributes and 0 for everything else. The string length byte must always be a 
//   multiple of 4 for alignment reasons, the string itself might have slightly less characters but 
//   always round up to the nearest multiple of 4 for the string length value. e.g. a string of length 
//   5 should have a string length value of 8. Note that a string of 4 characters has a null terminator
//   on the end which makes it length 5, so even though it has a multiple of 4 characters already it 
//   must use a length value of 8 due to the null terminator. 
//   The attribute name string will be used by the shader to recognise what the vertex data is, 
//   the attribute names recognised by AGK are "position", "normal", "tangent", "binormal", "color", 
//   "uv", "uv1", "boneweights", and "boneindices", however you may add attributes with any name you 
//   like as long as you write a matching shader that has the same names. If you are not using your 
//   own shader and instead rely on AGK to draw the object then you must stick to the above attribute 
//   names.
//   Following the attribute data is the raw vertex data, which usually starts with the "position" 
//   attribute. It will be a 4 byte float for the X position, a 4 byte float for the Y position, and
//   a 4 byte float for the Z position. This continues for each attribute specified in the attribute 
//   data. Note that color data will always be 4 bytes in total, 1 unsigned byte for each color 
//   channel. You can access individual vertices by using the vertex size provided above and the 
//   vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).
//   Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex 
//   in the vertex data. Every three indices represents a polygon.
//   If you plan on making regular changes to the mesh you should keep the memblock around after 
//   using <i>SetObjectMeshFromMemblock</i> instead of regenerating from the object it everytime you
//   want to make a change. Then call <i>SetObjectMeshFromMemblock</i> again when you want to push
//   your new changes onto the object.
// INPUTS
//   objID -- The ID of the object to modify
//   meshIndex -- The index of the mesh to modify
//   memID -- The index of the memblock to use to modify the mesh
// SOURCE
void agk::SetObjectMeshFromMemblock( uint32_t objID, uint32_t meshIndex, uint32_t memID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set object mesh from memblock - object %d does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
		uString errStr;
		errStr.Format( "Failed to set object %d mesh from memblock - mesh index %d is out of range", objID, meshIndex );
		Error( errStr );
		return;
	}

	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set object mesh from memblock %d, memblock does not exist", memID );
		Error( errStr );
#endif
		return;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	if ( !pMesh ) return;
	pMesh->SetVerticesFromMemblock( pMem->m_iSize, pMem->m_pData );
	pObject->UpdateCollisionData();
}

//****f* Memblock/Mesh/AddObjectMeshFromMemblock
// FUNCTION
//   Adds a new mesh to the object, constructed from the given memblock.
//   The first 4 bytes of the memblock represent the number of vertices in the mesh. The second 4 
//   bytes represent the number of indices in the mesh, this may be 0 in which case every three 
//   vertices represents a polygon, and no vertices can be shared. If the number of indices is 
//   greater than 0 then every three indices represent a polygon and vertices may be shared between 
//   polygons. Indices start at 0 so index 0 references the first vertex in the list.
//   The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and 
//   UV data are all potential attributes, so a vertex containing all three would have 3 attributes.
//   A vertex must have a position attribute, everything else is optional.
//   The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from 
//   the attribute data but is given for convenience.
//   The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.
//   The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.
//   After those 6 values, starting at offset 24, is the vertex attribute data. The vertex 
//   attribute data describes how the vertex data is laid out, for example if it has normals, UV 
//   data, etc. For each attribute there is a 1 byte data type, 1 byte component count, 1 byte 
//   normalize flag, 1 byte string length, and X bytes of string data for the attribute name.
//   The data type will be 0 for floats (used for almost everything, e.g. position, normals, etc) or
//   1 for unsigned bytes (used for vertex colors). The component count is the number of values per 
//   attribute, e.g. position has 3 components, x,y,z, UV data has 2 components, and vertex colors 
//   have 4 components. Note that any unsigned byte data type must have 4 components even if some 
//   are unused. The normalize flag is only used for unsigned byte data types and will convert 
//   values in the range 0-255 into 0.0-1.0 for use in a shader. Usually the normalize flag will be 
//   1 for color attributes and 0 for everything else. The string length byte must always be a 
//   multiple of 4 for alignment reasons, the string itself might have slightly less characters but 
//   always round up to the nearest multiple of 4 for the string length value. e.g. a string of length 
//   5 should have a string length value of 8. Note that a string of 4 characters has a null terminator
//   on the end which makes it length 5, so even though it has a multiple of 4 characters already it 
//   must use a length value of 8 due to the null terminator. 
//   The attribute name string will be used by the shader to recognise what the vertex data is, 
//   the attribute names recognised by AGK are "position", "normal", "tangent", "binormal", "color", 
//   "uv", "uv1", "boneweights", and "boneindices", however you may add attributes with any name you 
//   like as long as you write a matching shader that has the same names. If you are not using your 
//   own shader and instead rely on AGK to draw the object then you must stick to the above attribute 
//   names.
//   Following the attribute data is the raw vertex data, which usually starts with the "position" 
//   attribute. It will be a 4 byte float for the X position, a 4 byte float for the Y position, and
//   a 4 byte float for the Z position. This continues for each attribute specified in the attribute 
//   data. Note that color data will always be 4 bytes in total, 1 unsigned byte for each color 
//   channel. You can access individual vertices by using the vertex size provided above and the 
//   vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).
//   Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex 
//   in the vertex data. Every three indices represents a polygon.
// INPUTS
//   objID -- The ID of the object to modify
//   memID -- The index of the memblock to use to create the new mesh
// SOURCE
void agk::AddObjectMeshFromMemblock( uint32_t objID, uint32_t memID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to add object mesh from memblock - object %d does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to add object mesh from memblock %d, memblock does not exist", memID );
		Error( errStr );
#endif
		return;
	}

	cMesh *pMesh = new cMesh( pObject );
	pMesh->SetVerticesFromMemblock( pMem->m_iSize, pMem->m_pData );
	
	pObject->AddMesh( pMesh );
}

unsigned short agk::InternalGetMemblockPosOffset( cMemblock *pMem )
{
	// check the position attribute hasn't moved
	unsigned short posCheck = pMem->m_iUser1 & 0xffff;
	unsigned short posOffset = (pMem->m_iUser1 >> 16) & 0xffff;
	if ( posCheck != 0xffff )
	{
		if ( pMem->m_pData[ posCheck ] != 'p'
		  || pMem->m_pData[ posCheck + 1 ] != 'o' ) 
		{
			posCheck = 0xffff;
			posOffset = 0xffff;
		}
	}

	if ( posCheck == 0xffff )
	{
		// find the position offset and cache it for next time
		uint32_t offset = 24;
		uint32_t attribOffset = 0;
		uint32_t numAttributes = ((int*)(pMem->m_pData))[ 2 ];
		for ( uint32_t a = 0; a < numAttributes; a++ )
		{
			uint32_t length = pMem->m_pData[ offset + 3 ];
			char *str = new char[ length ];
			memcpy( str, pMem->m_pData+offset+4, length );
			str[ length-1 ] = 0; // just in case it didn't include a null terminator
			if ( strcmp(str,"position") == 0 )
			{
				posCheck = offset+4;
				posOffset = attribOffset;
				pMem->m_iUser1 = (posOffset << 16) | posCheck;
				delete [] str;
				break;
			}

			delete [] str;

			if ( pMem->m_pData[ offset + 0 ] == 1 ) ++attribOffset;
			else attribOffset += pMem->m_pData[ offset + 1 ];

			offset += (4 + length);
		}
	}

	return posOffset;
}

unsigned short agk::InternalGetMemblockNormOffset( cMemblock *pMem )
{
	// check the normal attribute hasn't moved
	unsigned short normCheck = pMem->m_iUser2 & 0xffff;
	unsigned short normOffset = (pMem->m_iUser2 >> 16) & 0xffff;
	if ( normCheck != 0xffff )
	{
		if ( pMem->m_pData[ normCheck ] != 'n'
		  || pMem->m_pData[ normCheck + 1 ] != 'o' ) 
		{
			normCheck = 0xffff;
			normOffset = 0xffff;
		}
	}

	if ( normCheck == 0xffff )
	{
		// find the normal offset and cache it for next time
		uint32_t offset = 24;
		uint32_t attribOffset = 0;
		uint32_t numAttributes = ((int*)(pMem->m_pData))[ 2 ];
		for ( uint32_t a = 0; a < numAttributes; a++ )
		{
			uint32_t length = pMem->m_pData[ offset + 3 ];
			char *str = new char[ length ];
			memcpy( str, pMem->m_pData+offset+4, length );
			str[ length-1 ] = 0; // just in case it didn't include a null terminator
			if ( strcmp(str,"normal") == 0 )
			{
				normCheck = offset+4;
				normOffset = attribOffset;
				pMem->m_iUser2 = (normOffset << 16) | normCheck;
				delete [] str;
				break;
			}

			delete [] str;

			if ( pMem->m_pData[ offset + 0 ] == 1 ) ++attribOffset;
			else attribOffset += pMem->m_pData[ offset + 1 ];

			offset += (4 + length);
		}
	}

	return normOffset;
}

unsigned short agk::InternalGetMemblockUVOffset( cMemblock *pMem )
{
	// check the UV attribute hasn't moved
	unsigned short uvCheck = pMem->m_iUser3 & 0xffff;
	unsigned short uvOffset = (pMem->m_iUser3 >> 16) & 0xffff;
	if ( uvCheck != 0xffff )
	{
		if ( pMem->m_pData[ uvCheck ] != 'u'
		  || pMem->m_pData[ uvCheck + 1 ] != 'v' ) 
		{
			uvCheck = 0xffff;
			uvOffset = 0xffff;
		}
	}

	if ( uvCheck == 0xffff )
	{
		// find the position offset and cache it for next time
		uint32_t offset = 24;
		uint32_t attribOffset = 0;
		uint32_t numAttributes = ((int*)(pMem->m_pData))[ 2 ];
		for ( uint32_t a = 0; a < numAttributes; a++ )
		{
			uint32_t length = pMem->m_pData[ offset + 3 ];
			char *str = new char[ length ];
			memcpy( str, pMem->m_pData+offset+4, length );
			str[ length-1 ] = 0; // just in case it didn't include a null terminator
			if ( strcmp(str,"uv") == 0 )
			{
				uvCheck = offset+4;
				uvOffset = attribOffset;
				pMem->m_iUser3 = (uvOffset << 16) | uvCheck;
				delete [] str;
				break;
			}

			delete [] str;

			if ( pMem->m_pData[ offset + 0 ] == 1 ) ++attribOffset;
			else attribOffset += pMem->m_pData[ offset + 1 ];

			offset += (4 + length);
		}
	}

	return uvOffset;
}

unsigned short agk::InternalGetMemblockColorOffset( cMemblock *pMem )
{
	// check the color attribute hasn't moved
	unsigned short colorCheck = pMem->m_iUser4 & 0xffff;
	unsigned short colorOffset = (pMem->m_iUser4 >> 16) & 0xffff;
	if ( colorCheck != 0xffff )
	{
		if ( pMem->m_pData[ colorCheck ] != 'c'
		  || pMem->m_pData[ colorCheck + 1 ] != 'o' ) 
		{
			colorCheck = 0xffff;
			colorOffset = 0xffff;
		}
	}

	if ( colorCheck == 0xffff )
	{
		// find the normal offset and cache it for next time
		uint32_t offset = 24;
		uint32_t attribOffset = 0;
		uint32_t numAttributes = ((int*)(pMem->m_pData))[ 2 ];
		for ( uint32_t a = 0; a < numAttributes; a++ )
		{
			uint32_t length = pMem->m_pData[ offset + 3 ];
			char *str = new char[ length ];
			memcpy( str, pMem->m_pData+offset+4, length );
			str[ length-1 ] = 0; // just in case it didn't include a null terminator
			if ( strcmp(str,"color") == 0 )
			{
				colorCheck = offset+4;
				colorOffset = attribOffset;
				pMem->m_iUser4 = (colorOffset << 16) | colorCheck;
				delete [] str;
				break;
			}

			delete [] str;

			if ( pMem->m_pData[ offset + 0 ] == 1 ) ++attribOffset;
			else attribOffset += pMem->m_pData[ offset + 1 ];

			offset += (4 + length);
		}
	}

	return colorOffset;
}

//****f* Memblock/Mesh/SetMeshMemblockVertexPosition
// FUNCTION
//   Provides a quick way to modify the position of a vertex inside a mesh memblock. It uses the attribute
//   data from the beginning of the memblock to work out the vertex offset and change the position values.
//   Vertices start at index 0.
// INPUTS
//   memID -- The ID of the memblock to modify
//   vertexIndex -- The index of the vertex to modify
//   x -- The new X position for this vertex
//   y -- The new Y position for this vertex
//   z -- The new Z position for this vertex
// SOURCE
void agk::SetMeshMemblockVertexPosition( uint32_t memID, uint32_t vertexIndex, float x, float y, float z )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex position, memblock does not exist", memID );
		Error( errStr );
#endif
		return;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex position, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return;
	}

	unsigned short posOffset = InternalGetMemblockPosOffset( pMem );
	if ( posOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex position, no position attribute found for this mesh", memID );
		Error( errStr );
		return;
	}

	// set the actual position
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex position, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return;
	}

	vertexOffset /= 4;
	((float*)(pMem->m_pData))[ vertexOffset + posOffset + 0 ] = x;
	((float*)(pMem->m_pData))[ vertexOffset + posOffset + 1 ] = y;
	((float*)(pMem->m_pData))[ vertexOffset + posOffset + 2 ] = z;
}

//****f* Memblock/Mesh/SetMeshMemblockVertexNormal
// FUNCTION
//   Provides a quick way to modify the normal of a vertex inside a mesh memblock. It uses the attribute
//   data from the beginning of the memblock to work out the vertex offset and change the normal values.
//   Vertices start at index 0.
// INPUTS
//   memID -- The ID of the memblock to modify
//   vertexIndex -- The index of the vertex to modify
//   x -- The X component of the new normal for this vertex
//   y -- The Y component of the new normal for this vertex
//   z -- The Z component of the new normal for this vertex
// SOURCE
void agk::SetMeshMemblockVertexNormal( uint32_t memID, uint32_t vertexIndex, float x, float y, float z )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex normal, memblock does not exist", memID );
		Error( errStr );
#endif
		return;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex normal, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return;
	}

	unsigned short normOffset = InternalGetMemblockNormOffset( pMem );
	if ( normOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex normal, no normal attribute found for this mesh", memID );
		Error( errStr );
		return;
	}

	// set the actual normal
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex normal, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return;
	}

	vertexOffset /= 4;
	((float*)(pMem->m_pData))[ vertexOffset + normOffset + 0 ] = x;
	((float*)(pMem->m_pData))[ vertexOffset + normOffset + 1 ] = y;
	((float*)(pMem->m_pData))[ vertexOffset + normOffset + 2 ] = z;
}

//****f* Memblock/Mesh/SetMeshMemblockVertexUV
// FUNCTION
//   Provides a quick way to modify the UV values of a vertex inside a mesh memblock. It uses the attribute
//   data from the beginning of the memblock to work out the vertex offset and change the UV values.
//   Vertices start at index 0.
// INPUTS
//   memID -- The ID of the memblock to modify
//   vertexIndex -- The index of the vertex to modify
//   u -- The new U value for this vertex
//   v -- The new V value for this vertex
// SOURCE
void agk::SetMeshMemblockVertexUV( uint32_t memID, uint32_t vertexIndex, float u, float v )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex UV, memblock does not exist", memID );
		Error( errStr );
#endif
		return;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex UV, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return;
	}

	unsigned short uvOffset = InternalGetMemblockUVOffset( pMem );
	if ( uvOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex UV, no UV attribute found for this mesh", memID );
		Error( errStr );
		return;
	}

	// set the actual UV
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex UV, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return;
	}

	vertexOffset /= 4;
	((float*)(pMem->m_pData))[ vertexOffset + uvOffset + 0 ] = u;
	((float*)(pMem->m_pData))[ vertexOffset + uvOffset + 1 ] = v;
}

//****f* Memblock/Mesh/SetMeshMemblockVertexColor
// FUNCTION
//   Provides a quick way to modify the color values of a vertex inside a mesh memblock. It uses the attribute
//   data from the beginning of the memblock to work out the vertex offset and change the color values.
//   Vertices start at index 0. Color values must be between 0 and 255.
// INPUTS
//   memID -- The ID of the memblock to modify
//   vertexIndex -- The index of the vertex to modify
//   red -- The new red value for this vertex
//   green -- The new green value for this vertex
//   blue -- The new blue value for this vertex
//   alpha -- The new alpha value for this vertex
// SOURCE
void agk::SetMeshMemblockVertexColor( uint32_t memID, uint32_t vertexIndex, int red, int green, int blue, int alpha )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex color, memblock does not exist", memID );
		Error( errStr );
#endif
		return;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex color, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return;
	}

	unsigned short colorOffset = InternalGetMemblockColorOffset( pMem );
	if ( colorOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex color, no color attribute found for this mesh", memID );
		Error( errStr );
		return;
	}

	// set the actual color
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to set memblock %d vertex color, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return;
	}

	if ( red < 0 ) red = 0;
	if ( green < 0 ) green = 0;
	if ( blue < 0 ) blue = 0;
	if ( alpha < 0 ) alpha = 0;

	if ( red > 255 ) red = 255;
	if ( green > 255 ) green = 255;
	if ( blue > 255 ) blue = 255;
	if ( alpha > 255 ) alpha = 255;

	vertexOffset /= 4;
	((uint32_t*)(pMem->m_pData))[ vertexOffset + colorOffset ] = (alpha << 24) | (blue << 16) | (green << 8) | red;
}

//****f* Memblock/Mesh/GetMeshMemblockVertexX
// FUNCTION
//   Provides a quick way to get the X position of the specified vertex from the memblock. It uses the attribute
//   data from the beginning of the memblock to work out the vertex offset and the location of the position values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
float agk::GetMeshMemblockVertexX( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex X, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex X, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short posOffset = InternalGetMemblockPosOffset( pMem );
	if ( posOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex X, no position attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the position
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex X, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	return ((float*)(pMem->m_pData))[ vertexOffset + posOffset + 0 ];
}

//****f* Memblock/Mesh/GetMeshMemblockVertexY
// FUNCTION
//   Provides a quick way to get the Y position of the specified vertex from the memblock. It uses the attribute
//   data from the beginning of the memblock to work out the vertex offset and the location of the position values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
float agk::GetMeshMemblockVertexY( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex Y, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex Y, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short posOffset = InternalGetMemblockPosOffset( pMem );
	if ( posOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex Y, no position attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the position
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex Y, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	return ((float*)(pMem->m_pData))[ vertexOffset + posOffset + 1 ];
}

//****f* Memblock/Mesh/GetMeshMemblockVertexZ
// FUNCTION
//   Provides a quick way to get the Z position of the specified vertex from the memblock. It uses the attribute
//   data from the beginning of the memblock to work out the vertex offset and the location of the position values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
float agk::GetMeshMemblockVertexZ( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex Z, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex Z, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short posOffset = InternalGetMemblockPosOffset( pMem );
	if ( posOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex Z, no position attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the position
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex Z, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	return ((float*)(pMem->m_pData))[ vertexOffset + posOffset + 2 ];
}

//****f* Memblock/Mesh/GetMeshMemblockVertexNormalX
// FUNCTION
//   Provides a quick way to get the X component of the normal of the specified vertex from the memblock. It uses the 
//   attribute data from the beginning of the memblock to work out the vertex offset and the location of the normal values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
float agk::GetMeshMemblockVertexNormalX( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal X, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal X, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short normOffset = InternalGetMemblockNormOffset( pMem );
	if ( normOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal X, no normal attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the position
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal X, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	return ((float*)(pMem->m_pData))[ vertexOffset + normOffset + 0 ];
}

//****f* Memblock/Mesh/GetMeshMemblockVertexNormalY
// FUNCTION
//   Provides a quick way to get the Y component of the normal of the specified vertex from the memblock. It uses the 
//   attribute data from the beginning of the memblock to work out the vertex offset and the location of the normal values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
float agk::GetMeshMemblockVertexNormalY( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal Y, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal Y, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short normOffset = InternalGetMemblockNormOffset( pMem );
	if ( normOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal Y, no normal attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the position
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal Y, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	return ((float*)(pMem->m_pData))[ vertexOffset + normOffset + 1 ];
}

//****f* Memblock/Mesh/GetMeshMemblockVertexNormalZ
// FUNCTION
//   Provides a quick way to get the Z component of the normal of the specified vertex from the memblock. It uses the 
//   attribute data from the beginning of the memblock to work out the vertex offset and the location of the normal values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
float agk::GetMeshMemblockVertexNormalZ( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal Z, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal Z, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short normOffset = InternalGetMemblockNormOffset( pMem );
	if ( normOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal Z, no normal attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the position
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex normal Z, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	return ((float*)(pMem->m_pData))[ vertexOffset + normOffset + 2 ];
}

//****f* Memblock/Mesh/GetMeshMemblockVertexU
// FUNCTION
//   Provides a quick way to get the U value of the specified vertex from the memblock. It uses the attribute 
//   data from the beginning of the memblock to work out the vertex offset and the location of the UV values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
float agk::GetMeshMemblockVertexU( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex U, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex U, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short uvOffset = InternalGetMemblockUVOffset( pMem );
	if ( uvOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex U, no UV attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the position
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex U, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	return ((float*)(pMem->m_pData))[ vertexOffset + uvOffset + 0 ];
}

//****f* Memblock/Mesh/GetMeshMemblockVertexV
// FUNCTION
//   Provides a quick way to get the V value of the specified vertex from the memblock. It uses the attribute 
//   data from the beginning of the memblock to work out the vertex offset and the location of the UV values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
float agk::GetMeshMemblockVertexV( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex V, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex V, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short uvOffset = InternalGetMemblockUVOffset( pMem );
	if ( uvOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex V, no UV attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the position
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex V, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	return ((float*)(pMem->m_pData))[ vertexOffset + uvOffset + 1 ];
}

//****f* Memblock/Mesh/GetMeshMemblockVertexRed
// FUNCTION
//   Provides a quick way to get the red value of the specified vertex from the memblock. It uses the attribute 
//   data from the beginning of the memblock to work out the vertex offset and the location of the color values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
int agk::GetMeshMemblockVertexRed( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex red, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex red, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short colorOffset = InternalGetMemblockColorOffset( pMem );
	if ( colorOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex red, no color attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the color
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex red, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	uint32_t color = ((uint32_t*)(pMem->m_pData))[ vertexOffset + colorOffset ];
	return color & 0xff;
}

//****f* Memblock/Mesh/GetMeshMemblockVertexGreen
// FUNCTION
//   Provides a quick way to get the green value of the specified vertex from the memblock. It uses the attribute 
//   data from the beginning of the memblock to work out the vertex offset and the location of the color values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
int agk::GetMeshMemblockVertexGreen( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex green, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex green, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short colorOffset = InternalGetMemblockColorOffset( pMem );
	if ( colorOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex green, no color attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the color
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex green, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	uint32_t color = ((uint32_t*)(pMem->m_pData))[ vertexOffset + colorOffset ];
	return (color >> 8) & 0xff;
}

//****f* Memblock/Mesh/GetMeshMemblockVertexBlue
// FUNCTION
//   Provides a quick way to get the blue value of the specified vertex from the memblock. It uses the attribute 
//   data from the beginning of the memblock to work out the vertex offset and the location of the color values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
int agk::GetMeshMemblockVertexBlue( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex blue, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex blue, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short colorOffset = InternalGetMemblockColorOffset( pMem );
	if ( colorOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex blue, no color attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the color
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex blue, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	uint32_t color = ((uint32_t*)(pMem->m_pData))[ vertexOffset + colorOffset ];
	return (color >> 16) & 0xff;
}

//****f* Memblock/Mesh/GetMeshMemblockVertexAlpha
// FUNCTION
//   Provides a quick way to get the alpha value of the specified vertex from the memblock. It uses the attribute 
//   data from the beginning of the memblock to work out the vertex offset and the location of the color values.
// INPUTS
//   memID -- The ID of the memblock to check
//   vertexIndex -- The index of the vertex to check
// SOURCE
int agk::GetMeshMemblockVertexAlpha( uint32_t memID, uint32_t vertexIndex )
//****
{
	cMemblock *pMem = m_cMemblockList.GetItem( memID );
	if ( !pMem )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex alpha, memblock does not exist", memID );
		Error( errStr );
#endif
		return 0;
	}

	if ( pMem->m_iSize < 24 )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex alpha, memblock is not big enough to be holding a mesh", memID );
		Error( errStr );
		return 0;
	}

	unsigned short colorOffset = InternalGetMemblockColorOffset( pMem );
	if ( colorOffset == 0xffff )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex alpha, no color attribute found for this mesh", memID );
		Error( errStr );
		return 0;
	}

	// get the color
	uint32_t vertexSize = ((int*)(pMem->m_pData))[ 3 ];
	uint32_t vertexOffset = ((int*)(pMem->m_pData))[ 4 ];
	vertexOffset += vertexSize*vertexIndex;
	if ( vertexOffset + vertexSize > pMem->m_iSize )
	{
		uString errStr;
		errStr.Format( "Failed to get memblock %d vertex alpha, memblock is not holding a mesh or it is not formatted correctly", memID );
		Error( errStr );
		return 0;
	}

	vertexOffset /= 4;
	uint32_t color = ((uint32_t*)(pMem->m_pData))[ vertexOffset + colorOffset ];
	return (color >> 24) & 0xff;
}

//
// V108 ULTRA RAW COMMANDS - In WindowsCore.cpp
//

//
// V108 3D
//

//****f* 3D/General/SetGlobal3DDepth
// FUNCTION
//   Sets the position of all 3D objects relative to 2D objects. For example using a global 3D depth
//   of 100 would mean that all sprites at a depth less than or equal to 100 would appear above any 
//   3D objects whilst sprites at a depth greater than 100 would appear below any 3D objects.
// INPUTS
//   depth -- The sprite depth to render 3D.
// SOURCE
void agk::SetGlobal3DDepth( int depth )
//****
{
	m_i3DDepth = depth;
}

//****f* 3D/Objects/CreateObjectBox
// FUNCTION
//   Creates a 3D box with the given width (X), height (Y), and length (Z).
// INPUTS
//   objID -- The ID to use for the new object.
//   width -- The size of the object in the X direction.
//   height -- The size of the object in the Y direction.
//   length -- The size of the object in the Z direction.
// SOURCE
void agk::CreateObjectBox( uint32_t objID, float width, float height, float length )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create box object " );
		errStr.AppendUInt( objID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->CreateBox( width, height, length );
	m_cObjectMgr.AddObject( pObject );
	m_cObject3DList.AddItem( pObject, objID );
}

//****f* 3D/Objects/CreateObjectBox
// FUNCTION
//   Creates a 3D box with the given width (X), height (Y), and length (Z).
//   Returns an ID you can use to reference this object in other commands.
// INPUTS
//   width -- The size of the object in the X direction.
//   height -- The size of the object in the Y direction.
//   length -- The size of the object in the Z direction.
// SOURCE
uint32_t agk::CreateObjectBox( float width, float height, float length )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create box object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateObjectBox( objID, width, height, length ); 
	return objID;
}

//****f* 3D/Objects/CreateObjectCapsule
// FUNCTION
//   Creates a Capsule primitive.
// INPUTS
//  objID -- The ID to use for the new object.
//  diameter -- The diameter of the capsule.
//  height -- The height of the capsule
//  axis -- 0 = X, 1 = Y, Z = 2 
// SOURCE
void agk::CreateObjectCapsule( uint32_t objID, float diameter, float height, int axis )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create capsule object " );
		errStr.AppendUInt( objID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->CreateCapsule( diameter, height, axis );
	m_cObjectMgr.AddObject( pObject );
	m_cObject3DList.AddItem( pObject, objID );
}

//****f* 3D/Objects/CreateObjectCapsule
// FUNCTION
//   Creates a Capsule primitive.
// INPUTS
//  diameter -- The diameter of the capsule.
//  height -- The height of the capsule
//  axis -- 0 = X, 1 = Y, Z = 2 
// SOURCE
uint32_t agk::CreateObjectCapsule( float diameter, float height, int axis )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create capsule object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}
	CreateObjectCapsule( objID, diameter, height, axis ); 
	return objID;
}

//****f* 3D/Objects/CreateObjectSphere
// FUNCTION
//   Creates a 3D sphere with the given diameter, and an optional number of polygons.
//   The rows parameter determines how many rows of polygons make up the sphere and 
//   must be at least 2. The columns parameter determines how many columns of polygons
//   make up the sphere and must be at least 3. The formula for calculating the total
//   number of polygons used in the sphere is 2*columns*(rows-1)
// INPUTS
//   objID -- The ID to use for the new object.
//   diameter -- The diameter of the sphere.
//   rows -- The number of rows of polygons that make up the sphere.
//   columns -- The number of columns of polygons that make up the sphere.
// SOURCE
void agk::CreateObjectSphere( uint32_t objID, float diameter, int rows, int columns )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create sphere object " );
		errStr.AppendUInt( objID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->CreateSphere( diameter, rows, columns );
	m_cObjectMgr.AddObject( pObject );
	m_cObject3DList.AddItem( pObject, objID );
}

//****f* 3D/Objects/CreateObjectSphere
// FUNCTION
//   Creates a 3D sphere with the given diameter, and an optional number of polygons.
//   The rows parameter determines how many rows of polygons make up the sphere and 
//   must be at least 2. The columns parameter determines how many columns of polygons
//   make up the sphere and must be at least 3. The formula for calculating the total
//   number of polygons used in the sphere is 2*columns*(rows-1).
//   Returns an ID you can use to reference this object in other commands.
// INPUTS
//   diameter -- The diameter of the sphere.
//   rows -- The number of rows of polygons that make up the sphere.
//   columns -- The number of columns of polygons that make up the sphere.
// SOURCE
uint32_t agk::CreateObjectSphere( float diameter, int rows, int columns )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create sphere object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateObjectSphere( objID, diameter, rows, columns ); 
	return objID;
}

//****f* 3D/Objects/CreateObjectCone
// FUNCTION
//   Creates a 3D cone with the given diameter and height, and an optional number of polygons.
//   The segments parameter determines how many columns of polygons make up the cone and must 
//   be at least 3. The formula for calculating the total number of polygons used in the cone 
//   is 2*segments.
// INPUTS
//   objID -- The ID to use for the new object.
//   height -- The height of the cone.
//   diameter -- The diameter of the base of the cone.
//   segments -- The number of columns of polygons that make up the cone.
// SOURCE
void agk::CreateObjectCone( uint32_t objID, float height, float diameter, int segments )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create cone object " );
		errStr.AppendUInt( objID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->CreateCone( height, diameter, segments );
	m_cObjectMgr.AddObject( pObject );
	m_cObject3DList.AddItem( pObject, objID );
}

//****f* 3D/Objects/CreateObjectCone
// FUNCTION
//   Creates a 3D cone with the given diameter and height, and an optional number of polygons.
//   The segments parameter determines how many columns of polygons make up the cone and must 
//   be at least 3. The formula for calculating the total number of polygons used in the cone 
//   is 2*segments.
//   Returns an ID you can use to reference this object in other commands.
// INPUTS
//   height -- The height of the cone.
//   diameter -- The diameter of the base of the cone.
//   segments -- The number of columns of polygons that make up the cone.
// SOURCE
uint32_t agk::CreateObjectCone( float height, float diameter, int segments )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create cone object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateObjectCone( objID, height, diameter, segments ); 
	return objID;
}

//****f* 3D/Objects/CreateObjectCylinder
// FUNCTION
//   Creates a 3D cylinder with the given diameter and height, and an optional number of polygons.
//   The segments parameter determines how many columns of polygons make up the cylinder and must 
//   be at least 3. The formula for calculating the total number of polygons used in the cylinder 
//   is 3*segments.
// INPUTS
//   objID -- The ID to use for the new object.
//   height -- The height of the cylinder.
//   diameter -- The diameter of the base of the cylinder.
//   segments -- The number of columns of polygons that make up the cylinder.
// SOURCE
void agk::CreateObjectCylinder( uint32_t objID, float height, float diameter, int segments )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create cylinder object " );
		errStr.AppendUInt( objID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->CreateCylinder( height, diameter, segments );
	m_cObjectMgr.AddObject( pObject );
	m_cObject3DList.AddItem( pObject, objID );
}

//****f* 3D/Objects/CreateObjectCylinder
// FUNCTION
//   Creates a 3D cylinder with the given diameter and height, and an optional number of polygons.
//   The segments parameter determines how many columns of polygons make up the cylinder and must 
//   be at least 3. The formula for calculating the total number of polygons used in the cylinder 
//   is 3*segments.
//   Returns an ID you can use to reference this object in other commands.
// INPUTS
//   height -- The height of the cylinder.
//   diameter -- The diameter of the base of the cylinder.
//   segments -- The number of columns of polygons that make up the cylinder.
// SOURCE
uint32_t agk::CreateObjectCylinder( float height, float diameter, int segments )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create cylinder object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateObjectCylinder( objID, height, diameter, segments ); 
	return objID;
}

//****f* 3D/Objects/CreateObjectPlane
// FUNCTION
//   Creates a 3D double sided plane with the given width (X) and height (Y).
//   The plane is created in the XY plane and has no size in the Z direction.
// INPUTS
//   objID -- The ID to use for the new object.
//   width -- The width of the plane.
//   height -- The height of the plane.
// SOURCE
void agk::CreateObjectPlane( uint32_t objID, float width, float height )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create plane object " );
		errStr.AppendUInt( objID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->CreatePlane( width, height );
	m_cObjectMgr.AddObject( pObject );
	m_cObject3DList.AddItem( pObject, objID );
}

//****f* 3D/Objects/CreateObjectPlane
// FUNCTION
//   Creates a 3D double sided plane with the given width (X) and height (Y).
//   The plane is created in the XY plane and has no size in the Z direction.
//   Returns an ID you can use to reference this object in other commands.
// INPUTS
//   width -- The width of the plane.
//   height -- The height of the plane.
// SOURCE
uint32_t agk::CreateObjectPlane( float width, float height )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create plane object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateObjectPlane( objID, width, height ); 
	return objID;
}

//****f* 3D/Objects/CreateObjectQuad
// FUNCTION
//   Creates a plane that will fill the entire screen and can be used to render full screen shaders.
// INPUTS
//   objID -- The ID to use for the new object.
// SOURCE
void agk::CreateObjectQuad( uint32_t objID )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create quad object " );
		errStr.AppendUInt( objID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->CreateQuad();
	m_cObject3DList.AddItem( pObject, objID );
}

//****f* 3D/Objects/CreateObjectQuad
// FUNCTION
//   Creates a plane that will fill the entire screen and can be used to render full screen shaders.
//   Returns an ID you can use to reference this object in other commands.
// SOURCE
uint32_t agk::CreateObjectQuad()
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create quad object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateObjectQuad( objID ); 
	return objID;
}

//****f* 3D/Objects/CreateObjectFromHeightMap
// FUNCTION
//   Creates an object from a specified height map, useful for making terrain.
//   The image should be PNG 8-bit greyscale or RGB, if it is RGB then only the red channel is read. 16-bit greyscale 
//   support may be added in future.
//   The object will have a single UV channel with the range 0 to 1 mapped to the entire terrain. If you wish to 
//   modify this then you can use <i>SetObjectUVOffset</i> and <i>SetObjectUVScale</i>, or use a shader that 
//   multiplies the UV coordinates by a specified amount. A shader can also be used to create multiple UV channels
//   from this single channel by applying different scale factors to each.
//   A smoothing value of 1 is recommended to remove stepping artifacts, adjust as necessary.
//   The split value lets you create multiple meshes which can improve performance, as unseen meshes will not be drawn.
//   The split value specifies how many meshes to create along each edge, for example a split value of 5 will create
//   5x5 = 25 meshes in total. 
//   Unlike other objects collision data is not generated by default on this object as it can consume a lot of memory,
//   use <i>SetObjectCollisionMode</i> if you want to turn it on. For terrains greater than 1024x1024 this is not 
//   recommended on mobile devices, and you should use <i>GetObjectHeightMapHeight</i> instead if possible.
//   Turning on physics for this object will use even more memory and is not recommended on terrains greater than
//   1024x1024 on any platform.
// INPUTS
//   objID -- The ID of the object to create
//   szImageFile -- The filename of the image to use as a height map, PNG preferred, also supports JPEG
//   width -- The desired width of the new object in the X direction
//   height -- The desired height of the new object in the Y direction
//   length -- The desired length of the new object in the Z direction
//   smoothing -- The amount of smoothing to apply to the height values, 0=none, 1=one pass, 2=two passes, etc
//   split -- 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen meshes, etc
// SOURCE
uint32_t agk::CreateObjectFromHeightMap( const char* szImageFile, float width, float height, float length, int smoothing, int split )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create quad object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateObjectFromHeightMap( objID, szImageFile, width, height, length, smoothing, split ); 
	return objID;
}

//****f* 3D/Objects/CreateObjectFromHeightMap
// FUNCTION
//   Creates an object from a specified height map, useful for making terrain.
//   The image should be PNG 8-bit greyscale or RGB, if it is RGB then only the red channel is read. 16-bit greyscale 
//   support may be added in future.
//   The object will have a single UV channel with the range 0 to 1 mapped to the entire terrain. If you wish to 
//   modify this then you can use <i>SetObjectUVOffset</i> and <i>SetObjectUVScale</i>, or use a shader that 
//   multiplies the UV coordinates by a specified amount. A shader can also be used to create multiple UV channels
//   from this single channel by applying different scale factors to each.
//   A smoothing value of 1 is recommended to remove stepping artifacts, adjust as necessary.
//   The split value lets you create multiple meshes which can improve performance, as unseen meshes will not be drawn.
//   The split value specifies how many meshes to create along each edge, for example a split value of 5 will create
//   5x5 = 25 meshes in total. 
//   Unlike other objects collision data is not generated by default on this object as it can consume a lot of memory,
//   use <i>SetObjectCollisionMode</i> if you want to turn it on. For terrains greater than 1024x1024 this is not 
//   recommended on mobile devices, and you should use <i>GetObjectHeightMapHeight</i> instead if possible.
//   Turning on physics for this object will use even more memory and is not recommended on terrains greater than
//   1024x1024 on any platform.
// INPUTS
//   objID -- The ID of the object to create
//   szImageFile -- The filename of the image to use as a height map, PNG preferred, also supports JPEG
//   width -- The desired width of the new object in the X direction
//   height -- The desired height of the new object in the Y direction
//   length -- The desired length of the new object in the Z direction
//   smoothing -- The amount of smoothing to apply to the height values, 0=none, 1=one pass, 2=two passes, etc
//   split -- 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen meshes, etc
// SOURCE
void agk::CreateObjectFromHeightMap( uint32_t objID, const char* szImageFile, float width, float height, float length, int smoothing, int split )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create object " );
		errStr.AppendUInt( objID ).Append( " from height map - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->CreateFromHeightMap( szImageFile, width, height, length, smoothing, split );
	m_cObject3DList.AddItem( pObject, objID );
	m_cObjectMgr.AddObject( pObject );
}

//****f* 3D/Objects/CreateObjectFromRawHeightMap
// FUNCTION
//   Creates an object from a specified .raw or .dat height map, useful for making terrain.
//   The file should be in raw 16-bit data. If you use extension ".dat" in <b>szFilename</b> it will expect that this is a
//   GameGuru 32-bit raw height map and convert that to 16-bit. If the file is not a GameGuru height map then you must 
//   change the extension to ".raw".
//   If you convert a GameGuru height map (.dat) file, <b>rawWidth</b> and <b>rawHeight</b> should always be set to 1024.
//   The object will have a single UV channel with the range 0 to 1 mapped to the entire terrain. If you wish to 
//   modify this then you can use <i>SetObjectUVOffset</i> and <i>SetObjectUVScale</i>, or use a shader that 
//   multiplies the UV coordinates by a specified amount. A shader can also be used to create multiple UV channels
//   from this single channel by applying different scale factors to each.
//   Normally when using 16-bit data you don't need to set a smoothing value, but if its not already been smoothed adjust as necessary.
//   The split value lets you create multiple meshes which can improve performance, as unseen meshes will not be drawn.
//   The split value specifies how many meshes to create along each edge, for example a split value of 5 will create
//   5x5 = 25 meshes in total. 
//   Unlike other objects collision data is not generated by default on this object as it can consume a lot of memory,
//   use <i>SetObjectCollisionMode</i> if you want to turn it on. For terrains greater than 1024x1024 this is not 
//   recommended on mobile devices, and you should use <i>GetObjectHeightMapHeight</i> instead if possible.
//   Turning on physics for this object will use even more memory and is not recommended on terrains greater than
//   1024x1024 on any platform.
// INPUTS
//   szFilename -- The filename of the height map, must end in .raw or .dat
//   width -- The desired width of the new object in the X direction
//   height -- The desired height of the new object in the Y direction
//   length -- The desired length of the new object in the Z direction
//   smoothing -- The amount of smoothing to apply to the height values, 0=none, 1=one pass, 2=two passes, etc
//   split -- 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen meshes, etc
//   rawWidth -- The width of the height map data
//   rawHeight -- The height of the height map data
// SOURCE
uint32_t agk::CreateObjectFromRawHeightMap( const char* szFilename, float width, float height, float length, int smoothing, int split, int rawWidth, int rawHeight)
//****
{
	//PE:
	uint32_t objID = m_cObject3DList.GetFreeID();
	if (objID == 0)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr("Failed to create object - No free IDs found");
		Error(errStr);
#endif
		return 0;
	}
	
	uString m_szImageFile, ext;
	m_szImageFile.SetStr(szFilename);
	int pos = m_szImageFile.RevFind('.');
	if (pos >= 0) {
		m_szImageFile.SubString(ext, pos + 1);
	}
	ext.Lower();

	if (!(ext.CompareTo("raw") == 0 || ext.CompareTo("dat") == 0) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr("Failed to CreateObjectFromRawHeightMap - raw heightmaps files must be called .raw or .dat");
		Error(errStr);
#endif
		return 0;
	}

	CreateObjectFromRawHeightMap(objID, szFilename, width, height, length, smoothing, split, rawWidth, rawHeight);
	return objID;
}


//****f* 3D/Objects/CreateObjectFromRawHeightMap
// FUNCTION
//   Creates an object from a specified .raw or .dat height map, useful for making terrain.
//   The file should be in raw 16-bit data. If you use extension ".dat" in <b>szFilename</b> it will expect that this is a
//   GameGuru 32-bit raw height map and convert that to 16-bit. If the file is not a GameGuru height map then you must 
//   change the extension to ".raw".
//   If you convert a GameGuru height map (.dat) file, <b>rawWidth</b> and <b>rawHeight</b> should always be set to 1024.
//   The object will have a single UV channel with the range 0 to 1 mapped to the entire terrain. If you wish to 
//   modify this then you can use <i>SetObjectUVOffset</i> and <i>SetObjectUVScale</i>, or use a shader that 
//   multiplies the UV coordinates by a specified amount. A shader can also be used to create multiple UV channels
//   from this single channel by applying different scale factors to each.
//   Normally when using 16-bit data you don't need to set a smoothing value, but if its not already been smoothed adjust as necessary.
//   The split value lets you create multiple meshes which can improve performance, as unseen meshes will not be drawn.
//   The split value specifies how many meshes to create along each edge, for example a split value of 5 will create
//   5x5 = 25 meshes in total. 
//   Unlike other objects collision data is not generated by default on this object as it can consume a lot of memory,
//   use <i>SetObjectCollisionMode</i> if you want to turn it on. For terrains greater than 1024x1024 this is not 
//   recommended on mobile devices, and you should use <i>GetObjectHeightMapHeight</i> instead if possible.
//   Turning on physics for this object will use even more memory and is not recommended on terrains greater than
//   1024x1024 on any platform.
// INPUTS
//   objID -- The ID of the object to create
//   szFilename -- The filename of the height map, must end in .raw or .dat
//   width -- The desired width of the new object in the X direction
//   height -- The desired height of the new object in the Y direction
//   length -- The desired length of the new object in the Z direction
//   smoothing -- The amount of smoothing to apply to the height values, 0=none, 1=one pass, 2=two passes, etc
//   split -- 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen meshes, etc
//   rawWidth -- The width of the height map data
//   rawHeight -- The height of the height map data
// SOURCE
void agk::CreateObjectFromRawHeightMap( uint32_t objID, const char* szFilename, float width, float height, float length, int smoothing, int split, int rawWidth, int rawHeight )
//****
{
	//PE:
	if (objID == 0)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr("", 100);
		errStr.Format("Failed to create object %d, ID must be greater than 0", objID);
		Error(errStr);
#endif
		return;
	}

	uString m_szImageFile, ext;
	m_szImageFile.SetStr(szFilename);
	int pos = m_szImageFile.RevFind('.');
	if (pos >= 0) {
		m_szImageFile.SubString(ext, pos + 1);
	}
	ext.Lower();

	if (!(ext.CompareTo("raw") == 0 || ext.CompareTo("dat") == 0))
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr("Failed to CreateObjectFromRawHeightMap - raw heightmaps files must be called .raw or .dat");
		Error(errStr);
#endif
		return;
	}

	if (m_cObject3DList.GetItem(objID))
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr("Failed to create object ");
		errStr.AppendUInt(objID).Append(" from height map - ID already exists");
		Error(errStr);
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->CreateFromRawHeightMap(szFilename, width, height, length, smoothing, split, rawWidth, rawHeight);
	m_cObject3DList.AddItem(pObject, objID);
	m_cObjectMgr.AddObject(pObject);
}

//****f* 3D/Objects/CreateObjectFromObjectMesh
// FUNCTION
//   Creates an object by copying a single mesh from another object. An object can contain many
//   meshes, and using <i>CloneObject</i> would copy them all. Use this command if you only want
//   to copy a single mesh.
//   Mesh indices are in the range 1 to <i>GetObjectNumMeshes</i> inclusive.
// INPUTS
//   fromObjID -- The ID of the object that contains the mesh to copy
//   meshIndex -- The index of the mesh to copy
// SOURCE
uint32_t agk::CreateObjectFromObjectMesh( uint32_t fromObjID, uint32_t meshIndex )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create object from mesh - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CreateObjectFromObjectMesh( objID, fromObjID, meshIndex ); 
	return objID;
}




//****f* 3D/Objects/CreateObjectFromObjectMesh
// FUNCTION
//   Creates an object by copying a single mesh from another object. An object can contain many
//   meshes, and using <i>CloneObject</i> would copy them all. Use this command if you only want
//   to copy a single mesh.
//   Mesh indices are in the range 1 to <i>GetObjectNumMeshes</i> inclusive.
// INPUTS
//   objID -- The ID of the new object
//   fromObjID -- The ID of the object that contains the mesh to copy
//   meshIndex -- The index of the mesh to copy
// SOURCE
void agk::CreateObjectFromObjectMesh( uint32_t objID, uint32_t fromObjID, uint32_t meshIndex )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create object " );
		errStr.AppendUInt( objID ).Append( " from mesh - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pFromObject = m_cObject3DList.GetItem( fromObjID );
	if ( !pFromObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create object from mesh object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pFromObject->GetNumMeshes() )
	{
		uString errStr( "Failed to create object from mesh " );
		errStr.AppendUInt( objID ).Append( " - mesh index is out of range" );
		Error( errStr );
		return;
	}

	cObject3D *pObject = new cObject3D();

	cMesh *pMesh = pFromObject->GetMesh( meshIndex-1 );
	cMesh *pNewMesh = new cMesh( pObject, pMesh, 0 );
	
	pObject->m_iID = objID;
	pObject->CreateFromMeshes( 1, &pNewMesh );
	m_cObjectMgr.AddObject( pObject );
	m_cObject3DList.AddItem( pObject, objID );
}

//****f* 3D/Objects/LoadObject
// FUNCTION
//   Loads an object from a file, currently supported formats are .X .fbx .dae 
//   .3ds .obj .b3d .3d .lwo .obj and .ago. 
//   This command will not load any animation or bone data and will consolidate
//   the vertices into a single object with as few meshes as possible. To load 
//   animation and bone data use <i>LoadObjectWithChildren</i> instead.
//   Returns an ID you can use to reference this object in other commands.
// INPUTS
//   szFilename -- The name of the object file to load.
// SOURCE
uint32_t agk::LoadObject( const char* szFilename )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	LoadObject( objID, szFilename, 0 );
	return objID;
}

//****f* 3D/Objects/LoadObject
// FUNCTION
//   Loads an object from a file, currently supported formats are .X .fbx .dae 
//   .3ds .obj .b3d .3d .lwo .obj and .ago. 
//   This command includes the optional height parameter that will scale the 
//   object's vertices to the given height, the X and Z directions will be matched
//   to this height so the object is still in proportion.
//   This command will not load any animation or bone data and will consolidate
//   the vertices into a single object with as few meshes as possible. To load 
//   animation and bone data use <i>LoadObjectWithChildren</i> instead.
//   Returns an ID you can use to reference this object in other commands.
// INPUTS
//   szFilename -- The name of the object file to load.
//   height -- Scale the loaded object to this height.
// SOURCE
uint32_t agk::LoadObject( const char* szFilename, float height )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	LoadObject( objID, szFilename, height );
	return objID;
}

//****f* 3D/Objects/LoadObject
// FUNCTION
//   Loads an object from a file, currently supported formats are .X .3ds .md3 
//   .smd .md5 .lwo. .ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj and .ago.
//   This command will not load any animation or bone data and will consolidate
//   the vertices into a single object with as few meshes as possible. To load 
//   animation and bone data use <i>LoadObjectWithChildren</i> instead.
// INPUTS
//   objID -- The ID to use for the new object.
//   szFilename -- The name of the object file to load.
// SOURCE
void agk::LoadObject( uint32_t objID, const char* szFilename )
//****
{
	LoadObject( objID, szFilename, 0 );
}

//****f* 3D/Objects/LoadObject
// FUNCTION
//   Loads an object from a file, currently supported formats are .X .3ds .md3 
//   .smd .md5 .lwo. .ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj and .ago.
//   This command includes the optional height parameter that will scale the 
//   object's vertices to the given height, the X and Z directions will be matched
//   to this height so the object is still in proportion.
//   This command will not load any animation or bone data and will consolidate
//   the vertices into a single object with as few meshes as possible. To load 
//   animation and bone data use <i>LoadObjectWithChildren</i> instead.
// INPUTS
//   objID -- The ID to use for the new object.
//   szFilename -- The name of the object file to load.
//   height -- Scale the loaded object to this height.
// SOURCE
void agk::LoadObject( uint32_t objID, const char* szFilename, float height )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load object " );
		errStr.AppendUInt( objID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	pObject->LoadObject( szFilename, 0, height );
	m_cObjectMgr.AddObject( pObject );
	m_cObject3DList.AddItem( pObject, objID );
}

// WithChildren = animated objects

//****f* 3D/Objects/LoadObjectWithChildren
// FUNCTION
//   Loads an object from a file, currently supported formats are .X .FBX .dae (collada) .3ds .md3 
//   .smd .md5 .lwo .ac .b3d .dae .3d .lws .ms3d .blend .obj and .ago. If the model file contains 
//   a bone hierarchy or animation data then this will also be loaded and associated with the object. 
//   Note that objects with more than 50 bones may fail to render on some old devices. AGK has a 
//   limit of 200 bones.
//   If the model file contains a scene graph containing multiple objects then these will also be 
//   loaded and stored in separate objects which can be discovered with <i>GetObjectNumChildren</i>. 
//   If you just want to load a single object without any bones, animation, or children then use 
//   <i>LoadObject</i> instead.
//   Returns an ID you can use to reference this object in other commands.
// INPUTS
//   szFilename -- The name of the object file to load.
// SOURCE
uint32_t agk::LoadObjectWithChildren( const char* szFilename )
//****
{
	uint32_t objID = m_cObject3DList.GetFreeID();
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	LoadObjectWithChildren( objID, szFilename );
	return objID;
}

//****f* 3D/Objects/LoadObjectWithChildren
// FUNCTION
//   Loads an object from a file, currently supported formats are .X .3ds .md3 
//   .smd .md5 .lwo. .ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj and .ago.
//   If the model file contains a bone hierarchy or animation data then this
//   will also be loaded and associated with the object. If the model file
//   contains a scene graph containing multiple objects then these will also
//   be loaded and stored in separate objects which can be discovered with
//   <i>GetObjectNumChildren</i>. If you just want to load a single object
//   without any bones, animation, or children then use <i>LoadObject</i> 
//   instead.
// INPUTS
//   objID -- The ID to use for the new object.
//   szFilename -- The name of the object file to load.
// SOURCE
void agk::LoadObjectWithChildren( uint32_t objID, const char* szFilename )
//****
{
	if ( objID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load object %d, ID must be greater than 0", objID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( objID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load object " );
		errStr.AppendUInt( objID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = new cObject3D();
	pObject->m_iID = objID;
	m_cObject3DList.AddItem( pObject, objID );
	pObject->LoadObject( szFilename, 1, 0 );
	m_cObjectMgr.AddObject( pObject );
}

//****f* 3D/Objects/SaveObject
// FUNCTION
//   Not yet functional.
// INPUTS
//   objID -- The ID of the object to save.
//   szFilename -- The file name to use for the new file.
// SOURCE
void agk::SaveObject( uint32_t objID, const char *szFilename )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to save object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( !szFilename ) return;

	pObject->SaveObject( szFilename );
}

//****f* 3D/Objects/CloneObject
// FUNCTION
//   Copies an object into a new ID, the new object is completely separate from the original object.
//   Cloning an instanced object will produce another instance that shares vertex data with
//   the original object.
//   Returns the ID of the new object.
// INPUTS
//   objID -- The ID of the object to copy.
// SOURCE
uint32_t agk::CloneObject( uint32_t objID )
//****
{
	uint32_t newobjID = m_cObject3DList.GetFreeID();
	if ( newobjID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to clone object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	CloneObject( newobjID, objID );
	return newobjID;
}

//****f* 3D/Objects/CloneObject
// FUNCTION
//   Copies an object into a new ID, the new object is completely separate from the original object.
//   Cloning an instanced object will produce another instance that shares vertex data with
//   the original object.
// INPUTS
//   newobjID -- The ID of the new object.
//   objID -- The ID of the object to copy.
// SOURCE
void agk::CloneObject( uint32_t newobjID, uint32_t objID )
//****
{
	if ( newobjID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load object %d, ID must be greater than 0", newobjID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( newobjID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load object " );
		errStr.AppendUInt( newobjID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to clone object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pNewObject = new cObject3D( pObject, 0 );
	pNewObject->m_iID = newobjID;
	m_cObjectMgr.AddObject( pNewObject );
	m_cObject3DList.AddItem( pNewObject, newobjID );
}

//****f* 3D/Objects/InstanceObject
// FUNCTION
//   Copies an object into a new ID, the new object shares vertex data with the original object.
//   The original object must exist for the instanced object to draw properly.
//   Instancing an object that is already an instance will do nothing.
//   Instancing an object and then deleting the original will probably crash.
//   Setting a shader on an instance object is allowed as long as the vertex attributes used by the
//   shader match exactly in name and order as those used on the shader of the original object.
//   Setting different images on the instance and original object is supported.
// INPUTS
//   objID -- The ID of the object to copy.
// SOURCE
uint32_t agk::InstanceObject( uint32_t objID )
//****
{
	uint32_t newobjID = m_cObject3DList.GetFreeID();
	if ( newobjID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to instance object - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	InstanceObject( newobjID, objID );
	return newobjID;
}

//****f* 3D/Objects/InstanceObject
// FUNCTION
//   Copies an object into a new ID, the new object shares vertex data with the original object.
//   The original object must exist for the instanced object to draw properly.
//   Instancing an object that is already an instance will do nothing.
//   Instancing an object and then deleting the original will probably crash.
//   Setting a shader on an instance object is allowed as long as the vertex attributes used by the
//   shader match exactly in name and order as those used on the shader of the original object.
//   Setting different images on the instance and original object is supported.
// INPUTS
//   newobjID -- The ID of the new object.
//   objID -- The ID of the object to copy.
// SOURCE
void agk::InstanceObject( uint32_t newobjID, uint32_t objID )
//****
{
	if ( newobjID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load object %d, ID must be greater than 0", newobjID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cObject3DList.GetItem( newobjID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load object " );
		errStr.AppendUInt( newobjID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to instance object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	/*
	if ( pObject->m_pSharedVerticesObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create an instance of object " );
		errStr.AppendUInt( objID ).Append( " - object is already an instance" );
		Error( errStr );
#endif
		return;
	}
	*/

	cObject3D *pNewObject = new cObject3D( pObject, 1 );
	pNewObject->m_iID = newobjID;
	m_cObjectMgr.AddObject( pNewObject );
	m_cObject3DList.AddItem( pNewObject, newobjID );
}

//****f* 3D/Objects/GetObjectExists
// FUNCTION
//   Returns 1 if an object exists at the given ID, 0 otherwise.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectExists( uint32_t objID )
//****
{
	if ( m_cObject3DList.GetItem( objID ) ) return 1;
	else return 0;
}

//****f* 3D/Objects/DeleteObject
// FUNCTION
//   Deletes the object at the given ID, if the object doesn't exist then this command does nothing.
//   Note that if the object was loaded with <i>LoadObjectWithChildren</i> then any child objects 
//   that were created during that loading process will not be deleted by this command. 
//   You can use <i>GetObjectChildID</i> to get and delete those objects manually, or use 
//   <i>DeleteObjectWithChildren</i> to delete everything that was created when this object was loaded.
// INPUTS
//   objID -- The ID of the object to delete.
// SOURCE
void agk::DeleteObject( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.RemoveItem( objID );
	if ( pObject )
	{
		m_cObjectMgr.RemoveObject( pObject );		
		delete pObject;
	}
}

//****f* 3D/Objects/DeleteObjectWithChildren
// FUNCTION
//   Deletes the object at the given ID, if the object doesn't exist then this command does nothing.
//   This command also deletes any child objects that were created when this object was loaded, if 
//   you do not want to delete those then use <i>DeleteObject</i> instead. If you use
//   this command on an object that was loaded with <i>LoadObject</i> then it deletes it as normal.
// INPUTS
//   objID -- The ID of the object to delete.
// SOURCE
void agk::DeleteObjectWithChildren( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.RemoveItem( objID );
	if ( pObject )
	{
		pObject->DeleteChildren();
		m_cObjectMgr.RemoveObject( pObject );
		delete pObject;
	}
}

//****f* 3D/Objects/DeleteObjectTree
// FUNCTION
//   Deletes the object at the given ID, if the object doesn't exist then this command does nothing.
//   This command also deletes any child objects that were created when this object was loaded, and 
//   any objects that are currently attached to this object from using <i>FixObjectToObject</i> or 
//   <i>FixObjectToBone</i>.
// INPUTS
//   objID -- The ID of the object to delete.
// SOURCE
void agk::DeleteObjectTree( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.RemoveItem( objID );
	if ( pObject )
	{
		pObject->DeleteTree();
		
		m_cObjectMgr.RemoveObject( pObject );
		delete pObject;
	}
}

//****f* 3D/Objects/DeleteAllObjects
// FUNCTION
//   Deletes all objects created with an ID. This also resets the 
//   auto object ID to 10000.
// SOURCE
void agk::DeleteAllObjects()
//****
{
	m_cObjectMgr.ClearAll();

	cObject3D *pObject = m_cObject3DList.GetFirst();
	while ( pObject )
	{
		delete pObject;		
		pObject = m_cObject3DList.GetNext();
	}
	m_cObject3DList.ClearAll();
}

cObject3D* agk::GetObjectPtr( uint32_t objID )
{
	return m_cObject3DList.GetItem( objID );
}

//****f* 3D/Objects/GetObjectNumChildren
// FUNCTION
//   Gets the number of child objects that were loaded as a result of loading this object. For example
//   a bone animated character object may have a gun model attached to the bone representing its hand,
//   this gun model would be loaded as a separate object and given its own ID, which you can manipulate
//   separately from the main object. You can even detach the gun from the hand with 
//   <i>FixObjectToBone(ID,0)</i> to make it a normal object that will not move when the character moves.
//   It will however always remain in this list of children, for reference, and will get deleted if 
//   <i>DeleteObjectWithChildren</i> is called on the character object.
//   For those of you that are familiar with DarkBasic, objects that contained limbs in DarkBasic would
//   be loaded as child objects in AGK. However there is no hierarchy in the child objects, they would
//   not have children of their own. Instead a bone structure is created in the root object that 
//   represents the limb hierarchy, and the child objects are attached to the appropriate bones.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
uint32_t agk::GetObjectNumChildren( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get num children for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_iNumChildren;
}

//****f* 3D/Objects/GetObjectChildID
// FUNCTION
//   Returns the object ID for a specified child object that was loaded as a result of this object. 
//   To find the number of child objects use <i>GetObjectNumChildren</i>. childIndex is in the range 
//   1 to the number of children inclusive.
//   For those of you that are familiar with DarkBasic, objects that contained limbs in DarkBasic would
//   be loaded as child objects in AGK. However there is no hierarchy in the child objects, they would
//   not have children of their own. Instead a bone structure is created in the root object that 
//   represents the limb hierarchy, and the child objects are attached to the appropriate bones.
// INPUTS
//   objID -- The ID of the object to check.
//   childIndex -- The index of the child to get.
// SOURCE
uint32_t agk::GetObjectChildID( uint32_t objID, int childIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get child for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( childIndex < 1 || childIndex > (int)pObject->m_iNumChildren )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get child for object %d - child index %d is out of range", objID, childIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_iLoadedChildren[ childIndex-1 ];
}

//****f* 3D/Bones/GetObjectNumBones
// FUNCTION
//   Gets the number of bones that were loaded as a result of loading this object. This only happens
//   if the object was loaded with <i>LoadObjectWithChildren</i>. If the object has limb animation
//   like in DarkBasic Classic, then the bones represent the limb hierarchy and each limb is loaded
//   as a child object attached to a bone. If the object has weighted vertex animation then the bones
//   represent the skeleton and the skin is loaded as a single mesh stored in the root object.
//   The two forms of animation can be combined, so a weighted vertex bone structure can have objects
//   attached to its bones at the same time as deforming the skin mesh.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
uint32_t agk::GetObjectNumBones( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get num bones for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton ) return 0;
	else return pObject->m_pSkeleton->m_iNumBones;
}

//****f* 3D/Bones/GetObjectBoneByName
// FUNCTION
//   Gets the index of a bone by its name. Names are loaded from the model file when 
//   <i>LoadObjectWithChildren</i> is used, otherwise no bones are loaded.
//   Indexes will be in the range 1 to num bones, or 0 if not found.
// INPUTS
//   objID -- The ID of the object to check.
//   name -- The name of the bone to find.
// SOURCE
uint32_t agk::GetObjectBoneByName( uint32_t objID, const char *name )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get num bones for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton ) return 0;
	else 
	{
		return pObject->m_pSkeleton->GetBoneIndex( name ) + 1;
	}
}



//****f* 3D/Meshes/SetObjectMeshCollisionMode
// FUNCTION
//   Sets collision detection on or off for a single mesh in a object.
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to change collison mode, first mesh is at index 1.
//   mode -- 0 to turn collision off, 1 to turn it on.
// SOURCE
void agk::SetObjectMeshCollisionMode(uint32_t objID,int meshIndex, int mode)
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem(objID);
	if (!pObject)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr("Failed to set collision mode for object ");
		errStr.AppendUInt(objID).Append(" - object does not exist");
		Error(errStr);
#endif
		return;
	}
	if (meshIndex == 0 || meshIndex > (int)pObject->GetNumMeshes())
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to set mesh collision for object %d mesh %d - mesh index is out of range", objID, meshIndex);
		Error(errStr);
#endif
		return;
	}

	cMesh *pMesh = pObject->GetMesh(meshIndex - 1);
	pMesh->SetCollision(mode);
	pObject->UpdateCollisionData();
}


//****f* 3D/Meshes/SetObjectMeshVisible
// FUNCTION
//   Sets whether this object's mesh is visible or not. This only has an effect if the object is set as visible,
//   if the object is not visible then none of its meshes will be drawn.
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to change, first mesh is at index 1.
//   mode -- 1 to set this object's mesh as visible, 0 to hide it.
// SOURCE
void agk::SetObjectMeshVisible(uint32_t objID, uint32_t meshIndex,int mode)
//****
{
	//PE:
	cObject3D *pObject = m_cObject3DList.GetItem(objID);
	if (!pObject)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to set mesh visibility for object %d - object does not exist", objID);
		Error(errStr);
#endif
		return;
	}

	if (meshIndex == 0 || meshIndex > pObject->GetNumMeshes())
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to set mesh visibility for object %d mesh %d - mesh index is out of range", objID, meshIndex);
		Error(errStr);
#endif
		return;
	}

	cMesh *pMesh = pObject->GetMesh(meshIndex - 1);

	pMesh->SetVisible(mode);
}

//****f* 3D/Meshes/SetObjectMeshCastShadow
// FUNCTION
//   Sets whether this object's mesh casts a shadow or not. This only has an effect if the object is set as casting a shadow,
//   if the object is set to not cast a shadow then none of its meshes will cast shadows.
//   By default all meshes are set as casting a shadow but all objects are set as not casting a shadow. Therefore you can enable
//   and disable shadow casting for an object by toggling the object cast mode. This mesh casting command can be used to exclude 
//   particular meshes from the shadow cast routine if desired.
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to change, first mesh is at index 1.
//   mode -- 1 to set this object's mesh as casting a shadow, 0 to never cast a shadow.
// SOURCE
void agk::SetObjectMeshCastShadow(uint32_t objID, uint32_t meshIndex,int mode)
//****
{
	//PE:
	cObject3D *pObject = m_cObject3DList.GetItem(objID);
	if (!pObject)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to set mesh shadow casting for object %d - object does not exist", objID);
		Error(errStr);
#endif
		return;
	}

	if (meshIndex == 0 || meshIndex > pObject->GetNumMeshes())
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to set mesh shadow casting for object %d mesh %d - mesh index is out of range", objID, meshIndex);
		Error(errStr);
#endif
		return;
	}

	cMesh *pMesh = pObject->GetMesh(meshIndex - 1);

	pMesh->SetShadowCastMode( mode );
}

//****f* 3D/Meshes/GetObjectTextureName
// FUNCTION
//   Gets the name of a texture as defined in the model file that it was loaded from, but textures are not 
//   guaranteed to have names.
//   Texture names are in the range 1 to <i>GetObjectNumTextures</i> inclusive.
//   If you are calling this command from tier 2 you must delete the returned string with <i>agk::DeleteString</i> when you are done 
//   with it.
// INPUTS
//   objID -- The ID of the object to check.
//   textureIndex -- The index of the texture to check, first texture is at index 1.
// SOURCE
char* agk::GetObjectTextureName(uint32_t objID, uint32_t textureIndex)
//****
{
	//PE:
	cObject3D *pObject = m_cObject3DList.GetItem(objID);
	if (!pObject)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to get texture name for object %d - object does not exist", objID);
		Error(errStr);
#endif
		char *str = new char[1]; *str = 0;
		return str;
	}

	if (textureIndex == 0 || textureIndex > pObject->GetNumTextures())
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to get mesh texture for object %d texture %d - texture index is out of range", objID, textureIndex);
		Error(errStr);
#endif
		char *str = new char[1]; *str = 0;
		return str;
	}

	char *str = new char[ strlen(pObject->GetTexture(textureIndex - 1)) + 1];
	strcpy(str, pObject->GetTexture(textureIndex - 1) );
	return str;
}

//****f* 3D/Meshes/GetObjectNumTextures
// FUNCTION
//   Gets the number of texture references that was found when loading the object. An object can have multiple texture references.
//   This information will only be available if the model file have a material setup with a diffuse texture reference.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
uint32_t agk::GetObjectNumTextures(uint32_t objID)
//****
{
	//PE:
	cObject3D *pObject = m_cObject3DList.GetItem(objID);
	if (!pObject)
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format("Failed to get num textures for object %d - object does not exist", objID);
		Error(errStr);
#endif
		return 0;
	}

	return pObject->GetNumTextures();
}


//****f* 3D/Meshes/GetObjectNumMeshes
// FUNCTION
//   Gets the number of meshes that belong to this object. An object can have multiple meshes, usually
//   this happens in the case of multi-material objects where the object is split into multiple meshes,
//   each using a different texture.
//   Note that instanced objects may not have any meshes.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
uint32_t agk::GetObjectNumMeshes( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get num meshes for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetNumMeshes();
}

//****f* 3D/Meshes/GetObjectMeshName
// FUNCTION
//   Gets the name of a mesh as defined in the model file that it was loaded from, but meshes are not 
//   guaranteed to have names.
//   Mesh indices are in the range 1 to <i>GetObjectNumMeshes</i> inclusive.
//   If you are calling this command from tier 2 you must delete the returned string with agk::DeleteString when you are done 
//   with it.
// INPUTS
//   objID -- The ID of the object to check.
//   meshIndex -- The index of the mesh to check, first mesh is at index 1.
// SOURCE
char* agk::GetObjectMeshName( uint32_t objID, uint32_t meshIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh name for object %d - object does not exist", objID );
		Error( errStr );
#endif
		char *str = new char[1]; *str = 0;
		return str;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh name for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		char *str = new char[1]; *str = 0;
		return str;	
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	char *str = new char[ pMesh->GetName()->GetLength() + 1 ]; 
	strcpy( str, pMesh->GetName()->GetStr() );
	return str;
}

//****f* 3D/Meshes/SetObjectMeshImage
// FUNCTION
//   Sets an object mesh to use this image when rendering. A mesh can have up to 8 images assigned
//   to it in the texture stages 0 to 7. If you are unsure of which texture stage to use, place the 
//   image in stage 0. Texture stages can be used to assign multiple images to a mesh, for example 
//   you might put the base (diffuse) texture in stage 0, a normal map in stage 1, and a light map in 
//   stage 2. The shader used to draw this object can then combine the various textures into a pixel
//   value to show on the screen.
//   Using an image value of 0 for a particular texture stage removes any assigned image from that stage.
//   Mesh indices are in the range 1 to <i>GetObjectNumMeshes</i>
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to modify, first mesh is at index 1.
//   imageID -- The ID of the image to assign to this object.
//   textureStage -- The texture stage to use for this image.
// SOURCE
void agk::SetObjectMeshImage( uint32_t objID, uint32_t meshIndex, uint32_t imageID, uint32_t textureStage )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh image for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh image for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return;	
	}
	
	cImage *pImage = 0;
	if ( imageID > 0 )
	{
		pImage = m_cImageList.GetItem( imageID );
		if ( !pObject )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr;
			errStr.Format( "Failed to set mesh image for object %d - image %d does not exist", objID, imageID );
			Error( errStr );
#endif
			return;
		}
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	pMesh->SetImage( pImage, textureStage );
	return;
}

//****f* 3D/Meshes/SetObjectMeshLightMap
// FUNCTION
//   Sets an object mesh to use the specified image as a lightmap.
//   The lightmap will be placed in texture stage 1, overwriting anything that is already there and
//   will have a shader generated that combines it with texture stage 0, and any dynamic lighting, to 
//   correctly light the object. If you are setting your own shader with <i>SetObjectShader</i> then 
//   your shader will have to make use of the lightmap itself as AGK will not modify your shader in 
//   this way.
//   Mesh indices are in the range 1 to <i>GetObjectNumMeshes</i>
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to modify, first mesh is at index 1.
//   imageID -- The ID of the image to use as a light map.
// SOURCE
void agk::SetObjectMeshLightMap( uint32_t objID, uint32_t meshIndex, uint32_t imageID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh lightmap for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh lightmap for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return;	
	}

	cImage *pImage = m_cImageList.GetItem( imageID );
	if ( !pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh lightmap for object %d - image %d does not exist", objID, imageID );
		Error( errStr );
#endif
		return;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	pMesh->SetLightMap( pImage );
	return;
}

//****f* 3D/Meshes/SetObjectMeshNormalMap
// FUNCTION
//   Sets an object mesh to use the specified image as a normal map.
//   The normal map will be placed in texture stage 2, overwriting anything that is already there and
//   will have a shader generated that combines it with any dynamic lighting, to correctly light the 
//   object. If you are setting your own shader with <i>SetObjectShader</i> then 
//   your shader will have to make use of the normal map itself as AGK will not modify your shader in 
//   this way.
//   Mesh indices are in the range 1 to <i>GetObjectNumMeshes</i>
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to modify, first mesh is at index 1.
//   imageID -- The ID of the image to use as a normal map.
// SOURCE
void agk::SetObjectMeshNormalMap( uint32_t objID, uint32_t meshIndex, uint32_t imageID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh normal map for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh normal map for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return;	
	}

	cImage *pImage = m_cImageList.GetItem( imageID );
	if ( !pImage )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh normal map for object %d - image %d does not exist", objID, imageID );
		Error( errStr );
#endif
		return;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	pMesh->SetNormalMap( pImage );
}

//****f* 3D/Objects/SetObjectMeshNormalMapScale
// FUNCTION
//   Scales the normal map UV coordinates by the specified amount. This does not affect any other
//   texture, but does stack on top of the object's UV offset and scale. A scale value of 1.0 would
//   use unmodified UVs, a scale value of 2.0 would double the UV value, and so on.
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to modify, first mesh is at index 1.
//   scaleU -- The amount to scale the normal map in the U direction
//   scaleV -- The amount to scale the normal map in the V direction
// SOURCE
void agk::SetObjectMeshNormalMapScale( uint32_t objID, uint32_t meshIndex, float scaleU, float scaleV )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set normal map scale for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh normal map scale for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return;	
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	pMesh->SetNormalMapScale( scaleU, scaleV );
}

//****f* 3D/Meshes/SetObjectMeshShader
// FUNCTION
//   Sets the shader used to draw this mesh, the shader must have been loaded with <i>LoadShader</i>.
//   A shader is like a script sent to the GPU to tell it how to combine the polygon and texture data 
//   to display it on screen. By default meshes are assigned an internal shader that will handle 
//   lighting and texturing. If you use a shader ID of 0 the mesh is assigned the internal shader.
//   Mesh indices are in the range 1 to <i>GetObjectNumMeshes</i>
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to modify, first mesh is at index 1.
//   shaderID -- The ID of the shader to use.
// SOURCE
void agk::SetObjectMeshShader( uint32_t objID, uint32_t meshIndex, uint32_t shaderID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh shader for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh shader for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return;	
	}

	AGKShader *pShader = 0;
	if ( shaderID > 0 )
	{
		pShader = m_cShaderList.GetItem( shaderID );
		if ( !pShader )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set mesh shader for object " );
			errStr.AppendUInt( objID ).Append( " - shader ");
			errStr.AppendUInt( shaderID ).Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	pMesh->SetShader( pShader );
}

//****f* 3D/Meshes/GetObjectMeshVSSource
// FUNCTION
//   Returns the source code to the vertex shader currently being used on this object. If you haven't assigned
//   a shader to this mesh then one is generated automatically, and you can use this command to get its
//   source code if you want to make adjustments to it. You can then load this modified shader source
//   with <i>LoadShader</i> and assign it with <i>SetObjectMeshShader</i>.
//   Note that modifying the number of textures, or using <i>SetObjectLightMode</i> will normally generate
//   a new shader to handle the changes, however if you have used <i>SetObjectMeshShader</i> then AGK will
//   no longer modify your shader, assuming you have accounted for these changes yourself.
//   Note that shaders which use lighting will have the functions GetVSLighting() and GetPSLighting()
//   that will be filled out by AGK at runtime based on how many lights are near the mesh. Removing these
//   functions from the shader source will remove all lighting from the mesh.
//   If you call this command from tier 2 you must delete the string when you are done with it.
// INPUTS
//   objID -- The ID of the object to check.
//   meshIndex -- The index of the mesh to check, first mesh is at index 1.
// SOURCE
char* agk::GetObjectMeshVSSource( uint32_t objID, uint32_t meshIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get mesh shader source for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		char *str = new char[1];
		*str = 0;
		return str;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh shader source for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		char *str = new char[1];
		*str = 0;
		return str;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	if ( !pMesh->GetShader() ) pMesh->CheckShader();
	if ( !pMesh->GetShader() ) 
	{
		char *str = new char[1];
		*str = 0;
		return str;
	}

	char *str = new char[ strlen(pMesh->GetShader()->GetVSSource())+1 ];
	strcpy( str, pMesh->GetShader()->GetVSSource() );
	return str;
}

//****f* 3D/Meshes/GetObjectMeshPSSource
// FUNCTION
//   Returns the source code to the pixel shader currently being used on this object. If you haven't assigned
//   a shader to this mesh then one is generated automatically, and you can use this command to get its
//   source code if you want to make adjustments to it. You can then load this modified shader source
//   with <i>LoadShader</i> and assign it with <i>SetObjectMeshShader</i>.
//   Note that modifying the number of textures, or using <i>SetObjectLightMode</i> will normally generate
//   a new shader to handle the changes, however if you have used <i>SetObjectMeshShader</i> then AGK will
//   no longer modify your shader, assuming you have accounted for these changes yourself.
//   Note that shaders which use lighting will have the functions GetVSLighting() and GetPSLighting()
//   that will be filled out by AGK at runtime based on how many lights are near the mesh. Removing these
//   functions from the shader source will remove all lighting from the mesh.
//   If you call this command from tier 2 you must delete the string when you are done with it.
// INPUTS
//   objID -- The ID of the object to check.
//   meshIndex -- The index of the mesh to check, first mesh is at index 1.
// SOURCE
char* agk::GetObjectMeshPSSource( uint32_t objID, uint32_t meshIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get mesh shader source for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		char *str = new char[1];
		*str = 0;
		return str;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh shader source for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		char *str = new char[1];
		*str = 0;
		return str;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	if ( !pMesh->GetShader() ) pMesh->CheckShader();
	if ( !pMesh->GetShader() ) 
	{
		char *str = new char[1];
		*str = 0;
		return str;
	}

	char *str = new char[ strlen(pMesh->GetShader()->GetPSSource())+1 ];
	strcpy( str, pMesh->GetShader()->GetPSSource() );
	return str;
}

//****f* 3D/Objects/SetObjectMeshUVOffset
// FUNCTION
//   Modifies the mesh UVs to shift them by the specified offset. This may push the UV coordinates outside
//   the range 0.0 to 1.0, in which case the image wrap mode will be used to either clamp or repeat the texture.
//   Use <i>SetImageWrapU</i> and <i>SetImageWrapV</i> to set the wrap mode. Note that the image must be a power 
//   of 2 in size to use the repeat mode.
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to modify.
//   textureStage -- The texture stage of the UVs to modify, in the range 0 to 7
//   offsetU -- The offset to use in the U direction, the default is 0
//   offsetV -- The offset to use in the V direction, the default is 0
// SOURCE
void agk::SetObjectMeshUVOffset( uint32_t objID, uint32_t meshIndex, uint32_t textureStage, float offsetU, float offsetV )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set mesh UV offset for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh UV offset for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	pMesh->SetUVOffset( textureStage, offsetU, offsetV );
}

//****f* 3D/Objects/SetObjectMeshUVScale
// FUNCTION
//   Modifies the mesh UVs to scale them by the specified amount. This may push the UV coordinates outside
//   the range 0.0 to 1.0, in which case the image wrap mode will be used to either clamp or repeat the texture.
//   Use <i>SetImageWrapU</i> and <i>SetImageWrapV</i> to set the wrap mode. A scale value of 1 will leave the
//   UV coordinates with their default values, whilst a scale value of 2.0 would double the number of times the
//   texture appears across the mesh (assuming the wrap mode is set to repeat). Note that the image must be a
//   power of 2 in size to use the repeat mode.
// INPUTS
//   objID -- The ID of the object to modify.
//   meshIndex -- The index of the mesh to modify.
//   textureStage -- The texture stage of the UVs to modify, in the range 0 to 7
//   scaleU -- The scale to use in the U direction, the default is 1
//   scaleV -- The scale to use in the V direction, the default is 1
// SOURCE
void agk::SetObjectMeshUVScale( uint32_t objID, uint32_t meshIndex, uint32_t textureStage, float scaleU, float scaleV )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set mesh UV offset for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set mesh UV offset for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	pMesh->SetUVScale( textureStage, scaleU, scaleV );
}

//****f* 3D/Objects/GetObjectMeshSizeMinX
// FUNCTION
//   Returns the minimum extent of the mesh in the X direction, this can be combined with <i>GetObjectMeshSizeMaxX</i>
//   to determine the size of the mesh in the X direction. Note that the mesh may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the X direction.
// INPUTS
//   objID -- The ID of the object to check.
//   meshIndex -- The index of the mesh to check.
// SOURCE
float agk::GetObjectMeshSizeMinX( uint32_t objID, uint32_t meshIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get mesh size min X for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh size min X for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return 0;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	return pMesh->GetMinX();
}

//****f* 3D/Objects/GetObjectMeshSizeMaxX
// FUNCTION
//   Returns the maximum extent of the mesh in the X direction, this can be combined with <i>GetObjectMeshSizeMinX</i>
//   to determine the size of the mesh in the X direction. Note that the mesh may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the X direction.
// INPUTS
//   objID -- The ID of the object to check.
//   meshIndex -- The index of the mesh to check.
// SOURCE
float agk::GetObjectMeshSizeMaxX( uint32_t objID, uint32_t meshIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get mesh size max X for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh size max X for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return 0;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	return pMesh->GetMaxX();
}

//****f* 3D/Objects/GetObjectMeshSizeMinY
// FUNCTION
//   Returns the minimum extent of the mesh in the Y direction, this can be combined with <i>GetObjectMeshSizeMaxY</i>
//   to determine the size of the mesh in the Y direction. Note that the mesh may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the Y direction.
// INPUTS
//   objID -- The ID of the object to check.
//   meshIndex -- The index of the mesh to check.
// SOURCE
float agk::GetObjectMeshSizeMinY( uint32_t objID, uint32_t meshIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get mesh size min Y for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh size min Y for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return 0;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	return pMesh->GetMinY();
}

//****f* 3D/Objects/GetObjectMeshSizeMaxY
// FUNCTION
//   Returns the maximum extent of the mesh in the Y direction, this can be combined with <i>GetObjectMeshSizeMinY</i>
//   to determine the size of the mesh in the Y direction. Note that the mesh may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the Y direction.
// INPUTS
//   objID -- The ID of the object to check.
//   meshIndex -- The index of the mesh to check.
// SOURCE
float agk::GetObjectMeshSizeMaxY( uint32_t objID, uint32_t meshIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get mesh size max Y for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh size max Y for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return 0;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	return pMesh->GetMaxY();
}

//****f* 3D/Objects/GetObjectMeshSizeMinZ
// FUNCTION
//   Returns the minimum extent of the mesh in the Z direction, this can be combined with <i>GetObjectMeshSizeMaxZ</i>
//   to determine the size of the mesh in the Z direction. Note that the mesh may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the Z direction.
// INPUTS
//   objID -- The ID of the object to check.
//   meshIndex -- The index of the mesh to check.
// SOURCE
float agk::GetObjectMeshSizeMinZ( uint32_t objID, uint32_t meshIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get mesh size min Z for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh size min Z for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return 0;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	return pMesh->GetMinZ();
}

//****f* 3D/Objects/GetObjectMeshSizeMaxZ
// FUNCTION
//   Returns the maximum extent of the mesh in the Z direction, this can be combined with <i>GetObjectMeshSizeMinZ</i>
//   to determine the size of the mesh in the Z direction. Note that the mesh may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the Z direction.
// INPUTS
//   objID -- The ID of the object to check.
//   meshIndex -- The index of the mesh to check.
// SOURCE
float agk::GetObjectMeshSizeMaxZ( uint32_t objID, uint32_t meshIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get mesh size max Z for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	if ( meshIndex == 0 || meshIndex > pObject->GetNumMeshes() )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get mesh size max Z for object %d mesh %d - mesh index is out of range", objID, meshIndex );
		Error( errStr );
#endif
		return 0;
	}

	cMesh *pMesh = pObject->GetMesh( meshIndex-1 );
	return pMesh->GetMaxZ();
}

//****f* 3D/Objects/FixObjectToObject
// FUNCTION
//   Fixes an object to another object so that any movement of the parent also affects the child.
//   The object being fixed uses its current position, rotation, and scale as an offset to the 
//   parent. For example if the parent was placed at 10,5,0 and an object was fixed to it with
//   the current position 0,10,0 then the child would now inherit the position of the parent, 
//   combine it with its own, and the child would be placed at 10,15,0. The same applies to 
//   rotation and scaling, so if the parent was rotated around the Y axis then the child would 
//   rotate by the same amount. <br/><br/>
//   Note that using <i>GetObjectY</i> on the child would only show its local position relative to 
//   its parent (in this case it would return 10). To get the final world position of the child
//   use <i>GetObjectWorldY</i> on it, which in this case would return 15.
//   There is no limit to the number of objects an object can have fixed to it, nor is there a 
//   limit to objects being fixed to objects which are fixed to other objects, just don't 
//   create any loops. <br/><br/>
//   An object can only be fixed to one thing at a time, fixing it to something else will remove
//   it from its current attachment (if any). To stop an object being fixed to anything set toObjID 
//   to 0 and it will become independent 
//   again.
// INPUTS
//   objID -- The ID of the object to fix.
//   toObjID -- The ID of the object to fix it to.
// SOURCE
void agk::FixObjectToObject( uint32_t objID, uint32_t toObjID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to fix object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( toObjID == 0 )
	{
		pObject->RemoveFromParent();
	}
	else
	{
		cObject3D *pToObject = m_cObject3DList.GetItem( toObjID );
		if ( !pToObject )
		{
	#ifdef _AGK_ERROR_CHECK
			uString errStr;
			errStr.Format( "Failed to fix to object %d - object does not exist", toObjID );
			Error( errStr );
	#endif
			return;
		}

		pToObject->AddChild( pObject );
	}
}

//****f* 3D/Objects/FixObjectToBone
// FUNCTION
//   Similar to <i>FixObjectToObject</i> except the parent will be a bone in the other object.
// INPUTS
//   objID -- The ID of the object to fix.
//   toObjID -- The ID of the object to fix it to.
//   toBoneIndex -- The index of the bone to fix it to.
// SOURCE
void agk::FixObjectToBone( uint32_t objID, uint32_t toObjID, uint32_t toBoneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to fix object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	cObject3D *pToObject = m_cObject3DList.GetItem( toObjID );
	if ( !pToObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to fix to object %d - object does not exist", toObjID );
		Error( errStr );
#endif
		return;
	}

	if ( !pToObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to fix to bone of object %d - object does not have any bones", toObjID );
		Error( errStr );
#endif
		return;
	}

	if ( toBoneIndex == 0 || toBoneIndex > pToObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to fix to bone %d of object %d - bone index is out of range", toBoneIndex, toObjID );
		Error( errStr );
#endif
		return;
	}

	pToObject->m_pSkeleton->m_pBones[ toBoneIndex-1 ]->AddChild( pObject );
}

//****f* 3D/Objects/FixObjectToCamera
// FUNCTION
//   Fixes an object to a camera so that any movement of the parent also affects the child.
//   The object being fixed uses its current position, rotation, and scale as an offset to the 
//   parent. For example if the camera was placed at 10,5,0 and an object was fixed to it with
//   the current position 0,10,0 then the object would now inherit the position of the camera, 
//   combine it with its own, and the object would be placed at 10,15,0. The same applies to 
//   rotation and scaling, so if the camera was rotated around the Y axis then the object would 
//   rotate by the same amount.  <br/><br/>
//   Note that using <i>GetObjectY</i> on the child would only show its local position relative to 
//   its parent (in this case it would return 10). To get the final world position of the child
//   use <i>GetObjectWorldY</i> on it, which in this case would return 15.
//   There is no limit to the number of objects a camera can have fixed to it, nor is there a 
//   limit to objects being fixed to objects which are fixed to cameras, just don't 
//   create any loops. <br/><br/>
//   An object can only be fixed to one thing at a time, fixing it to something else will remove
//   it from its current attachment (if any). To stop an object being fixed to anything set toObjID 
//   to 0 and it will become independent 
//   again.
// INPUTS
//   objID -- The ID of the object to fix.
//   toCameraID -- The ID of the camera to fix it to.
// SOURCE
void agk::FixObjectToCamera( uint32_t objID, uint32_t toCameraID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to fix object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( toCameraID == 0 )
	{
		pObject->RemoveFromParent();
	}
	else
	{
		cCamera *pCamera = m_cCameraList.GetItem( toCameraID );
		if ( !pCamera )
		{
	#ifdef _AGK_ERROR_CHECK
			uString errStr;
			errStr.Format( "Failed to fix to camera %d - camera does not exist", toCameraID );
			Error( errStr );
	#endif
			return;
		}

		pCamera->AddChild( pObject );
	}
}

// animation

//****f* 3D/Objects/GetObjectNumAnimations
// FUNCTION
//   Returns the number of animations currently assigned to the object. Only objects loaded with 
//   <i>LoadObjectWithChildren</i> get animations assigned to them.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectNumAnimations( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get num animations for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_iNumAnims;
}

//****f* 3D/Objects/GetObjectAnimationName
// FUNCTION
//   Returns the name of the specified animation for the given object. You can find the number of 
//   animations for this object with <i>GetObjectNumAnimations</i>. The index should be in the 
//   range 1 to numAnimations inclusive.
// INPUTS
//   objID -- The ID of the object to check.
//   index -- The index of the animation to check, indices start at 1.
// SOURCE
char* agk::GetObjectAnimationName( uint32_t objID, int index )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get animation name for object %d - object does not exist", objID );
		Error( errStr );
#endif
		char *str = new char[1]; str[0] = 0;
		return str;
	}

	if ( index == 0 || index > (int)pObject->m_iNumAnims ) 
	{
		char *str = new char[1]; str[0] = 0;
		return str;
	}

	char *str = new char[ pObject->m_pAnims[index-1]->GetNameString().GetLength() + 1 ];
	strcpy( str, pObject->m_pAnims[index-1]->GetNameString().GetStr() );
	return str;
}

//****f* 3D/Objects/PlayObjectAnimation
// FUNCTION
//   Plays an given animation on its parent object. Only objects loaded with <i>LoadObjectWithChildren</i>
//   will have animations assigned to them. Animation names are defined by the modelling program when the
//   animations were created, you can discover what the names are by using <i>GetObjectAnimationName</i>.
//   The animation can be started and ended at any point in the animation using the start and end parameters, 
//   these are given in seconds, and if looping is turned on then the object will return to the given start 
//   time at the start of each loop. If you want the looping to be seamless then the bone positions at the 
//   start and end time must be exactly the same, as there will be no interpolation between them when it 
//   loops.
//   The tweentime parameter can be used to interpolate between the current bone positions and the start
//   time of the animation so that there is no sudden jump in bone positions. This tweening only happens 
//   once, it does not happen every loop, and does not contribute to the animation time. Essentially the 
//   animation is paused until tweening has finished.
//   Note that as soon as this command is called the bones will be controlled by animation and cannot be
//   moved with <i>SetObjectBonePosition</i> or similar commands. You can regain manual control of 
//   individual bones by using <i>SetObjectBoneCanAnimate</i> on it. You can regain control of the entire
//   bone structure by using <i>ResetObjectAnimation</i>.
// INPUTS
//   objID -- The ID of the object to modify.
//   animName -- The name of the animation to play, defined by the modelling program
//   starttime -- The point in the animation at which the object should start playing, in seconds
//   endtime -- The point in the animation at which the object should stop playing, minus 1 to continue to the end
//   loop -- 1 to loop the animation forever, 0 to play once, any other positive integer to loop that many times
//   tweentime -- The time in seconds to transition from the objects current state to the first frame of animation
// SOURCE
void agk::PlayObjectAnimation( uint32_t objID, const char *animName, float starttime, float endtime, int loop, float tweentime )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to play animation for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to play animation for object %d - object is not set up for animation, use LoadObjectWithChildren for animated objects", objID );
		Error( errStr );
#endif
		return;
	}

	int found = -1;
	for( uint32_t i = 0; i < pObject->m_iNumAnims; i++ )
	{
		if ( pObject->m_pAnims[ i ]->GetNameString().CompareCaseTo( animName ) == 0 ) 
		{
			found = i;
			break;
		}
	}

	if ( found < 0 )
	{
		if ( animName[0] == 0 && pObject->m_iNumAnims > 0 ) found = 0;
		else
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr;
			errStr.Format( "Failed to play animation \"%s\" for object %d - an animation with that name does not exist", animName, objID );
			Error( errStr );
#endif
			return;		
		}
	}

	pObject->m_pSkeleton->PlayAnimation( pObject->m_pAnims[ found ], starttime, endtime, loop, tweentime );
}

//****f* 3D/Objects/SetObjectAnimationFrame
// FUNCTION
//   Sets the object bone positions to match a given time in the animation. Only objects loaded with 
//   <i>LoadObjectWithChildren</i> will have animations assigned to them. Animation names are defined 
//   by the modelling program when the animations were created, you can discover what the names are by 
//   using <i>GetObjectAnimationName</i>.
//   If the given time falls between keyframes then the bone positions will be interpolated between them.
//   The tweentime parameter can be used to interpolate between the current bone positions and the given
//   time of the animation so that there is no sudden jump in bone positions.
//   Note that as soon as this command is called the bones will be controlled by animation and cannot be
//   moved with <i>SetObjectBonePosition</i> or similar commands. You can regain manual control of 
//   individual bones by using <i>SetObjectBoneCanAnimate</i> on it. You can regain control of the entire
//   bone structure by using <i>ResetObjectAnimation</i>.
// INPUTS
//   objID -- The ID of the object to modify.
//   animName -- The name of the animation to play, defined by the modelling program
//   time -- The point in the animation to read the bone positions, in seconds
//   tweentime -- The time in seconds to transition from the objects current state to the given frame
// SOURCE
void agk::SetObjectAnimationFrame(uint32_t objID, const char *animName, float time, float tweentime )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set animation frame for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set animation frame for object %d - object is not set up for animation, use LoadObjectWithChildren for animated objects", objID );
		Error( errStr );
#endif
		return;
	}

	int found = -1;
	for( uint32_t i = 0; i < pObject->m_iNumAnims; i++ )
	{
		if ( pObject->m_pAnims[ i ]->GetNameString().CompareCaseTo( animName ) == 0 ) 
		{
			found = i;
			break;
		}
	}

	if ( found < 0 )
	{
		if ( animName[0] == 0 && pObject->m_iNumAnims > 0 ) found = 0;
		else
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr;
			errStr.Format( "Failed to set animation \"%s\" for object %d - an animation with that name does not exist", animName, objID );
			Error( errStr );
#endif
			return;		
		}
	}

	pObject->m_pSkeleton->SetAnimationFrame( pObject->m_pAnims[ found ], time, tweentime );
}

//****f* 3D/Objects/StopObjectAnimation
// FUNCTION
//   Stops any animation that is currently playing on the object and leaves the bones in their current position.
//   If the object is currently tweening then the tween will also be stopped with the bones left mid-tween.
// INPUTS
//   objID -- The ID of the object to modify.
// SOURCE
void agk::StopObjectAnimation( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to stop animation for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to stop animation for object %d - object is not set up for animation, use LoadObjectWithChildren for animated objects", objID );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->StopAnimation();
}

//****f* 3D/Objects/ResetObjectAnimation
// FUNCTION
//   Stops any playing animation and resets the object bones to their bind positions.
// INPUTS
//   objID -- The ID of the object to modify.
// SOURCE
void agk::ResetObjectAnimation( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to stop animation for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to stop animation for object %d - object is not set up for animation, use LoadObjectWithChildren for animated objects", objID );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->ResetAnimation();
}

//****f* 3D/Objects/SetObjectAnimationSpeed
// FUNCTION
//   Sets the animation speed for the given object as a multiple of the default time, i.e. 1.0 would 
//   use the times from the animation keyframes, 2.0 would play them twice as fast, 0.5 twice as 
//   slow, and so on. You can also use negative values to play the animation in reverse, or 0 to pause
//   it.
// INPUTS
//   objID -- The ID of the object to modify.
//   speed -- The new animation speed to use for this object, default 1.0
// SOURCE
void agk::SetObjectAnimationSpeed(  uint32_t objID, float speed )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set animation speed for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set animation speed for object %d - object is not set up for animation, use LoadObjectWithChildren for animated objects", objID );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->SetAnimationSpeed( speed );
}

//****f* 3D/Objects/GetObjectIsAnimating
// FUNCTION
//   Returns 1 if the object is currently playing an animation, this includes tween to the start 
//   of an animation, but not tweening to a single frame. Essentially it returns 1 if the object 
//   should be playing an animation.
//   If the animation is set to loop a specified number of times, or to only play once, then this
//   command will return 0 when the animation is finished.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectIsAnimating( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get IsAnimating for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get IsAnimating for object %d - object is not set up for animation, use LoadObjectWithChildren for animated objects", objID );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->GetIsAnimating();
}

//****f* 3D/Objects/GetObjectIsTweening
// FUNCTION
//   Returns 1 if the object is currently tweening to an animation frame or the beginning or an 
//   animation about to play. This only occurs immediately after <i>PlayObjectAnimation</i> or
//   <i>SetObjectAnimationFrame</i> if you specified a tween time greater than 0. It does not
//   occur at any other time during an animation.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectIsTweening( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get IsTweening for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get IsTweening for object %d - object is not set up for animation, use LoadObjectWithChildren for animated objects", objID );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->GetIsTweening();
}

//****f* 3D/Objects/GetObjectAnimationTime
// FUNCTION
//   Returns the current time of a playing animation, or if the animation has stopped then the last
//   time used for interpolation is returned.  
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectAnimationTime( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get animation time for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get animation time for object %d - object is not set up for animation, use LoadObjectWithChildren for animated objects", objID );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->GetAnimationTime();
}

//****f* 3D/Objects/GetObjectAnimationDuration
// FUNCTION
//   Returns the duration of a specified animation in seconds.
// INPUTS
//   objID -- The ID of the object to check.
//   animName -- The name of the animation to check, defined by the modelling program
// SOURCE
float agk::GetObjectAnimationDuration( uint32_t objID, const char *animName )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get animation duration for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get animation duration for object %d - object is not set up for animation, use LoadObjectWithChildren for animated objects", objID );
		Error( errStr );
#endif
		return 0;
	}

	int found = -1;
	for( uint32_t i = 0; i < pObject->m_iNumAnims; i++ )
	{
		if ( pObject->m_pAnims[ i ]->GetNameString().CompareCaseTo( animName ) == 0 ) 
		{
			found = i;
			break;
		}
	}

	if ( found < 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get duration for animation \"%s\" on object %d - an animation with that name does not exist", animName, objID );
		Error( errStr );
#endif
		return 0;		
	}

	return pObject->m_pAnims[ found ]->GetDuration();
}

//****f* 3D/Bones/SetObjectBonePosition
// FUNCTION
//   Sets the position of the specified bone relative to its parent.
// INPUTS
//   objID -- The ID of the object that contains the bone.
//   boneIndex -- The index of the bone to modify
//   x -- The X component of the position.
//   y -- The Y component of the position.
//   z -- The Z component of the position.
// SOURCE
void agk::SetObjectBonePosition( uint32_t objID, uint32_t boneIndex, float x, float y, float z )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone position for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone position for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone position for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->SetNodePosition( x,y,z );
}

//****f* 3D/Bones/SetObjectBoneRotation
// FUNCTION
//   Sets the rotation of the specified bone using euler angles in degrees. Alternatively you can
//   use SetObjectBoneRotationQuat to use a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone.
//   boneIndex -- The index of the bone to modify
//   angx -- The X component of the rotation.
//   angy -- The Y component of the rotation.
//   angz -- The Z component of the rotation.
// SOURCE
void agk::SetObjectBoneRotation( uint32_t objID, uint32_t boneIndex, float angx, float angy, float angz )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone rotation for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone rotation for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone rotation for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return;
	}

	AGKQuaternion q;
	q.MakeFromEulerYXZ( angx, angy, angz ); 
	pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->SetNodeRotation( q.w, q.x, q.y, q.z );
}

//****f* 3D/Bones/SetObjectBoneRotationQuat
// FUNCTION
//   Sets the rotation of the specified bone relative to its parent as a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone.
//   boneIndex -- The index of the bone to modify.
//   w -- The W component of the rotation.
//   x -- The X component of the rotation.
//   y -- The Y component of the rotation.
//   z -- The Z component of the rotation.
// SOURCE
void agk::SetObjectBoneRotationQuat( uint32_t objID, uint32_t boneIndex, float w, float x, float y, float z )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone rotation for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone rotation for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone rotation for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->SetNodeRotation( w, x, y, z );
}

//****f* 3D/Bones/SetObjectBoneLookAt
// FUNCTION
//   Rotates the bone to look at a particular point in world space with an optional roll value.
//   "looking at" is defined as aligning the bone's local Z axis to point its positive side
//   at the given point. This can be achieved using only the Y and X angles in Euler notation,
//   so you can specify an optional Z angle in degrees to roll the bone left of right whilst
//   always looking at the same spot.
// INPUTS
//   objID -- The ID of the object that contains the bone.
//   boneIndex -- The index of the bone to modify.
//   x -- The X component of the position to look at.
//   y -- The Y component of the position to look at.
//   z -- The Z component of the position to look at.
//   roll -- The Z angle to roll the bone when looking at the given position, negative is clockwise.
// SOURCE
void agk::SetObjectBoneLookAt( uint32_t objID, uint32_t boneIndex, float x, float y, float z, float roll )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone look at for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone look at for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone look at for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->LookAt( x, y, z, roll );
}

//****f* 3D/Bones/SetObjectBoneCanAnimate
// FUNCTION
//   Sets whether the specified bone is controlled by animation or controlled manually. When controlled 
//   by animation then none of the <i>SetObjectBonePosition</i> or similar commands will have any effect.
//   When controlled manually the bone will maintain its current position unless modified by you.
// INPUTS
//   objID -- The ID of the object that contains the bone.
//   boneIndex -- The index of the bone to modify.
//   animate -- 1 to allow animation to affect this bone, 0 to allow manual control.
// SOURCE
void agk::SetObjectBoneCanAnimate( uint32_t objID, uint32_t boneIndex, int animate )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone can anmimate for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone can animate for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone can animate for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->SetCanAnimate( animate );
}

//****f* 3D/Bones/RotateObjectBoneLocalX
// FUNCTION
//   Rotates the specified bone around its local X axis, i.e. if the bone were an airplane
//   this command would make it pitch up and down no matter which direction it was facing.
// INPUTS
//   objID -- The ID of the object that contains the bone.
//   boneIndex -- The index of the bone to modify.
//   amount -- The angle to rotate on the local X axis in degrees, positive looks down, negative looks up.
// SOURCE
void agk::RotateObjectBoneLocalX( uint32_t objID, uint32_t boneIndex, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone local rotation for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone local rotation for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone local rotation for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->RotateLocalX( amount );
}

//****f* 3D/Bones/RotateObjectBoneLocalY
// FUNCTION
//   Rotates the specified bone around its local Y axis, i.e. if the bone were an airplane
//   this command would make it turn left and right no matter which direction it was facing.
// INPUTS
//   objID -- The ID of the object that contains the bone.
//   boneIndex -- The index of the bone to modify.
//   amount -- The angle to rotate on the local Y axis in degrees, positive turns right, negative turns left.
// SOURCE
void agk::RotateObjectBoneLocalY( uint32_t objID, uint32_t boneIndex, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone local rotation for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone local rotation for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone local rotation for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->RotateLocalY( amount );
}

//****f* 3D/Bones/RotateObjectBoneLocalZ
// FUNCTION
//   Rolls the specified bone around its local Z axis, i.e. if the bone were an airplane
//   this command would make it do a barrel roll no matter which direction it was facing.
// INPUTS
//   objID -- The ID of the object that contains the bone.
//   boneIndex -- The index of the bone to modify.
//   amount -- The angle to rotate on the local Z axis in degrees, positive rolls anti-clockwise, negative rolls clockwise.
// SOURCE
void agk::RotateObjectBoneLocalZ( uint32_t objID, uint32_t boneIndex, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone local rotation for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone local rotation for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to set bone local rotation for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return;
	}

	pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->RotateLocalZ( amount );
}

//****f* 3D/Bones/GetObjectBoneName
// FUNCTION
//   Returns the name of the bone. If this command is called from tier 2 then you must delete
//   the returned string when you are done with it.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
char* agk::GetObjectBoneName( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone name for object %d - object does not exist", objID );
		Error( errStr );
#endif
		char *str = new char[1]; str[0] = 0;
		return str;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone name for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		char *str = new char[1]; str[0] = 0;
		return str;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone name for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		char *str = new char[1]; str[0] = 0;
		return str;
	}

	char *str = new char[ pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->m_sName.GetLength() + 1 ];
	strcpy( str, pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->m_sName.GetStr() );
	return str;
}

//****f* 3D/Bones/GetObjectBoneX
// FUNCTION
//   Returns the current X position of the bone.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneX( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone position for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone position for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone position for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->pos().x;
}

//****f* 3D/Bones/GetObjectBoneY
// FUNCTION
//   Returns the current Y position of the bone.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneY( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone position for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone position for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone position for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->pos().y;
}

//****f* 3D/Bones/GetObjectBoneZ
// FUNCTION
//   Returns the current Z position of the bone.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneZ( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone position for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone position for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone position for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->pos().z;
}

//****f* 3D/Bones/GetObjectBoneAngleX
// FUNCTION
//   Returns the X component of the bone's current rotation converted to Euler angles.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneAngleX( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rot().GetEulerX();
}

//****f* 3D/Bones/GetObjectBoneAngleY
// FUNCTION
//   Returns the Y component of the bone's current rotation converted to Euler angles.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneAngleY( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rot().GetEulerY();
}

//****f* 3D/Bones/GetObjectBoneAngleZ
// FUNCTION
//   Returns the Z component of the bone's current rotation converted to Euler angles.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneAngleZ( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rot().GetEulerZ();
}

//****f* 3D/Bones/GetObjectBoneQuatW
// FUNCTION
//   Returns the W component of the bone's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneQuatW( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rot().w;
}

//****f* 3D/Bones/GetObjectBoneQuatX
// FUNCTION
//   Returns the X component of the bone's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneQuatX( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rot().x;
}

//****f* 3D/Bones/GetObjectBoneQuatY
// FUNCTION
//   Returns the Y component of the bone's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneQuatY( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rot().y;
}

//****f* 3D/Bones/GetObjectBoneQuatZ
// FUNCTION
//   Returns the Z component of the bone's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneQuatZ( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rot().z;
}




//****f* 3D/Bones/GetObjectBoneWorldX
// FUNCTION
//   Returns the current X position of the bone in world coordinates.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldX( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone world position for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone world position for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone world position for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->posFinal().x;
}

//****f* 3D/Bones/GetObjectBoneWorldY
// FUNCTION
//   Returns the current Y position of the bone in world coordinates.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldY( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone world position for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone world position for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone world position for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->posFinal().y;
}

//****f* 3D/Bones/GetObjectBoneWorldZ
// FUNCTION
//   Returns the current Z position of the bone in world coordinates.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldZ( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone world position for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone world position for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone world position for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->posFinal().z;
}

//****f* 3D/Bones/GetObjectBoneWorldAngleX
// FUNCTION
//   Returns the X component of the bone's current rotation in world coordinates converted to Euler angles.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldAngleX( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rotFinal().GetEulerX();
}

//****f* 3D/Bones/GetObjectBoneWorldAngleY
// FUNCTION
//   Returns the Y component of the bone's current rotation converted to Euler angles.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldAngleY( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rotFinal().GetEulerY();
}

//****f* 3D/Bones/GetObjectBoneWorldAngleZ
// FUNCTION
//   Returns the Z component of the bone's current rotation converted to Euler angles.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldAngleZ( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rotFinal().GetEulerZ();
}

//****f* 3D/Bones/GetObjectBoneWorldQuatW
// FUNCTION
//   Returns the W component of the bone's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldQuatW( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rotFinal().w;
}

//****f* 3D/Bones/GetObjectBoneWorldQuatX
// FUNCTION
//   Returns the X component of the bone's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldQuatX( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rotFinal().x;
}

//****f* 3D/Bones/GetObjectBoneWorldQuatY
// FUNCTION
//   Returns the Y component of the bone's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldQuatY( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rotFinal().y;
}

//****f* 3D/Bones/GetObjectBoneWorldQuatZ
// FUNCTION
//   Returns the Z component of the bone's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object that contains the bone to check.
//   boneIndex -- The index of the bone to check.
// SOURCE
float agk::GetObjectBoneWorldQuatZ( uint32_t objID, uint32_t boneIndex )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not exist", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( !pObject->m_pSkeleton )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d - object does not have any bones", objID );
		Error( errStr );
#endif
		return 0;
	}

	if ( boneIndex == 0 || boneIndex > pObject->m_pSkeleton->m_iNumBones )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr;
		errStr.Format( "Failed to get world bone angle for object %d bone %d - bone index is out of bounds", objID, boneIndex );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->m_pSkeleton->m_pBones[ boneIndex-1 ]->rotFinal().z;
}


//****f* 3D/Objects/SetObjectPosition
// FUNCTION
//   Sets the position of the specified object. By default objects are positioned at 0,0,0
// INPUTS
//   objID -- The ID of the object to modify.
//   x -- The X component of the position.
//   y -- The Y component of the position.
//   z -- The Z component of the position.
// SOURCE
void agk::SetObjectPosition( uint32_t objID, float x, float y, float z )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetPosition( x,y,z );
}

//****f* 3D/Objects/SetObjectRotation
// FUNCTION
//   Sets the rotation of the specified object using euler angles in degrees. Alternatively you can
//   use <i>SetObjectRotationQuat</i> to use a quaternion. By default objects are created with the
//   angles 0,0,0 in the order YXZ. Euler angles are compound angles where the object starts 
//   at 0,0,0 and is then rotated using the given Y angle, then by the given X angle, then
//   rolled by the given Z angle. Each 3D rotation can be represented by 2 Euler angle 
//   combinations, Y,X,Z and Y-180,X-180,Z-180 so either version may be returned by the 
//   GetObjectAngle commands.
//   Quaternions and Euler angles can both be used at the same time. For example setting a 
//   quaternion rotation will generate equivalent Euler values that can be retrieved with 
//   <i>GetObjectAngleX</i>, <i>GetObjectAngleX</i>, and <i>GetObjectAngleZ</i>.
// INPUTS
//   objID -- The ID of the object to modify.
//   angx -- The X component of the euler rotation.
//   angy -- The Y component of the euler rotation.
//   angz -- The Z component of the euler rotation.
// SOURCE
void agk::SetObjectRotation( uint32_t objID, float angx, float angy, float angz )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetRotationEuler( angx, angy, angz );
}

//****f* 3D/Objects/SetObjectRotationQuat
// FUNCTION
//   Sets the rotation of the specified object using a quaternion. Alternatively you can
//   use <i>SetObjectRotation</i> to use Euler angles. By default objects are created with the
//   quaternion 1,0,0,0 in the order w,x,y,z. A Quaternion is a 4 dimensional representation
//   of a 3D rotation with the property w^2+x^2+y^2+z^2 = 1 which allows easy interpolation 
//   between two rotations by linearly interpolating the two quaternions and normalising them. 
//   Each 3D rotation is represented by exactly 2 quaternions, w,x,y,z and -w,-x,-y,-z so
//   either version may be returned by the GetObjectQuat commands.
//   Quaternions and Euler angles can both be used at the same time. For example setting a 
//   quaternion rotation will generate equivalent Euler values that can be retrieved with 
//   <i>GetObjectAngleX</i>, <i>GetObjectAngleX</i>, and <i>GetObjectAngleZ</i>.
// INPUTS
//   objID -- The ID of the object to modify.
//   w -- The W component of the quaternion.
//   x -- The X component of the quaternion.
//   y -- The Y component of the quaternion.
//   z -- The Z component of the quaternion.
// SOURCE
void agk::SetObjectRotationQuat( uint32_t objID, float w, float x, float y, float z )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetRotationQuat( AGKQuaternion(w,x,y,z) );
}

//****f* 3D/Objects/SetObjectScale
// FUNCTION
//   Modifies the object size in the X, Y, and Z directions. A scale value of 1,1,1 returns the object
//   to its original size, a scale value of 2 would make the object twice as big, 0.5 would be half the 
//   size, and so on. This command does not stack, so calling it twice with a value of 2 would not make 
//   it 4 times bigger, it would remain 2 times bigger.
//   Note that using different values for the X, Y, and Z directions like so 1,2,1 is called a non-uniform
//   scale, whilst 1.5,1.5,1.5 would be a uniform scale. Non-uniform scaling requires that any shader
//   used by this object use the agk_WorldNormal matrix for any normal transformations to look correct.
//   If this object was loaded with <i>LoadObjectWithChildren</i> command and has child objects, or has 
//   objects attached to it with FixObjectToObject, then they will also be scaled by this amount in 
//   addition to their own scaling.
//   Note that this will not work correctly with bone animated objects, use <i>SetObjectScalePermanent</i>
//   instead.
// INPUTS
//   objID -- The ID of the object to modify.
//   x -- The amount to scale the object on the X axis.
//   y -- The amount to scale the object on the Y axis.
//   z -- The amount to scale the object on the Z axis.
// SOURCE
void agk::SetObjectScale( uint32_t objID, float x, float y, float z )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set scale for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetScale( x, y, z );
}

//****f* 3D/Objects/SetObjectScalePermanent
// FUNCTION
//   Modifies the object size in the X, Y, and Z directions. This modifies the object's vertices which 
//   makes this a permanent change, and is slower than <i>SetObjectScale</i>.
//   This command does not read or affect the values set with <i>SetObjectScale</i> so using 
//   SetObjectScale(ID,2,2,2) and then setting a permanent scale of 3,3,3 would still draw the object 2 
//   times bigger than normal, which means 6 times bigger than when you started.
//   This command does not affect any child objects that may have been loaded with it, nor any objects 
//   attached to it with <i>FixObjectToObject</i>.
//   This command will work on bone animated objects as long as the scale is uniform, i.e. the X, Y, and
//   Z scale values are all the same.
// INPUTS
//   objID -- The ID of the object to modify.
//   x -- The amount to scale the object on the X axis.
//   y -- The amount to scale the object on the Y axis.
//   z -- The amount to scale the object on the Z axis.
// SOURCE
void agk::SetObjectScalePermanent( uint32_t objID, float x, float y, float z )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set permanent scale for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetScalePermanent( x, y, z );
}

//****f* 3D/Objects/MoveObjectLocalX
// FUNCTION
//   Moves the specified object along its local X axis, i.e. if the object were a character
//   this command would make them strafe no matter which direction they were facing.
// INPUTS
//   objID -- The ID of the object to modify.
//   amount -- The distance to move in the local X direction, can be negative.
// SOURCE
void agk::MoveObjectLocalX( uint32_t objID, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->MoveLocalX( amount );
}

//****f* 3D/Objects/MoveObjectLocalY
// FUNCTION
//   Moves the specified object along its local Y axis, i.e. if the object were a character
//   this command would make them jump no matter which direction they were facing.
// INPUTS
//   objID -- The ID of the object to modify.
//   amount -- The distance to move in the local Y direction, can be negative.
// SOURCE
void agk::MoveObjectLocalY( uint32_t objID, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->MoveLocalY( amount );
}

//****f* 3D/Objects/MoveObjectLocalZ
// FUNCTION
//   Moves the specified object along its local Z axis, i.e. if the object were a character
//   this command would make them move forwards no matter which direction they were facing.
// INPUTS
//   objID -- The ID of the object to modify.
//   amount -- The distance to move in the local Z direction, can be negative.
// SOURCE
void agk::MoveObjectLocalZ( uint32_t objID, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->MoveLocalZ( amount );
}

//****f* 3D/Objects/RotateObjectLocalX
// FUNCTION
//   Rotates the specified object around its local X axis, i.e. if the object were an airplane
//   this command would make it pitch up and down no matter which direction it was facing.
// INPUTS
//   objID -- The ID of the object to modify.
//   amount -- The angle to rotate on the local X axis in degrees, positive looks down, negative looks up.
// SOURCE
void agk::RotateObjectLocalX( uint32_t objID, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->RotateLocalX( amount );
}

//****f* 3D/Objects/RotateObjectLocalY
// FUNCTION
//   Rotates the specified object around its local Y axis, i.e. if the object were an airplane
//   this command would make it turn left and right no matter which direction it was facing.
// INPUTS
//   objID -- The ID of the object to modify.
//   amount -- The angle to rotate on the local Y axis in degrees, positive turns right, negative turns left.
// SOURCE
void agk::RotateObjectLocalY( uint32_t objID, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->RotateLocalY( amount );
}

//****f* 3D/Objects/RotateObjectLocalZ
// FUNCTION
//   Rolls the specified object around its local Z axis, i.e. if the object were an airplane
//   this command would make it do a barrel roll no matter which direction it was facing.
// INPUTS
//   objID -- The ID of the object to modify.
//   amount -- The angle to rotate on the local Z axis in degrees, positive rolls anti-clockwise, negative rolls clockwise.
// SOURCE
void agk::RotateObjectLocalZ( uint32_t objID, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->RotateLocalZ( amount );
}

//****f* 3D/Objects/RotateObjectGlobalX
// FUNCTION
//   Rotates the specified object around global X axis. Imagine the camera looking down the Z axis at an object
//   with a random rotation. This command will pitch the object up and down relative to the camera regardless
//   of which way the object is facing.
// INPUTS
//   objID -- The ID of the object to modify.
//   amount -- The angle to rotate on the global X axis in degrees, positive pitches down, negative pitches up.
// SOURCE
void agk::RotateObjectGlobalX( uint32_t objID, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->RotateGlobalX( amount );
}

//****f* 3D/Objects/RotateObjectGlobalY
// FUNCTION
//   Rotates the specified object around global Y axis. Imagine the camera looking down the Z axis at an object
//   with a random rotation. This command will turn the object left and right relative to the camera regardless
//   of which way the object is facing.
// INPUTS
//   objID -- The ID of the object to modify.
//   amount -- The angle to rotate on the global Y axis in degrees, positive turns right, negative turns left.
// SOURCE
void agk::RotateObjectGlobalY( uint32_t objID, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->RotateGlobalY( amount );
}

//****f* 3D/Objects/RotateObjectGlobalZ
// FUNCTION
//   Rotates the specified object around global Z axis. Imagine the camera looking down the Z axis at an object
//   with a random rotation. This command will roll the object left and right relative to the camera regardless
//   of which way the object is facing.
// INPUTS
//   objID -- The ID of the object to modify.
//   amount -- The angle to rotate on the global Z axis in degrees, positive rolls anti-clockwise, negative rolls clockwise.
// SOURCE
void agk::RotateObjectGlobalZ( uint32_t objID, float amount )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->RotateGlobalZ( amount );
}

//****f* 3D/Objects/GetObjectX
// FUNCTION
//   Returns the current X position of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectX( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetX();
}

//****f* 3D/Objects/GetObjectY
// FUNCTION
//   Returns the current Y position of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectY( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetY();
}

//****f* 3D/Objects/GetObjectZ
// FUNCTION
//   Returns the current Z position of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectZ( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetZ();
}

//****f* 3D/Objects/GetObjectAngleX
// FUNCTION
//   Returns the X component of the object's current rotation converted to Euler angles.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectAngleX( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetEulerX();
}

//****f* 3D/Objects/GetObjectAngleY
// FUNCTION
//   Returns the Y component of the object's current rotation converted to Euler angles.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectAngleY( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetEulerY();
}

//****f* 3D/Objects/GetObjectAngleZ
// FUNCTION
//   Returns the Z component of the object's current rotation converted to Euler angles.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectAngleZ( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetEulerZ();
}

//****f* 3D/Objects/GetObjectQuatW
// FUNCTION
//   Returns the W component of the object's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectQuatW( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rot().w;
}

//****f* 3D/Objects/GetObjectQuatX
// FUNCTION
//   Returns the X component of the object's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectQuatX( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rot().x;
}

//****f* 3D/Objects/GetObjectQuatY
// FUNCTION
//   Returns the Y component of the object's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectQuatY( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rot().y;
}

//****f* 3D/Objects/GetObjectQuatZ
// FUNCTION
//   Returns the Z component of the object's current rotation converted to a quaternion.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectQuatZ( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rot().z;
}

// Get world transforms

//****f* 3D/Objects/GetObjectWorldX
// FUNCTION
//   Returns the current X position of the object in world coordinates. This takes into 
//   account parent positions as a result of <i>FixObjectToObject</i> or 
//   <i>FixObjectToBone</i> and returns the absolute world position of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldX( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->posFinal().x;
}

//****f* 3D/Objects/GetObjectWorldY
// FUNCTION
//   Returns the current Y position of the object in world coordinates. This takes into 
//   account parent positions as a result of <i>FixObjectToObject</i> or 
//   <i>FixObjectToBone</i> and returns the absolute world position of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldY( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->posFinal().y;
}

//****f* 3D/Objects/GetObjectWorldZ
// FUNCTION
//   Returns the current Z position of the object in world coordinates. This takes into 
//   account parent positions as a result of <i>FixObjectToObject</i> or 
//   <i>FixObjectToBone</i> and returns the absolute world position of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldZ( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get position for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->posFinal().z;
}

//****f* 3D/Objects/GetObjectWorldAngleX
// FUNCTION
//   Returns the X component of the object's current rotation converted to Euler angles in 
//   world coordinates. This takes into account parent rotations as a result of 
//   <i>FixObjectToObject</i> or <i>FixObjectToBone</i> and returns the absolute world 
//   rotation of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldAngleX( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rotFinal().GetEulerX();
}

//****f* 3D/Objects/GetObjectWorldAngleY
// FUNCTION
//   Returns the Y component of the object's current rotation converted to Euler angles in 
//   world coordinates. This takes into account parent rotations as a result of 
//   <i>FixObjectToObject</i> or <i>FixObjectToBone</i> and returns the absolute world 
//   rotation of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldAngleY( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rotFinal().GetEulerY();
}

//****f* 3D/Objects/GetObjectWorldAngleZ
// FUNCTION
//   Returns the Z component of the object's current rotation converted to Euler angles in 
//   world coordinates. This takes into account parent rotations as a result of 
//   <i>FixObjectToObject</i> or <i>FixObjectToBone</i> and returns the absolute world 
//   rotation of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldAngleZ( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rotFinal().GetEulerZ();
}

//****f* 3D/Objects/GetObjectWorldQuatW
// FUNCTION
//   Returns the W component of the object's current rotation converted to a quaternion in 
//   world coordinates. This takes into account parent rotations as a result of 
//   <i>FixObjectToObject</i> or <i>FixObjectToBone</i> and returns the absolute world 
//   rotation of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldQuatW( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rotFinal().w;
}

//****f* 3D/Objects/GetObjectWorldQuatX
// FUNCTION
//   Returns the X component of the object's current rotation converted to a quaternion in 
//   world coordinates. This takes into account parent rotations as a result of 
//   <i>FixObjectToObject</i> or <i>FixObjectToBone</i> and returns the absolute world 
//   rotation of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldQuatX( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rotFinal().x;
}

//****f* 3D/Objects/GetObjectWorldQuatY
// FUNCTION
//   Returns the Y component of the object's current rotation converted to a quaternion in 
//   world coordinates. This takes into account parent rotations as a result of 
//   <i>FixObjectToObject</i> or <i>FixObjectToBone</i> and returns the absolute world 
//   rotation of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldQuatY( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rotFinal().y;
}

//****f* 3D/Objects/GetObjectWorldQuatZ
// FUNCTION
//   Returns the Z component of the object's current rotation converted to a quaternion in 
//   world coordinates. This takes into account parent rotations as a result of 
//   <i>FixObjectToObject</i> or <i>FixObjectToBone</i> and returns the absolute world 
//   rotation of the object.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectWorldQuatZ( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get rotation for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->rotFinal().z;
}

//****f* 3D/Objects/GetObjectSizeMinX
// FUNCTION
//   Returns the minimum extent of the object in the X direction, this can be combined with <i>GetObjectSizeMaxX</i>
//   to determine the size of the object in the X direction. Note that the object may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the X direction.
//   This command takes the bounds of all meshes that make up this object, to check the bounds of a single mesh use 
//   <i>GetObjectMeshSizeMinX</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectSizeMinX( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get object size min X - object " );
		errStr.AppendUInt( objID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetMinX();
}

//****f* 3D/Objects/GetObjectSizeMaxX
// FUNCTION
//   Returns the maximum extent of the object in the X direction, this can be combined with <i>GetObjectSizeMinX</i>
//   to determine the size of the object in the X direction. Note that the object may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the X direction.
//   This command takes the bounds of all meshes that make up this object, to check the bounds of a single mesh use 
//   <i>GetObjectMeshSizeMaxX</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectSizeMaxX( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get object size max X - object " );
		errStr.AppendUInt( objID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetMaxX();
}

//****f* 3D/Objects/GetObjectSizeMinY
// FUNCTION
//   Returns the minimum extent of the object in the X direction, this can be combined with <i>GetObjectSizeMaxY</i>
//   to determine the size of the object in the Y direction. Note that the object may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the Y direction.
//   This command takes the bounds of all meshes that make up this object, to check the bounds of a single mesh use 
//   <i>GetObjectMeshSizeMinY</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectSizeMinY( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get object size min Y - object " );
		errStr.AppendUInt( objID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetMinY();
}

//****f* 3D/Objects/GetObjectSizeMaxY
// FUNCTION
//   Returns the maximum extent of the object in the X direction, this can be combined with <i>GetObjectSizeMinY</i>
//   to determine the size of the object in the Y direction. Note that the object may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the Y direction.
//   This command takes the bounds of all meshes that make up this object, to check the bounds of a single mesh use 
//   <i>GetObjectMeshSizeMaxY</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectSizeMaxY( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get object size max Y - object " );
		errStr.AppendUInt( objID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetMaxY();
}

//****f* 3D/Objects/GetObjectSizeMinZ
// FUNCTION
//   Returns the minimum extent of the object in the Z direction, this can be combined with <i>GetObjectSizeMaxZ</i>
//   to determine the size of the object in the Z direction. Note that the object may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the Z direction.
//   This command takes the bounds of all meshes that make up this object, to check the bounds of a single mesh use 
//   <i>GetObjectMeshSizeMinZ</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectSizeMinZ( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get object size min Z - object " );
		errStr.AppendUInt( objID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetMinZ();
}

//****f* 3D/Objects/GetObjectSizeMaxZ
// FUNCTION
//   Returns the maximum extent of the object in the Z direction, this can be combined with <i>GetObjectSizeMinZ</i>
//   to determine the size of the object in the Z direction. Note that the object may be off center so its min value may be
//   10 whilst its max value is 12, meaning its size is 2 units in the Z direction.
//   This command takes the bounds of all meshes that make up this object, to check the bounds of a single mesh use 
//   <i>GetObjectMeshSizeMaxZ</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectSizeMaxZ( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get object size max Z - object " );
		errStr.AppendUInt( objID ).Append( " does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetMaxZ();
}

//****f* 3D/Objects/SetObjectLookAt
// FUNCTION
//   Rotates the object to look at a particular point in space with an optional roll value.
//   "looking at" is defined as aligning the object's local Z axis to point its positive side
//   at the given point. This can be achieved using only the Y and X angles in Euler notation,
//   so you can specify an optional Z angle in degrees to roll the object left of right whilst
//   always looking at the same spot.
// INPUTS
//   objID -- The ID of the object to modify.
//   x -- The X component of the position to look at.
//   y -- The Y component of the position to look at.
//   z -- The Z component of the position to look at.
//   roll -- The Z angle to roll the object when looking at the given position, negative is clockwise.
// SOURCE
void agk::SetObjectLookAt( uint32_t objID, float x, float y, float z, float roll )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set look at for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->LookAt( x,y,z, roll );
}

//****f* 3D/Objects/FixObjectPivot
// FUNCTION
//   Resets the object's position and rotation to 0 whilst keeping the object's vertices where they 
//   are. This can be used to change the center of rotation of an object or adjust its default 
//   orientation when it's rotation is 0.
//   This command modifies the vertices of the object's meshes so is not recommended to call this 
//   every frame, unless the target platform is quite powerful i.e. Windows, Mac, or Linux.
// INPUTS
//   objID -- The ID of the object to modify.
// SOURCE
void agk::FixObjectPivot( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to fix pivot for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->FixPivot();
}

//****f* 3D/Objects/GetObjectHeightMapHeight
// FUNCTION
//   If the object was created with <i>CreateObjectFromHeightMap</i> then this command can be used to
//   quickly get the height of the object at a particular world position. This accounts for the 
//   object's position and Y rotation to provide the height regardless of where the object is 
//   positioned. If the object is rotated in the X or Z angles then this will produce incorrect values.
//   You should provide the X and Z coordinates in world units, if the point lies outside the object
//   then 0 will be returned.
// INPUTS
//   objID -- The ID of the object to check.
//   x -- The X component of the position to check
//   z -- The Z component of the position to check
// SOURCE
float agk::GetObjectHeightMapHeight( uint32_t objID, float x, float z )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get height map height for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetHeightMapHeight( x, z );
}

//****f* 3D/Objects/SetObjectImage
// FUNCTION
//   Sets all meshes in this object to use this image when rendering. You can set textures separately
//   for each mesh by using <i>SetObjectMeshImage</i>. Each mesh can have up to 8 images assigned
//   to it in the texture stages 0 to 7. If you are unsure of which texture stage to use, place the 
//   image in stage 0. Texture stages can be used to assign multiple images to a mesh, for example 
//   you might put the base (diffuse) texture in stage 0, a normal map in stage 1, and a light map in 
//   stage 2. The shader used to draw this object can then combine the various textures into a pixel
//   value to show on the screen.
//   Using an image value of 0 for a particular texture stage removes any assigned image from that stage.
// INPUTS
//   objID -- The ID of the object to modify.
//   imageID -- The ID of the image to assign to this object.
//   texStage -- The texture stage to use for this image.
// SOURCE
void agk::SetObjectImage( uint32_t objID, uint32_t imageID, uint32_t texStage )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set image for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = 0;
	if ( imageID > 0 )
	{
		pImage = m_cImageList.GetItem( imageID );
		if ( !pObject )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set image for object " );
			errStr.AppendUInt( objID ).Append( " - image ");
			errStr.AppendUInt( imageID ).Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}

	pObject->SetImage( pImage, texStage );
}

//****f* 3D/Objects/SetObjectLightMap
// FUNCTION
//   Sets all meshes in this object to use the specified image as a lightmap. You can set a light map
//   for a single mesh by using <i>SetObjectMeshLightMap</i>.
//   The lightmap will be placed in texture stage 1, overwriting anything that is already there and
//   will have a shader generated that combines it with texture stage 0, and any dynamic lighting, to 
//   correctly light the object. If you are setting your own shader with <i>SetObjectShader</i> then 
//   your shader will have to make use of the lightmap itself as AGK will not modify your shader in 
//   this way.<br/><br/>
//   The lightmap will use the second set of UV coordinates, if available, otherwise it will use the
//   same UV coordinates as the base texture.
// INPUTS
//   objID -- The ID of the object to modify.
//   imageID -- The ID of the image to use as a light map.
// SOURCE
void agk::SetObjectLightMap( uint32_t objID, uint32_t imageID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set lightmap for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = 0;
	pImage = m_cImageList.GetItem( imageID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set lightmap for object " );
			errStr.AppendUInt( objID ).Append( " - image ");
			errStr.AppendUInt( imageID ).Append( " does not exist" );
			Error( errStr );
#endif
		return;
	}

	pObject->SetLightMap( pImage );
}

//****f* 3D/Objects/SetObjectNormalMap
// FUNCTION
//   Sets all meshes in this object to use the specified image as a normal map. You can set a normal map
//   for a single mesh by using <i>SetObjectMeshNormalMap</i>.
//   The normal map will be placed in texture stage 2, overwriting anything that is already there and
//   will have a shader generated that combines it with any dynamic lighting, to correctly light the 
//   object. If you are setting your own shader with <i>SetObjectShader</i> then your shader will have 
//   to make use of the normal map itself as AGK will not modify your shader in 
//   this way.<br/><br/>
//   The normal map will use the second set of UV coordinates, if available, otherwise it will use the
//   same UV coordinates as the base texture. If there is also an image in texture stage 1 (such as a 
//   light map) then the normal map will always use the base UVs.
// INPUTS
//   objID -- The ID of the object to modify.
//   imageID -- The ID of the image to use as a normal map.
// SOURCE
void agk::SetObjectNormalMap( uint32_t objID, uint32_t imageID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set normal map for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = 0;
	pImage = m_cImageList.GetItem( imageID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set normal map for object " );
			errStr.AppendUInt( objID ).Append( " - image ");
			errStr.AppendUInt( imageID ).Append( " does not exist" );
			Error( errStr );
#endif
		return;
	}

	pObject->SetNormalMap( pImage );
}

//****f* 3D/Objects/SetObjectNormalMapScale
// FUNCTION
//   Scales the normal map UV coordinates by the specified amount. This does not affect any other
//   texture, but does stack on top of the object's UV offset and scale. A scale value of 1.0 would
//   use unmodified UVs, a scale value of 2.0 would double the UV value, and so on.
// INPUTS
//   objID -- The ID of the object to modify.
//   scaleU -- The amount to scale the normal map in the U direction
//   scaleV -- The amount to scale the normal map in the V direction
// SOURCE
void agk::SetObjectNormalMapScale( uint32_t objID, float scaleU, float scaleV )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set normal map scale for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetNormalMapScale( scaleU, scaleV );
}

//****f* 3D/Objects/SetObjectShader
// FUNCTION
//   Sets the shader used to draw the meshes in this object, each mesh can have its own shader set with 
//   SetObjectMeshShader, this command sets all meshes in this object to use the specified shader.
//   The shader must have been loaded with <i>LoadShader</i>.
//   A shader is like a script sent to the GPU to tell it how to combine the polygon and texture data 
//   to display it on screen. By default meshes are assigned an internal shader that will handle 
//   lighting and texturing. If you use a shader ID of 0 the meshes are assigned the internal shader.
// INPUTS
//   objID -- The ID of the object to modify.
//   shaderID -- The ID of the shader to use.
// SOURCE
void agk::SetObjectShader( uint32_t objID, uint32_t shaderID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shader for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	AGKShader *pShader = 0;
	if ( shaderID > 0 )
	{
		pShader = m_cShaderList.GetItem( shaderID );
		if ( !pShader )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "Failed to set shader for object " );
			errStr.AppendUInt( objID ).Append( " - shader ");
			errStr.AppendUInt( shaderID ).Append( " does not exist" );
			Error( errStr );
#endif
			return;
		}
	}

	pObject->SetShader( pShader );
}

//****f* 3D/Objects/SetObjectColor
// FUNCTION
//   Sets the diffuse color to use when drawing this object. Values should be in the range 0-255 but are not limited 
//   to it. Values greater than 255 will over saturate the object and values less than 0 will take light away.
// INPUTS
//   objID -- The ID of the object to modify.
//   red -- The red component of the color.
//   green -- The green component of the color.
//   blue -- The blue component of the color.
//   alpha -- The alpha component of the color.
// SOURCE
void agk::SetObjectColor( uint32_t objID, int red, int green, int blue, int alpha )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set color for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetColor( red, green, blue, alpha );
}

//****f* 3D/Objects/SetObjectAlpha
// FUNCTION
//   Sets the alpha value to use when drawing this object. This is the same alpha value that can be set in <i>SetObjectColor</i>.
//   Values should be in the range 0-255 but are not limited to it.
// INPUTS
//   objID -- The ID of the object to modify.
//   alpha -- The alpha component of the color.
// SOURCE
void agk::SetObjectAlpha( uint32_t objID, int alpha )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set alpha for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetAlpha( alpha );
}

//****f* 3D/Objects/SetObjectColorEmissive
// FUNCTION
//   Sets the emissive color to use when drawing this object. Values should be in the range 0-255 but are not limited 
//   to it. Values greater than 255 will over saturate the object and values less than 0 will take light away.
//   The emissive color simulates light being generated by the object so it will gain this color even if it is 
//   not being lit by anything. This does not not affect any surrounding objects.
// INPUTS
//   objID -- The ID of the object to modify.
//   red -- The red component of the color.
//   green -- The green component of the color.
//   blue -- The blue component of the color.
// SOURCE
void agk::SetObjectColorEmissive( uint32_t objID, int red, int green, int blue )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set emissive color for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetColorEmissive( red, green, blue );
}

//****f* 3D/Objects/SetObjectLightMode
// FUNCTION
//   Turns lighting on or off when drawing this object.
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- 0 to turn lighting off, 1 to turn it on.
// SOURCE
void agk::SetObjectLightMode( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set light mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetLightMode( mode );
}

//****f* 3D/Objects/SetObjectScreenCulling
// FUNCTION
//   Sets whether the object will be culled when it moves off screen. By default AGK will attempt to 
//   detect when an object has moved off screen, and objects that are no longer on screen will no 
//   longer be sent to the render pipeline.
//   If the vertex shader modifies the vertices from their normal positions then this should be turned 
//   off as AGK can't know in advance where the object will be drawn.
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- 0 to turn off screen culling, 1 to turn it on (default).
// SOURCE
void agk::SetObjectScreenCulling( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set screen culling mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetScreenCulling( mode );
}

//****f* 3D/Objects/SetObjectUVOffset
// FUNCTION
//   Modifies all meshes in the object to use the specified UV offset, see <i>SetObjectMeshUVOffset</i>
//   for more information.
// INPUTS
//   objID -- The ID of the object to modify.
//   textureStage -- The texture stage of the UVs to modify, in the range 0 to 7
//   offsetU -- The offset to use in the U direction, the default is 0
//   offsetV -- The offset to use in the V direction, the default is 0
// SOURCE
void agk::SetObjectUVOffset( uint32_t objID, uint32_t textureStage, float offsetU, float offsetV )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set UV offset for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetUVOffset( textureStage, offsetU, offsetV );
}

//****f* 3D/Objects/SetObjectUVScale
// FUNCTION
//   Modifies all meshes in the object to use the specified UV scale, see <i>SetObjectMeshUVScale</i>
//   for more information.
// INPUTS
//   objID -- The ID of the object to modify.
//   textureStage -- The texture stage of the UVs to modify, in the range 0 to 7
//   scaleU -- The scale to use in the U direction, the default is 1
//   scaleV -- The scale to use in the V direction, the default is 1
// SOURCE
void agk::SetObjectUVScale( uint32_t objID, uint32_t textureStage, float scaleU, float scaleV )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set UV scale for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetUVScale( textureStage, scaleU, scaleV );
}

//****f* 3D/Objects/SetObjectFogMode
// FUNCTION
//   Turns fog on or off when drawing this object. By default all objects receive fog when it is 
//   turned on with <i>SetFogMode</i>
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- 0 to turn fog off, 1 to turn it on.
// SOURCE
void agk::SetObjectFogMode( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set fog mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetFogMode( mode );
}

//****f* 3D/Shadows/SetObjectCastShadow
// FUNCTION
//   Sets an object to cast shadows on other objects. By default this is set to 0.
//   An object can be set to cast or receive shadows or both. You can exclude individual meshes 
//   of an object from casting shadows by using <i>SetObjectMeshCastShadow</i>.
// INPUTS
//   objID -- The ID of the object to cast shadows
//   mode -- 1 to make this object cast shadows, 0 to stop it casting shadows
// SOURCE
void agk::SetObjectCastShadow( int objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shadow cast mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetShadowCastMode( mode );
}

//****f* 3D/Shadows/SetObjectReceiveShadow
// FUNCTION
//   Sets an object to receive shadows from other objects. By default this is set to 1.
//   An object can be set to cast or receive shadows or both.
// INPUTS
//   objID -- The ID of the object to receive shadows
//   mode -- 1 to make this object receive shadows, 0 to stop it receiving shadows
// SOURCE
void agk::SetObjectReceiveShadow( int objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shadow receive mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetShadowReceiveMode( mode );
}

//****f* 3D/Objects/SetObjectDepthReadMode
// FUNCTION
//   Sets the depth read mode when drawing this object to the screen. The object must pass the 
//   the depth test in order to be visible. The available options are 0=never pass, 1=less than, 
//   2=equal, 3=less than or equal, 4=greater than, 5=not equal, 6=greater than or equal, 7=always
//   pass. By default all objects use the mode 1 (less than) which means they must be closer
//   than any objects already drawn to be visible.
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- The depth mode to use for this object.
// SOURCE
void agk::SetObjectDepthReadMode( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set depth read mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetDepthReadMode( mode );
}

//****f* 3D/Objects/SetObjectDepthWrite
// FUNCTION
//   Sets the depth write mode when drawing this object to the screen. If it passes the depth test
//   the object writes its depth value to the depth buffer to stop anything further behind from
//   passing their depth tests. By default only objects that are closer (less than) the current
//   depth value will overwrite the current contents of the screen.
//   You can turn off this writing to the depth buffer for this object, this can be useful for 
//   transparent objects that shouldn't block drawing behind themselves.
//   By default all opaque objects have depth write turned on and all transparent objects have depth
//   write turned off.
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- 0 to turn depth write off for this object, 1 to turn it on.
// SOURCE
void agk::SetObjectDepthWrite( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set depth write mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetDepthWrite( mode );
}

//****f* 3D/Objects/SetObjectDepthBias
// FUNCTION
//   Sets the depth bias when drawing this object to the screen. If two objects are very close
//   together, one in front of the other, they can cause Z fighting where they appear to flicker
//   between one object and the other being displayed in front of each other. For example a 
//   decal on the surface of another object. Z bias is designed to prevent this flickering by
//   forcing (biasing) one object to always be in front of, or behind, the other. The bias value
//   should be positive to bring this object towards the camera, and negative to push it 
//   backwards. This does not actually affect the position of the object, only its perceived 
//   position when the rendering system tests to see if the object should be drawn or not. If 
//   the object passes this biased depth test then it is drawn at its original position.
//   The bias value is in multiples of the smallest z buffer value, so a bias value of 1 is the
//   recommended value. Values smaller than this are not likely to have any effect, values 
//   bigger than this can be tried if a value of 1 does not work, try 1.5, 2.0, etc.
// INPUTS
//   objID -- The ID of the object to modify.
//   bias -- The bias amount, 0 to turn depth biasing off for this object.
// SOURCE
void agk::SetObjectDepthBias( uint32_t objID, float bias )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set depth bias for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetDepthBias( bias );
}

//****f* 3D/Objects/SetObjectDepthRange
// FUNCTION
//   Sets the range of depth values that this object is mapped to. By default this is 0 to 1 where
//   0 is the near plane and 1 is the far plane. For example setting a depth range of 1,1 will make 
//   every pixel in this object have a depth value of 1 when comparing and writing to the depth 
//   buffer. Values will be clamped to the range 0 to 1, objects outside the near or far planes will 
//   still be clipped.
//   Reverse mappings are allowed by setting near greater than far.
// INPUTS
//   objID -- The ID of the object to modify.
//   zNear -- The start of the depth range for this object
//   zFar -- The end of the depth range for this object
// SOURCE
void agk::SetObjectDepthRange( uint32_t objID, float zNear, float zFar )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set depth range for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetDepthRange( zNear, zFar );
}

//****f* 3D/Objects/SetObjectTransparency
// FUNCTION
//   Sets the transparency mode for this object, 0 is opaque, 1 is alpha blended, 2 is additive blended, 
//   3 is custom blending. Using a transparency value greater than 0 will slow down rendering, it also 
//	 doesn't write transparent objects to the Z buffer so it might cause some depth ordering problems.   
//   There is an alternative form of transparency called Alpha Masking that is useful if you only need
//   fully transparent or fully opaque pixels but no blending in between. See <i>SetObjectAlphaMask</i>
//   for more details.<br/><br/>
//
//   When using mode 3 (custom) the blend values must be specified with <i>SetObjectBlendModes</i>
//   otherwise the object will not be transparent.
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- The transparency mode to use for this object.
// SOURCE
void agk::SetObjectTransparency( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set transparency mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetTransparency( mode );
}

//****f* 3D/Objects/SetObjectBlendModes
// FUNCTION
//   When <i>SetObjectTransparency<i/> is set to 3 then the source and destination blend values can be
//   specified manually using this command. The blend modes available are as follows:<br/>
//    0 = 0<br/>
//    1 = 1<br/>
//    2 = Source Pixel Alpha<br/>
//    3 = 1 - Source Pixel Alpha<br/>
//    4 = Destination Pixel Alpha<br/>
//    5 = 1 - Destination Pixel Alpha<br/>
//    6 = Source Pixel Color (valid for destination mode only)<br/>
//    7 = 1 - Source Pixel Color (valid for destination mode only)<br/>
//    8 = Destination Pixel Color (valid for source mode only)<br/>
//    9 = 1 - Destination Pixel Color (valid for source mode only)<br/>
//    10 = Alpha Saturate (valid for source mode only)<br/>
//   The source pixel will be multiplied by the source mode, and the destination pixel will be multiplied
//   by the destination mode. The two will then be added together to make the final pixel color. The source
//   pixel is the pixel belonging to the object being drawn, whilst the destination pixel is the color of 
//   the pixel already on screen, which the current object is being drawn over.
// INPUTS
//   objID -- The ID of the object to modify.
//   src -- The blend mode to use for the source of the blend.
//   dst -- The blend mode to use for the destination of the blend.
// SOURCE
void agk::SetObjectBlendModes( uint32_t objID, int src, int dst )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set blend modes for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetBlendModes( src, dst );
}

//****f* 3D/Objects/SetObjectAlphaMask
// FUNCTION
//   Sets alpha masking on or off for this object. This is similar to transparency but only produces fully
//   transparent or fully opaque pixels, there are no blended or semi-transparent pixels. If a pixel has an
//   alpha value less than 128 it will be ignored, if it is greater than or equal to 128 then it will be drawn.
//   This has less problems with depth ordering than when using <i>SetObjectTransparency</i> but may be 
//   slightly slower in some cases. You should not use both transparency and alpha masking on the same object 
//   at the same time, only use one or the other.
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- 1=use alpha masking, 0=turn off alpha masking.
// SOURCE
void agk::SetObjectAlphaMask( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set alpha mask mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetAlphaMask( mode );
}

//****f* 3D/Objects/SetObjectCullMode
// FUNCTION
//   Sets whether this object should draw its back faces when rendering. Use mode 0=both front and back 
//   drawn, 1=only front faces, 2=only back faces. By default only front faces are drawn (mode 1).
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- The cull mode to use for this object.
// SOURCE
void agk::SetObjectCullMode( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set cull mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetCullMode( mode );
}

//****f* 3D/Objects/SetObjectVisible
// FUNCTION
//   Sets whether this object is visible or not. It will still participate in collisions and other 
//   non-visual interactions.
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- 1 to set this object as visible, 0 to hide it.
// SOURCE
void agk::SetObjectVisible( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set visibility for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetVisible( mode );
}

//****f* 3D/Objects/GetObjectDepthReadMode
// FUNCTION
//   Returns the current depth read mode for this object
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectDepthReadMode( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get depth read mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetDepthReadMode();
}

//****f* 3D/Objects/GetObjectDepthWrite
// FUNCTION
//   Returns the current depth write mode for this object
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectDepthWrite( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get depth write mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetDepthWrite();
}

//****f* 3D/Objects/GetObjectDepthBias
// FUNCTION
//   Returns the current depth bias for this object
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
float agk::GetObjectDepthBias( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get depth bias for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetDepthBias();
}

//****f* 3D/Objects/GetObjectTransparency
// FUNCTION
//   Returns the current transparency mode for this object
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectTransparency( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get transparency mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetTransparency();
}

//****f* 3D/Objects/GetObjectCullMode
// FUNCTION
//   Returns the current cull mode for this object
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectCullMode( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get cull mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetCullMode();
}

//****f* 3D/Objects/GetObjectVisible
// FUNCTION
//   Returns the current visibility mode for this object
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectVisible( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get visibility for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetVisible();
}

//****f* 3D/Objects/GetObjectInScreen
// FUNCTION
//   Returns 1 if AGK thinks the object is currently on screen, 0 if not. This is an estimate 
//   and if in doubt will assume the object is on screen. As such if this command returns 0 
//   then the object is definitely off screen, if it returns 1 the object may or may not be on
//   screen.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectInScreen( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to GetObjectInScreen for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetInScreen();
}

//****f* 3D/Shadows/GetObjectCastShadowMode
// FUNCTION
//   Returns 1 if the object is currently set to cast shadows, 0 otherwise.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectCastShadowMode( int objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to GetObjectCastShadowMode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->DoesCastShadows();
}

//****f* 3D/Shadows/GetObjectReceiveShadowMode
// FUNCTION
//   Returns 1 if the object is currently set to receive shadows, 0 otherwise.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectReceiveShadowMode( int objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to GetObjectReceiveShadowMode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->DoesReceiveShadows();
}

//****f* 3D/Objects/GetObjectColorRed
// FUNCTION
//   Returns the current red value of this object's color, as set by <i>SetObjectColor</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectColorRed( int objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to GetObjectColorRed for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetColorRed();
}

//****f* 3D/Objects/GetObjectColorGreen
// FUNCTION
//   Returns the current green value of this object's color, as set by <i>SetObjectColor</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectColorGreen( int objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to GetObjectColorGreen for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetColorGreen();
}

//****f* 3D/Objects/GetObjectColorBlue
// FUNCTION
//   Returns the current blue value of this object's color, as set by <i>SetObjectColor</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectColorBlue( int objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to GetObjectColorBlue for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetColorBlue();
}

//****f* 3D/Objects/GetObjectAlpha
// FUNCTION
//   Returns the current alpha value of this object's color, as set by <i>SetObjectColor</i> or <i>SetObjectAlpha</i>.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
int agk::GetObjectAlpha( int objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to GetObjectAlpha for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pObject->GetAlpha();
}

//****f* 3D/Objects/GetObjectName
// FUNCTION
//   Returns the name of the object as defined in the model file. This is useful when using <i>LoadObjectWithChildren</i>
//   to identify child objects which can be accessed with <i>GetObjectChildID</i>. <br>
//   If you are calling this command from Tier 2 then the returned string must be deleted with agk::DeleteString when you 
//   are done with it.
// INPUTS
//   objID -- The ID of the object to check.
// SOURCE
char* agk::GetObjectName( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get object name for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		char *str = new char[1]; *str = 0;
		return str;
	}

	const char *szName = pObject->GetName();
	char *str = new char[ strlen(szName)+1 ];
	strcpy( str, szName );
	return str;
}

//****f* 3D/Objects/SetObjectShaderConstantByName
// FUNCTION
//   Sets a shader constant for an object by name, the constant must be marked as "uniform" in the shader source.
//   The object will use the specified value with any shader that is applied to the object. This value will not 
//   affect any other objects that use that shader.
//   All shader values have 1 to 4 components, this command accepts 4 values and discards any that are not used 
//   by the named variable.
// INPUTS
//   objID -- The ID of the object to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   value1 -- The X or R component of the new value, this value will always be used.
//   value2 -- The Y or G component of the new value, if the constant only uses 1 component this value is discarded.
//   value3 -- The Z or B component of the new value, if the constant only uses 2 components this value is discarded.
//   value4 -- The W or A component of the new value, if the constant only uses 3 components this value is discarded.
// SOURCE
void agk::SetObjectShaderConstantByName( uint32_t objID, const char *szName, float value1, float value2, float value3, float value4 )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shader constant for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetShaderConstantByName( szName, value1, value2, value3, value4 );
}

//****f* 3D/Objects/SetObjectShaderConstantArrayByName
// FUNCTION
//   This command is deprecated, it is an exact copy of <i>SetObjectShaderConstantArrayVec4ByName</i>.
// INPUTS
//   objID -- The ID of the object to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The index of the element within the array to modify.
//   value1 -- The X or R component of the new value
//   value2 -- The Y or G component of the new value
//   value3 -- The Z or B component of the new value
//   value4 -- The W or A component of the new value
// SOURCE
void agk::SetObjectShaderConstantArrayByName( uint32_t objID, const char *szName, uint32_t arrayIndex, float value1, float value2, float value3, float value4 )
//****
{
	SetObjectShaderConstantArrayVec4ByName( objID, szName, arrayIndex, value1, value2, value3, value4 );
}

//****f* 3D/Objects/SetObjectShaderConstantArrayFloatByName
// FUNCTION
//   Sets a shader constant array index for an object by name, the constant must be marked as "uniform" in the shader source.
//   The object will use the specified value with any shader that is applied to the object. This value will not 
//   affect any other objects that use that shader.
//   Array indices start at 0, if the array index exceeds the size of the array defined in the shader then the result is undefined.
//   This command can only set arrays of floats.
// INPUTS
//   objID -- The ID of the object to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The element of the array to modify.
//   value -- The new value to use
// SOURCE
void agk::SetObjectShaderConstantArrayFloatByName( uint32_t objID, const char *szName, uint32_t arrayIndex, float value )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shader constant for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetShaderConstantArrayByName( szName, arrayIndex, 1, value, 0, 0, 0 );
}

//****f* 3D/Objects/SetObjectShaderConstantArrayVec2ByName
// FUNCTION
//   Sets a shader constant array index for an object by name, the constant must be marked as "uniform" in the shader source.
//   The object will use the specified value with any shader that is applied to the object. This value will not 
//   affect any other objects that use that shader.
//   Array indices start at 0, if the array index exceeds the size of the array defined in the shader then the result is undefined.
//   This command can only set arrays of vec2.
// INPUTS
//   objID -- The ID of the object to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The element of the array to modify.
//   value1 -- The X component of the new value
//   value2 -- The Y component of the new value
// SOURCE
void agk::SetObjectShaderConstantArrayVec2ByName( uint32_t objID, const char *szName, uint32_t arrayIndex, float value1, float value2 )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shader constant for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetShaderConstantArrayByName( szName, arrayIndex, 2, value1, value2, 0, 0 );
}

//****f* 3D/Objects/SetObjectShaderConstantArrayVec3ByName
// FUNCTION
//   Sets a shader constant array index for an object by name, the constant must be marked as "uniform" in the shader source.
//   The object will use the specified value with any shader that is applied to the object. This value will not 
//   affect any other objects that use that shader.
//   Array indices start at 0, if the array index exceeds the size of the array defined in the shader then the result is undefined.
//   This command can only set arrays of vec3.<br/><br/>
//   Note that arrays of vec3 have an inefficient use of space and are padded to vec4, so may be slghtly slower
//   than using an array of vec4.
// INPUTS
//   objID -- The ID of the object to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The element of the array to modify.
//   value1 -- The X component of the new value
//   value2 -- The Y component of the new value
//   value3 -- The Z component of the new value
// SOURCE
void agk::SetObjectShaderConstantArrayVec3ByName( uint32_t objID, const char *szName, uint32_t arrayIndex, float value1, float value2, float value3 )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shader constant for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetShaderConstantArrayByName( szName, arrayIndex, 3, value1, value2, value3, 0 );
}

//****f* 3D/Objects/SetObjectShaderConstantArrayVec4ByName
// FUNCTION
//   Sets a shader constant array index for an object by name, the constant must be marked as "uniform" in the shader source.
//   The object will use the specified value with any shader that is applied to the object. This value will not 
//   affect any other objects that use that shader.
//   Array indices start at 0, if the array index exceeds the size of the array defined in the shader then the result is undefined.
//   This command can only set arrays of vec4.
// INPUTS
//   objID -- The ID of the object to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The element of the array to modify.
//   value1 -- The X component of the new value
//   value2 -- The Y component of the new value
//   value3 -- The Z component of the new value
//   value4 -- The W component of the new value
// SOURCE
void agk::SetObjectShaderConstantArrayVec4ByName( uint32_t objID, const char *szName, uint32_t arrayIndex, float value1, float value2, float value3, float value4 )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shader constant for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetShaderConstantArrayByName( szName, arrayIndex, 4, value1, value2, value3, value4 );
}

//****f* 3D/Objects/SetObjectShaderConstantDefault
// FUNCTION
//   Stops an object setting the given constant name in its shaders and uses the shader's default value from now on.
// INPUTS
//   objID -- The ID of the object to modify.
//   szName -- The name of the constant to stop changing.
// SOURCE
void agk::SetObjectShaderConstantDefault( uint32_t objID, const char *szName )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set shader constant default for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetShaderConstantDefault( szName );
}

//****f* 3D/Objects/DrawObject
// FUNCTION
//   Immediately draws the object to the current render target at its current position, size, and rotation. 
//   This is useful if you want to draw particular objects like sky boxes before any other objects. In this 
//   case be sure to make the object invisible for calls to Render() or Sync() otherwise the object may 
//   appear twice.
// INPUTS
//   objID -- The ID of the object to draw.
// SOURCE
void agk::DrawObject( uint32_t objID )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to draw object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	return pObject->Draw();
}

//****f* 3D/Objects/GetScreenXFrom3D
// FUNCTION
//   Converts a 3D point into screen coordinates.
// INPUTS
//   x -- The X component of the 3D point.
//   y -- The Y component of the 3D point.
//   z -- The Z component of the 3D point.
// SOURCE
float agk::GetScreenXFrom3D( float x, float y, float z )
//****
{
	if ( !m_pCurrentCamera ) return 0;

	AGKVector4 vec4(x,y,z,1);
	vec4.vec -= m_cCameraList.GetItem( 1 )->posFinal();
	vec4.vec.Mult( -(m_cCameraList.GetItem( 1 )->rotFinal()) );
	vec4.Mult( *(m_pCurrentCamera->GetProjMatrix()) );
		
	x = vec4.vec.x/vec4.w;
	x = (x + 1)/2;
	x = x * (m_iDisplayWidth + 2*m_iDisplayExtraX) - m_iDisplayExtraX;
	return x;
}

//****f* 3D/Objects/GetScreenYFrom3D
// FUNCTION
//   Converts a 3D point into screen coordinates.
// INPUTS
//   x -- The X component of the 3D point.
//   y -- The Y component of the 3D point.
//   z -- The Z component of the 3D point.
// SOURCE
float agk::GetScreenYFrom3D( float x, float y, float z )
//****
{
	if ( !m_pCurrentCamera ) return 0;

	AGKVector4 vec4(x,y,z,1);
	vec4.vec -= m_cCameraList.GetItem( 1 )->posFinal();
	vec4.vec.Mult( -(m_cCameraList.GetItem( 1 )->rotFinal()) );
	vec4.Mult( *(m_pCurrentCamera->GetProjMatrix()) );

	if ( m_pCurrentCamera->IsInverted() ) vec4.vec.y = -vec4.vec.y;
	if ( g_pRenderer->IsTopLeftOrigin() ) vec4.vec.y = -vec4.vec.y;
	
	y = vec4.vec.y/vec4.w;
	y = (y + 1)/2;
	y = (1-y);
	y = y * (m_iDisplayHeight + 2*m_iDisplayExtraY) - m_iDisplayExtraY;
	return y;
}

//****f* 3D/Objects/Get3DVectorXFromScreen
// FUNCTION
//   Converts a 2D point on the screen into a vector pointing into the 3D world.
//   The vector is normalised to 1 unit long, to extend it into the world simply multiply
//   it by your desired distance.<br/>
//   <br/>
//   If the camera is using an orthographic projection matrix then this command behaves 
//   slightly differently, since all points on the screen would produce the same vector
//   pointing away from the camera, but each originating from a different point in 3D 
//   space. This differs from a perspective projection where all vectors start at the 
//   camera position and fan out as they move away from the camera. So when using an 
//   orthographic projection matrix this command will instead return a sideways unnormalised 
//   vector from the camera position to the point in 3D space that the vector should start. 
//   This can then be combined with a vector that points away from the camera to create a ray 
//   cast into the scene.
// INPUTS
//   x -- The X component of the screen position.
//   y -- The Y component of the screen position.
// SOURCE
float agk::Get3DVectorXFromScreen( float x, float y )
//****
{
	if ( !m_pCurrentCamera ) return 0;

	x += m_iDisplayExtraX;
	x /= (m_iDisplayWidth + 2*m_iDisplayExtraX);
	x = (x*2 - 1);

	y += m_iDisplayExtraY;
	y /= (m_iDisplayHeight + 2*m_iDisplayExtraY);
	y = ((1-y)*2 - 1);

	const AGKMatrix4 *proj = m_pCurrentCamera->GetProjMatrix();
	AGKVector v;

	if ( m_pCurrentCamera->GetFOV() == 0 )
	{
		float c1 = proj->mat[0][0];
		float c2 = proj->mat[1][1];
		float c3 = proj->mat[3][0];
		float c4 = proj->mat[3][1];

		float x2 = (x-c3)/c1;
		float y2 = (y-c4)/c2;

		v.Set( x2, y2, 0 );
	}
	else
	{
		float c1 = proj->mat[0][0];
		float c2 = proj->mat[1][1];
		float c3 = proj->mat[2][0];
		float c4 = proj->mat[2][1];

		float x2 = (x-c3)/c1;
		float y2 = (y-c4)/c2;

		v.Set( x2, y2, 1 );
	}


	if ( m_pCurrentCamera->IsInverted() ) v.y = -v.y;
	if ( g_pRenderer->IsTopLeftOrigin() ) v.y = -v.y;

	v.Mult( m_cCameraList.GetItem( 1 )->rotFinal() );
	if ( m_pCurrentCamera->GetFOV() != 0 ) v.Normalize();
	return v.x;
}

//****f* 3D/Objects/Get3DVectorYFromScreen
// FUNCTION
//   Converts a 2D point on the screen into a vector pointing into the 3D world.
//   The vector is normalised to 1 unit long, to extend it into the world simply multiply
//   it by your desired distance.<br/>
//   <br/>
//   If the camera is using an orthographic projection matrix then this command behaves 
//   slightly differently, since all points on the screen would produce the same vector
//   pointing away from the camera, but each originating from a different point in 3D 
//   space. This differs from a perspective projection where all vectors start at the 
//   camera position and fan out as they move away from the camera. So when using an 
//   orthographic projection matrix this command will instead return a sideways unnormalised 
//   vector from the camera position to the point in 3D space that the vector should start. 
//   This can then be combined with a vector that points away from the camera to create a ray 
//   cast into the scene.
// INPUTS
//   x -- The X component of the screen position.
//   y -- The Y component of the screen position.
// SOURCE
float agk::Get3DVectorYFromScreen( float x, float y )
//****
{
	if ( !m_pCurrentCamera ) return 0;

	x += m_iDisplayExtraX;
	x /= (m_iDisplayWidth + 2*m_iDisplayExtraX);
	x = (x*2 - 1);

	y += m_iDisplayExtraY;
	y /= (m_iDisplayHeight + 2*m_iDisplayExtraY);
	y = ((1-y)*2 - 1);

	const AGKMatrix4 *proj = m_pCurrentCamera->GetProjMatrix();
	AGKVector v;

	if ( m_pCurrentCamera->GetFOV() == 0 )
	{
		float c1 = proj->mat[0][0];
		float c2 = proj->mat[1][1];
		float c3 = proj->mat[3][0];
		float c4 = proj->mat[3][1];

		float x2 = (x-c3)/c1;
		float y2 = (y-c4)/c2;

		v.Set( x2, y2, 0 );
	}
	else
	{
		float c1 = proj->mat[0][0];
		float c2 = proj->mat[1][1];
		float c3 = proj->mat[2][0];
		float c4 = proj->mat[2][1];

		float x2 = (x-c3)/c1;
		float y2 = (y-c4)/c2;
		float z2 = 1;

		v.Set( x2, y2, z2 );
	}

	if ( m_pCurrentCamera->IsInverted() ) v.y = -v.y;
	if ( g_pRenderer->IsTopLeftOrigin() ) v.y = -v.y;

	v.Mult( m_cCameraList.GetItem( 1 )->rotFinal() );
	if ( m_pCurrentCamera->GetFOV() != 0 ) v.Normalize();
	return v.y;
}

//****f* 3D/Objects/Get3DVectorZFromScreen
// FUNCTION
//   Converts a 2D point on the screen into a vector pointing into the 3D world.
//   The vector is normalised to 1 unit long, to extend it into the world simply multiply
//   it by your desired distance.<br/>
//   <br/>
//   If the camera is using an orthographic projection matrix then this command behaves 
//   slightly differently, since all points on the screen would produce the same vector
//   pointing away from the camera, but each originating from a different point in 3D 
//   space. This differs from a perspective projection where all vectors start at the 
//   camera position and fan out as they move away from the camera. So when using an 
//   orthographic projection matrix this command will instead return a sideways unnormalised 
//   vector from the camera position to the point in 3D space that the vector should start. 
//   This can then be combined with a vector that points away from the camera to create a ray 
//   cast into the scene.
// INPUTS
//   x -- The X component of the screen position.
//   y -- The Y component of the screen position.
// SOURCE
float agk::Get3DVectorZFromScreen( float x, float y )
//****
{
	if ( !m_pCurrentCamera ) return 0;

	x += m_iDisplayExtraX;
	x /= (m_iDisplayWidth + 2*m_iDisplayExtraX);
	x = (x*2 - 1);

	y += m_iDisplayExtraY;
	y /= (m_iDisplayHeight + 2*m_iDisplayExtraY);
	y = ((1-y)*2 - 1);

	const AGKMatrix4 *proj = m_pCurrentCamera->GetProjMatrix();
	AGKVector v;

	if ( m_pCurrentCamera->GetFOV() == 0 )
	{
		float c1 = proj->mat[0][0];
		float c2 = proj->mat[1][1];
		float c3 = proj->mat[3][0];
		float c4 = proj->mat[3][1];

		float x2 = (x-c3)/c1;
		float y2 = (y-c4)/c2;

		v.Set( x2, y2, 0 );
	}
	else
	{
		float c1 = proj->mat[0][0];
		float c2 = proj->mat[1][1];
		float c3 = proj->mat[2][0];
		float c4 = proj->mat[2][1];

		float x2 = (x-c3)/c1;
		float y2 = (y-c4)/c2;
		float z2 = 1;

		v.Set( x2, y2, z2 );
	}

	if ( m_pCurrentCamera->IsInverted() ) v.y = -v.y;
	if ( g_pRenderer->IsTopLeftOrigin() ) v.y = -v.y;

	v.Mult( m_cCameraList.GetItem( 1 )->rotFinal() );
	if ( m_pCurrentCamera->GetFOV() != 0 ) v.Normalize();
	return v.z;
}


// collision

//****f* 3D/Objects/SetObjectCollisionMode
// FUNCTION
//   Sets collision detection on or off for this object.
// INPUTS
//   objID -- The ID of the object to modify.
//   mode -- 0 to turn collision off, 1 to turn it on.
// SOURCE
void agk::SetObjectCollisionMode( uint32_t objID, int mode )
//****
{
	cObject3D *pObject = m_cObject3DList.GetItem( objID );
	if ( !pObject )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set collision mode for object " );
		errStr.AppendUInt( objID ).Append( " - object does not exist" );
		Error( errStr );
#endif
		return;
	}

	pObject->SetCollisionMode( mode );
}

//****f* 3D/Objects/ObjectRayCast
// FUNCTION
//   Casts a ray through 1 or all objects to check for intersection with the object.
//   Rays are define with a start position and an end position and does not collide 
//   with backfaces, will return the number of the object hit first, or 0 for no collision.
//
//   Ray casting commands are useful for calculating the collisions of bullets with
//   levels and objects, or for representing the line of sight of an enemy to detect
//   if they can see the player.
// INPUTS
//   objID -- The ID of the object to check, 0 for all objects.
//   oldx -- The X component of the start position.
//   oldy -- The Y component of the start position.
//   oldz -- The Z component of the start position.
//   newx -- The X component of the end position.
//   newy -- The Y component of the end position.
//   newz -- The Z component of the end position.
// SOURCE
int agk::ObjectRayCast( uint32_t objID, float oldx, float oldy, float oldz, float newx, float newy, float newz )
//****
{
	m_cCollisionResults.reset( 1000000000 );

	AGKVector p( oldx, oldy, oldz );
	AGKVector v( newx-oldx, newy-oldy, newz-oldz );
	AGKVector vn( v );
	vn.Normalize();

	int hit = 0;

	if ( objID == 0 )
	{
		// all objects
		cObject3D *pObject = m_cObject3DList.GetFirst();
		while ( pObject )
		{
			if ( pObject->RayCast(  p, v, vn, &m_cCollisionResults ) ) hit = 1;

			pObject = m_cObject3DList.GetNext();
		}
	}
	else
	{
		// single object
		cObject3D *pObject = m_cObject3DList.GetItem( objID );
		if ( pObject ) hit = pObject->RayCast(  p, v, vn, &m_cCollisionResults ) ? 1 : 0;
	}

	if ( hit ) 
	{
        AGKVector p2( newx, newy, newz );
        m_cCollisionResults.completeResults( &p2, &v );
        if ( objID == 0 ) { hit = m_cCollisionResults.getObj(0); }
        else { hit = 1; }
    }

	return hit;
}

bool agk::InternalSphereCast( uint32_t objID, const AGKVector &p, const AGKVector &v, float radius )
{
	AGKVector vn( v );
	vn.Normalize();

	bool hit = false;

	if ( objID == 0 )
	{
		// all objects
		cObject3D *pObject = m_cObject3DList.GetFirst();
		while ( pObject )
		{
			if ( pObject->SphereCast( p, v, vn, radius, &m_cCollisionResults ) ) hit = true;

			pObject = m_cObject3DList.GetNext();
		}
	}
	else
	{
		// single object
		cObject3D *pObject = m_cObject3DList.GetItem( objID );
		if ( pObject ) hit = pObject->SphereCast( p, v, vn, radius, &m_cCollisionResults );
	}

	return hit;
}

//****f* 3D/Objects/ObjectSphereCast
// FUNCTION
//   Will check if the ray starting at oldx,oldy,oldz and ending at
//   newx, newy, newz, and of width radius, collides with the specified object (objID=0 for all).
//   Does not collide with backfaces, will return the number of the object
//   hit first, or 0 for no collision.
//
//   Sphere casting commands add a width dimension to normal ray casting which can be used
//   to check if a player has hit anything during movement and to position them at the collision
//   point to provide 'sticky' collision, where the player stops if they hit anything. The
//   alternative is sliding collision. see <i>ObjectSphereSlide</i>
// INPUTS
//   objID -- The ID of the object to check, 0 for all objects.
//   oldx -- The X component of the start position.
//   oldy -- The Y component of the start position.
//   oldz -- The Z component of the start position.
//   newx -- The X component of the end position.
//   newy -- The Y component of the end position.
//   newz -- The Z component of the end position.
//   radius -- The radius of the sphere to cast.
// SOURCE
int agk::ObjectSphereCast( uint32_t objID, float oldx, float oldy, float oldz, float newx, float newy, float newz, float radius )
//****
{
	m_cCollisionResults.reset( 1000000000 );

	AGKVector p( oldx, oldy, oldz );
	AGKVector v( newx-oldx, newy-oldy, newz-oldz );
	
	int hit = agk::InternalSphereCast( objID, p, v, radius ) ? 1 : 0;

	if ( hit ) 
	{
        AGKVector p2( newx, newy, newz );
        m_cCollisionResults.completeResults( &p2, &v );
        if ( objID == 0 ) { hit = m_cCollisionResults.getObj(0); }
        else { hit = 1; }
    }

	return hit;
}

//****f* 3D/Objects/ObjectSphereSlide
// FUNCTION
//   This command does the same as ObjectSphereCast but over multiple iterations to produce
//   a slide point for use in sliding collisions.
//
//   It produces a slide point that is checked again to make sure this new
//   point does not collide with any objects. This produces another point, which must be checked
//   and so on. ObjectSphereSlide uses a maximum of three iterations to finalize a point that
//   will keep the sphere outside all objects checked.

//   The command GetObjectRayCastNumHits can be used to get the number of iterations used by
//   this command. Details of the collision point, normal, and slide point for each iteration
//   are also available using collision indices 1 to 3 i.e. GetObjectRayCastX(1) (2) or (3). 
//   The final collision point, normal and slide point are in index 0, i.e. GetObjectRayCastSlideX(0).
// INPUTS
//   objID -- The ID of the object to check, 0 for all objects.
//   oldx -- The X component of the start position.
//   oldy -- The Y component of the start position.
//   oldz -- The Z component of the start position.
//   newx -- The X component of the end position.
//   newy -- The Y component of the end position.
//   newz -- The Z component of the end position.
//   radius -- The radius of the sphere to cast.
// SOURCE
int agk::ObjectSphereSlide( uint32_t objID, float oldx, float oldy, float oldz, float newx, float newy, float newz, float radius )
//****
{
	int finalHit = 0;
	
	AGKVector p( oldx, oldy, oldz );
	AGKVector v( newx-oldx, newy-oldy, newz-oldz );

	if ( m_cCollisionResults.getMaxCollisions() < 4 ) m_cCollisionResults.setMaxCollisions( 4 );
	m_cCollisionResults.reset( 1000000000 );
	
	bool hit = agk::InternalSphereCast( objID, p, v, radius );
	if ( hit )
	{
		if ( objID == 0 ) finalHit = m_cCollisionResults.getObj(0);
		else finalHit = 1;

		AGKVector p2( newx, newy, newz );
		m_cCollisionResults.completeResults( &p2, &v );

		AGKVector intersect, slide, normal, slideVec;
        m_cCollisionResults.storePoints(0,&intersect,&normal,&slide);
        m_cCollisionResults.copyElements(0,1);
        slideVec = slide - intersect;
		
        m_cCollisionResults.reset(1000000000);
		hit = InternalSphereCast( objID, intersect, slideVec, radius );
        if ( !hit )
		{
			intersect += slideVec;
            m_cCollisionResults.setSlidePoint(1,&intersect);
            m_cCollisionResults.copyElements(1,0);
            m_cCollisionResults.setNumCols(1);
		}
		else
		{
			m_cCollisionResults.completeResults( &p2, &v );

			AGKVector normal2;
            m_cCollisionResults.storePoints(0,&intersect,&normal2,&slide);
            m_cCollisionResults.copyElements(0,2);
            slideVec = slide - intersect;
            
            AGKVector v1;
            float dist = normal.Dot( slideVec );
            
            if ( dist < 0.00001 ) 
			{
				slideVec.FlattenToCrossVector( normal, normal2 );
				
                intersect.x += normal.x*(agk::Abs(intersect.x)*0.00001f);
				intersect.y += normal.y*(agk::Abs(intersect.y)*0.00001f);
				intersect.z += normal.z*(agk::Abs(intersect.z)*0.00001f);
			}

			m_cCollisionResults.reset(1000000000);
			hit = agk::InternalSphereCast( objID, intersect, slideVec, radius );
            if ( !hit )
			{
				intersect += slideVec;
                m_cCollisionResults.setSlidePoint(2,&intersect);
                m_cCollisionResults.copyElements(2,0);
                m_cCollisionResults.setNumCols(2);
			}
			else
			{
				m_cCollisionResults.completeResults( &p2, &v );
                
                AGKVector normal3;
                m_cCollisionResults.storePoints(0,&intersect,&normal3,&slide);
                m_cCollisionResults.copyElements(0,3);
                slideVec = slide - intersect;
                
                dist = normal.Dot( slideVec );
                float dist2 = normal2.Dot( slideVec );
                
                if ( dist < 0.00001f && dist2 < 0.00001f ) slideVec.Set(0,0,0);
                else
                {
                    if ( dist < 0.00001f )
                    {
                        slideVec.FlattenToCrossVector( normal, normal3 );
                        if ( normal2.Dot( slideVec ) < 0.00001f ) slideVec.Set(0,0,0);
                    }
                    if ( dist2 < 0.00001f )
                    {
                        slideVec.FlattenToCrossVector( normal2, normal3 );
                        if ( normal.Dot( slideVec ) < 0.00001f ) slideVec.Set(0,0,0);
                    }
                }
                
                intersect += slideVec;
                m_cCollisionResults.setSlidePoint(3,&intersect);
                m_cCollisionResults.copyElements(3,0);
                m_cCollisionResults.setNumCols(3);
			}		
		}
	}

	return finalHit;
}

//****f* 3D/Objects/GetObjectRayCastNumHits
// FUNCTION
//   Returns the number of collisions that occurred in the last collision check.
//   In the case of ObjectRayCast and ObjectSphereCast this will be 0 or 1.
//   For ObjectSphereSlide this could be anywhere between 0 and 4.
// SOURCE
uint32_t agk::GetObjectRayCastNumHits()
//****
{
	return m_cCollisionResults.getNumCols();
}

//****f* 3D/Objects/GetObjectRayCastHitID
// FUNCTION
//   Returns the object ID hit for the given collision index in the last collision check.
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
uint32_t agk::GetObjectRayCastHitID( uint32_t index )
//****
{
	return m_cCollisionResults.getObj( index );
}

//****f* 3D/Objects/GetObjectRayCastX
// FUNCTION
//   Returns the X component of the point of collision for the given collision index in the last collision check.
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastX( uint32_t index )
//****
{
	return m_cCollisionResults.getIntersectX( index );
}

//****f* 3D/Objects/GetObjectRayCastY
// FUNCTION
//   Returns the Y component of the point of collision for the given collision index in the last collision check.
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastY( uint32_t index )
//****
{
	return m_cCollisionResults.getIntersectY( index );
}

//****f* 3D/Objects/GetObjectRayCastZ
// FUNCTION
//   Returns the Z component of the point of collision for the given collision index in the last collision check.
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastZ( uint32_t index )
//****
{
	return m_cCollisionResults.getIntersectZ( index );
}

//****f* 3D/Objects/GetObjectRayCastSlideX
// FUNCTION
//   Returns the X component of the final resting point for sliding collisions. This is only
//   valid for index 0 and after calling ObjectSphereSlide. Position an object here to make it 
//   look like it slid after colliding.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastSlideX( uint32_t index )
//****
{
	return m_cCollisionResults.getSlideX( index );
}

//****f* 3D/Objects/GetObjectRayCastSlideY
// FUNCTION
//   Returns the Y component of the final resting point for sliding collisions. This is only
//   valid for index 0 and after calling ObjectSphereSlide. Position an object here to make it 
//   look like it slid after colliding.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastSlideY( uint32_t index )
//****
{
	return m_cCollisionResults.getSlideY( index );
}

//****f* 3D/Objects/GetObjectRayCastSlideZ
// FUNCTION
//   Returns the Z component of the final resting point for sliding collisions. This is only
//   valid for index 0 and after calling ObjectSphereSlide. Position an object here to make it 
//   look like it slid after colliding.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastSlideZ( uint32_t index )
//****
{
	return m_cCollisionResults.getSlideZ( index );
}

//****f* 3D/Objects/GetObjectRayCastNormalX
// FUNCTION
//   Returns the X component of the collision normal in the last collision check. 
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastNormalX( uint32_t index )
//****
{
	return m_cCollisionResults.getNormalX( index );
}

//****f* 3D/Objects/GetObjectRayCastNormalY
// FUNCTION
//   Returns the Y component of the collision normal in the last collision check. 
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastNormalY( uint32_t index )
//****
{
	return m_cCollisionResults.getNormalY( index );
}

//****f* 3D/Objects/GetObjectRayCastNormalZ
// FUNCTION
//   Returns the Z component of the collision normal in the last collision check. 
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastNormalZ( uint32_t index )
//****
{
	return m_cCollisionResults.getNormalZ( index );
}

//****f* 3D/Objects/GetObjectRayCastBounceX
// FUNCTION
//   Returns the X component of the bounce vector for the last collision check. 
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
//   Position an object here to make it look like it bounced after colliding.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastBounceX( uint32_t index )
//****
{
	return m_cCollisionResults.getBounceX( index );
}

//****f* 3D/Objects/GetObjectRayCastBounceY
// FUNCTION
//   Returns the Y component of the bounce vector for the last collision check. 
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
//   Position an object here to make it look like it bounced after colliding.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastBounceY( uint32_t index )
//****
{
	return m_cCollisionResults.getBounceY( index );
}

//****f* 3D/Objects/GetObjectRayCastBounceZ
// FUNCTION
//   Returns the Z component of the bounce vector for the last collision check. 
//   You can check the number of valid indices with <i>GetObjectRayCastNumHits</i>.
//   Position an object here to make it look like it bounced after colliding.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastBounceZ( uint32_t index )
//****
{
	return m_cCollisionResults.getBounceZ( index );
}

//****f* 3D/Objects/GetObjectRayCastDistance
// FUNCTION
//   Returns the distance between the start point for the ray and the collision point.
// INPUTS
//   index -- The index of the collision to check, starting at index 0.
// SOURCE
float agk::GetObjectRayCastDistance( uint32_t index )
//****
{
	return m_cCollisionResults.getDistance( index );
}


// fog

//****f* 3D/Fog/SetFogMode
// FUNCTION
//   Sets 3D fog on or off, this can be used to create an atmospheric haze or fade objects to the 
//   background color to simulate reduced visibility. Fog will be automatically applied to all 3D 
//   objects if they are using the default shader. If you have applied your own shader with 
//   <i>SetObjectShader</i> then declare the function 
//   <u>mediump vec3 ApplyFog( mediump vec3 color, highp vec3 pointPos );</u> in the pixel shader 
//   which AGK will fill in for you at run time. <u>pointPos</u> is the pixel position in world 
//   coordinates, which you will need to pass in from the vertex shader.
// INPUTS
//   mode -- 1 to turn fog on, 0 to turn it off.
// SOURCE
void agk::SetFogMode( int mode )
//****
{
	m_iFogMode = (mode == 1) ? 1 : 0;
}

//****f* 3D/Fog/SetFogColor
// FUNCTION
//   Sets the 3D fog color. Objects will gradually fade to this color as they get further from the 
//   camera. Color values should be in the range 0 to 255, but they are not limited to this and the
//   system will accept out of range values, including negative.
// INPUTS
//   red -- The red component of the color.
//   green -- The green component of the color.
//   blue -- The blue component of the color.
// SOURCE
void agk::SetFogColor( int red, int green, int blue )
//****
{
	// signed R11_G11_B10, used for comparison with m_iFogColor2 only
	m_iFogColor1 = (red & 0x7ff) << 21;
	m_iFogColor1 |= (green & 0x7ff) << 10;
	m_iFogColor1 |= (blue & 0x3ff);

	AGKShader::g_varFogColor1.SetVector3( red/255.0f, green/255.0f, blue/255.0f );
}

//****f* 3D/Fog/SetFogSunColor
// FUNCTION
//   Sets the 3D fog sun color. This is used in place of the normal fog color when the camera is 
//   facing the sun, as defined by the command <i>SetSunDirection</i>. This can be used to simulate
//   light scattering effects to make the air seem hazy. The fog sun color should be close to the 
//   sun color for best effect, but this need not be the case.
//   Note that calling this command changes the fog calculation to a more complicated version that
//   will reduce performance on mobile devices. To return to the faster method of calculating fog, 
//   make the fog sun color equal to the normal fog color.
// INPUTS
//   red -- The red component of the color.
//   green -- The green component of the color.
//   blue -- The blue component of the color.
// SOURCE
void agk::SetFogSunColor( int red, int green, int blue )
//****
{
	m_iFogColor2IsSet = 1;

	// signed R11_G11_B10, used for comparison with m_iFogColor1 only
	m_iFogColor2 = (red & 0x7ff) << 21;
	m_iFogColor2 |= (green & 0x7ff) << 10;
	m_iFogColor2 |= (blue & 0x3ff);

	AGKShader::g_varFogColor2.SetVector3( red/255.0f, green/255.0f, blue/255.0f );
}

//****f* 3D/Fog/SetFogRange
// FUNCTION
//   Sets the range of the 3D fog. No fog will occur within the minimum distance, after which the fog
//   will begin to take affect. The maximum distance is not a limit and is only a rough guide for how
//   far you want to be able to see in your scene. The fog increases exponentially to mimic reality, 
//   meaning it increases quickly at first then tails off and gradually reaches full intensity around 
//   the maximum distance.
// INPUTS
//   minDist -- The minimum distance for the fog, no fog will affect pixels within this distance from the camera.
//   maxDist -- The maximum distance for the fog, the fog will reach full intensity around this distance.
// SOURCE
void agk::SetFogRange( float minDist, float maxDist )
//****
{
	m_fFogMinDist = minDist;
	m_fFogMaxDist = maxDist;

	AGKShader::g_varFogRange.SetVector2( m_fFogMinDist, -4.0f / (m_fFogMaxDist-m_fFogMinDist) );
}

//****f* 3D/Fog/GetFogMode
// FUNCTION
//   Returns 1 if 3D fog is currently on, otherwise it returns 0.
// SOURCE
int agk::GetFogMode()
//****
{
	return m_iFogMode;
}

// not a tier 1 function, used by AGKShader.cpp:MakeFinalShader() to check if it can take shortcuts in the fog shader
int agk::GetFogColorsEqual()
{
	if ( !m_iFogColor2IsSet || m_iFogColor1 == m_iFogColor2 ) return 1;
	else return 0;
}


// sky box

//****f* 3D/SkyBox/SetSkyBoxVisible
// FUNCTION
//   Sets whether the sky box object is visible or not. By default it is not visible. The sky box will always appear
//   behind all other 3D objects and will be drawn at the maximum visible view range, which is set with 
//   <i>SetCameraRange</i>. The sky box has an optional sun that will be drawn to match the current directional light
//   direction, set with <i>SetSunDirection</i>. However it will not use the directional light color, so you can have
//   the directional light as one color and the sky box sun as another color.
// INPUTS
//   active -- 1 to show the skybox, 0 to hide it
// SOURCE
void agk::SetSkyBoxVisible( int active )
//****
{
	if ( !m_pSkyBox ) 
	{
		m_pSkyBox = new AGKSkyBox(1);
		m_cObjectMgr.SetSkyBox( m_pSkyBox );
	}

	m_pSkyBox->SetActive( active );
}

//****f* 3D/SkyBox/SetSkyBoxSkyColor
// FUNCTION
//   Sets the color that will fill the majority of the sky. By default this is 161,183,209. Colors should be in the 
//   range 0 to 255, although this is not limited and values outside this range will be accepted, including negative 
//   values.
// INPUTS
//   red -- The red component of the sky color
//   green -- The green component of the sky color
//   blue -- The blue component of the sky color
// SOURCE
void agk::SetSkyBoxSkyColor( int red, int green, int blue )
//****
{
	if ( !m_pSkyBox ) 
	{
		m_pSkyBox = new AGKSkyBox(0);
		m_cObjectMgr.SetSkyBox( m_pSkyBox );
	}

	m_pSkyBox->SetSkyColor( red/255.0f, green/255.0f, blue/255.0f );
}

//****f* 3D/SkyBox/SetSkyBoxHorizonColor
// FUNCTION
//   Sets the color that will appear at the horizon. By default this is 255,255,255. Colors should be in the range 
//   0 to 255, although this is not limited and values outside this range will be accepted, including negative 
//   values.    
// INPUTS
//   red -- The red component of the sky color
//   green -- The green component of the sky color
//   blue -- The blue component of the sky color
// SOURCE
void agk::SetSkyBoxHorizonColor( int red, int green, int blue )
//****
{
	if ( !m_pSkyBox ) 
	{
		m_pSkyBox = new AGKSkyBox(0);
		m_cObjectMgr.SetSkyBox( m_pSkyBox );
	}

	m_pSkyBox->SetHorizonColor( red/255.0f, green/255.0f, blue/255.0f );
}

//****f* 3D/SkyBox/SetSkyBoxSunColor
// FUNCTION
//   Sets the color of the sun, if visible. By default this is 255,230,179. Colors should be in the range 0 to 255, 
//   although this is not limited and values outside this range will be accepted, including negative values.
//   Note that due to the way the sun color is added to the sky color, sun colors darker than the sky color may 
//   result in an unexpected sun color where one or more color components is completely missing. If this happens
//   then scaling up the sun color, going above 255 if necessary, will remove it. The sun color has some affect on
//   the size of the sun in addition to <i>SetSkyBoxSunSize</i>, with brighter colors making it bigger.
// INPUTS
//   red -- The red component of the sky color
//   green -- The green component of the sky color
//   blue -- The blue component of the sky color
// SOURCE
void agk::SetSkyBoxSunColor( int red, int green, int blue )
//****
{
	if ( !m_pSkyBox ) 
	{
		m_pSkyBox = new AGKSkyBox(0);
		m_cObjectMgr.SetSkyBox( m_pSkyBox );
	}

	m_pSkyBox->SetSunColor( red/255.0f, green/255.0f, blue/255.0f );
}

//****f* 3D/SkyBox/SetSkyBoxHorizonSize
// FUNCTION
//   Sets the size and height of the horizon. By default the size is 4.0 and the height is 0.0. This affects
//   how high the horizon color extends before becoming the sky color. The height value is in world coordinates 
//   and everything at or below this height will be the horizon color. Above this height the horizon is blended 
//   into the sky color until at a certain point only the sky color remains. The horizon will always be at the 
//   specified height in the world, even if the camera moves up and down. 
//   The size value is not relative to any world units and needs to be set to your liking, then effective range 
//   is from 0.1 to about 50.0, but can be set higher.
//   If the view range is small then the height value will appear to have greater effect as the sky box is drawn 
//   closer to the camera than if the view range was larger. For example a horizon height of 100 with a small 
//   view range will appear very high, but when the view range is larger the camera is viewing the horizon from
//   much further away, so a height change of 100 units will have less effect.
// INPUTS
//   size -- The size of the horizon above the horizon height
//   height -- The height that the horizon starts
// SOURCE
void agk::SetSkyBoxHorizonSize( float size, float height )
//****
{
	if ( !m_pSkyBox ) 
	{
		m_pSkyBox = new AGKSkyBox(0);
		m_cObjectMgr.SetSkyBox( m_pSkyBox );
	}

	m_pSkyBox->SetHorizonSize( size, height );
}

//****f* 3D/SkyBox/SetSkyBoxSunVisible
// FUNCTION
//   Sets whether the sky box will draw a sun at the location of the current directional light. It's position
//   can be set with <i>SetSunDirection</i>, but it will not use the directional light color, you can set that 
//   separately with <i>SetSkyBoxSunColor</i>.
//   Note that setting the sun visible changes the sky box drawing calculations to make them more complicated 
//   which may have an impact on performance.
// INPUTS
//   visible -- 1 to draw the sun, 0 to hide it
// SOURCE
void agk::SetSkyBoxSunVisible( int visible )
//****
{
	if ( !m_pSkyBox ) 
	{
		m_pSkyBox = new AGKSkyBox(0);
		m_cObjectMgr.SetSkyBox( m_pSkyBox );
	}

	m_pSkyBox->SetSunVisible( visible );
}

//****f* 3D/SkyBox/SetSkyBoxSunSize
// FUNCTION
//   Sets the size of the sun and its halo, if visible. The size values are not relative to any world units and 
//   must be in the range 1.0 to 100.0. The default values are 5.0 for the sun and 50.0 for the halo.
// INPUTS
//   sun -- The size of the sun
//   halo -- The size of the halo around the sun
// SOURCE
void agk::SetSkyBoxSunSize( float sun, float halo )
//****
{
	if ( !m_pSkyBox ) 
	{
		m_pSkyBox = new AGKSkyBox(0);
		m_cObjectMgr.SetSkyBox( m_pSkyBox );
	}

	m_pSkyBox->SetSunSize( sun, halo );
}

// shaders

//****f* 3D/Shaders/SetShaderErrorMode
// FUNCTION
//   Determines what AGK should do when it encounters an error when compiling a shader, or is told to
//   load a shader that is not supported by the current device. The modes are:<br/>
//     0 = Report all compile errors and unsupported shaders as AGK errors<br/>
//     1 = Only report compile errors, unsupported shaders will fail silently<br/>
//     2 = Both compile errors and unsupported shaders will fail silently<br/>
//   If a shader fails to load silently then you can check if it was successful by using <i>GetShaderExists</i>
//   with the corresponding ID.<br/>
//   Normal AGK errors such as missing shader files or using the wrong command for the type of shader you are loading
//   will continue to report errors in the normal way regardless of the setting of shader error mode.
// INPUTS
//   mode -- The error mode to use from now on, default is 0
// SOURCE
void agk::SetShaderErrorMode( uint32_t mode )
//****
{
	if ( !g_pRenderer ) return;
	g_pRenderer->SetShaderErrorMode( mode );
}

//****f* 3D/Shaders/LoadShader
// FUNCTION
//   Loads a shader used for drawing objects. The vertex shader transforms the polygons into
//   screen space and the pixel shader determines the final color of each pixel the object covers.
//   Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically 
//   added as the first line of the shader unless you specify a "#version " line of your own. Note
//   that doing this may mean your shader does not work on all devices and platforms.
//   The global "precision" value will be added and should not be included in the shader source.
//   Returns an ID that can be used to reference this shader in other commands.<br/><br/>
//   If the current device does not support the shader then no shader will exist at the given ID,
//   you should use <i>GetShaderExists</i> to check if the load was successful. You can use
//   <i>SetShaderErrorMode</i> to set what happens when a shader is not supported or fails to compile.
// INPUTS
//   szVertexFile -- The file name of the vertex shader file, normally ending .vs
//   szPixelFile -- The file name of the pixel shader file, normally ending .ps
// SOURCE
uint32_t agk::LoadShader( const char* szVertexFile, const char* szPixelFile )
//****
{
	uint32_t shaderID = m_cShaderList.GetFreeID();
	if ( shaderID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load shader - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	LoadShader( shaderID, szVertexFile, szPixelFile );
	return shaderID;
}

//****f* 3D/Shaders/LoadShader
// FUNCTION
//   Loads a shader used for drawing objects. The vertex shader transforms the polygons into
//   screen space and the pixel shader determines the final color of each pixel the object covers.
//   Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically 
//   added as the first line of the shader unless you specify a "#version " line of your own. Note
//   that doing this may mean your shader does not work on all devices and platforms.
//   The global "precision" value will be added and should not be included in the shader source.<br/><br/>
//   If the current device does not support the shader then no shader will exist at the given ID,
//   you should use <i>GetShaderExists</i> to check if the load was successful. You can use
//   <i>SetShaderErrorMode</i> to set what happens when a shader is not supported or fails to compile.
// INPUTS
//   shaderID -- An ID used to reference this shader in other commands.
//   szVertexFile -- The file name of the vertex shader file, normally ending .vs
//   szPixelFile -- The file name of the pixel shader file, normally ending .ps
// SOURCE
void agk::LoadShader( uint32_t shaderID, const char* szVertexFile, const char* szPixelFile )
//****
{
	if ( !g_pRenderer ) 
	{
		Error( "Cannot load shaders without a renderer" );
		return;
	}

	if ( shaderID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load shader %d, ID must be greater than 0", shaderID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cShaderList.GetItem( shaderID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load shader " );
		errStr.AppendUInt( shaderID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cFile vertexFile, pixelFile;
	if ( !vertexFile.OpenToRead( szVertexFile ) )
	{
		uString info;
		info.Format( "Failed to open vertex shader file \"%s\" for reading", szVertexFile );
		agk::Error( info.GetStr() );
		return;
	}

	if ( !pixelFile.OpenToRead( szPixelFile ) )
	{
		uString info;
		info.Format( "Failed to open pixel shader file \"%s\" for reading", szPixelFile );
		agk::Error( info.GetStr() );
		return;
	}

	uint32_t length = vertexFile.GetSize();
	char *vertexSource = new char[ length+1 ];
	vertexFile.ReadData( vertexSource, length );
	vertexSource[ length ] = 0;

	length = pixelFile.GetSize();
	char *pixelSource = new char[ length+1 ];
	pixelFile.ReadData( pixelSource, length );
	pixelSource[ length ] = 0;

	vertexFile.Close();
	pixelFile.Close();

	AGKShader *pShader = g_pRenderer->LoadShader( vertexSource, pixelSource, szVertexFile, szPixelFile );

	delete [] vertexSource;
	delete [] pixelSource;

	if ( !pShader ) return;
	
	m_cShaderList.AddItem( pShader, shaderID );
}

//****f* 3D/Shaders/LoadShaderFromString
// FUNCTION
//   Loads a shader used for drawing objects. The vertex shader transforms the polygons into
//   screen space and the pixel shader determines the final color of each pixel the object covers.
//   Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically 
//   added as the first line of the shader unless you specify a "#version " line of your own. Note
//   that doing this may mean your shader does not work on all devices and platforms.
//   The global "precision" value will be added and should not be included in the shader source.
//   Returns an ID that can be used to reference this shader in other commands.<br/><br/>
//   If the current device does not support the shader then no shader will exist at the given ID,
//   you should use <i>GetShaderExists</i> to check if the load was successful. You can use
//   <i>SetShaderErrorMode</i> to set what happens when a shader is not supported or fails to compile.
// INPUTS
//   szVertexSource -- The file name of the vertex shader file, normally ending .vs
//   szPixelSource -- The file name of the pixel shader file, normally ending .ps
// SOURCE
uint32_t agk::LoadShaderFromString( const char* szVertexSource, const char* szPixelSource )
//****
{
	uint32_t shaderID = m_cShaderList.GetFreeID();
	if ( shaderID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load shader - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	LoadShaderFromString( shaderID, szVertexSource, szPixelSource );
	return shaderID;
}

//****f* 3D/Shaders/LoadShaderFromString
// FUNCTION
//   Loads a shader used for drawing objects. The vertex shader transforms the polygons into
//   screen space and the pixel shader determines the final color of each pixel the object covers.
//   Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically 
//   added as the first line of the shader unless you specify a "#version " line of your own. Note
//   that doing this may mean your shader does not work on all devices and platforms.
//   The global "precision" value will be added and should not be included in the shader source.<br/><br/>
//   If the current device does not support the shader then no shader will exist at the given ID,
//   you should use <i>GetShaderExists</i> to check if the load was successful. You can use
//   <i>SetShaderErrorMode</i> to set what happens when a shader is not supported or fails to compile.
// INPUTS
//   shaderID -- An ID used to reference this shader in other commands.
//   szVertexSource -- The file name of the vertex shader file, normally ending .vs
//   szPixelSource -- The file name of the pixel shader file, normally ending .ps
// SOURCE
void agk::LoadShaderFromString( uint32_t shaderID, const char* szVertexSource, const char* szPixelSource )
//****
{
	if ( !g_pRenderer ) 
	{
		Error( "Cannot load shaders without a renderer" );
		return;
	}

	if ( shaderID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load shader %d, ID must be greater than 0", shaderID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cShaderList.GetItem( shaderID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load shader " );
		errStr.AppendUInt( shaderID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	AGKShader *pShader = g_pRenderer->LoadShader( szVertexSource, szPixelSource, "User String", "User String" );
	if ( !pShader ) return;
	
	m_cShaderList.AddItem( pShader, shaderID );
}

//****f* 3D/Shaders/LoadFullScreenShader
// FUNCTION
//   Loads a shader used for modifying render targets, as such it only contains a pixel shader,
//   the vertex shader is automatically generated to make sure it applies to the full screen.
//   This type of shader should only be applied to objects created with <i>CreateObjectQuad</i>
//   but nothing bad will happen if you choose to apply it to other objects, it will just produce
//   unusual rendering results for that object.
//   Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically 
//   added as the first line of the shader unless you specify a "#version " line of your own. Note
//   that doing this may mean your shader does not work on all devices and platforms.
//   The global "precision" value will be added and should not be included in the shader source.
//   Returns an ID that can be used to reference this shader in other commands. IDs are shared across
//   all shader types so loading a full screen shader into ID 1 will not work if a normal shader 
//   exists with ID 1.<br/><br/>
//   If the current device does not support the shader then no shader will exist at the given ID,
//   you should use <i>GetShaderExists</i> to check if the load was successful. You can use
//   <i>SetShaderErrorMode</i> to set what happens when a shader is not supported or fails to compile.
// INPUTS
//   szPixelFile -- The file name of the pixel shader file, normally ending .ps
// SOURCE
uint32_t agk::LoadFullScreenShader( const char* szPixelFile )
//****
{
	uint32_t shaderID = m_cShaderList.GetFreeID();
	if ( shaderID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load full screen shader - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	LoadFullScreenShader( shaderID, szPixelFile );
	return shaderID;
}

//****f* 3D/Shaders/LoadFullScreenShader
// FUNCTION
//   Loads a shader used for modifying render targets, as such it only contains a pixel shader,
//   the vertex shader is automatically generated to make sure it applies to the full screen.
//   This type of shader should only be applied to objects created with <i>CreateObjectQuad</i>
//   but nothing bad will happen if you choose to apply it to other objects, it will just produce
//   unusual rendering results for that object.
//   Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically 
//   added as the first line of the shader unless you specify a "#version " line of your own. Note
//   that doing this may mean your shader does not work on all devices and platforms.
//   The global "precision" value will be added and should not be included in the shader source.
//   IDs are shared across all shader types so loading a full screen shader into ID 1 will not 
//   work if a normal shader exists with ID 1.<br/><br/>
//   If the current device does not support the shader then no shader will exist at the given ID,
//   you should use <i>GetShaderExists</i> to check if the load was successful. You can use
//   <i>SetShaderErrorMode</i> to set what happens when a shader is not supported or fails to compile.
// INPUTS
//   shaderID -- An ID used to reference this shader in other commands.
//   szPixelFile -- The file name of the pixel shader file, normally ending .ps
// SOURCE
void agk::LoadFullScreenShader( uint32_t shaderID, const char* szPixelFile )
//****
{
	if ( !g_pRenderer ) 
	{
		Error( "Cannot load shaders without a renderer" );
		return;
	}

	if ( shaderID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load full screen shader %d, ID must be greater than 0", shaderID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cShaderList.GetItem( shaderID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load full screen shader " );
		errStr.AppendUInt( shaderID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cFile pixelFile;
	if ( !pixelFile.OpenToRead( szPixelFile ) )
	{
		uString info;
		info.Format( "Failed to open pixel shader file \"%s\" for reading", szPixelFile );
		agk::Error( info.GetStr() );
		return;
	}

	uint32_t length = pixelFile.GetSize();
	char *pixelSource = new char[ length+1 ];
	pixelFile.ReadData( pixelSource, length );
	pixelSource[ length ] = 0;

	pixelFile.Close();

	AGKShader *pShader = g_pRenderer->LoadShader( g_pRenderer->GetShaderDefaultFullScreenVS(), pixelSource, "Default Fullscreen Shader", szPixelFile );
	
	delete [] pixelSource;

	if ( !pShader ) return;

	m_cShaderList.AddItem( pShader, shaderID );
}

//****f* 3D/Shaders/LoadSpriteShader
// FUNCTION
//   Loads a shader used for modifying sprites, as such it only contains a pixel shader,
//   the vertex shader is automatically generated to make sure it appears in the right place.
//   This type of shader should only be applied to sprites but nothing bad will happen if 
//   you choose to apply it to objects, it will just produce unusual rendering results for 
//   that object.
//   Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically 
//   added as the first line of the shader unless you specify a "#version " line of your own. Note
//   that doing this may mean your shader does not work on all devices and platforms. 
//   The global "precision" value will be added and should not be included in the shader source.
//   Returns an ID that can be used to reference this shader in other commands. IDs are shared 
//   across all shader types so loading a sprite shader into ID 1 will not work if a 3D shader 
//   exists with ID 1.<br/><br/>
//   If the current device does not support the shader then no shader will exist at the given ID,
//   you should use <i>GetShaderExists</i> to check if the load was successful. You can use
//   <i>SetShaderErrorMode</i> to set what happens when a shader is not supported or fails to compile.
// INPUTS
//   szPixelFile -- The file name of the pixel shader file, normally ending .ps
// SOURCE
uint32_t agk::LoadSpriteShader( const char* szPixelFile )
//****
{
	uint32_t shaderID = m_cShaderList.GetFreeID();
	if ( shaderID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load sprite shader - No free IDs found" );
		Error( errStr );
#endif
		return 0;
	}

	LoadSpriteShader( shaderID, szPixelFile );
	return shaderID;
}

//****f* 3D/Shaders/LoadSpriteShader
// FUNCTION
//   Loads a shader used for modifying sprites, as such it only contains a pixel shader,
//   the vertex shader is automatically generated to make sure it appears in the right place.
//   This type of shader should only be applied to sprites but nothing bad will happen if 
//   you choose to apply it to objects, it will just produce unusual rendering results for 
//   that object.
//   Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically 
//   added as the first line of the shader unless you specify a "#version " line of your own. Note
//   that doing this may mean your shader does not work on all devices and platforms. 
//   The global "precision" value will be added and should not be included in the shader source.
//   IDs are shared across all shader types so loading a sprite shader into ID 1 will not 
//   work if a normal shader exists with ID 1.<br/><br/>
//   If the current device does not support the shader then no shader will exist at the given ID,
//   you should use <i>GetShaderExists</i> to check if the load was successful. You can use
//   <i>SetShaderErrorMode</i> to set what happens when a shader is not supported or fails to compile.
// INPUTS
//   shaderID -- An ID used to reference this shader in other commands.
//   szPixelFile -- The file name of the pixel shader file, normally ending .ps
// SOURCE
void agk::LoadSpriteShader( uint32_t shaderID, const char* szPixelFile )
//****
{
	if ( !g_pRenderer ) 
	{
		Error( "Cannot load shaders without a renderer" );
		return;
	}

	if ( shaderID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to load sprite shader %d, ID must be greater than 0", shaderID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cShaderList.GetItem( shaderID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to load sprite shader " );
		errStr.AppendUInt( shaderID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	cFile pixelFile;
	if ( !pixelFile.OpenToRead( szPixelFile ) )
	{
		uString info;
		info.Format( "Failed to open pixel shader file \"%s\" for reading", szPixelFile );
		agk::Error( info.GetStr() );
		return;
	}

	uint32_t length = pixelFile.GetSize();
	char *pixelSource = new char[ length+1 ];
	pixelFile.ReadData( pixelSource, length );
	pixelSource[ length ] = 0;

	pixelFile.Close();

	AGKShader *pShader = g_pRenderer->LoadShader( g_pRenderer->GetShaderDefaultSpriteVS(), pixelSource, "Default Sprite Shader", szPixelFile );
	
	delete [] pixelSource;

	if ( !pShader ) return;

	m_cShaderList.AddItem( pShader, shaderID );
}

//****f* 3D/Shaders/SetShaderConstantByName
// FUNCTION
//   Sets a shader constant by name, the constant must be marked as "uniform" in the shader source.
//   This will affect all objects drawn using this shader.
//   All shader values have 1 to 4 components, this command accepts 4 values and discards any that 
//   are not used by the named variable.
// INPUTS
//   shaderID -- The ID of the shader to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   value1 -- The X or R component of the new value, this value will always be used.
//   value2 -- The Y or G component of the new value, if the constant only uses 1 component this value is discarded.
//   value3 -- The Z or B component of the new value, if the constant only uses 2 components this value is discarded.
//   value4 -- The W or A component of the new value, if the constant only uses 3 components this value is discarded.
// SOURCE
void agk::SetShaderConstantByName( uint32_t shaderID, const char *szName, float value1, float value2, float value3, float value4 )
//****
{
	AGKShader *pShader = m_cShaderList.GetItem( shaderID );
	if ( !pShader )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set constant for shader " );
		errStr.AppendUInt( shaderID ).Append( " - shader does not exist" );
		Error( errStr );
#endif
		return;
	}

	pShader->SetConstantByName( szName, value1, value2, value3, value4 );
}

//****f* 3D/Shaders/SetShaderConstantArrayByName
// FUNCTION
//   This command is deprecated, it is an exact copy of <i>SetShaderConstantArrayVec4ByName</i>.
// INPUTS
//   shaderID -- The ID of the shader to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The element of the array to modify.
//   value1 -- The X or R component of the new value
//   value2 -- The Y or G component of the new value
//   value3 -- The Z or B component of the new value
//   value4 -- The W or A component of the new value
// SOURCE
void agk::SetShaderConstantArrayByName( uint32_t shaderID, const char *szName, uint32_t arrayIndex, float value1, float value2, float value3, float value4 )
//****
{
	SetShaderConstantArrayVec4ByName( shaderID, szName, arrayIndex, value1, value2, value3, value4 );
}

//****f* 3D/Shaders/SetShaderConstantArrayFloatByName
// FUNCTION
//   Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.
//   Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will 
//   be made.
//   This will affect all objects drawn using this shader.
//   This command can only set arrays of floats
// INPUTS
//   shaderID -- The ID of the shader to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The index of the element within the array to modify.
//   value -- The new value to use
// SOURCE
void agk::SetShaderConstantArrayFloatByName( uint32_t shaderID, const char *szName, uint32_t arrayIndex, float value )
//****
{
	AGKShader *pShader = m_cShaderList.GetItem( shaderID );
	if ( !pShader )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set constant for shader " );
		errStr.AppendUInt( shaderID ).Append( " - shader does not exist" );
		Error( errStr );
#endif
		return;
	}

	pShader->SetConstantArrayByName( szName, arrayIndex, 1, value, 0, 0, 0 );
}

//****f* 3D/Shaders/SetShaderConstantArrayVec2ByName
// FUNCTION
//   Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.
//   Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will 
//   be made.
//   This will affect all objects drawn using this shader.
//   This command can only set arrays of vec2
// INPUTS
//   shaderID -- The ID of the shader to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The element of the array to modify.
//   value1 -- The X component of the new value
//   value2 -- The Y component of the new value
// SOURCE
void agk::SetShaderConstantArrayVec2ByName( uint32_t shaderID, const char *szName, uint32_t arrayIndex, float value1, float value2 )
//****
{
	AGKShader *pShader = m_cShaderList.GetItem( shaderID );
	if ( !pShader )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set constant for shader " );
		errStr.AppendUInt( shaderID ).Append( " - shader does not exist" );
		Error( errStr );
#endif
		return;
	}

	pShader->SetConstantArrayByName( szName, arrayIndex, 2, value1, value2, 0, 0 );
}

//****f* 3D/Shaders/SetShaderConstantArrayVec3ByName
// FUNCTION
//   Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.
//   Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will 
//   be made.
//   This will affect all objects drawn using this shader.
//   This command can only set arrays of vec3.<br/><br/>
//   Note that arrays of vec3 have an inefficient use of space and are padded to vec4, so may be slghtly slower
//   than using an array of vec4.
// INPUTS
//   shaderID -- The ID of the shader to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The element of the array to modify.
//   value1 -- The X component of the new value
//   value2 -- The Y component of the new value
//   value3 -- The Z component of the new value
// SOURCE
void agk::SetShaderConstantArrayVec3ByName( uint32_t shaderID, const char *szName, uint32_t arrayIndex, float value1, float value2, float value3 )
//****
{
	AGKShader *pShader = m_cShaderList.GetItem( shaderID );
	if ( !pShader )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set constant for shader " );
		errStr.AppendUInt( shaderID ).Append( " - shader does not exist" );
		Error( errStr );
#endif
		return;
	}

	pShader->SetConstantArrayByName( szName, arrayIndex, 3, value1, value2, value3, 0 );
}

//****f* 3D/Shaders/SetShaderConstantArrayVec4ByName
// FUNCTION
//   Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.
//   Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will 
//   be made.
//   This will affect all objects drawn using this shader.
//   This command can only set arrays of vec4
// INPUTS
//   shaderID -- The ID of the shader to modify.
//   szName -- The name of the constant to change, as defined in the shader source file.
//   arrayIndex -- The element of the array to modify.
//   value1 -- The X component of the new value
//   value2 -- The Y component of the new value
//   value3 -- The Z component of the new value
//   value4 -- The W component of the new value
// SOURCE
void agk::SetShaderConstantArrayVec4ByName( uint32_t shaderID, const char *szName, uint32_t arrayIndex, float value1, float value2, float value3, float value4 )
//****
{
	AGKShader *pShader = m_cShaderList.GetItem( shaderID );
	if ( !pShader )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set constant for shader " );
		errStr.AppendUInt( shaderID ).Append( " - shader does not exist" );
		Error( errStr );
#endif
		return;
	}

	pShader->SetConstantArrayByName( szName, arrayIndex, 4, value1, value2, value3, value4 );
}

//****f* 3D/Shaders/GetShaderExists
// FUNCTION
//   Returns 1 if a shader is currently loaded at the given ID, otherwise it returns 0.
// INPUTS
//   shaderID -- The ID of the shader to check
// SOURCE
int agk::GetShaderExists( uint32_t shaderID )
//****
{
	AGKShader *pShader = m_cShaderList.GetItem( shaderID );
	if ( pShader ) return 1;
	else return 0;
}

//****f* 3D/Shaders/DeleteShader
// FUNCTION
//   Deletes a shader and frees the ID. The shader must not currently be assigned to any object, mesh, quad, or sprite, otherwise 
//   it may cause a crash when it tries to draw.
// INPUTS
//   shaderID -- The ID of the shader to delete
// SOURCE
void agk::DeleteShader( uint32_t shaderID )
//****
{
	AGKShader *pShader = m_cShaderList.RemoveItem( shaderID );
	if ( pShader ) delete pShader;
}

// cameras

//****f* 3D/Cameras/SetCameraPosition
// FUNCTION
//   Sets the position of the specified camera. By default cameras are positioned at 0,0,0
//   The main camera is ID 1.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   x -- The X component of the position.
//   y -- The Y component of the position.
//   z -- The Z component of the position.
// SOURCE
void agk::SetCameraPosition( uint32_t cameraID, float x, float y, float z )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->SetPosition( x,y,z );
}

//****f* 3D/Cameras/SetCameraRotationQuat
// FUNCTION
//   Sets the rotation of the specified camera using a quaternion. Alternatively you can
//   use SetCameraRotation to use Euler angles. By default cameras are created with the
//   quaternion 1,0,0,0 in the order w,x,y,z. A Quaternion is a 4 dimensional representation
//   of a 3D rotation with the property w^2+x^2+y^2+z^2 = 1 which allows easy interpolation 
//   between two rotations by linearly interpolating the two quaternions and normalising them. 
//   Each 3D rotation is represented by exactly 2 quaternions, w,x,y,z and -w,-x,-y,-z so
//   either version may be returned by the GetCameraQuat commands.
//   Quaternions and Euler angles can both be used at the same time. For example setting a 
//   quaternion rotation will generate Euler representation that can be retrieved with 
//   GetCameraAngleX, etc.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   w -- The W component of the quaternion.
//   x -- The X component of the quaternion.
//   y -- The Y component of the quaternion.
//   z -- The Z component of the quaternion.
// SOURCE
void agk::SetCameraRotationQuat( uint32_t cameraID, float w, float x, float y, float z )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set rotation quat for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->SetRotationQuat( AGKQuaternion(w,x,y,z) );
}

//****f* 3D/Cameras/SetCameraRotation
// FUNCTION
//   Sets the rotation of the specified camera using euler angles in degrees. Alternatively you can
//   use SetCameraRotationQuat to use a quaternion. By default cameras are created with the
//   angles 0,0,0 in the order YXZ. Euler angles are compound angles where the camera starts 
//   at 0,0,0 and is then rotated using the given Y angle, then by the given X angle, then
//   rolled by the given Z angle. Each 3D rotation can be represented by 2 Euler angle 
//   combinations, Y,X,Z and Y-180,X-180,Z-180 so either version may be returned by the 
//   GetCameraAngle commands.
//   Quaternions and Euler angles can both be used at the same time. For example setting an 
//   Euler angle rotation will generate a quaternion representation that can be retrieved with 
//   GetCameraQuatX, etc.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   angx -- The X component of the euler rotation.
//   angy -- The Y component of the euler rotation.
//   angz -- The Z component of the euler rotation.
// SOURCE
void agk::SetCameraRotation( uint32_t cameraID, float angx, float angy, float angz )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set rotation for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->SetRotationEuler( angx, angy, angz );
}

//****f* 3D/Cameras/MoveCameraLocalX
// FUNCTION
//   Moves the specified camera along its local X axis, i.e. if the camera were a character
//   this command would make them strafe no matter which direction they were facing.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   amount -- The distance to move in the local X direction, can be negative.
// SOURCE
void agk::MoveCameraLocalX( uint32_t cameraID, float amount )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set move local x for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->MoveLocalX( amount );
}

//****f* 3D/Cameras/MoveCameraLocalY
// FUNCTION
//   Moves the specified camera along its local Y axis, i.e. if the camera were a character
//   this command would make them jump no matter which direction they were facing.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   amount -- The distance to move in the local Y direction, can be negative.
// SOURCE
void agk::MoveCameraLocalY( uint32_t cameraID, float amount )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set move local y for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->MoveLocalY( amount );
}

//****f* 3D/Cameras/MoveCameraLocalZ
// FUNCTION
//   Moves the specified camera along its local Z axis, i.e. if the camera were a character
//   this command would make them move forwards no matter which direction they were facing.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   amount -- The distance to move in the local Z direction, can be negative.
// SOURCE
void agk::MoveCameraLocalZ( uint32_t cameraID, float amount )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set move local z for camera " );
		errStr.AppendUInt( cameraID ).Append( " - Camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->MoveLocalZ( amount );
}

//****f* 3D/Cameras/RotateCameraLocalX
// FUNCTION
//   Rotates the specified camera around its local X axis, i.e. if the camera were an airplane
//   this command would make it pitch up and down no matter which direction it was facing.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   amount -- The angle to rotate on the local X axis in degrees, positive looks down, negative looks up.
// SOURCE
void agk::RotateCameraLocalX( uint32_t cameraID, float amount )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set rotate local x for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->RotateLocalX( amount );
}

//****f* 3D/Cameras/RotateCameraLocalY
// FUNCTION
//   Rotates the specified camera around its local Y axis, i.e. if the camera were an airplane
//   this command would make it turn left and right no matter which direction it was facing.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   amount -- The angle to rotate on the local Y axis in degrees, positive turns right, negative turns left.
// SOURCE
void agk::RotateCameraLocalY( uint32_t cameraID, float amount )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set rotate local y for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->RotateLocalY( amount );
}

//****f* 3D/Cameras/RotateCameraLocalZ
// FUNCTION
//   Rotates the specified camera around its local Z axis, i.e. if the camera were an airplane
//   this command would make it roll left and right no matter which direction it was facing.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   amount -- The angle to rotate on the local Z axis in degrees, negative is clockwise.
// SOURCE
void agk::RotateCameraLocalZ( uint32_t cameraID, float amount )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set rotate local z for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->RotateLocalZ( amount );
}

//****f* 3D/Cameras/RotateCameraGlobalX
// FUNCTION
//   Rotates the specified camera around global X axis. Imagine looking at the camera as if it were an object 
//   positioned at 0,0,0 looking in a random direction. This command would roll it around the fixed X axis, the 
//   one which is used to define the positions of everything in the world. 
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   amount -- The angle to rotate on the global X axis in degrees, positive pitches down, negative pitches up.
// SOURCE
void agk::RotateCameraGlobalX( uint32_t cameraID, float amount )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set rotate global x for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->RotateGlobalX( amount );
}

//****f* 3D/Cameras/RotateCameraGlobalY
// FUNCTION
//   Rotates the specified camera around global Y axis. Imagine looking at the camera as if it were an object 
//   positioned at 0,0,0 looking in a random direction. This command would turn it around the fixed Y axis, the 
//   one which is used to define the positions of everything in the world. 
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   amount -- The angle to rotate on the global Y axis in degrees, positive turns right, negative turns left.
// SOURCE
void agk::RotateCameraGlobalY( uint32_t cameraID, float amount )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set rotate global y for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->RotateGlobalY( amount );
}

//****f* 3D/Cameras/RotateCameraGlobalZ
// FUNCTION
//   Rotates the specified camera around global Z axis. Imagine looking at the camera as if it were an object 
//   positioned at 0,0,0 looking in a random direction. This command would roll it around the fixed Z axis, the 
//   one which is used to define the positions of everything in the world. 
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   amount -- The angle to rotate on the global Z axis in degrees, negative is clockwise.
// SOURCE
void agk::RotateCameraGlobalZ( uint32_t cameraID, float amount )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set rotate global z for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->RotateGlobalZ( amount );
}

//****f* 3D/Cameras/GetCameraX
// FUNCTION
//   Returns the current X position of the camera.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraX( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get x for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetX();
}

//****f* 3D/Cameras/GetCameraY
// FUNCTION
//   Returns the current Y position of the camera.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraY( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get y for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetY();
}

//****f* 3D/Cameras/GetCameraZ
// FUNCTION
//   Returns the current Z position of the camera.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraZ( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get z for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetZ();
}



//****f* 3D/Cameras/GetCameraAngleX
// FUNCTION
//   Returns the X component of the camera's current rotation converted to Euler angles.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraAngleX( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get angle x for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetEulerX();
}

//****f* 3D/Cameras/GetCameraAngleY
// FUNCTION
//   Returns the Y component of the camera's current rotation converted to Euler angles.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraAngleY( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get angle y for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetEulerY();
}

//****f* 3D/Cameras/GetCameraAngleZ
// FUNCTION
//   Returns the Z component of the camera's current rotation converted to Euler angles.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraAngleZ( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get angle z for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetEulerZ();
}

//****f* 3D/Cameras/GetCameraQuatW
// FUNCTION
//   Returns the W component of the camera's current rotation converted to a quaternion.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraQuatW( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get quat w for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->rot().w;
}

//****f* 3D/Cameras/GetCameraQuatX
// FUNCTION
//   Returns the X component of the camera's current rotation converted to a quaternion.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraQuatX( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get quat x for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->rot().x;
}

//****f* 3D/Cameras/GetCameraQuatY
// FUNCTION
//   Returns the Y component of the camera's current rotation converted to a quaternion.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraQuatY( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get quat y for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->rot().y;
}

//****f* 3D/Cameras/GetCameraQuatZ
// FUNCTION
//   Returns the Z component of the camera's current rotation converted to a quaternion.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraQuatZ( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get quat z for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->rot().z;
}

//****f* 3D/Cameras/GetCameraWorldX
// FUNCTION
//   Returns the current X position of the camera after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldX( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world x for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetWorldX();
}

//****f* 3D/Cameras/GetCameraWorldY
// FUNCTION
//   Returns the current Y position of the camera after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldY( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world y for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetWorldY();
}

//****f* 3D/Cameras/GetCameraWorldZ
// FUNCTION
//   Returns the current Z position of the camera after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldZ( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world z for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetWorldZ();
}

//****f* 3D/Cameras/GetCameraWorldAngleX
// FUNCTION
//   Returns the X component of the camera's current rotation converted to Euler angles after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldAngleX( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world angle x for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetWorldEulerX();
}

//****f* 3D/Cameras/GetCameraWorldAngleY
// FUNCTION
//   Returns the Y component of the camera's current rotation converted to Euler angles after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldAngleY( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world angle y for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetWorldEulerY();
}

//****f* 3D/Cameras/GetCameraWorldAngleZ
// FUNCTION
//   Returns the Z component of the camera's current rotation converted to Euler angles after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldAngleZ( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world angle z for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetWorldEulerZ();
}

//****f* 3D/Cameras/GetCameraWorldQuatW
// FUNCTION
//   Returns the W component of the camera's current rotation converted to a quaternion after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldQuatW( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world quat w for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->rotFinal().w;
}

//****f* 3D/Cameras/GetCameraWorldQuatX
// FUNCTION
//   Returns the X component of the camera's current rotation converted to a quaternion after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldQuatX( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world quat x for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->rotFinal().x;
}

//****f* 3D/Cameras/GetCameraWorldQuatY
// FUNCTION
//   Returns the Y component of the camera's current rotation converted to a quaternion after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldQuatY( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world quat y for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->rotFinal().y;
}

//****f* 3D/Cameras/GetCameraWorldQuatZ
// FUNCTION
//   Returns the Z component of the camera's current rotation converted to a quaternion after all transformations due to <i>FixCameraToObject</i>.
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraWorldQuatZ( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get world quat z for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->rotFinal().z;
}

//****f* 3D/Cameras/SetCameraLookAt
// FUNCTION
//   Rotates the camera to look at a particular point in space with an optional roll value.
//   "looking at" is defined as aligning the camera's local Z axis to point its positive side
//   at the given point. This can be achieved using only the Y and X angles in Euler notation,
//   so you can specify an optional Z angle in degrees to roll the camera left of right whilst
//   always looking at the same spot.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   x -- The X component of the position to look at.
//   y -- The Y component of the position to look at.
//   z -- The Z component of the position to look at.
//   roll -- The Z angle to roll the camera when looking at the given position, negative is clockwise.
// SOURCE
void agk::SetCameraLookAt( uint32_t cameraID, float x, float y, float z, float roll )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set look at for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->LookAt( x,y,z, roll );
}

//****f* 3D/Cameras/SetCameraRange
// FUNCTION
//   Sets the near and far planes of the camera. Due to rendering limitations not everything in front of 
//   the camera can be rendered so they must be limited to a visible range. Anything outside this range is 
//   clipped by the rendering system and is invisible.
//   The near plane is the closest that an object can be to the camera and still be rendered, it must be 
//   greater than 0. Note that using very small values for the near plane will affect the accuracy of the
//   depth buffer when rendering objects far away which might cause flickering on far away objects. This 
//   is because the depth buffer is not linear, instead it is skewed towards the near plane and the closer
//   to 0 the near plane becomes the less of the depth buffer is available for far objects.
//   The far plane is the maximum distance an object can be from the camera and still be rendered, it's 
//   maximum value is infinity but again the further you try to render an object from the near plane the
//   less accurate depth buffering becomes.
//   If an object crosses the near or far plane so that part of it is on one side and part is on the other
//   the object will be cut by the plane and only the part within the view range will be visible.
//   The default range is near=1, far=1000.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   fNear -- The nearest that an object will be rendered.
//   fFar -- The furthest that an object will be rendered.
// SOURCE
void agk::SetCameraRange( uint32_t cameraID, float fNear, float fFar )
//****
{
	if ( fNear <= 0 ) 
	{
		agk::Error( "Failed to set camera range, near value must be greater than 0." );
		return;
	}

	if ( fFar <= fNear ) 
	{
		agk::Error( "Failed to set camera range, near value must be less than far value." );
		return;
	}

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set range for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->SetRange( fNear, fFar );
}

//****f* 3D/Cameras/SetCameraAspect
// FUNCTION
//   Sets the camera aspect ratio when rendering 3D. The default is GetDeviceWidth()/GetDeviceHeight()
//   and provides a realistic 3D projection. If the device backbuffer size changes, for example if the 
//   device changes orientation, or the window size is changed, or SetScreenResolution is called, then 
//   this value will reset to its default.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   aspect -- The new aspect ratio to use.
// SOURCE
void agk::SetCameraAspect( uint32_t cameraID, float aspect )
//****
{
	if ( aspect <= 0 ) 
	{
		agk::Error( "Failed to set camera aspect ratio, value must be greater than 0." );
		return;
	}

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set aspect for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->SetAspectRatio( aspect );
}

//****f* 3D/Cameras/SetCameraFOV
// FUNCTION
//   Sets the camera horizontal field of view (FOV). This determines the angle between the left and 
//   right of the camera view, the default being 70 and provides a realistic 3D projection. Using 
//   smaller values would look like the camera is zooming in on the scene without actually moving. 
//   This is sometimes used for dramatic effect in movies where the FOV zooms one way whilst the 
//   camera moves the other way.
//   Using an FOV value of 0 is a special case that will generate an orthographic matrix instead of
//   a projection matrix, this will make everything stay the same size no matter how near or far it
//   is to the camera. The orthographic matrix will have a width of 40 world units with a height 
//   determined by the camera aspect ratio.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   fov -- The field of view in degrees.
// SOURCE
void agk::SetCameraFOV( uint32_t cameraID, float fov )
//****
{
	if ( fov < 0 ) 
	{
		agk::Error( "Failed to set camera field of view, value must be greater than or equal to 0" );
		return;
	}

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set FOV for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->SetFOV( fov );
}

//****f* 3D/Cameras/SetCameraOrthoWidth
// FUNCTION
//   If the camera FOV is set to 0 then this will determine the width of the orthographic view, the 
//   default is 40. The height value will be calculated from it based on the camera aspect ratio.
//   When using an orthographic projection everything remains the same size no matter how near or far 
//   it is to the camera, so when using the default width value, a cube of size 80 units would always 
//   fill the camera view when the camera is looking at it, since the 40 is measured from the center 
//   of the screen to the edge.
//   This command will overwrite any values set with <i>SetCameraBounds</i>.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   width -- The width of the view in world coordinates.
// SOURCE
void agk::SetCameraOrthoWidth( uint32_t cameraID, float width )
//****
{
	if ( width <= 0 ) 
	{
		agk::Error( "Failed to set camera ortho width, value must be greater than 0." );
		return;
	}

	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set ortho width for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->SetOrthoWidth( width );
}

//****f* 3D/Cameras/SetCameraBounds
// FUNCTION
//   Sets the parameters for an off center projection matrix. The near and far values are set separately 
//   with <i>SetCameraRange</i>. To use an off center projection matrix you must activate it with 
//   <i>SetCameraOffCenter</i>.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   left -- The left component of the projection matrix.
//   right -- The right component of the projection matrix.
//   top -- The top component of the projection matrix.
//   bottom -- The bottom component of the projection matrix.
// SOURCE
void agk::SetCameraBounds( uint32_t cameraID, float left, float right, float top, float bottom )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set bounds for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->SetBounds( left, right, top, bottom );
}

//****f* 3D/Cameras/SetCameraOffCenter
// FUNCTION
//   Sets the camera to use an off center projection matrix. You must set the projection matrix values by using 
//   <i>SetCameraBounds</i> and <i>SetCameraRange</i>.
// INPUTS
//   cameraID -- The ID of the camera to modify, the main camera is ID 1.
//   mode -- 1 to use an off center projection matrix, 0 to use a normal matrix, default is 0.
// SOURCE
void agk::SetCameraOffCenter( uint32_t cameraID, int mode )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set off center for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	pCamera->SetOffCenter( mode );
}


//****f* 3D/Cameras/GetCameraFOV
// FUNCTION
//   Returns the current Field Of View for the specified camera
// INPUTS
//   cameraID -- The ID of the camera to check, the main camera is ID 1.
// SOURCE
float agk::GetCameraFOV( uint32_t cameraID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to get FOV for camera " );
		errStr.AppendUInt( cameraID ).Append( " - camera does not exist" );
		Error( errStr );
#endif
		return 0;
	}

	return pCamera->GetFOV();
}

//****f* 3D/Cameras/FixCameraToObject
// FUNCTION
//   Fixes a camera to an object so that any movement of the object also affects the camera.
//   The camera uses its current position, rotation, and scale as an offset to the 
//   object. For example if the object was placed at 10,5,0 and a camera was fixed to it with
//   a current position of 0,10,0 then the camera would now inherit the position of the object, 
//   combine it with its own, and the camera would be placed at 10,15,0. The same applies to 
//   rotation and scaling, so if the object was rotated around the Y axis then the camera would 
//   rotate by the same amount. 
//   Note that using <i>GetCameraY</i> would only show its local position relative to 
//   the parent object (in this case it would return 10). To get the final world position of the camera
//   use <i>GetCameraWorldY</i>, which in this case would return 15.
//   There is no limit to the number of objects or cameras an object can have fixed to it, nor is there a 
//   limit to objects being fixed to objects which are fixed to other objects, just don't 
//   create any loops.
//   To stop a camera being fixed to anything set objID to 0 and it will become independent 
//   again.
// INPUTS
//   cameraID -- The ID of the camera to fix, must be equal to 1
//   objID -- The ID of the object to fix it to.
// SOURCE
void agk::FixCameraToObject( uint32_t cameraID, uint32_t objID )
//****
{
	cCamera *pCamera = m_cCameraList.GetItem( cameraID );
	if ( !pCamera )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to fix camera " );
		errStr.AppendUInt( cameraID ).Append( " to object - camera does not exist" );
		Error( errStr );
#endif
		return;
	}

	if ( objID == 0 )
	{
		pCamera->RemoveFromParent();
	}
	else
	{
		cObject3D *pToObject = m_cObject3DList.GetItem( objID );
		if ( !pToObject )
		{
	#ifdef _AGK_ERROR_CHECK
			uString errStr;
			errStr.Format( "Failed to fix camera to object %d - object does not exist", objID );
			Error( errStr );
	#endif
			return;
		}

		pToObject->AddChild( pCamera );
	}
}

void agk::SetCurrentCamera( cCamera *pCamera ) 
{ 
	m_pCurrentCamera = pCamera ? pCamera : m_cCameraList.GetItem((uint32_t)0); 
}

// lights

//****f* 3D/Lights/CreatePointLight
// FUNCTION
//   Creates a point light that shines equally in all directions. This affects all objects using the 
//   default internal shader with SetObjectLightMode set to 1. If you are using a custom shader then
//   AGK will add lighting functions to your shader during loading if you reference them, see the 
//   guide to shaders for more information on this.
//   By default, lights are created in vertex mode, this is faster than pixel mode but lower quality.
//   To change this use <i>SetPointLightMode</i>.
//   Color values should be in the range 0-255 but are not limited to it. Values greater than 255 
//   will over saturate things and values less than 0 will take light away.
// INPUTS
//   lightID -- The ID of the light to reference it in other commands.
//   x -- The X component of the light position.
//   y -- The Y component of the light position.
//   z -- The Z component of the light position.
//   radius -- The range that the light affects.
//   red -- The red component of the light color.
//   green -- The green component of the light color.
//   blue -- The blue component of the light color.
// SOURCE
void agk::CreatePointLight( uint32_t lightID, float x, float y, float z, float radius, int red, int green, int blue )
//****
{
	if ( lightID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create point light %d, ID must be greater than 0", lightID );
		Error( errStr );
#endif
		return;
	}

	if ( m_cPointLightList.GetItem( lightID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to create point light " );
		errStr.AppendUInt( lightID ).Append( " - ID already exists" );
		Error( errStr );
#endif
		return;
	}

	AGKPointLight *pLight = new AGKPointLight();
	pLight->SetColor( red, green, blue );
	pLight->SetPosition( x,y,z );
	pLight->SetRadius( radius );
	m_cPointLightList.AddItem( pLight, lightID );
}

//****f* 3D/Lights/GetPointLightExists
// FUNCTION
//   returns 1 if the specified point light exists, 0 otherwise.
// INPUTS
//   lightID -- The ID of the light to check.
// SOURCE
int agk::GetPointLightExists( uint32_t lightID )
//****
{
	AGKPointLight *pLight = m_cPointLightList.GetItem( lightID );
	return pLight ? 1 : 0;
}

//****f* 3D/Lights/DeletePointLight
// FUNCTION
//   Deletes the specified point light. If the point light doesn't exist this command does nothing.
// INPUTS
//   lightID -- The ID of the light to delete.
// SOURCE
void agk::DeletePointLight( uint32_t lightID )
//****
{
	AGKPointLight *pLight = m_cPointLightList.RemoveItem( lightID );
	if ( pLight ) delete pLight;
}

//****f* 3D/Lights/ClearPointLights
// FUNCTION
//   Deletes all point lights.
// SOURCE
void agk::ClearPointLights()
//****
{
	AGKPointLight *pLight = m_cPointLightList.GetFirst();
	while ( pLight )
	{
		delete pLight;
		pLight = m_cPointLightList.GetNext();
	}
	m_cPointLightList.ClearAll();
}

//****f* 3D/Lights/SetPointLightPosition
// FUNCTION
//   Places the point light at a new position.
// INPUTS
//   lightID -- The ID of the light to modify.
//   x -- The X component of the new position.
//   y -- The Y component of the new position.
//   z -- The Z component of the new position.
// SOURCE
void agk::SetPointLightPosition( uint32_t lightID, float x, float y, float z )
//****
{
	AGKPointLight *pLight = m_cPointLightList.GetItem( lightID );
	if ( !pLight )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set position for point light " );
		errStr.AppendUInt( lightID ).Append( " - light does not exist" );
		Error( errStr );
#endif
		return;
	}

	pLight->SetPosition( x,y,z );
}

//****f* 3D/Lights/SetPointLightColor
// FUNCTION
//   Changes the point light to a new color. Values should be in the range 0-255 but are not limited 
//   to it. Values greater than 255 will over saturate things and values less than 0 will take light away.
// INPUTS
//   lightID -- The ID of the light to modify.
//   red -- The red component of the light color.
//   green -- The green component of the light color.
//   blue -- The blue component of the light color.
// SOURCE
void agk::SetPointLightColor( uint32_t lightID, int red, int green, int blue )
//****
{
	AGKPointLight *pLight = m_cPointLightList.GetItem( lightID );
	if ( !pLight )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set color for point light " );
		errStr.AppendUInt( lightID ).Append( " - light does not exist" );
		Error( errStr );
#endif
		return;
	}

	pLight->SetColor( red, green, blue );
}

//****f* 3D/Lights/SetPointLightRadius
// FUNCTION
//   Changes the point light to a new radius of affect. Objects greater than this distance from the
//   light will receive zero light from it.
// INPUTS
//   lightID -- The ID of the light to modify.
//   radius -- The distance that the light can affect.
// SOURCE
void agk::SetPointLightRadius( uint32_t lightID, float radius )
//****
{
	AGKPointLight *pLight = m_cPointLightList.GetItem( lightID );
	if ( !pLight )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set radius for point light " );
		errStr.AppendUInt( lightID ).Append( " - light does not exist" );
		Error( errStr );
#endif
		return;
	}

	pLight->SetRadius( radius );
}

//****f* 3D/Lights/SetPointLightMode
// FUNCTION
//   Sets the point light to vertex or pixel mode. Vertex mode is faster but pixel mode has better quality.
//   By default lights are created in vertex mode.
//   A mesh can be lit by up to 8 vertex lights and 4 pixel lights at a time, if you add more lights 
//   than this then the closest lights will be used by the mesh.
// INPUTS
//   lightID -- The ID of the light to modify.
//   mode -- 0 for vertex, 1 for pixel mode.
// SOURCE
void agk::SetPointLightMode( uint32_t lightID, int mode )
//****
{
	AGKPointLight *pLight = m_cPointLightList.GetItem( lightID );
	if ( !pLight )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "Failed to set radius for point light " );
		errStr.AppendUInt( lightID ).Append( " - light does not exist" );
		Error( errStr );
#endif
		return;
	}

	pLight->SetType( mode );
}

//****f* 3D/Lights/SetSunDirection
// FUNCTION
//   Sets the direction for the global directional light to shine.
// INPUTS
//   vx -- The X component of the new direction.
//   vy -- The Y component of the new direction.
//   vz -- The Z component of the new direction.
// SOURCE
void agk::SetSunDirection( float vx, float vy, float vz )
//****
{
	m_cDirectionalLight.SetDirection( vx, vy, vz );
	AGKShader::g_varDirLightDir.SetVector3( m_cDirectionalLight.m_direction.x, m_cDirectionalLight.m_direction.y, m_cDirectionalLight.m_direction.z );
}

//****f* 3D/Lights/SetSunColor
// FUNCTION
//   Sets a new color for the global directional light. Values should be in the range 0-255 but are not limited 
//   to it. Values greater than 255 will over saturate things and values less than 0 will take light away.
// INPUTS
//   red -- The red component of the new color.
//   green -- The green component of the new color.
//   blue -- The blue component of the new color.
// SOURCE
void agk::SetSunColor( int red, int green, int blue )
//****
{
	m_cDirectionalLight.SetColor( red, green, blue );
	AGKShader::g_varDirLightColor.SetVector3( m_cDirectionalLight.m_color.x, m_cDirectionalLight.m_color.y, m_cDirectionalLight.m_color.z );
}

//****f* 3D/Lights/SetSunActive
// FUNCTION
//   Sets whether the global directional light shines or not.
// INPUTS
//   active -- 1 to active it, 0 to deactivate it
// SOURCE
void agk::SetSunActive( int active )
//****
{
	m_cDirectionalLight.m_active = (active != 0) ? 1 : 0;

	if ( active ) AGKShader::g_varDirLightColor.SetVector3( m_cDirectionalLight.m_color.x, m_cDirectionalLight.m_color.y, m_cDirectionalLight.m_color.z );
	else AGKShader::g_varDirLightColor.SetVector3( 0, 0, 0 );
}

//****f* 3D/Lights/SetAmbientColor
// FUNCTION
//   Sets a new color for the global ambient light. Values should be in the range 0-255 but are not limited 
//   to it. Values greater than 255 will over saturate things and values less than 0 will take light away.
//   The default ambient color is 76,76,76.
// INPUTS
//   red -- The red component of the new color.
//   green -- The green component of the new color.
//   blue -- The blue component of the new color.
// SOURCE
void agk::SetAmbientColor( int red, int green, int blue )
//****
{
	m_AmbientColor.Set( red/255.0f, green/255.0f, blue/255.0f );
	AGKShader::g_varLightAmbient.SetVector3( m_AmbientColor.x, m_AmbientColor.y, m_AmbientColor.z );
}

//****f* 3D/Shadows/GetShadowMappingSupported
// FUNCTION
//   Returns 1 if shadow mapping is supported on this device, 0 otherwise.
// SOURCE
int agk::GetShadowMappingSupported()
//****
{
	if ( !g_pRenderer ) return 0;
	return agk::IsSupportedDepthTexture() && g_pRenderer->SupportsPSHighP();
}

//****f* 3D/Shadows/SetShadowMappingMode
// FUNCTION
//   Turns shadow mapping on or off, by default this is off. Shadows are only generated by the the global 
//   directional light, which can be controlled with the <i>SetSunDirection</i> command. Note that this is not 
//   guaranteed to be supported on all devices, you can check for the current device by calling 
//   <i>GetShadowMappingSupported</i>. There are currently three shadow modes that can be used, mode 1 uses 
//   Uniform shadow mapping which has lower but consistent quality. Mode 2 uses Light Space Perspective shadow
//   mapping (LiPSM) which has higher quality in most cases but if the camera is looking in the same direction 
//   as the light then it is no better than Uniform shadow mapping. Light Space Perspective also suffers from 
//   shadow shimmering as the camera moves whereas Uniform is more stable. Both have about the same performance. 
//   Mode 3 uses Cascade shadow mapping which uses multiple shadow maps to maintain high quality near the
//   camera whilst still allowing lower quality shadows in the distance. This method has much lower performance
//   than the previous two methods but results in better quality shadows in all cases.<br/><br/>
//   Note that when using modes 1 and 2, texture stage 7 on all objects receiving shadow is reserved for the
//   shadow map. When using shadow mode 3 (cascade shadows) then texture stages 4, 5, 6, and 7 are reserved for
//   the shadow maps.
// INPUTS
//   mode -- 0 to turn it off, 1 to use Uniform shadows, 2 to use LiPSM shadows, 3 to use Cascade shadows
// SOURCE
void agk::SetShadowMappingMode( int mode ) 
//****
{
	if ( !g_pRenderer ) return;

	if ( !g_pRenderer->SupportsPSHighP() || !agk::IsSupportedDepthTexture() )
	{
		m_iShadowMode = 0;
		return;
	}

	if ( mode < 0 ) mode = 0;
	if ( mode > 3 ) mode = 3;
	m_iShadowMode = mode;

	if ( m_iShadowMode == 0 )
	{
		// remove any existing shadow maps
		if ( m_pShadowMapFBO ) delete m_pShadowMapFBO;
		if ( m_pShadowMapFBO2 ) delete m_pShadowMapFBO2;
		if ( m_pShadowMapFBO3 ) delete m_pShadowMapFBO3;
		if ( m_pShadowMapFBO4 ) delete m_pShadowMapFBO4;
		m_pShadowMapFBO = 0;
		m_pShadowMapFBO2 = 0;
		m_pShadowMapFBO3 = 0;
		m_pShadowMapFBO4 = 0;

		if ( m_pShadowMap ) delete m_pShadowMap;
		if ( m_pShadowMap2 ) delete m_pShadowMap2;
		if ( m_pShadowMap3 ) delete m_pShadowMap3;
		if ( m_pShadowMap4 ) delete m_pShadowMap4;
		m_pShadowMap = 0;
		m_pShadowMap2 = 0;
		m_pShadowMap3 = 0;
		m_pShadowMap4 = 0;
	}
}

//****f* 3D/Shadows/GetShadowMappingMode
// FUNCTION
//   Returns the current shadow mapping mode that was set with <i>SetShadowMappingMode</i>
// SOURCE
int agk::GetShadowMappingMode()
//****
{
	return m_iShadowMode;
}

//****f* 3D/Shadows/SetShadowSmoothing
// FUNCTION
//   Sets the smoothing mode for the shadow map. <br/>
//     Mode 0 turns smoothing off and results in the fastest shadows<br/>
//     Mode 1 uses 4 fixed samples to smooth out the shadows<br/>
//     Mode 2 uses 4 random samples to avoid banding produced by mode 1<br/>
//     Mode 3 uses 16 fixed samples<br/>
//     Mode 4 uses 16 random samples and is the slowest<br/>
// INPUTS
//   mode -- The smoothing mode to use
// SOURCE
void agk::SetShadowSmoothing( int mode )
//****
{
	if ( mode < 0 ) mode = 0;
	if ( mode > 4 ) mode = 4;
	/*
	if ( !agk::PlatformSupportsPSHighp() && mode == 2 )
	{
		agk::Warning( "This device does not support shadow smoothing mode 2" );
		mode = 1;
	}
	*/
	m_iShadowSmoothing = mode;
}

// not exposed to Tier 1
int agk::GetShadowSmoothing()
{
	return m_iShadowSmoothing;
}

//****f* 3D/Shadows/SetShadowMapSize
// FUNCTION
//   Sets the shadow map resolution in pixels. Good values are 512x512 or 1024x1024, it does not need to be a
//   power of two in size. The higher the resolution the better quality the shadows will be, although performance
//   will be lower with higher resolution shadow maps.
// INPUTS
//   width -- The width in pixels to use for the shadow map
//   height -- The height in pixels to use for the shadow map
// SOURCE
void agk::SetShadowMapSize( int width, int height )
//****
{
	if ( width < 1 ) width = 1;
	if ( height < 1 ) height = 1;

	if ( m_iShadowMapWidth == width && m_iShadowMapHeight == height ) return;

	m_iShadowMapWidth = width;
	m_iShadowMapHeight = height;

	float range = m_fShadowRange;
	if ( range <= 0 ) range = m_pCurrentCamera->GetFarRange();
	AGKShader::g_varShadowParams.SetVector4( range, agk::m_fShadowBias, 1.0f/agk::m_iShadowMapWidth, 1.0f/agk::m_iShadowMapHeight );

	// remove any existing shadow map so they can be recreated at the new size
	if ( m_pShadowMapFBO ) delete m_pShadowMapFBO;
	if ( m_pShadowMapFBO2 ) delete m_pShadowMapFBO2;
	if ( m_pShadowMapFBO3 ) delete m_pShadowMapFBO3;
	if ( m_pShadowMapFBO4 ) delete m_pShadowMapFBO4;
	m_pShadowMapFBO = 0;
	m_pShadowMapFBO2 = 0;
	m_pShadowMapFBO3 = 0;
	m_pShadowMapFBO4 = 0;

	if ( m_pShadowMap ) delete m_pShadowMap;
	if ( m_pShadowMap2 ) delete m_pShadowMap2;
	if ( m_pShadowMap3 ) delete m_pShadowMap3;
	if ( m_pShadowMap4 ) delete m_pShadowMap4;
	m_pShadowMap = 0;
	m_pShadowMap2 = 0;
	m_pShadowMap3 = 0;
	m_pShadowMap4 = 0;
}

//****f* 3D/Shadows/SetShadowRange
// FUNCTION
//   Sets the range from the camera that shadows will be drawn. Ideally this would be set to the camera far range from
//   <i>SetCameraRange</i>, but drawing shadows all the way to the far plane may take some quality away from those 
//   shadows closer to the camera. Therefore setting the shadow range lower than the camera far range may improve shadow
//   quality at the expense of distant objects not having shadows.
//   The actual shadow range will be the lower value of the the camera far range and this shadow range, so you can safely 
//   set it larger than the camera far range without any effect on quality. If you later adjust the camera far range then
//   the shadow range will not change accordingly, you must set it separately.<br/><br/>
//   Use a value of -1 to ignore this value and always use the camera far range for shadows. By default this is set to -1.
// INPUTS
//   range -- The distance to stop drawing shadows, -1 to use the camera far range instead
// SOURCE
void agk::SetShadowRange( float range )
//****
{
	if ( !g_pRenderer ) return;

	if ( range < 0 ) range = -1;
	m_fShadowRange = range;

	if ( range <= 0 ) range = m_pCurrentCamera->GetFarRange();
	AGKShader::g_varShadowParams.SetVector4( range, agk::m_fShadowBias, 1.0f/agk::m_iShadowMapWidth, 1.0f/agk::m_iShadowMapHeight );
}

//****f* 3D/Shadows/SetShadowBias
// FUNCTION
//   Sets the bias to shift shadows so that object surfaces don't shadow themselves, default is 0.001. This can help 
//   prevent shadow artifacts on surfaces that are in light but also casting a shadow behind themselves.
// INPUTS
//   bias -- The distance to shift shadows
// SOURCE
void agk::SetShadowBias( float bias )
//****
{
	if ( !g_pRenderer ) return;

	m_fShadowBias = bias;

	float range = m_fShadowRange;
	if ( range <= 0 ) range = m_pCurrentCamera->GetFarRange();
	AGKShader::g_varShadowParams.SetVector4( range, agk::m_fShadowBias, 1.0f/agk::m_iShadowMapWidth, 1.0f/agk::m_iShadowMapHeight );
}

//****f* 3D/Shadows/SetShadowLightStepSize
// FUNCTION
//   Limits the directional light angle to steps of the given size rather than being a continuous value. This can prevent 
//   shadow shimmering if the directional light is slowly changing its angle, such as the sun moving across the sky. 
//   By default this is set to 0 which disables the step size and keeps the angle as a continuous value. Values in the 
//   range 0.1 to 2.0 seem to work best. This only applies if the <i>SetShadowMappingMode</i> is set to Uniform.
// INPUTS
//   step -- The light angle step size in degrees
// SOURCE
void agk::SetShadowLightStepSize( float step )
//****
{
	if ( step < 0 ) step = 0;
	m_fShadowLightStep = step;
}

//****f* 3D/Shadows/SetShadowCascadeValues
// FUNCTION
//   When using cascade shadow maps (<i>SetShadowMappingMode</i> 3), this command sets the range that each cascade map will 
//   cover. In total there are 4 cascade shadow maps, the fourth one always covers the entire shadowed area (cascade4 = 1.0),
//   by default the third cascade covers half the shadowed area (cascade3 = 0.5), the second cascade covers a quarter of the 
//   shadowed area (cascade2 = 0.25), and the first cascade covers one eighth of the shadowed area (cascade1 = 0.125). Since 
//   all the cascade shadow maps use the same resolution, the smaller the area it covers the greater the shadow detail will
//   be in that area. The cascade shadow maps are ordered so that the smallest one is closest to the camera, and the largest 
//   is the furthest away. In this way the shadows close to the camera should have high detail whilst the ones furthest away,
//   which area less noticeable, will have lower detail. Note that whilst using a smaller area for a particular cascade will
//   increase the shadow quality, it will reduce the area which that cascade covers, so shadow quality will drop to the next 
//   level sooner as the distance from the camera increases. <br/>
//   <br/>
//   Cascade levels must be in the range 0.0 to 1.0, and each level must be greater than the previous level, i.e. cascade2 
//   must be greater than cascade1, and so on. If these rules are broken then this command will do nothing.
// INPUTS
//   cascade1 -- The smallest cascade level, must be less than cascade2, must be greater than 0.0
//   cascade2 -- The second cascade level, must be less than cascade3
//   cascade3 -- The third cascade level, must be less than 1.0
// SOURCE
void agk::SetShadowCascadeValues( float cascade1, float cascade2, float cascade3 )
//****
{
	if ( cascade1 <= 0 ) return;
	if ( cascade2 < cascade1 ) return;
	if ( cascade3 < cascade2 ) return;
	if ( cascade3 >= 1.0 ) return;

	m_fShadowCascade1 = cascade1;
	m_fShadowCascade2 = cascade2;
	m_fShadowCascade3 = cascade3;
}

//
// Particle functions
//

//****f* 3DParticles/Creation/Create3DParticles
// FUNCTION
//   Creates a particle emitter with the given ID and the given location in world coordinates. 
//   Particle emitters create a flow of small sprites that last for a fixed amount of time before
//   disappearing. The particles can be influenced by forces during their life using 
//   <i>Add3DParticlesForce</i>. They can also change color over time using <i>Add3DParticlesColorKeyFrame</i>.
//   <br><br>Particles cannot be modified individually and behave as a group using the same texture. 
//   This allows AGK to draw them more efficiently than a similar number of normal objects.
// INPUTS
//   ID -- The ID to use when referencing this 3D particle emitter.
//   x -- The x coordinate to position this emitter.
//   y -- The y coordinate to position this emitter.
//   z -- The z coordinate to position this emitter.
// SOURCE
void agk::Create3DParticles( uint32_t ID, float x, float y, float z )
//****
{
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create 3D particle emitter %d, ID must be greater than 0", ID );
		Error( errStr );
#endif
		return;
	}

	if ( m_3DParticleEmitterList.GetItem( ID ) )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create 3D particle emitter %d, ID already exists", ID );
		Error( errStr );
#endif
		return;
	}

	AGK3DParticleEmitter *pEmitter = new AGK3DParticleEmitter();
	m_3DParticleEmitterList.AddItem( pEmitter, ID );
	pEmitter->SetID( ID );
	pEmitter->SetPosition( x, y, z );
}

//****f* 3DParticles/Creation/Create3DParticles
// FUNCTION
//   Creates a particle emitter with the given ID and the given location in world coordinates. 
//   Particle emitters create a flow of small sprites that last for a fixed amount of time before
//   disappearing. The particles can be influenced by forces during their life using 
//   <i>Add3DParticlesForce</i>. They can also change color over time using <i>Add3DParticleColorKeyFrame</i>.
//   <br><br>Particles cannot be modified individually and behave as a group using the same texture. 
//   This allows AGK to draw them more efficiently than a similar number of normal objects.
// INPUTS
//   x -- The x coordinate to position this emitter.
//   y -- The y coordinate to position this emitter.
//   z -- The z coordinate to position this emitter.
// SOURCE
uint32_t agk::Create3DParticles( float x, float y, float z )
//****
{
	uint32_t ID = m_3DParticleEmitterList.GetFreeID();
	if ( ID == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to create 3D particle emitter, no free ID found" );
		Error( errStr );
#endif
		return 0;
	}

	AGK3DParticleEmitter *pEmitter = new AGK3DParticleEmitter();
	m_3DParticleEmitterList.AddItem( pEmitter, ID );
	pEmitter->SetID( ID );
	pEmitter->SetPosition( x, y, z );
	return ID;
}

//****f* 3DParticles/Properties/Get3DParticlesExists
// FUNCTION
//   Returns 1 if a 3D particle emitter exists at the given ID. 0 if not.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
int agk::Get3DParticlesExists( uint32_t ID )
//****
{
	return m_3DParticleEmitterList.GetItem( ID ) ? 1 : 0;
}

//****f* 3DParticles/Creation/Delete3DParticles
// FUNCTION
//   Deletes a 3D particle emitter and all its particles. If any particles were currently visible they 
//   will disappear instantly.
// INPUTS
//   ID -- The ID of the emitter to delete.
// SOURCE
void agk::Delete3DParticles( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.RemoveItem( ID );
	if ( pEmitter )
	{
		delete pEmitter;
	}
}

//****f* 3DParticles/Properties/Set3DParticlesPosition
// FUNCTION
//   Sets the position of the 3D particle emitter. This is the position that new particles will emerge from 
//   and does not affect particles that are already visible.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   x -- The new x coordinate for the emitter in world coordinates.
//   y -- The new y coordinate for the emitter in world coordinates.
//   z -- The new z coordinate for the emitter in world coordinates.
// SOURCE
void agk::Set3DParticlesPosition( uint32_t ID, float x, float y, float z )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d position, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetPosition( x, y, z );
}

//****f* 3DParticles/Properties/Set3DParticlesFrequency
// FUNCTION
//   Sets the frequency of new particle generation. The freq value states how many particles should be 
//   produced per second, this is independent of frame rate. This is one of the two values that affects
//   the number of particles generated, the other being <i>SetParticlesLife</i>. The maximum number of 
//   particles that can be on screen at any one time is freq*life, with life being the number of seconds
//   a particle lives before it disappears.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   freq -- The rate of new particle production in particles per second.
// SOURCE
void agk::Set3DParticlesFrequency( uint32_t ID, float freq )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d frequency, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetFrequency( freq );
}

//****f* 3DParticles/Properties/Set3DParticlesStartZone
// FUNCTION
//   Sets the area around the emitter where new particles may appear. The values are relative to the 
//   emitter position, for example a zone of 0,0,0,0 would mean that all particles start on the emitter
//   position point. A zone of -10 in x and +10 x, with y and z being 0 (-10,0,0,10,0,0) would create a line 
//   centered on the emitter position that particles would randomly appear along. A box zone where
//   x, y, and z are non-zero would mean that particles could start at any point inside the box.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   x1 -- The x coordinate of the top left corner of the start zone.
//   y1 -- The y coordinate of the top left corner of the start zone.
//   z1 -- The z coordinate of the top left corner of the start zone.
//   x2 -- The x coordinate of the bottom right corner of the start zone.
//   y2 -- The y coordinate of the bottom right corner of the start zone.
//   z2 -- The z coordinate of the bottom right corner of the start zone.
// SOURCE
void agk::Set3DParticlesStartZone( uint32_t ID, float x1, float y1, float z1, float x2, float y2, float z2 )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d start zone, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetStartZone( x1, y1, z1, x2, y2, z2 );
}

//****f* 3DParticles/Properties/Set3DParticlesDirection
// FUNCTION
//   Sets the initial direction of new particles when they emerge from the emitter. This can be used
//   along with the <i>Set3DParticlesDirectionRange</i> command to set the range of variation from this initial direction
//   that new particles can choose. This also sets the initial speed of the particles by taking the length
//   of the vector as units per second. For example if the initial direction is vx=10, vy=-15, vz=0 particles
//   will begin by moving in the X direction at a rate of 10 units per second and in the Y direction at a rate of 15 units
//   per second and will continue this rate of motion for their entire life unless influenced by forces 
//   added with <i>Add3DParticlesForce</i>.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   vx -- The x direction that particles will move initially.
//   vy -- The y direction that particles will move initially.
//   vz -- The z direction that particles will move initially.
//   roll -- The angle to turn the emitter as it is facing in the given direction
// SOURCE
void agk::Set3DParticlesDirection( uint32_t ID, float vx, float vy, float vz, float roll )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d direction, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetDirection( vx, vy, vz, roll );
}

//****f* 3DParticles/Properties/Set3DParticlesVelocityRange
// FUNCTION
//     Sets a minimum and maximum multiplier that will affect particles being emitted. This can
//     be used to ensure that there will be some variation in velocity when particles are emitted.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   v1 -- The minimum velocity multiplier.
//   v2 -- The maximum velocity multiplier.
// SOURCE
void agk::Set3DParticlesVelocityRange( uint32_t ID, float v1, float v2 )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d velocity range, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetVelocityRange( v1, v2 );
}


//****f* 3DParticles/Properties/Set3DParticlesDirectionRange
// FUNCTION
//   Sets the range of direction in degrees that a particle can choose when it first starts. This takes the base 
//   direction set with <i>Set3DParticlesDirection</i> and adjusts it by a random amount between 0 and angle1/2 
//   degrees in one direction and angle2/2 degrees in the perpendicular direction. 
//   For example an angle1 of 0 and an angle2 of 0 would mean that all new particles follow exactly the direction 
//   specified earlier. An angle1 of 360 and an angle2 of 0 would mean that particles could appear travelling 
//   in any direction in a flat circle, whilst an angle1 of 360 and an angle2 of 180 would mean that particles 
//   would travel in any direction in a sphere. The angles form a pyramid aligned with the particle emitter 
//   direction specified earlier. Angle1 must be between 0 and 360, angle2 must be between 0 and 180.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   angle1 -- The range of variation a particle can choose from the emitter direction.
//   angle2 -- The perpendicular range of variation a particle can choose from the emitter direction.
// SOURCE
void agk::Set3DParticlesDirectionRange( uint32_t ID, float angle1, float angle2 )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d angle, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetDirectionRange( angle1, angle2 );
}

//****f* 3DParticles/Properties/Set3DParticlesSize
// FUNCTION
//   Sets the size of all particles in world coordinates. Setting a large number of particles to a large
//   size will perform poorly on mobile devices that have a low fill rate (number of pixels it can draw 
//   per second).
// INPUTS
//   ID -- The ID of the emitter to modify.
//   size -- Size of the particles
// SOURCE
void agk::Set3DParticlesSize( uint32_t ID, float size )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d size, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetSize( size );
}

//****f* 3DParticles/Properties/Set3DParticlesLife
// FUNCTION
//   Sets the life of particles in seconds once they have been emitted. After particles have been alive for the
//   given number of seconds they will disappear. This is one of the two values that affects the number of 
//   particles generated, the other being <i>Set3DParticlesFrequency</i>. The maximum number of particles that can be 
//   on screen at any one time is freq*life, with freq being the number of particles emitted per second.
//   This value is independent of frame rate.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   time -- The time in seconds that a particle is visible.
// SOURCE
void agk::Set3DParticlesLife( uint32_t ID, float time )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d life, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetLife( time );
}

//****f* 3DParticles/Properties/Set3DParticlesMax
// FUNCTION
//   Sets the maximum number of particles that will be emitted. If this value is equal to -1 then the number is
//   infinite. The emitter will keep a count of the total number of particles it emits and stop when the limit is reached.
//   To check if the emitter has reached its limit use <i>Get3DParticlesMaxReached</i>. To reset the count and make it start
//   emitting again use <i>Reset3DParticleCount</i>.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   max -- The maximum number of particles to emit
// SOURCE
void agk::Set3DParticlesMax( uint32_t ID, int max )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d max, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetMaxParticles( max );
}

//****f* 3DParticles/Properties/Reset3DParticleCount
// FUNCTION
//   Resets the emitted particle count when the emitter has been set with a maximum number of particles using
//   <i>Set3DParticlesMax</i>. You can check when the emitter has reached its maximum count using <i>Get3DParticlesMaxReached</i>.
//   If the maximum is set at -1 then this command has no effect.
// INPUTS
//   ID -- The ID of the emitter to modify.
// SOURCE
void agk::Reset3DParticleCount( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to reset 3D particle emitter %d count, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->ResetParticleCount();
}

//****f* 3DParticles/Properties/Set3DParticlesImage
// FUNCTION
//   Sets the image to use for each particle.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   imageID -- The ID of an image to use for emitted particles.
// SOURCE
void agk::Set3DParticlesImage( uint32_t ID, uint32_t imageID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d image, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	cImage *pImage = 0;
	if ( imageID > 0 )
	{
		pImage = m_cImageList.GetItem( imageID );
		if ( pImage == 0 )
		{
#ifdef _AGK_ERROR_CHECK
			uString errStr( "", 100 );
			errStr.Format( "Failed to set 3D particle emitter %d image, image %d does not exist", ID, imageID );
			Error( errStr );
#endif
			return;
		}
	}

	pEmitter->SetImage( pImage );
}

//****f* 3DParticles/Properties/Set3DParticlesVisible
// FUNCTION
//   Sets whether the emitted particles are drawn. Set to 1 to show particles, 0 to hide
//   them. Particles will still update whilst hidden, you can stop particles updating with <i>Set3DParticlesActive</i>
// INPUTS
//   ID -- The ID of the emitter to modify.
//   visible -- 1=show, 0=hide
// SOURCE
void agk::Set3DParticlesVisible( uint32_t ID, int visible )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d visibility, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetVisible( visible );
}

//****f* 3DParticles/Properties/Set3DParticlesActive
// FUNCTION
//   Sets whether the emitted particles are updated every frame. Set to 1 to update particles as normal, 0 to pause
//   them. Particles will continue to be visible when paused. To hide particles use <i>Set3DParticlesVisible</i>.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   active -- 1=normal, 0=pause
// SOURCE
void agk::Set3DParticlesActive( uint32_t ID, int active )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d active, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetActive( active );
}

//****f* 3DParticles/Properties/Set3DParticlesTransparency
// FUNCTION
//   Set the particle transparency to a particular setting, with a choice of no transparency, alpha transparency,
//   and additive blending. By default particles are created with alpha transparency.
// INPUTS
//   ID -- The ID of the particle emitter to modify.
//   mode -- The transparency mode for these particles, 0=off, 1=alpha transparency, 2=additive blending
// SOURCE
void agk::Set3DParticlesTransparency( uint32_t ID, int mode )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d transparency, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetTransparency( mode );
}


//****f* 3DParticles/Properties/Set3DParticlesColorInterpolation
// FUNCTION
//   Sets the interpolation mode for color changes. Colors can be set at certain points in a particle's life using
//   <i>Add3DParticlesColorKeyFrame</i> and the particle will either blend between these colors (smooth interpolation) 
//   or quickly change when it reaches the next color change (no interpolation).
// INPUTS
//   ID -- The ID of the emitter to modify.
//   mode -- 1=smooth interpolation, 0=no interpolation
// SOURCE
void agk::Set3DParticlesColorInterpolation( uint32_t ID, int mode )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to set 3D particle emitter %d color interpolation, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->SetColorInterpolation( mode );
}

//****f* 3DParticles/Properties/Get3DParticlesX
// FUNCTION
//   Returns the current X position of the emitter, this is the point that new particles will appear from.
//   It is not possible to get the position of individual particles, they are merely created, follow a 
//   path influenced by forces, and then disappear.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesX( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d X, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetX();
}

//****f* 3DParticles/Properties/Get3DParticlesY
// FUNCTION
//   Returns the current Y position of the emitter, this is the point that new particles will appear from.
//   It is not possible to get the position of individual particles, they are merely created, follow a 
//   path influenced by forces, and then disappear.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesY( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d Y, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetY();
}

//****f* 3DParticles/Properties/Get3DParticlesZ
// FUNCTION
//   Returns the current Z position of the emitter, this is the point that new particles will appear from.
//   It is not possible to get the position of individual particles, they are merely created, follow a 
//   path influenced by forces, and then disappear.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesZ( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d Z, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetZ();
}

//****f* 3DParticles/Properties/Get3DParticlesVisible
// FUNCTION
//   Returns 0 if the given particles have been set as invisible using <i>Set3DParticlesVisible</i>, or 1 if they
//   are currently set as visible (default). This does not check if the particles are within the visible viewport.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
int agk::Get3DParticlesVisible( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d visibility, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetVisible();
}

//****f* 3DParticles/Properties/Get3DParticlesActive
// FUNCTION
//   Returns 0 if the given particles have been paused using <i>Set3DParticlesActive</i>, or 1 if they
//   are currently updating as normal (default). 
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
int agk::Get3DParticlesActive( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d active, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetActive();
}

//****f* 3DParticles/Properties/Get3DParticlesFrequency
// FUNCTION
//   Returns the current frequency of particle generation in particles per second. This value is independent 
//   of frame rate.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesFrequency( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d frequency, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetFrequency();
}

//****f* 3DParticles/Properties/Get3DParticlesDirectionX
// FUNCTION
//   Returns the X component of the emitter direction, which is the base direction that particles will be
//   moving when they are created. Particles can vary their direction slightly when emitted based on the 
//   current <i>Set3DParticlesDirection</i> value.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesDirectionX( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d direction X, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetDirectionX();
}

//****f* 3DParticles/Properties/Get3DParticlesDirectionY
// FUNCTION
//   Returns the y component of the emitter direction, which is the base direction that particles will be
//   moving when they are created. Particles can vary their direction slightly when emitted based on the 
//   current <i>Set3DParticlesDirection</i> value.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesDirectionY( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d direction Y, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetDirectionY();
}

//****f* 3DParticles/Properties/Get3DParticlesDirectionZ
// FUNCTION
//   Returns the z component of the emitter direction, which is the base direction that particles will be
//   moving when they are created. Particles can vary their direction slightly when emitted based on the 
//   current <i>Set3DParticlesDirection</i> value.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesDirectionZ( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d direction Z, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetDirectionZ();
}

//****f* 3DParticles/Properties/Get3DParticlesDirectionRange1
// FUNCTION
//   Returns the first emitter angle in degrees. This value represents the amount of deviation a particle
//   can have from the emitter direction when emitted. An angle of 0 means there is no deviation while an 
//   angle of 360 means a particle can be travelling in any direction in that plane when emitted.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesDirectionRange1( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d direction range1, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetDirectionRange1();
}

//****f* 3DParticles/Properties/Get3DParticlesDirectionRange2
// FUNCTION
//   Returns the second emitter angle in degrees. This value represents the amount of deviation a particle
//   can have from the emitter direction when emitted. An angle of 0 means there is no deviation while an 
//   angle of 360 means a particle can be travelling in any direction in that plane when emitted.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesDirectionRange2( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get particle emitter %d direction range2, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetDirectionRange2();
}

//****f* 3DParticles/Properties/Get3DParticlesSize
// FUNCTION
//   Returns the current size of all particles in world coordinates. For details on setting the particle size
//   see <i>Set3DParticlesSize</i>.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesSize( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d size, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetSize();
}

//****f* 3DParticles/Properties/Get3DParticlesLife
// FUNCTION
//   Returns the current life of particles in seconds. It is not possible to get the current life of individual
//   particles. This value is independent of frame rate.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
float agk::Get3DParticlesLife( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d life, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetLife();
}

//****f* 3DParticles/Properties/Get3DParticlesMaxReached
// FUNCTION
//   Returns 1 if the emitter has emitted the number of particles specified in <i>Set3DParticlesMax</i> and all emitted particles 
//   have since died, otherwise returns 0. If the max is set at -1 this will always return 0. To reset
//   the count and make the emitter start emitting again use <i>Reset3DParticleCount</i>.
// INPUTS
//   ID -- The ID of the emitter to check.
// SOURCE
int agk::Get3DParticlesMaxReached( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to get 3D particle emitter %d max reached, emitter does not exist", ID );
		Error( errStr );
#endif
		return 0;
	}

	return pEmitter->GetMaxParticlesReached();
}

//****f* 3DParticles/Properties/Add3DParticlesForce
// FUNCTION
//   Adds a force that will act at a given time in every particle's life. For example a force set to start at time
//   2 and end at time 3 will start influencing particles when they have been alive for 2 seconds. It will continue 
//   to act on those particles until they have been alive for 3 seconds. The force's influence is defined by an x, y,
//   and z value that represent acceleration in units per second. For example a force with x=5 will adjust a 
//   particle's horizontal speed by adding 5 units for every second the force is active, if the force is only active 
//   for 0.5 seconds the particle would then be moving 2.5 units per second faster in the X direction.
//   Multiple forces can be acting on a particle at the same time if their timings overlap.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   starttime -- The time in a particle's life at which this force should start having an effect.
//   endtime -- The time in a particle's life at which this force should stop having an effect.
//   x -- The x component of the force's influence on a particle's speed in units per second.
//   y -- The y component of the force's influence on a particle's speed in units per second.
//   z -- The z component of the force's influence on a particle's speed in units per second.
// SOURCE
void agk::Add3DParticlesForce( uint32_t ID, float starttime, float endtime, float x, float y, float z )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to add 3D particle emitter %d force, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->AddForce( starttime, endtime, x, y, z );
}

//****f* 3DParticles/Properties/Clear3DParticlesForces
// FUNCTION
//   Clears all forces assigned to this emitter. All forces will immediately stop influencing particles.
// INPUTS
//   ID -- The ID of the emitter to modify.
// SOURCE
void agk::Clear3DParticlesForces( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to clear 3D particle emitter %d forces, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->ClearForces();
}

//****f* 3DParticles/Properties/Add3DParticlesColorKeyFrame
// FUNCTION
//   Adds a color change at a certain point in a particle's life. For example a color added with time=1
//   will make the particle equal the given color when it has been alive for 1 second. If color interpolation
//   is turned on using <i>Set3DParticlesColorInterpolation</i> the particle will gradually transform from its current 
//   color to the next color. For example if you add three colors, red when time=1, green when time=2, and blue when 
//   time=3, then the particle will start its life as red (as that is the nearest color) and remain completely red
//   until it is 1 second old. When the particle is between 1 and 2 seconds old it will gradually change from red
//   to green until it is 2 seconds old, at this point it is completely green. When the particle is between 2 and
//   3 seconds old it will gradually change from green to blue until it is 3 seconds old, at this point it is 
//   completely blue. The particle will remain completely blue until the end of its life as no other colors have
//   been added.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   time -- The time that particles should become this color.
//   red -- The red component of the new color.
//   green -- The green component of the new color.
//   blue -- The blue component of the new color.
//   alpha -- The alpha component of the new color.
// SOURCE
void agk::Add3DParticlesColorKeyFrame( uint32_t ID, float time, uint32_t red, uint32_t green, uint32_t blue, uint32_t alpha )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to add 3D particle emitter %d color, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->AddColorKeyFrame( time, red, green, blue, alpha );
}

//****f* 3DParticles/Properties/Clear3DParticlesColors
// FUNCTION
//   Clears all colors that have been assigned to the emitter, the particles will maintain whatever color
//   they currently have.
// INPUTS
//   ID -- The ID of the emitter to modify.
// SOURCE
void agk::Clear3DParticlesColors( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to clear 3D particle emitter %d colors, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->ClearColors();
}

//****f* 3DParticles/Properties/Add3DParticlesScaleKeyFrame
// FUNCTION
//   Adds a size change at a certain point in a particle's life. Scale values are relative to the value
//   set by <i>Set3DParticlesSize</i> so a scale of 2 means double its normal size and 0.5 is half its
//   normal size.
//   A scale added with time=1 will make the particle gradually transform to the given until it has been 
//   alive for 1 second when it will match the given size. The particle will then gradually transform 
//   from that size to the next size (if a next size exists). 
// INPUTS
//   ID -- The ID of the emitter to modify.
//   time -- The time that particles should become this size.
//   scale -- The scale relative to the normal particle size, must be greater then or equal to 0.
// SOURCE
void agk::Add3DParticlesScaleKeyFrame( uint32_t ID, float time, float scale )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to add 3D particle emitter %d scale, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->AddScaleKeyFrame( time, scale );
}

//****f* 3DParticles/Properties/Clear3DParticlesScales
// FUNCTION
//   Clears all size modifiers that have been assigned to the emitter, the particles will maintain whatever size
//   they currently are.
// INPUTS
//   ID -- The ID of the emitter to modify.
// SOURCE
void agk::Clear3DParticlesScales( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to clear 3D particle emitter %d scales, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->ClearScales();
}

//****f* 3DParticles/Properties/Update3DParticles
// FUNCTION
//   Immediately advances the particle emitter by the given amount of time. If you want to advance a high frequency emitter 
//   by a large time period such as 1 second you should call this command multiple times with a small time value such as 0.02
//   so that it creates new particles in batches and spreads them out evenly. Calling it once with a large time value
//   of 1 second would create a huge batch of particles all at once and move them together as a blob instead of spreading them out.
// INPUTS
//   ID -- The ID of the emitter to check.
//   time -- The time in seconds to advance the emitter.
// SOURCE
void agk::Update3DParticles( uint32_t ID, float time )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to update 3D particle emitter %d, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->Update( time );
}

//****f* 3DParticles/Properties/Offset3DParticles
// FUNCTION
//   Immediately moves all existing particles by the given offset. For example an offset of x=3,y=5,z=0 would move
//   all particles to the right by 3 units and down 5 units. This does not affect the particle emitter
//   but can be used in conjunction with <i>Set3DParticlesPosition</i> to move both the emitter and the
//   particles that already exist.
// INPUTS
//   ID -- The ID of the emitter to modify.
//   x -- The distance to move the particles in the X direction.
//   y -- The distance to move the particles in the Y direction.
//   z -- The distance to move the particles in the Z direction.
// SOURCE
void agk::Offset3DParticles( uint32_t ID, float x, float y, float z )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to offset 3D particle emitter %d, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->Offset( x, y, z );
}

//****f* 3DParticles/Properties/Draw3DParticles
// FUNCTION
//   Immediately draws the particles to the backbuffer at its current position, size, and rotation. This is 
//   useful if you want to take control of the order that things are drawn. If you do this then be sure 
//   to make the particles invisible before calling <i>Render</i> or <i>Sync</i> otherwise the particles will 
//   be drawn twice
// INPUTS
//   ID -- The ID of the emitter to draw.
// SOURCE
void agk::Draw3DParticles( uint32_t ID )
//****
{
	AGK3DParticleEmitter *pEmitter = m_3DParticleEmitterList.GetItem( ID );
	if ( pEmitter == 0 )
	{
#ifdef _AGK_ERROR_CHECK
		uString errStr( "", 100 );
		errStr.Format( "Failed to draw 3D particle emitter %d, emitter does not exist", ID );
		Error( errStr );
#endif
		return;
	}

	pEmitter->DrawAll();
}

//************************************ Bullet Physics Milestone 1 ************************************************************** 

//****f* 3DPhysics/World/Create3DPhysicsWorld
// FUNCTION
//   You must create the the Physics world before calling any other physics commands.
//   <i>Create3DPhysicsWorld</i> Creates the physics world using the default scale factor of 40.
//   The scale is not the size of the world, it is the factor by which all the data passed in is
//   scaled down by to convert it to the Bullet Physics scale for the physics calculations./	  Then the data from Bullet is scaled up before it is passed to the AGK 3D world.
//   The default scale factor will be correct if your average character size is 72 AGK units tall.
//   Then the default gravity of -10.0 meters per second on the Y axis will give the correct visual result.
//   The Bullet Physics solver has a minimum size for objects. Objects below this size will cause instability with the solver.
//   At the default scale factor of 40 the smallest dimension that the solver can handle is about 3.5 AGK units.
//   To calculate the scale factor first determine your character's height in meters, a character of 72 units tall would be 1.8288 meters (or 6ft).
//   Then divide the character's height in units by the characters height in meters, for this example the scale factor would be (72 / 1.8) = 40.
// SOURCE
void agk::Create3DPhysicsWorld()
//****
{
	srand( ( unsigned )time( NULL ) ); //Must randomize timer
	DynamicsWorld* btWorld = new DynamicsWorld();
	btWorld->Initialize();
	DynamicsWorldArray.push_back( btWorld );
}

//****f* 3DPhysics/World/Create3DPhysicsWorld
// FUNCTION
//  You must create the the Physics world before calling any other physics commands.
//  <i>Create3DPhysicsWorld</i> Creates the physics world using the default scale factor of 40.
//  This function will create the physics world with a different scale factor.
//  The scale is not the size of the world, it is the factor by which all the data passed in is
//   scaled down by to convert it to the Bullet Physics scale for the physics calculations.
//	  Then the data from Bullet is scaled up before it is passed to the AGK 3D world.
//   The default scale factor will be correct if your average character size is 72 AGK units tall.
//   Then the default gravity of -10.0 meters per second on the Y axis will give the correct visual result.
//   The Bullet Physics solver has a minimum size for objects. Objects below this size will cause instability with the solver.
//   At the default scale factor of 40 the smallest dimension that the solver can handle is about 3.5 AGK units.
//   To calculate the scale factor first determine your character's height in meters, a character of 72 units tall would be 1.8288 meters (or 6ft).
//   Then divide the character's height in units by the characters height in meters, for this example the scale factor would be (72 / 1.8) = 40.
// INPUTS
//   scaleFactor -- The default scale factor is 40.
// SOURCE
void agk::Create3DPhysicsWorld( float scaleFactor )
//****
{
	srand( ( unsigned )time( NULL ) );
	DynamicsWorld* btWorld = new DynamicsWorld( scaleFactor );
	btWorld->Initialize();
	DynamicsWorldArray.push_back( btWorld );
}

//****f* 3DPhysics/World/Set3DPhysicsGravity
// FUNCTION
//   Sets the gravity of the physics world, gravity is in meters per second.
//   Gravity is set to ( 0.0, -10.0, 0.0 ) by default. You only need to call this command if 
//   you need to change from the default setting.
// INPUTS
//   x -- The value of gravity on the X axis in meters per second.
//	 y -- The value of gravity on the Y axis in meters per second.
//   z -- The value of gravity on the Z axis in meters per second.  
// SOURCE
void agk::Set3DPhysicsGravity( float x, float y, float z )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( GetCurrentDynamicsWorld()->m_dynamicsWorld ){
		GetCurrentDynamicsWorld()->m_dynamicsWorld->setGravity( btVector3( x, y, z ) );
	}
}

//****f* 3DPhysics/World/Set3DPhysicsGravity
// FUNCTION
//   Sets the gravity of the physics world, gravity is in meters per second.
//   Gravity is set to ( 0.0, -10.0, 0.0 ) by default. You only need to call this command if 
//   you need to change from the default setting.
// INPUTS
//   vectorID -- The ID of the vector to use
// SOURCE
void agk::Set3DPhysicsGravity( uint32_t vectorID )
//****
{
	if ( !AGKToBullet::AssertValidVectorID( vectorID, "Set3DPhysicsGravity: vector ID is not valid" ) )
		return;
	AGKVector* vec = vectorManager.GetItem( vectorID )->GetAGKVector();
	agk::Set3DPhysicsGravity( vec->x, vec->y, vec->z );
}

//****f* 3DPhysics/World/Step3DPhysicsWorld
// FUNCTION
//   Call before the <i>Sync()</i> command at the bottom of the loop. 
//   This will step the physics world. Keeps physics constant regardless of framerate.
//   Not calling this command will pause the physics world action.
// SOURCE
void agk::Step3DPhysicsWorld()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( GetCurrentDynamicsWorld()->m_dynamicsWorld ){
		float ms = GetCurrentDynamicsWorld()->GetDeltaTimeMilliseconds();
		//The second parameter is max number of substeps and keeps physics consistant regardless of framerate.
		GetCurrentDynamicsWorld()->m_dynamicsWorld->stepSimulation( ms / 1000.0f, 20 );
		DynamicsWorld::UpdateRagdolls();
		DynamicsWorld::UpdateCharacterControllers();
	}
}

//****f* 3DPhysics/World/Reset3DPhysicsWorld
// FUNCTION
//  This deletes the physics world and all the shapes, rigid bodies, joints, joint motors, ragdolls and character controllers.
//  Then recreates an empty physics world with default scale and gravity. You will then need to recreate all the shapes, rigid bodies, joints, joint motors, 
//  ragdolls and character controllers that you require.
// SOURCE
void agk::Reset3DPhysicsWorld()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	GetCurrentDynamicsWorld()->Reset();
}

//****f* 3DPhysics/World/Delete3DPhysicsWorld
// FUNCTION
//  Deletes the entire 3D physics world.
// SOURCE
void agk::Delete3DPhysicsWorld()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if (GetCurrentDynamicsWorld()){
		delete GetCurrentDynamicsWorld();
		DynamicsWorldArray.clear();
	}
}

//****f* 3DPhysics/World/Debug3DPhysicsWorld
// FUNCTION
//  Call in loop before step physics. Draws the debug overlay of the 3D physics world.
//  Note: This command does not currently work needs the ability to draw wireframe in AGK.
// SOURCE
void agk::Debug3DPhysicsWorld()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if (GetCurrentDynamicsWorld()){
		//GetCurrentDynamicsWorld()->m_dynamicsWorld->debugDrawWorld();
	}
}

//****f* 3DPhysics/World/Get3DPhysicsTotalObjects
// FUNCTION
//  Returns the total number of physics objects in the world.
// SOURCE
int agk::Get3DPhysicsTotalObjects()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	return GetCurrentBulletDynamicsWorld()->getNumCollisionObjects();
}

//****f* 3DPhysics/World/Get3DPhysicsActiveObjects
// FUNCTION
//  Returns the total number of active objects in the physics world.
// SOURCE
int agk::Get3DPhysicsActiveObjects()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	return GetCurrentDynamicsWorld()->GetNumberOfActiveObjects();
}

//****f* 3DPhysics/World/Get3DPhysicsTotalJoints
// FUNCTION
//  Returns the total number of joints in the physics world
// SOURCE
int agk::Get3DPhysicsTotalJoints()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	return GetCurrentBulletDynamicsWorld()->getNumConstraints();
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeBox
// FUNCTION
//   Sets the collision shape to a box based on the size of the object.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::SetObjectShapeBox( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeBox: Object ID Is Not Valid" ) )
		return;
	btVector3 sizeVec = AGKToBullet::GetObjectSize( objID ) / GetCurrentDynamicsWorld()->m_scaleFactor;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeBox: Object does not have a Physics body" ) )
		return;
	btCollisionShape* collShape = CollisionShapes::Box( sizeVec );
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeBox
// FUNCTION
//   Sets the collision shape to a box based on the size passed in.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
//  sizeX -- dimension on the x axis
//  sizeY -- dimension on the Y axis
//  sizeZ -- dimension on the Z axis
// SOURCE
void agk::SetObjectShapeBox( uint32_t objID, float sizeX, float sizeY, float sizeZ )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeBox: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeBox: Object does not have a Physics body" ) )
		return;
	btVector3 sizeVec( sizeX, sizeY, sizeZ );
	sizeVec /= GetCurrentDynamicsWorld()->m_scaleFactor ;
	btCollisionShape* collShape = CollisionShapes::Box( sizeVec );
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeBox
// FUNCTION
//   Sets the collision shape to a box based on the size passed in.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
//  vectorID -- Id of a dimension vector
// SOURCE
void agk::SetObjectShapeBox( uint32_t objID, uint32_t vectorID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidVectorID( vectorID, "SetObjectShapeBox: vector ID is not valid" ) )
		return;
	AGKVector* vec = vectorManager.GetItem( vectorID )->GetAGKVector();
	agk::SetObjectShapeBox( objID, vec->x, vec->y, vec->z );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeSphere
// FUNCTION
//  Sets the collision shape to a sphere based on the size of the object.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::SetObjectShapeSphere( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeSphere: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeSphere: Object does not have a Physics body" ) )
		return;
	btScalar diameter = AGKToBullet::GetObjectDiameter( objID ) / GetCurrentDynamicsWorld()->m_scaleFactor;
	btCollisionShape* collShape = CollisionShapes::Sphere( diameter );
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeSphere
// FUNCTION
//  Sets the collision shape to a sphere based on the size passed in.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
//  diameter -- size of sphere
// SOURCE
void agk::SetObjectShapeSphere( uint32_t objID, float diameter )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeSphere: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeSphere: Object does not have a Physics body" ) )
		return;
	btCollisionShape* collShape = CollisionShapes::Sphere( diameter / GetCurrentDynamicsWorld()->m_scaleFactor );
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeCylinder
// FUNCTION
//  Sets the collision shape to a Cylinder based on the size of the object.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
//  axis -- 0 =X axis, 1 =Y axis, 2 = Z axis orientation
// SOURCE
void agk::SetObjectShapeCylinder( uint32_t objID, int axis )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeCylinder: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeCylinder: Object does not have a Physics body" ) )
		return;
	btVector3 sizeVec = AGKToBullet::GetObjectSize( objID ) / GetCurrentDynamicsWorld()->m_scaleFactor;
	btCollisionShape* collShape = CollisionShapes::Cylinder(sizeVec, axis);
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeCylinder
// FUNCTION
//  Sets the collision shape to a Cylinder based on the size passed in.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
//  axis -- 0 =X axis, 1 =Y axis, 2 = Z axis orientation
//  height -- height on the y
//  diameter -- diameter on the x and z
// SOURCE
void agk::SetObjectShapeCylinder( uint32_t objID, int axis, float height, float diameter )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeCylinder: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeCylinder: Object does not have a Physics body" ) )
		return;
	btVector3 sizeVec( diameter, height, diameter );
	sizeVec /= GetCurrentDynamicsWorld()->m_scaleFactor;
	btCollisionShape* collShape = CollisionShapes::Cylinder(sizeVec, axis);
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeCone
// FUNCTION
//   Sets the collision shape to a cone based on the size of the object.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
//  axis -- 0 =X axis, 1 =Y axis, 2 = Z axis orientation
// SOURCE
void agk::SetObjectShapeCone( uint32_t objID, int axis )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeCone: Object ID Is Not Valid" ) )
		return;
	btVector3 sizeVec = AGKToBullet::GetObjectSize( objID ) / GetCurrentDynamicsWorld()->m_scaleFactor ;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeCone: Object does not have a Physics body" ) )
		return;
	btCollisionShape* collShape = CollisionShapes::Cone( sizeVec, axis );
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeCone
// FUNCTION
//   Sets the collision shape to a cone based on the size passed in.
//   You must first create a physics body for the object or this command will fail.
//   Returns shape ID.
// INPUTS
//  objID -- object ID
//  axis -- 0 =X axis, 1 =Y axis, 2 = Z axis orientation
//  height -- height on the y
//  diameter -- diameter on the x and z
// SOURCE
void agk::SetObjectShapeCone( uint32_t objID, int axis, float height, float diameter )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeCone: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeCone: Object does not have a Physics body" ) )
		return;
	btVector3 sizeVec( diameter, height, diameter );
	sizeVec /= GetCurrentDynamicsWorld()->m_scaleFactor;
	btCollisionShape* collShape = CollisionShapes::Cone(sizeVec, axis);
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeCapsule
// FUNCTION
//   Sets the collision shape to a capsule based on the size of the object.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
//  axis -- 0 =X axis, 1 =Y axis, 2 = Z axis orientation
// SOURCE
void agk::SetObjectShapeCapsule( uint32_t objID, int axis )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeCapsule: Object ID Is Not Valid" ) )
		return;
	btVector3 sizeVec = AGKToBullet::GetObjectSize( objID );
	sizeVec	/= GetCurrentDynamicsWorld()->m_scaleFactor;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeCapsule: Object does not have a Physics body" ) )
		return;
	btCollisionShape* collShape = CollisionShapes::Capsule( sizeVec, axis );
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeCapsule
// FUNCTION
//   Sets the collision shape to a capsule based on the size passed in.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
//  axis -- 0 =X axis, 1 =Y axis, 2 = Z axis orientation
//  sizeX -- dimension on the x axis
//  sizeY -- dimension on the Y axis
//  sizeZ -- dimension on the Z axis
// SOURCE
void agk::SetObjectShapeCapsule( uint32_t objID, int axis, float sizeX, float sizeY, float sizeZ )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeCapsule: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeCapsule: Object does not have a Physics body" ) )
		return;
	btVector3 sizeVec( sizeX, sizeY, sizeZ );
	sizeVec /= GetCurrentDynamicsWorld()->m_scaleFactor;
	btCollisionShape* collShape = CollisionShapes::Capsule( sizeVec, axis );
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeCapsule
// FUNCTION
//   Sets the collision shape to a capsule based on the size passed in.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
//  axis -- 0 =X axis, 1 =Y axis, 2 = Z axis orientation
//  vectorID -- ID of the dimension vector. 
// SOURCE
void agk::SetObjectShapeCapsule( uint32_t objID, int axis, uint32_t vectorID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidVectorID( vectorID, "SetObjectShapeCapsule: vector ID is not valid" ) )
		return;
	AGKVector* vec = vectorManager.GetItem( vectorID )->GetAGKVector();
	 agk::SetObjectShapeCapsule( objID, axis, vec->x, vec->y, vec->z );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeConvexHull
// FUNCTION
//   Sets the objects collision shape to a convex hull based on the size of the object. 
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::SetObjectShapeConvexHull( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeConvexHull: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeConvexHull: Object does not have a Physics body" ) )
		return;
	btCollisionShape* collShape = CollisionShapes::ConvexHull( objID, true );
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeStaticPolygon
// FUNCTION
//   Sets the objects collision shape to a static triangle mesh based on the size of the object.
//   The object becomes a static object a triangle mesh shape can not be dynamic.
//   You must first create a physics body for the object or this command will fail.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::SetObjectShapeStaticPolygon( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeStaticPolygon: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeStaticPolygon: Object does not have a Physics body" ) )
		return;
	btBvhTriangleMeshShape* collShape = CollisionShapes::TriangleMesh( objID, true );
	delete body->getCollisionShape();
	body->setCollisionShape( collShape );
	RigidBodies::SetMass( body, 0.0 );
	body->setCollisionFlags(body->getCollisionFlags() | btCollisionObject::CF_STATIC_OBJECT);
	//--- STUFF NEEDED TO FIX INTERNAL EDGES PROBLEMS WITH btBvhTriangleMeshShapes ---
	//http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=6662&p=24566#p24566
	btTriangleInfoMap* triangleInfoMap = new btTriangleInfoMap();
    btGenerateInternalEdgeInfo( collShape, triangleInfoMap );
    body->setCollisionFlags( body->getCollisionFlags() | btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK );
}

//****f* 3DPhysics/CollisionShapes/SetObjectShapeCompound
// FUNCTION
//   Sets the objects collision shape to a compound shape ready to add more shapes.
//   The object must be dynamic.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::SetObjectShapeCompound( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObjectShapeCompound: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObjectShapeCompound: Object does not have a Physics body" ) )
		return;
	btCollisionShape* collShape = new btCompoundShape();
	CollisionShapes::DeleteShape( body->getCollisionShape() );
	body->setCollisionShape( collShape );
}

//****f* 3DPhysics/RigidBodies/Create3DPhysicsDynamicBody
// FUNCTION
//  Deletes the existing physics body and creates a dynamic body for the object with a box collision shape and a mass of 5.0 
//  Based on the objects size.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::Create3DPhysicsDynamicBody( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Create3DPhysicsDynamicBody: Object ID Is Not Valid" ) )
		return;
	if ( rigidBodyManager.GetItem( objID ) )
		delete rigidBodyManager.RemoveItem( objID );

	btVector3 sizeVec = AGKToBullet::GetObjectSize( objID ) / GetCurrentDynamicsWorld()->m_scaleFactor;
	btCollisionShape* collShape = CollisionShapes::Box( sizeVec );
	btRigidBody* body = RigidBodies::CreateRigidBody( collShape, objID, 5.0 );
	GetCurrentDynamicsWorld()->m_dynamicsWorld->addRigidBody( body );
	rigidBodyManager.AddItem( new RigidBody(body, objID) , objID );
	
}

//****f* 3DPhysics/RigidBodies/Create3DPhysicsStaticBody
// FUNCTION
//  Deletes the existing physics body and creates a Static triangle mesh collision shape and physics body for the object.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::Create3DPhysicsStaticBody( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Create3DPhysicsStaticBody: Object ID Is Not Valid" ) )
		return;
	if ( rigidBodyManager.GetItem( objID ) )
		delete rigidBodyManager.RemoveItem( objID );
	btBvhTriangleMeshShape* collShape = CollisionShapes::TriangleMesh( objID, true );
	btRigidBody* body = RigidBodies::CreateRigidBody( collShape, objID, 0.0 , false);
	GetCurrentDynamicsWorld()->m_dynamicsWorld->addRigidBody( body );
	body->setCollisionFlags(body->getCollisionFlags() | btCollisionObject::CF_STATIC_OBJECT);
	//--- STUFF NEEDED TO FIX INTERNAL EDGES PROBLEMS WITH btBvhTriangleMeshShapes ---
	//http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=6662&p=24566#p24566
	btTriangleInfoMap* triangleInfoMap = new btTriangleInfoMap();
    btGenerateInternalEdgeInfo( collShape, triangleInfoMap );
    body->setCollisionFlags( body->getCollisionFlags() | btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK );

	rigidBodyManager.AddItem( new RigidBody( body, objID) , objID );
}

//****f* 3DPhysics/RigidBodies/Create3DPhysicsKinematicBody
// FUNCTION
//  Deletes the existing physics body and creates a box collision shape and kinematic physics body for the object.
//  A kinematic body can be moved by using the agk commands for position and rotation of objects.
//  Note: A kinematic body can only interact with a dynamic body and will pass through a static body.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::Create3DPhysicsKinematicBody( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Create3DPhysicsKinematicBody: Object ID Is Not Valid" ) )
		return;
	if ( rigidBodyManager.GetItem( objID ))
		delete rigidBodyManager.RemoveItem( objID );
	btVector3 sizeVec = AGKToBullet::GetObjectSize( objID ) / GetCurrentDynamicsWorld()->m_scaleFactor;
	btCollisionShape* collShape = CollisionShapes::Box( sizeVec );
	btRigidBody* body = RigidBodies::CreateRigidBody( collShape, objID, 0.0 );
	body->setCollisionFlags( body->getCollisionFlags() | btCollisionObject::CF_KINEMATIC_OBJECT );
	body->setActivationState(DISABLE_DEACTIVATION);
	GetCurrentDynamicsWorld()->m_dynamicsWorld->addRigidBody( body );
	rigidBodyManager.AddItem( new RigidBody( body, objID ), objID );

	
}

//****f* 3DPhysics/RigidBodies/Delete3DPhysicsBody
// FUNCTION
//  Removes the physics body from the world and deletes it.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::Delete3DPhysicsBody( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Delete3DPhysicsBody: Object ID Is Not Valid" ) )
		return;
	if ( rigidBodyManager.GetItem( objID ))
	{
		delete rigidBodyManager.RemoveItem( objID );
	}
}

//****f* 3DPhysics/RigidBodies/Create3DPhysicsStaticPlane
// FUNCTION
//   Creates a static plane.
//   Returns a static Plane ID
// INPUTS
//  normalX -- x value of the normal vector.
//  normalY -- y value of the normal vector.
//  normalZ -- z value of the  normal vector.
//  offsetPosition -- How much the plane will be offset from its world position.
// SOURCE
int agk::Create3DPhysicsStaticPlane( float normalX, float normalY, float normalZ, float offsetPosition )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	offsetPosition /= GetCurrentDynamicsWorld()->m_scaleFactor;
	btCollisionShape* collShape = new btStaticPlaneShape(btVector3( normalX, normalY, normalZ ), offsetPosition );
	btRigidBody* body = RigidBodies::CreateRigidBodyStatic( collShape );
	GetCurrentDynamicsWorld()->m_dynamicsWorld->addRigidBody( body );
	int planeID = staticPlaneManager.GetFreeID();
	staticPlaneManager.AddItem( new StaticPlane( planeID, body ), planeID );
	return planeID;
}

//****f* 3DPhysics/RigidBodies/Set3DPhysicsStaticPlanePosition
// FUNCTION
//   Sets the position of the static plane
// INPUTS
//  planeID -- static plane ID
//  posX -- The world X position.
//  posY -- The world Y position.
//  posZ -- The world Z position.
// SOURCE
void agk::Set3DPhysicsStaticPlanePosition( uint32_t planeID, float posX, float posY, float posZ )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidPlaneID( planeID, "Set3DPhysicsStaticPlanePosition: Plane ID is not valid" ) )
		return;
	btScalar scaleFactor = GetCurrentDynamicsWorld()->m_scaleFactor;
	btVector3 posVec( posX , posY, posZ );
	posVec /= scaleFactor;
	StaticPlane* agkPlane = staticPlaneManager.GetItem( planeID );
	btRigidBody* body = agkPlane->GetPlane();
	body->getWorldTransform().setOrigin( posVec );
}

//****f* 3DPhysics/RigidBodies/Set3DPhysicsStaticPlaneRotation
// FUNCTION
//  Sets the rotation of the static Plane
// INPUTS
//  planeID -- static plane ID
//  angX -- The world X angle of rotation.
//  angY -- The world Y angle of rotation.
//  angZ -- The world Z angle of rotation.
// SOURCE
void agk::Set3DPhysicsStaticPlaneRotation( uint32_t planeID, float angX, float angY, float angZ )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidPlaneID( planeID, "Set3DPhysicsStaticPlaneRotation: Plane ID is not valid" ) )
		return;
	btMatrix3x3 btMatrix;
	btMatrix.setEulerYPR( btScalar( btRadians( angZ ) ), btScalar( btRadians( angY ) ), btScalar( btRadians( angX ) ));
	StaticPlane* agkPlane = staticPlaneManager.GetItem( planeID );
	btRigidBody* body = agkPlane->GetPlane();
	body->getWorldTransform().setBasis( btMatrix );
}

//****f* 3DPhysics/RigidBodies/Delete3DPhysicsStaticPlane
// FUNCTION
//   Deletes the static plane.
// INPUTS
//  planeID -- static plane ID
// SOURCE
void agk::Delete3DPhysicsStaticPlane( uint32_t planeID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidPlaneID( planeID, "Delete3DPhysicsStaticPlane: Plane ID is not valid" ) )
		return;
	StaticPlane* agkPlane = staticPlaneManager.GetItem( planeID );
	if(agkPlane){
		btRigidBody* body = agkPlane->GetPlane();
		staticPlaneManager.RemoveItem( planeID );
		RigidBodies::Delete( body );
	}
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsGroupAndMask
// FUNCTION
//   Sets the objects collision group and mask.
//   By default all physics objects are in one group and are not masked.
//   If you use collision groups and masks you must use them for all physics objects in the world.
// INPUTS
//  objID -- object ID
//	 group -- collision group that this Physics object belongs too.
//	 group1 = 2,
//	 group2 = 4,
//	 group3 = 8,
//	 group4 = 16,
//	 group5 = 32
//  mask --  collision groups you want masked from collision.
//	 mask1 = 2,
//	 mask2 = 4,
//	 mask3 = 8,
//	 mask4 = 16,
//	 mask5 = 32
//  -1 is all Maskes
// SOURCE
void agk::SetObject3DPhysicsGroupAndMask( uint32_t objID, int group, int mask )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsGroupAndMask: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsGroupAndMask: Object does not have a Physics body" ) )
		return;
	GetCurrentDynamicsWorld()->m_dynamicsWorld->removeRigidBody( body );
	GetCurrentDynamicsWorld()->m_dynamicsWorld->addRigidBody( body, group, mask );
	rigidBodyManager.GetItem( objID )->SetCollissionGroup( group );
	rigidBodyManager.GetItem( objID )->SetCollissionMask( mask );
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsGroup
// FUNCTION
//   Returns the objects collision group.
//   By default all physics objects are in one group and are not masked.
//   If you use collision groups and masks you must use them for all physics objects.
// INPUTS
//  objID -- object ID
// SOURCE
int agk::GetObject3DPhysicsGroup( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsGroup: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsGroup: Object does not have a Physics body" ) )
		return 0;
	return rigidBodyManager.GetItem( objID )->GetCollissionGroup();
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsMask
// FUNCTION
//   Returns the objects collision mask.
//   By default all physics objects are in one group and are not masked.
//   If you use collision groups and masks you must use them for all physics objects.
// INPUTS
//  objID -- object ID
// SOURCE
int agk::GetObject3DPhysicsMask( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsMask: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsMask: Object does not have a Physics body" ) )
		return 0;
	return rigidBodyManager.GetItem( objID )->GetCollissionMask();
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsMass
// FUNCTION
//  Sets the mass of the object
// INPUTS
//  objID -- object ID
//  mass -- mass of the object
// SOURCE
void agk::SetObject3DPhysicsMass( uint32_t objID, float mass )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsMass: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsMass: Object does not have a Physics body" ) )
		return;
	RigidBodies::SetMass( body, mass );
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsMass
// FUNCTION
//   Returns the objects mass
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsMass( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsMass: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsMass: Object does not have a Physics body" ) )
		return 0;
	return RigidBodies::GetMass( body );
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsCanSleep
// FUNCTION
//   All dynamic objects are automatically put to sleep at rest.
//   This will stop the dynamic object from being automatically put to sleep.
// INPUTS
//  objID -- object ID
//  canSleep -- 1 = true , 0 = false
// SOURCE
void agk::SetObject3DPhysicsCanSleep( uint32_t objID, int canSleep )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsCanSleep: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsCanSleep: Object does not have a Physics body" ) )
		return;
	if ( !body->isStaticOrKinematicObject() ){
		if ( canSleep == 0 ){
			RigidBodies::SetActivationSate( body, DISABLE_DEACTIVATION );
		}
		else{
			RigidBodies::SetActivationSate( body, ACTIVE_TAG );
		}
	}
	else{
		Error( "SetObject3DPhysicsCanSleep: Object is not a dynamic body" );
	}
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsFriction
// FUNCTION
//   This will set the friction for dynamic and static objects
// INPUTS
//  objID -- object ID
//  friction -- friction value as a float
// SOURCE
void agk::SetObject3DPhysicsFriction( uint32_t objID, float friction )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsFriction: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsFriction: Object does not have a Physics body" ) )
		return;
	RigidBodies::SetFriction( body, friction );
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsFriction
// FUNCTION
//  Returns the friction for the physics object.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsFriction( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsFriction: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsFriction: Object does not have a Physics body" ) )
		return 0;
	return body->getFriction();
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsRollingFriction
// FUNCTION
//   This will set the rolling friction for static and dynamic objects.
// INPUTS
//  objID -- object ID
//   friction -- rolling friction value as a float
// SOURCE
void agk::SetObject3DPhysicsRollingFriction( uint32_t objID, float friction )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsRollingFriction: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsRollingFriction: Object does not have a Physics body" ) )
		return;
	RigidBodies::SetRollingFriction( body, friction);
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsRollingFriction
// FUNCTION
//  Returns the rolling friction for the physics object.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsRollingFriction( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsRollingFriction: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsRollingFriction: Object does not have a Physics body" ) )
		return 0;
	return body->getRollingFriction();
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsAnisotropicFriction
// FUNCTION
//   This will set the type of anisotropic friction.
// INPUTS
//  objID -- object ID
//	 type -- DISABLED = 0, FRICTION = 1, ROLLING_FRICTION = 2
// SOURCE
void agk::SetObject3DPhysicsAnisotropicFriction( uint32_t objID, int type )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsAnisotropicFriction: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsAnisotropicFriction: Object does not have a Physics body" ) )
		return;
	if ( type >= 3 ){
		Error( "SetObject3DPhysicsAnisotropicFriction: In valid parameter. Type = 0,1,2 " );
	}
	RigidBodies::SetAnisotropicFriction( body, type );
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsMaxLinearVelocity
// FUNCTION
//   This will set the max linear velocity for the dynamic object.
//   This will prevent objects from going too fast to be seen on screen.
// INPUTS
//  objID -- object ID
//  maxLinearVelocity -- max speed an object can reach.
// SOURCE
void agk::SetObject3DPhysicsMaxLinearVelocity( uint32_t objID, float maxLinearVelocity )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsMaxLinearVelocity: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsMaxLinearVelocity: Object does not have a Physics body" ) )
		return;
	( ( AGKMotionState* )body->getMotionState() )->SetMaxLinearVelocity(btScalar( maxLinearVelocity ) );
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsMaxLinearVelocity
// FUNCTION
//  Returns the max linear velocity for the physics object.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsMaxLinearVelocity( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsMaxLinearVelocity: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsMaxLinearVelocity: Object does not have a Physics body" ) )
		return 0;
	return ( ( AGKMotionState* )body->getMotionState() )->GetMaxLinearVelocity();
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsLinearVelocity
// FUNCTION
//  Sets the linear velocity vector for the object.
//  The direction vector is automatically normalized.
// INPUTS
//  objID -- object ID
//  dirX -- the X component of the direction vector
//  dirY -- the Y component of the direction vector
//  dirZ -- the Z component of the direction vector
//  initialSpeed -- the initial speed.
// SOURCE
void agk::SetObject3DPhysicsLinearVelocity( uint32_t objID, float dirX, float dirY, float dirZ, float initialSpeed )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsLinearVelocity: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsLinearVelocity: Object does not have a Physics body" ) )
		return;
	btVector3 linVelocity( dirX, dirY, dirZ );
	linVelocity.normalize();
	linVelocity = linVelocity * initialSpeed;
	linVelocity = linVelocity / GetCurrentDynamicsWorld()->m_scaleFactor;
	RigidBodies::SetLinearVelocity( body, linVelocity );
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsLinearVelocity
// FUNCTION
//  Sets the linear velocity vector for the object.
//  The direction vector is automatically normalized.
// INPUTS
//  objID -- object ID
//  vectorID -- ID of the direction vector
//  initialSpeed -- the initial speed.
// SOURCE
void agk::SetObject3DPhysicsLinearVelocity( uint32_t objID, uint32_t vectorID, float initialSpeed )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidVectorID( vectorID, "SetObject3DPhysicsLinearVelocity: vector ID is not valid" ) )
		return;
	AGKVector* vec = vectorManager.GetItem( vectorID )->GetAGKVector();
	agk::SetObject3DPhysicsLinearVelocity( objID, vec->x, vec->y, vec->z, initialSpeed );
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsLinearVelocityX
// FUNCTION
//   Returns the X component of the Linear Velocity vector.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsLinearVelocityX( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsLinearVelocityX: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsLinearVelocityX: Object does not have a Physics body" ) )
		return 0;
	btVector3 linVelocity = RigidBodies::GetLinearVelocity( body );
	linVelocity *= GetCurrentDynamicsWorld()->m_scaleFactor;
	return linVelocity.getX();
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsLinearVelocityY
// FUNCTION
//   Returns the X component of the Linear Velocity vector.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsLinearVelocityY( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsLinearVelocityY: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsLinearVelocityY: Object does not have a Physics body" ) )
		return 0;
	btVector3 linVelocity = RigidBodies::GetLinearVelocity( body );
	linVelocity *= GetCurrentDynamicsWorld()->m_scaleFactor;
	return linVelocity.getY();
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsLinearVelocityZ
// FUNCTION
//   Returns the X component of the Linear Velocity vector.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsLinearVelocityZ( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsLinearVelocityZ: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsLinearVelocityZ: Object does not have a Physics body" ) )
		return 0;
	btVector3 linVelocity = RigidBodies::GetLinearVelocity( body );
	linVelocity *= GetCurrentDynamicsWorld()->m_scaleFactor;
	return linVelocity.getZ();
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsAngularVelocity
// FUNCTION
//  Sets the angular velocity of the object. 
//  The angle vector is automatically normalized.
// INPUTS
//  objID -- object ID
//  angX -- the X component of the angle vector
//  angY -- the Y component of the angle vector
//  angZ -- the Z component of the angle vector
//  initialSpeed -- the initial speed.
// SOURCE
void agk::SetObject3DPhysicsAngularVelocity( uint32_t objID, float angX, float angY, float angZ, float initialSpeed )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsAngularVelocity: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsAngularVelocity: Object does not have a Physics body" ) )
		return;
	btVector3 angVelocity( angX, angY, angZ );
	angVelocity.normalize();
	angVelocity = angVelocity * initialSpeed;
	angVelocity = angVelocity / GetCurrentDynamicsWorld()->m_scaleFactor;
	RigidBodies::SetAngularVelocity( body, angVelocity );
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsAngularVelocity
// FUNCTION
//  Sets the angular velocity of the object
//  The angle vector is automatically normalized.
// INPUTS
//  objID -- object ID
//  vectorID -- ID of direction Vector.
//  initialSpeed -- the initial speed.
// SOURCE
void agk::SetObject3DPhysicsAngularVelocity( uint32_t objID, uint32_t vectorID, float initialSpeed )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidVectorID( vectorID, "SetObject3DPhysicsAngularVelocity: vector ID is not valid" ) )
		return;
	AGKVector* vec = vectorManager.GetItem( vectorID )->GetAGKVector();
	agk::SetObject3DPhysicsAngularVelocity( objID, vec->x, vec->y, vec->z, initialSpeed );
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsAngularVelocityX
// FUNCTION
//   Return the X component of the angular velocity vector.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsAngularVelocityX( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsAngularVelocityX: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsAngularVelocityX: Object does not have a Physics body" ) )
		return 0;
	btVector3 angVelocity = body->getAngularVelocity();
	angVelocity *= GetCurrentDynamicsWorld()->m_scaleFactor;
	return angVelocity.getX();
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsAngularVelocityY
// FUNCTION
//   Return the Y component of the angular velocity vector.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsAngularVelocityY( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsAngularVelocityY: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsAngularVelocityY: Object does not have a Physics body" ) )
		return 0;
	btVector3 angVelocity = body->getAngularVelocity();
	angVelocity *= GetCurrentDynamicsWorld()->m_scaleFactor;
	return angVelocity.getY();
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsAngularVelocityZ
// FUNCTION
//   Return the Z component of the angular velocity vector.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsAngularVelocityZ( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsAngularVelocityZ: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsAngularVelocityZ: Object does not have a Physics body" ) )
		return 0;
	btVector3 angVelocity = body->getAngularVelocity();
	angVelocity *= GetCurrentDynamicsWorld()->m_scaleFactor;
	return angVelocity.getZ();
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsDamping
// FUNCTION
//   Sets the linear and angular damping for the object
// INPUTS
//  objID -- object ID
//  linearDamp -- The amount of linear damping applied to the object.
//  angularDamp -- The amount of angular damping applied to the object.
// SOURCE
void agk::SetObject3DPhysicsDamping( uint32_t objID, float linearDamp, float angularDamp )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsDamping: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsDamping: Object does not have a Physics body" ) )
		return;
	RigidBodies::SetDamping( body, linearDamp, angularDamp );
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsLinearDamp
// FUNCTION
//   Return the linear Damping value
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsLinearDamp( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsLinearDamp: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsLinearDamp: Object does not have a Physics body" ) )
		return 0;
	return body->getLinearDamping();
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsAngularDamp
// FUNCTION
//   Returns the Angular Damping value
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsAngularDamp( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsAngularDamp: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsAngularDamp: Object does not have a Physics body" ) )
		return 0;
	return body->getAngularDamping();
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsSleepingThreshold
// FUNCTION
//  Sets the 3d physics sleeping thresholds for the object.
// INPUTS
//  objID -- object ID
//  angular -- angular velocity
//  linear --  linear velocity
// SOURCE
void agk::SetObject3DPhysicsSleepingThreshold( uint32_t objID, float angular, float linear )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsSleepingThreshold: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsSleepingThreshold: Object does not have a Physics body" ) )
		return;
	body->setSleepingThresholds( btScalar( linear ) / GetCurrentDynamicsWorld()->m_scaleFactor , btScalar( angular ) );
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsAngularSleepingThreshold
// FUNCTION
//  Returns the angular Sleeping threshold for the Physics Object.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsAngularSleepingThreshold( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsAngularSleepingThreshold: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsAngularSleepingThreshold: Object does not have a Physics body" ) )
		return 0;
	return body->getAngularSleepingThreshold();
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsLinearSleepingThreshold
// FUNCTION
//  Returns the linear Sleeping threshold for the Physics Object.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsLinearSleepingThreshold( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsLinearSleepingThreshold: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsLinearSleepingThreshold: Object does not have a Physics body" ) )
		return 0;
	return body->getLinearSleepingThreshold() * GetCurrentDynamicsWorld()->m_scaleFactor;
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsDeactivationTime
// FUNCTION
//  Sets the deactivation time for the physics object.
//  This is the amount of time the physics object waits when it comes to rest before it becomes deactivated.
// INPUTS
//  objID -- object ID
//  time -- 
// SOURCE
void agk::SetObject3DPhysicsDeactivationTime( uint32_t objID, float time )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsDeactivationTime: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsDeactivationTime: Object does not have a Physics body" ) )
		return;
	body->setDeactivationTime( btScalar( time ) );
}

//****f* 3DPhysics/RigidBodies/SetObject3DPhysicsRestitution
// FUNCTION
//   Sets the restitution friction for the object.
//   You can set the Restitution for dynamic and static objects.
// INPUTS
//  objID -- object ID
//  friction -- The amount of friction applied to the object.
// SOURCE
void agk::SetObject3DPhysicsRestitution( uint32_t objID, float friction)
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "SetObject3DPhysicsRestitution: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SetObject3DPhysicsRestitution: Object does not have a Physics body" ) )
		return;
	body->setRestitution( btScalar( friction ) );
}

//****f* 3DPhysics/RigidBodies/GetObject3DPhysicsRestitution
// FUNCTION
//   Gets the current restitution value for the physics object.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::GetObject3DPhysicsRestitution(  uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsRestitution: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsRestitution: Object does not have a Physics body" ) )
		return 0;
	return body->getRestitution();
}

//****f* 3DPhysics/ContactReports/GetObject3DPhysicsFirstContact
// FUNCTION
//   Returns true if object has had a contact in the physics step.
// INPUTS
//  objID -- object ID
// SOURCE
int agk::GetObject3DPhysicsFirstContact( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "GetObject3DPhysicsFirstContact: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "GetObject3DPhysicsFirstContact: Object does not have a Physics body" ) )
		return 0;
	return RigidBodies::GetContacts( body );
}

//****f* 3DPhysics/ContactReports/GetObject3DPhysicsContactX
// FUNCTION
//   Returns X position of contact
// INPUTS
// SOURCE
float agk::GetObject3DPhysicsContactX()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if(ContactReport::GetContact() == NULL ){
		agk::Error("GetObject3DPhysicsContactX: No Contact Exists");
		return 0;
	}
	return ContactReport::GetContact()->GetContactPosition().getX();
}

//****f* 3DPhysics/ContactReports/GetObject3DPhysicsContactY
// FUNCTION
//   Returns Y position of contact
// INPUTS
// SOURCE
float agk::GetObject3DPhysicsContactY()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if(ContactReport::GetContact() == NULL ){
		agk::Error("GetObject3DPhysicsContactY: No Contact Exists");
		return 0;
	}
	return ContactReport::GetContact()->GetContactPosition().getY();
}

//****f* 3DPhysics/ContactReports/GetObject3DPhysicsContactZ
// FUNCTION
//   Returns Z position of contact
// INPUTS
// SOURCE
float agk::GetObject3DPhysicsContactZ()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if(ContactReport::GetContact() == NULL ){
		agk::Error("GetObject3DPhysicsContactZ: No Contact Exists");
		return 0;
	}
	return ContactReport::GetContact()->GetContactPosition().getZ();
}

//****f* 3DPhysics/ContactReports/GetObject3DPhysicsContactVector
// FUNCTION
//  Returns true if there is a contact vector and fills the vector outPosVec3.
//  First create a vector with <i>CreateVector3()</i> then pass in the ID.
//  The vector you have created and passed in will be filled with the results.
// INPUTS
//  outPosVec3 -- The ID of the vector to be filled with the results.
// SOURCE
int agk::GetObject3DPhysicsContactVector(int outPosVec3)
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID(outPosVec3, "GetObject3DPhysicsContactVector: Vector ID not valid") )
		return 0;
	if( ContactReport::GetContact() == NULL ){
		agk::Error("GetObject3DPhysicsContactVector: No Contact Exists");
		return 0;
	}
	AGKVector* outVec3 = vectorManager.GetItem( outPosVec3 )->GetAGKVector();
	outVec3->Set( ContactReport::GetContact()->GetContactPosition().getX(), ContactReport::GetContact()->GetContactPosition().getY(), ContactReport::GetContact()->GetContactPosition().getZ() );
	outVec3->Mult( GetCurrentDynamicsWorld()->m_scaleFactor );
	return 1;
}

//****f* 3DPhysics/ContactReports/GetObject3DPhysicsContactObjectB
// FUNCTION
//   Returns the object ID of the second object in the contact.
// INPUTS
// SOURCE
int agk::GetObject3DPhysicsContactObjectB()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if(ContactReport::GetContact() == NULL ){
		return -1;
	}
	return ContactReport::GetContact()->GetObjectB();
}

//****f* 3DPhysics/ContactReports/GetObject3DPhysicsNextContact
// FUNCTION
//  Returns true if there is another contact to report.
// INPUTS
// SOURCE
int agk::GetObject3DPhysicsNextContact()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	return ContactReport::GetNextContact() != NULL;
}

//****f* 3DPhysics/ContactReports/GetObjects3DPhysicsContactPositionVector
// FUNCTION
//   Fills <i>outPosVec3</i> with contact position.
//   Returns false if no contact.
//   First create a vector with <i>CreateVector3()</i> then pass in the ID.
//   The vector you have created and passed in will be filled with the results.
// INPUTS
//  objA -- first object ID
//  objB -- second object ID
//  outPosVec3 -- Id of the position Vector to be filled. Create this vector first.
// SOURCE
int agk::GetObjects3DPhysicsContactPositionVector( uint32_t objA, uint32_t objB, int outPosVec3 )
//****
{
	//This uses a special contact call back.
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objA, "GetObjects3DPhysicsContactPositionVector: Object A ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyA = rigidBodyManager.GetItem( objA ) ? rigidBodyManager.GetItem( objA )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyA, "GetObjects3DPhysicsContactPositionVector: Object A does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objB, "GetObjects3DPhysicsContactPositionVector: Object B ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyB = rigidBodyManager.GetItem( objB ) ? rigidBodyManager.GetItem( objB )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyB, "GetObjects3DPhysicsContactPositionVector: Object B does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( outPosVec3, "GetObjects3DPhysicsContactPositionVector: positionVec3 ID not valid" ) )
		return 0;
	btTransform contactTrans;
	contactTrans.setIdentity();
	int error = Joints::GetContactPosition( bodyA, bodyB, contactTrans );
	if(error == 1){
		AGKVector* outVec3 = vectorManager.GetItem( outPosVec3 )->GetAGKVector();
		btVector3 contactPos( contactTrans.getOrigin().getX(), contactTrans.getOrigin().getY(), contactTrans.getOrigin().getZ() );
		contactPos *= GetCurrentDynamicsWorld()->m_scaleFactor;
		outVec3->Set( contactPos.getX(), contactPos.getY(), contactPos.getZ() );
		return 1;
	}
	return 0;
}

//****f* 3DPhysics/Joints/Create3DPhysicsPickJoint
// FUNCTION
//   Returns Joint ID
// INPUTS
//  objID -- object ID
//  positionVec3 -- Id of the position Vector
// SOURCE
int agk::Create3DPhysicsPickJoint( uint32_t objID, int positionVec3 )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return -1;
	if ( !AGKToBullet::AssertValidObject( objID, "Create3DPhysicsPickJoint: Object ID Is Not Valid" ) )
		return -1;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "Create3DPhysicsPickJoint: Object does not have a Physics body" ) )
		return -1;
	if ( body != NULL ){
		if ( !AGKToBullet::AssertValidVectorID( positionVec3, "Create3DPhysicsPickJoint: positionVec3 ID not valid" ) )
			return -1;
		btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
		scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
		btGeneric6DofConstraint* dof6 = Joints::CreatePickConstraint( body, scaledPos );
		if( dof6==NULL )
			return -1;
		uint32_t jointID = jointManager.GetFreeID();
		jointManager.AddItem( new Joint( jointID, dof6 ), jointID );
		return jointID;
	}
	return -1;
}

//****f* 3DPhysics/Joints/Update3DPhysicsPickJoint
// FUNCTION
//  Sets new position of pick joint.
// INPUTS
//  jointID -- ID of Joint
//  positionVec3 -- Id of the position Vector
// SOURCE
void agk::Update3DPhysicsPickJoint( uint32_t jointID, int positionVec3 )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Update3DPhysicsPickJoint: Joint Id is not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "Update3DPhysicsPickJoint: positionVec3 ID not valid" ) )
		return;
	btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
	scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
	btGeneric6DofConstraint* pickJoint = static_cast<btGeneric6DofConstraint*>(constraint);
	pickJoint->getFrameOffsetA().setOrigin(scaledPos);
}

//****f* 3DPhysics/Joints/Delete3DPhysicsPickJoint
// FUNCTION
//  Deletes pick joint.
// INPUTS
//  jointID -- ID of Joint
// SOURCE
void agk::Delete3DPhysicsPickJoint( uint32_t jointID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidJointID( jointID, "Update3DPhysicsPickJoint: Joint Id is not valid" ) )
		return;
	if(jointManager.GetItem( jointID ))
	{
		btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
		if ( !AGKToBullet::AssertValidJoint( constraint, "Update3DPhysicsPickJoint: Joint is not valid" ) )
			return;
		btGeneric6DofConstraint* pickJoint = static_cast<btGeneric6DofConstraint*>( constraint );
		int objID = ( ( AGKMotionState* )pickJoint->getRigidBodyB().getMotionState())->GetObjID();
		if(rigidBodyManager.GetItem( objID )){
			btRigidBody* pickedBody = rigidBodyManager.GetItem( objID )->GetRigidBody();
			pickedBody->forceActivationState( ACTIVE_TAG );
			pickedBody->setDeactivationTime( 0.0 );
		}
		delete jointManager.RemoveItem( jointID );
	}
}

//****f* 3DPhysics/Joints/Create3DPhysicsHingeJoint
// FUNCTION
//  Creates a hinge joint between object a and b.
//  The rotationVec3 parameter should be an axis in the form (0,1,0) for vertical, (1,0,0) for horizontal along the X axis, 
//  (0,0,1) for horizontal along the Z axis, or any combination of these. The rotation vector does not need to be normalized.
//  Returns a joint ID.
// INPUTS
//  objA -- first object ID
//  objB -- second object ID
//  positionVec3 -- vector ID
//  rotationVec3 -- vector ID
//  disableCollisions -- 1 = collisions will be disabled between linked objects, 0 collisions will be enabled between linked objects.
// SOURCE
int agk::Create3DPhysicsHingeJoint( uint32_t objA, uint32_t objB, int positionVec3, int rotationVec3, int disableCollisions )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objA, "Create3DPhysicsHingeJoint: Object A ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyA = rigidBodyManager.GetItem( objA ) ? rigidBodyManager.GetItem( objA )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyA, "Create3DPhysicsHingeJoint: Object A does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objB, "Create3DPhysicsHingeJoint: Object B ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyB = rigidBodyManager.GetItem( objB ) ? rigidBodyManager.GetItem( objB )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyB, "Create3DPhysicsHingeJoint: Object B does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "Create3DPhysicsHingeJoint: positionVec3 ID not valid" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( rotationVec3, "Create3DPhysicsHingeJoint: rotationVec3 ID not valid" ) )
		return 0;

	btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
	scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
	btTransform localATrans, localBTrans, jointTrans;
	btMatrix3x3 jointMatrix;
	//When we use setEulerYPR here for joints it needs to be ZYX
	//btVector3 rotVecRadians = AGKToBullet::GetBtVector3ToRadians( rotationVec3 );
	//jointMatrix.setEulerYPR( rotVecRadians.getZ(), rotVecRadians.getY(), rotVecRadians.getX() );
	btVector3 rotVecAxis = AGKToBullet::GetBtVector3FromVecID( rotationVec3 );
	rotVecAxis.normalize();
	rotVecAxis.setY( -rotVecAxis.getY() );
	btVector3 origAxis(0,0,1);
	btQuaternion rotQuat = shortestArcQuat( origAxis, rotVecAxis );
	jointMatrix.setRotation( rotQuat );
	jointTrans.setIdentity();
	jointTrans.setOrigin( scaledPos );
	jointTrans.setBasis( jointMatrix );

	Joints::CreateLocalTransforms( bodyA, bodyB, jointTrans, localATrans, localBTrans );
	uint32_t jointID = jointManager.GetFreeID();
	jointManager.AddItem( new Joint( jointID, Joints::CreateHingeConstraint(bodyA, bodyB, localATrans, localBTrans, disableCollisions > 0 ) ), jointID );
	return jointID;
}

//****f* 3DPhysics/Joints/Create3DPhysicsConeTwistJoint
// FUNCTION
//  Creates a Cone Twist joint between object a and b.
//  The rotationVec3 parameter should be an axis in the form (0,1,0) for vertical, (1,0,0) for horizontal along the X axis, 
//  (0,0,1) for horizontal along the Z axis, or any combination of these. The rotation vector does not need to be normalized.
//  The joint will spin along the given axis and rotate freely within a cone along this axis. The cone limits can be 
//  specified with <i>Set3DPhysicsJointConeTwistLimits</i>.
//  Returns a joint ID.
// INPUTS
//  objA -- first object ID
//  objB -- second object ID
//  positionVec3 -- vector ID
//  rotationVec3 -- vector ID
//  disableCollisions -- 1 = collisions will be disabled between linked objects, 0 collisions will be enabled between linked objects.
// SOURCE
int agk::Create3DPhysicsConeTwistJoint( uint32_t objA, uint32_t objB, int positionVec3, int rotationVec3, int disableCollisions )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objA, "Create3DPhysicsConeTwistJoint: Object A ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyA = rigidBodyManager.GetItem( objA ) ? rigidBodyManager.GetItem( objA )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyA, "Create3DPhysicsConeTwistJoint: Object A does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objB, "Create3DPhysicsConeTwistJoint: Object B ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyB = rigidBodyManager.GetItem( objB ) ? rigidBodyManager.GetItem( objB )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyB, "Create3DPhysicsConeTwistJoint: Object B does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "Create3DPhysicsConeTwistJoint: positionVec3 ID not valid" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( rotationVec3, "Create3DPhysicsConeTwistJoint: rotationVec3 ID not valid" ) )
		return 0;

	btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
	scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
	//btVector3 rotVecRadians = AGKToBullet::GetBtVector3ToRadians( rotationVec3 );
	btTransform localATrans, localBTrans, jointTrans;
	btMatrix3x3 jointMatrix;
	//When we use setEulerYPR here for joints it needs to be ZYX
	//jointMatrix.setEulerYPR( rotVecRadians.getZ(), rotVecRadians.getY(), rotVecRadians.getX() );
	btVector3 rotVecAxis = AGKToBullet::GetBtVector3FromVecID( rotationVec3 );
	rotVecAxis.normalize();
	rotVecAxis.setY( -rotVecAxis.getY() );
	btVector3 origAxis(1,0,0);
	btQuaternion rotQuat = shortestArcQuat( origAxis, rotVecAxis );
	jointMatrix.setRotation( rotQuat );
	jointTrans.setIdentity();
	jointTrans.setOrigin( scaledPos );
	jointTrans.setBasis( jointMatrix );

	Joints::CreateLocalTransforms( bodyA, bodyB, jointTrans, localATrans, localBTrans );
	uint32_t jointID = jointManager.GetFreeID();
	jointManager.AddItem( new Joint( jointID, Joints::CreateTwistConstraint( bodyA, bodyB, localATrans, localBTrans, disableCollisions > 0 ) ), jointID );
	return jointID;
}

//****f* 3DPhysics/Joints/Create3DPhysicsSliderJoint
// FUNCTION
//  Creates a Slider joint between object a and b.
//  The rotationVec3 parameter should be an axis in the form (0,1,0) for vertical, (1,0,0) for horizontal along the X axis, 
//  (0,0,1) for horizontal along the Z axis, or any combination of these. The rotation vector does not need to be normalized.
//  Returns a joint ID.
// INPUTS
//  objA -- first object ID
//  objB -- second object ID
//  positionVec3 -- vector ID
//  rotationVec3 -- vector ID
// SOURCE
int agk::Create3DPhysicsSliderJoint( uint32_t objA, uint32_t objB, int positionVec3, int rotationVec3 )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objA, "Create3DPhysicsSliderJoint: Object A ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyA = rigidBodyManager.GetItem( objA ) ? rigidBodyManager.GetItem( objA )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyA, "Create3DPhysicsSliderJoint: Object A does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objB, "Create3DPhysicsSliderJoint: Object B ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyB = rigidBodyManager.GetItem( objB ) ? rigidBodyManager.GetItem( objB )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyB, "Create3DPhysicsSliderJoint: Object B does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "Create3DPhysicsSliderJoint: positionVec3 ID not valid" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( rotationVec3, "Create3DPhysicsSliderJoint: rotationVec3 ID not valid" ) )
		return 0;

	btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
	scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
	//btVector3 rotVecRadians = AGKToBullet::GetBtVector3ToRadians( rotationVec3 );
	btTransform localATrans, localBTrans, jointTrans;
	btMatrix3x3 jointMatrix;
	//When we use setEulerYPR here for joints it needs to be ZYX
	//jointMatrix.setEulerYPR( rotVecRadians.getZ(), rotVecRadians.getY(), rotVecRadians.getX() );
	btVector3 rotVecAxis = AGKToBullet::GetBtVector3FromVecID( rotationVec3 );
	rotVecAxis.normalize();
	rotVecAxis.setY( -rotVecAxis.getY() );
	btVector3 origAxis(1,0,0);
	btQuaternion rotQuat = shortestArcQuat( origAxis, rotVecAxis );
	jointMatrix.setRotation( rotQuat );
	jointTrans.setIdentity();
	jointTrans.setOrigin( scaledPos );
	jointTrans.setBasis( jointMatrix );
	Joints::CreateLocalTransforms( bodyA, bodyB, jointTrans, localATrans, localBTrans );
	uint32_t jointID = jointManager.GetFreeID();
	jointManager.AddItem( new Joint( jointID, Joints::CreateSliderConstraint( bodyA, bodyB, localATrans, localBTrans ) ), jointID );
	return jointID;
}

//****f* 3DPhysics/Joints/Create3DPhysicsFixedJoint
// FUNCTION
//  Creates a Fixed joint between object a and b.
//  Returns a joint ID.
// INPUTS
//  objA -- first object ID
//  objB -- second object ID
//  positionVec3 -- vector ID
// SOURCE
int agk::Create3DPhysicsFixedJoint( uint32_t objA, uint32_t objB, int positionVec3 )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objA, "Create3DPhysicsFixedJoint: Object A ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyA = rigidBodyManager.GetItem( objA ) ? rigidBodyManager.GetItem( objA )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyA, "Create3DPhysicsFixedJoint: Object A does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objB, "Create3DPhysicsFixedJoint: Object B ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyB = rigidBodyManager.GetItem( objB ) ? rigidBodyManager.GetItem( objB )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyB, "Create3DPhysicsFixedJoint: Object B does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "Create3DPhysicsFixedJoint: positionVec3 ID not valid" ) )
		return 0;

	btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
	scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
	btTransform localATrans, localBTrans, jointTrans;
	jointTrans.setIdentity();
	jointTrans.setOrigin( scaledPos );
	Joints::CreateLocalTransforms( bodyA, bodyB, jointTrans, localATrans, localBTrans );
	uint32_t jointID = jointManager.GetFreeID();
	jointManager.AddItem( new Joint( jointID, Joints::CreateFixedConstraint(bodyA, bodyB, localATrans, localBTrans ) ), jointID );
	return jointID;
}


//****f* 3DPhysics/Joints/Create3DPhysics6DOFJoint
// FUNCTION
//  Creates a 6 degrees of freedom joint between object a and b.
//  Returns a joint ID.
// INPUTS
//  objA -- first object ID
//  objB -- second object ID
//  positionVec3 -- vector ID
//  rotationVec3 -- vector ID
// SOURCE
int agk::Create3DPhysics6DOFJoint( uint32_t objA, uint32_t objB, int positionVec3, float rotationVec3 )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objA, "Create3DPhysics6DOFJoint: Object A ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyA = rigidBodyManager.GetItem( objA ) ? rigidBodyManager.GetItem( objA )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyA, "Create3DPhysics6DOFJoint: Object A does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objB, "Create3DPhysics6DOFJoint: Object B ID Is Not Valid" ) )
		return 0;
	btRigidBody* bodyB = rigidBodyManager.GetItem( objB ) ? rigidBodyManager.GetItem( objB )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( bodyB, "Create3DPhysics6DOFJoint: Object B does not have a Physics body" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "Create3DPhysicsConeTwistJoint: positionVec3 ID not valid" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( (int)rotationVec3, "Create3DPhysicsConeTwistJoint: rotationVec3 ID not valid" ) )
		return 0;

	btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
	scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
	//btVector3 rotVecRadians = AGKToBullet::GetBtVector3ToRadians( rotationVec3 );
	btTransform localATrans, localBTrans, jointTrans;
	btMatrix3x3 jointMatrix;
	//When we use setEulerYPR here for joints it needs to be ZYX
	//jointMatrix.setEulerYPR( rotVecRadians.getZ(), rotVecRadians.getY(), rotVecRadians.getX() );
	btVector3 rotVecAxis = AGKToBullet::GetBtVector3FromVecID( (int)rotationVec3 );
	rotVecAxis.normalize();
	rotVecAxis.setY( -rotVecAxis.getY() );
	btVector3 origAxis(1,0,0);
	btQuaternion rotQuat = shortestArcQuat( origAxis, rotVecAxis );
	jointMatrix.setRotation( rotQuat );
	jointTrans.setIdentity();
	jointTrans.setOrigin( scaledPos );
	jointTrans.setBasis( jointMatrix );
	Joints::CreateLocalTransforms( bodyA, bodyB, jointTrans, localATrans, localBTrans );
	uint32_t jointID = jointManager.GetFreeID();
	jointManager.AddItem( new Joint( jointID, Joints::Create6DofConstraint(bodyA, bodyB, localATrans, localBTrans ) ), jointID );
	return jointID;
}

//****f* 3DPhysics/Joints/Set3DPhysicsJointSliderAngularLimits
// FUNCTION
//   Sets the Angular limits for a slider joint. To unlock the joint set the lower limit greater than upper limit.
// INPUTS
//  jointID -- Id of joint
// lowerLimit -- The Lower limit in degrees
// upperLimit --  The upper limit in degrees
// SOURCE
void agk::Set3DPhysicsJointSliderAngularLimits( uint32_t jointID, float lowerLimit, float upperLimit )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsSliderJointAngularLimits: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  != SLIDER_CONSTRAINT_TYPE ){
		Error( " Set3DPhysicsSliderJointAngularLimits: JointID is not a slider joint" );
		return;
	}
	btSliderConstraint* joint = static_cast<btSliderConstraint*>( constraint );
	joint->setLowerAngLimit( btRadians( lowerLimit ) );
	joint->setUpperAngLimit( btRadians( upperLimit ) );
}

//****f* 3DPhysics/Joints/Set3DPhysicsJointSliderLinearLimits
// FUNCTION
//   Sets the Linear limits for a slider joint. To unlock the joint set the lower limit greater than upper limit.
// INPUTS
//  jointID -- Id of joint
// lowerLimit -- The lower limit 
// upperLimit --  The upper limit 
// SOURCE
void agk::Set3DPhysicsJointSliderLinearLimits( uint32_t jointID, float lowerLimit, float upperLimit )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsSliderJointLinearLimits: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  != SLIDER_CONSTRAINT_TYPE ){
		Error( " Set3DPhysicsSliderJointLinearLimits: JointID is not a slider joint" );
		return;
	}
	btSliderConstraint* joint = static_cast<btSliderConstraint*>( constraint );
	lowerLimit /= GetCurrentDynamicsWorld()->m_scaleFactor;
	upperLimit /= GetCurrentDynamicsWorld()->m_scaleFactor;
	joint->setLowerLinLimit( lowerLimit );
	joint->setUpperLinLimit( upperLimit );
}

//****f* 3DPhysics/Joints/Set3DPhysicsJointConeTwistLimits
// FUNCTION
//   Sets the angular limits for a conetwist joint in degrees. To unlock a particular value set it to 360 
// INPUTS
//  jointID -- Id of joint
// swingSpan1 -- angle in degrees
// swingSpan2 -- angle in degrees
// twistSpan -- angle in degrees
// SOURCE
void agk::Set3DPhysicsJointConeTwistLimits(  uint32_t jointID, float swingSpan1, float swingSpan2, float twistSpan )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsJointConeTwistLimits: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  != CONETWIST_CONSTRAINT_TYPE ){
		Error( " Set3DPhysicsJointConeTwistLimits: JointID is not a cone twist joint" );
		return;
	}
	btConeTwistConstraint* joint = static_cast<btConeTwistConstraint*>( constraint );
	joint->setLimit( btRadians( swingSpan1 ), btRadians( swingSpan2 ), btRadians( twistSpan ) );
}

//****f* 3DPhysics/Joints/Set3DPhysicsJointHingeLimits
// FUNCTION
//   Sets the angular limits for a hinge joint in degrees. 
//   To unlock the joint set the lower limit greater than upper limit.
// INPUTS
//  jointID -- Id of joint
//  minAng -- The minimum angle in degrees.
//  maxAng -- The maximum angle in degrees.
// SOURCE
void agk::Set3DPhysicsJointHingeLimits( uint32_t jointID, float minAng, float maxAng )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsJointHingeLimits: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  != HINGE_CONSTRAINT_TYPE ){
		Error( " Set3DPhysicsJointHingeLimits: JointID is not a hinge joint" );
		return;
	}
	btHingeConstraint* joint = static_cast<btHingeConstraint*>( constraint );
	joint->setLimit( btRadians( minAng ), btRadians( maxAng ) );
}

//****f* 3DPhysics/Joints/Set3DPhysicsJointBreakingThreshold
// FUNCTION
//   Sets the breaking threshold for the joint.
// INPUTS
//  jointID -- Id of joint
//  breakThreshold -- breaking threshold value
// SOURCE
void agk::Set3DPhysicsJointBreakingThreshold( uint32_t jointID, float breakThreshold )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsJointBreakingThreshold: Joint Id is not valid" ) )
		return;
	Joints::SetBreakingThreshold( constraint, breakThreshold );
}

//****f* 3DPhysics/Joints/Set3DPhysicsJointEnabled
// FUNCTION
//   Sets the breaking threshold for the joint.
// INPUTS
//  jointID -- Id of joint
//  isEnabled -- 0 will disable joint
// SOURCE
void agk::Set3DPhysicsJointEnabled( uint32_t jointID, int isEnabled )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsJointEnabled: Joint Id is not valid" ) )
		return;
	constraint->setEnabled( isEnabled > 0 );
}

//****f* 3DPhysics/Joints/Get3DPhysicsJointEnabled
// FUNCTION
//   Returns the breaking threshold for the joint.
// INPUTS
//  jointID -- Id of joint
// SOURCE
int agk::Get3DPhysicsJointEnabled( uint32_t jointID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Get3DPhysicsJointEnabled: Joint Id is not valid" ) )
		return 0;
	return constraint->isEnabled();
}

//****f* 3DPhysics/Joints/Get3DPhysicsJointPositionVector
// FUNCTION
//   Returns the vector ID
// INPUTS
//  jointID -- Id of a Joint
// SOURCE
int agk::Get3DPhysicsJointPositionVector( uint32_t jointID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Get3DPhysicsJointPositionVector: Joint Id is not valid" ) )
		return 0;
	switch ( constraint->getConstraintType() )
	{
		case HINGE_CONSTRAINT_TYPE:
			{
				btHingeConstraint* joint = static_cast<btHingeConstraint*>( constraint );
				btTransform calculatedTrans = (joint->getRigidBodyA().getWorldTransform() * joint->getAFrame());
				btVector3 scaledPosition = calculatedTrans.getOrigin() * GetCurrentDynamicsWorld()->m_scaleFactor;
				int vecID = vectorManager.GetFreeID();
				vectorManager.AddItem( new Vector(  vecID, new AGKVector( scaledPosition.getX(), scaledPosition.getY(), scaledPosition.getZ() ) ) ,vecID );
				return vecID;
			}
		case CONETWIST_CONSTRAINT_TYPE:
			{
				btConeTwistConstraint* joint = static_cast<btConeTwistConstraint*>( constraint );
				btTransform calculatedTrans = (joint->getRigidBodyA().getWorldTransform() * joint->getAFrame());
				btVector3 scaledPosition = calculatedTrans.getOrigin() * GetCurrentDynamicsWorld()->m_scaleFactor;
				int vecID = vectorManager.GetFreeID();
				vectorManager.AddItem( new Vector(  vecID, new AGKVector( scaledPosition.getX(), scaledPosition.getY(), scaledPosition.getZ() ) ) ,vecID );
				return vecID;
			}
		case POINT2POINT_CONSTRAINT_TYPE:
			{
				Error( "Get3DPhysicsJointPositionVector: Point 2 Point joint does not change" );
			}
		case SLIDER_CONSTRAINT_TYPE:
			{
				btSliderConstraint* joint = static_cast<btSliderConstraint*>( constraint );
				btTransform calculatedTrans = joint->getCalculatedTransformA();
				btVector3 scaledPosition = calculatedTrans.getOrigin() * GetCurrentDynamicsWorld()->m_scaleFactor;
				int vecID = vectorManager.GetFreeID();
				vectorManager.AddItem( new Vector(  vecID, new AGKVector( scaledPosition.getX(), scaledPosition.getY(), scaledPosition.getZ() ) ) ,vecID );
				return vecID;
			}
		case FIXED_CONSTRAINT_TYPE:
			{
				Error( "Get3DPhysicsJointPositionVector: Fixed Joint Position does not change" );
			}
		case D6_CONSTRAINT_TYPE:
			{
				btGeneric6DofConstraint* joint = static_cast<btGeneric6DofConstraint*>( constraint );
				btTransform calculatedTrans = joint->getCalculatedTransformA();
				btVector3 scaledPosition = calculatedTrans.getOrigin() * GetCurrentDynamicsWorld()->m_scaleFactor;
				int vecID = vectorManager.GetFreeID();
				vectorManager.AddItem( new Vector(  vecID, new AGKVector( scaledPosition.getX(), scaledPosition.getY(), scaledPosition.getZ() ) ) ,vecID );
				return vecID;
			}
		default: break;
	}

	return 0;
}

//****f* 3DPhysics/Joints/Get3DPhysicsJointRotationVector
// FUNCTION
//   Returns the joints X rotation angle in degrees
// INPUTS
//  jointID -- The ID of the joint.
// SOURCE
int agk::Get3DPhysicsJointRotationVector( uint32_t jointID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Get3DPhysicsJointRotationVector: Joint Id is not valid" ) )
		return 0;
	switch ( constraint->getConstraintType() )
	{
		case HINGE_CONSTRAINT_TYPE:
			{
				btHingeConstraint* joint = static_cast<btHingeConstraint*>( constraint );
				btTransform calculatedTrans = (joint->getRigidBodyA().getWorldTransform() * joint->getAFrame());
				btQuaternion tempQ;
				tempQ = calculatedTrans.getRotation();
				int vecID = vectorManager.GetFreeID();
				vectorManager.AddItem( new Vector(  vecID, new AGKVector(btDegrees( tempQ.getX() ), btDegrees( tempQ.getY() ), btDegrees( tempQ.getZ() ) ) ),vecID );
				return vecID;
			}
		case CONETWIST_CONSTRAINT_TYPE:
			{
				btConeTwistConstraint* joint = static_cast<btConeTwistConstraint*>( constraint );
				btTransform calculatedTrans = (joint->getRigidBodyA().getWorldTransform() * joint->getAFrame());
				btQuaternion tempQ;
				tempQ = calculatedTrans.getRotation();
				int vecID = vectorManager.GetFreeID();
				vectorManager.AddItem( new Vector(  vecID, new AGKVector(btDegrees( tempQ.getX() ), btDegrees( tempQ.getY() ), btDegrees( tempQ.getZ() ) ) ),vecID );
				return vecID;
			}
		case POINT2POINT_CONSTRAINT_TYPE:
			{
				Error( "Get3DPhysicsJointRotationVector: Point 2 Point joint does not change" );
			}
		case SLIDER_CONSTRAINT_TYPE:
			{
				btSliderConstraint* joint = static_cast<btSliderConstraint*>( constraint );
				btTransform calculatedTrans = joint->getCalculatedTransformA();
				btQuaternion tempQ;
				tempQ = calculatedTrans.getRotation();
				int vecID = vectorManager.GetFreeID();
				vectorManager.AddItem( new Vector(  vecID, new AGKVector(btDegrees( tempQ.getX() ), btDegrees( tempQ.getY() ), btDegrees( tempQ.getZ() ) ) ),vecID );
				return vecID;
			}
		case FIXED_CONSTRAINT_TYPE:
			{
				Error( "Get3DPhysicsJointRotationVector: Fixed Joint Position does not change" );
			}
		case D6_CONSTRAINT_TYPE:
			{
				btGeneric6DofConstraint* joint = static_cast<btGeneric6DofConstraint*>( constraint );
				btTransform calculatedTrans = joint->getCalculatedTransformA();
				btQuaternion tempQ;
				tempQ = calculatedTrans.getRotation();
				int vecID = vectorManager.GetFreeID();
				vectorManager.AddItem( new Vector(  vecID, new AGKVector(btDegrees( tempQ.getX() ), btDegrees( tempQ.getY() ), btDegrees( tempQ.getZ() ) ) ),vecID );
				return vecID;
			}
	}

	return 0;
}

//****f* 3DPhysics/Joints/Delete3DPhysicsJoint
// FUNCTION
//   Deletes the physics joint
// INPUTS
//  jointID -- Id of joint
// SOURCE
void agk::Delete3DPhysicsJoint( uint32_t jointID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidJointID( jointID, "Delete3DPhysicsJoint: Joint Id is not valid" ) )
		return;
	delete jointManager.RemoveItem( jointID );
}

//****f* 3DPhysics/Joints/Set3DPhysicsHingeJointMotorIsEnabled
// FUNCTION
//  Enables a hinge joint motor.
// INPUTS
//  jointID -- Id of joint
//  isEnabled -- 1 = true , 0 = false
// SOURCE
void agk::Set3DPhysicsHingeJointMotorIsEnabled( uint32_t jointID, int isEnabled )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsHingeJointMotorIsEnabled: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  == HINGE_CONSTRAINT_TYPE ){
		btHingeConstraint* joint = static_cast<btHingeConstraint*>( constraint );
		if ( isEnabled ){
			joint->enableMotor( true );
		}
		else{
			joint->enableMotor( false );
		}
	}
	else{
		agk::Error( "Set3DPhysicsHingeJointMotorIsEnabled: Joint is not a hinge joint" );
		return;
	}
}

//****f* 3DPhysics/Joints/Set3DPhysicsHingeJointMaxMotorImpulse
// FUNCTION
//  Sets the maximum motor Impulse value for a hinge joint.
//  Enable joint first with Set3DPhysicsHingeJointMotorIsEnabled()
// INPUTS
//  jointID -- Id of joint
//  maxImpulse -- The Maximum impulse value to be applied to the joint motor.
// SOURCE
void agk::Set3DPhysicsHingeJointMaxMotorImpulse( uint32_t jointID, float maxImpulse )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsHingeJointMaxMotorImpulse: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  == HINGE_CONSTRAINT_TYPE ){
		btHingeConstraint* joint = static_cast<btHingeConstraint*>( constraint );
		joint->setMaxMotorImpulse( maxImpulse / GetCurrentDynamicsWorld()->m_scaleFactor );
	}
		else{
		agk::Error( "Set3DPhysicsHingeJointMaxMotorImpulse: Joint is not a hinge joint" );
	}
}

//****f* 3DPhysics/Joints/Set3DPhysicsHingeJointMotorVelocity
// FUNCTION
//  Set the target velocity for a hinge joint. Must be called in the loop.
//  Enable joint first with Set3DPhysicsHingeJointMotorIsEnabled()
// INPUTS
//  jointID -- Id of joint
//  targetVelocity -- The target velocity to be used.
// SOURCE
void agk::Set3DPhysicsHingeJointMotorVelocity( uint32_t jointID, float targetVelocity )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsHingeJointMotorVelocity: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  == HINGE_CONSTRAINT_TYPE ){
		btHingeConstraint* joint = static_cast<btHingeConstraint*>( constraint );
		btScalar dt = GetCurrentDynamicsWorld()->GetDeltaTimeMilliseconds();
		targetVelocity /= GetCurrentDynamicsWorld()->m_scaleFactor;
		joint->setMotorTarget( targetVelocity, dt );
	}
		else{
		agk::Error( "Set3DPhysicsHingeJointMotorVelocity: Joint is not a hinge joint" );
	}
}

//****f* 3DPhysics/Joints/Set3DPhysicsTwistJointMotorIsEnabled
// FUNCTION
//   Enables a twist joint motor.
// INPUTS
//  jointID -- joint ID
//  isEnabled -- 1 = true , 0 = false
// SOURCE
void agk::Set3DPhysicsTwistJointMotorIsEnabled( uint32_t jointID, int isEnabled )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsTwistJointMotorIsEnabled: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  == CONETWIST_CONSTRAINT_TYPE )
	{
		btConeTwistConstraint* joint = static_cast<btConeTwistConstraint*>( constraint );
		if ( isEnabled ){
			joint->enableMotor( true );
		}
		else{
			joint->enableMotor( false );
		}
	}
	else{
		agk::Error( "Set3DPhysicsTwistJointMotorIsEnabled: Joint is not a Twist joint" );
	}
}

//****f* 3DPhysics/Joints/Set3DPhysicsTwistJointMaxMotorImpulse
// FUNCTION
//  Sets the max motor Impulse value for a Twist joint.
//  Enable joint first with <i>Set3DPhysicsTwistJointMotorIsEnabled()</i>
// INPUTS
//  jointID -- Id of joint
//  maxImpulse -- The maximum impulse to be applied to the joint motor.
// SOURCE
void agk::Set3DPhysicsTwistJointMaxMotorImpulse( uint32_t jointID, float maxImpulse )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsTwistJointMaxMotorImpulse: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  == CONETWIST_CONSTRAINT_TYPE ){
		btConeTwistConstraint* joint = static_cast<btConeTwistConstraint*>( constraint );
		joint->setMaxMotorImpulse( maxImpulse / GetCurrentDynamicsWorld()->m_scaleFactor );
	}
	else{
	agk::Error( "Set3DPhysicsTwistJointMaxMotorImpulse: Joint is not a twist joint" );
	}
}

//****f* 3DPhysics/Joints/Set3DPhysicsTwistJointMotorRotationTarget
// FUNCTION
//  Set the target velocity for a twist joint. Must be called in the loop.
//  Enable joint first with <i>Set3DPhysicsTwistJointMotorIsEnabled()</i>
// INPUTS
//  jointID -- Id of joint
//  rotationVec3ID -- The Id of a Vector which has the rotation target for a twist joint motor.
// SOURCE
void agk::Set3DPhysicsTwistJointMotorRotationTarget( uint32_t jointID, int rotationVec3ID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsTwistJointMotorRotationTarget: Joint Id is not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID(rotationVec3ID, "Set3DPhysicsTwistJointMotorRotationTarget: Vector ID not valid") )
		 return;
	AGKVector* rotationVec = vectorManager.GetItem( rotationVec3ID )->GetAGKVector();
	btVector3 rot = AGKToBullet::GetBtVector3( *rotationVec);

	if ( constraint->getConstraintType()  == CONETWIST_CONSTRAINT_TYPE ){
		btConeTwistConstraint* joint = static_cast<btConeTwistConstraint*>( constraint );
		btQuaternion tempQ;
		tempQ.setEulerZYX( rot.getZ(), rot.getY(), rot.getX() );
		joint->setMotorTarget( tempQ );
	}
		else{
		agk::Error( "Set3DPhysicsTwistJointMotorRotationTarget: Joint is not a twist joint" );
	}
}

//****f* 3DPhysics/Joints/Set3DPhysicsSliderJointPoweredLinearMotorIsEnabled
// FUNCTION
//	  Set the slider joints powered linear motor to enabled.
// INPUTS
//  jointID -- Id of joint
//  isEnabled -- 1 = true, 0 = false
// SOURCE
void agk::Set3DPhysicsSliderJointPoweredLinearMotorIsEnabled( uint32_t jointID, int isEnabled )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsSliderJointPoweredLinearMotorIsEnabled: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  == SLIDER_CONSTRAINT_TYPE ){
		btSliderConstraint* joint = static_cast<btSliderConstraint*>( constraint );
		if ( isEnabled ){
			joint->setPoweredLinMotor( true );
		}
		else{
			joint->setPoweredLinMotor( false );
		}
	}
	else{
		agk::Error( "Set3DPhysicsSliderJointPoweredLinearMotorIsEnabled: Joint is not a slider joint" );
	}
}

//****f* 3DPhysics/Joints/Set3DPhysicsSliderJointMaxLinearMotorForce
// FUNCTION
//   Sets the joints motor to the maximum linear force.
// INPUTS
//  jointID -- Id of joint
//  maxLinearForce -- The maximum linear force to be applied to the joint motor.
// SOURCE
void agk::Set3DPhysicsSliderJointMaxLinearMotorForce( uint32_t jointID, float maxLinearForce )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsSliderJointMaxLinearMotorForce: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  == SLIDER_CONSTRAINT_TYPE ){
		btSliderConstraint* joint = static_cast<btSliderConstraint*>( constraint );
		joint->setMaxLinMotorForce( maxLinearForce / GetCurrentDynamicsWorld()->m_scaleFactor );
	}
	else{
		agk::Error( "Set3DPhysicsSliderJointMaxLinearMotorForce: Joint is not a slider joint" );
	}
}

//****f* 3DPhysics/Joints/Set3DPhysicsSliderJointTargetLinearMotorVelocity
// FUNCTION
//  Sets the target linear Motor Velocity for the physics slider joint.
// INPUTS
//  jointID -- Id of joint
//  linearMotorVelocity -- The linear velocity to be applied to the joint motor.
// SOURCE
void agk::Set3DPhysicsSliderJointTargetLinearMotorVelocity( uint32_t jointID, float linearMotorVelocity )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	btTypedConstraint* constraint = jointManager.GetItem( jointID )->GetConstraint();
	if ( !AGKToBullet::AssertValidJoint( constraint, "Set3DPhysicsSliderJointTargetLinearMotorVelocity: Joint Id is not valid" ) )
		return;
	if ( constraint->getConstraintType()  == SLIDER_CONSTRAINT_TYPE ){
		btSliderConstraint* joint = static_cast<btSliderConstraint*>( constraint );
		joint->setTargetLinMotorVelocity( linearMotorVelocity / GetCurrentDynamicsWorld()->m_scaleFactor );
	}
	else{
		agk::Error( "Set3DPhysicsSliderJointTargetLinearMotorVelocity: Joint is not a slider joint" );
	}
}

//****f* 3DPhysics/CompoundCollisionShapes/AddObjectShapeBox
// FUNCTION
//   Adds a box collision shape to a compound shape.
//   First set the objects shape to a compound collision shape with <i>SetObjectShapeCompound()</i>.
// INPUTS
//  objID -- object ID
//  positionVec3 -- The vector Id of the vector with the world position for the center of the shape.
//  rotationVec3 -- The vector ID of the vector with the world rotation of the shape.
//  sizeVec3 -- The vector ID of the vector with the size of the shape.
// SOURCE
void agk::AddObjectShapeBox( int objID, int positionVec3, int rotationVec3, int sizeVec3 )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "AddObjectShapeBox: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "AddObjectShapeBox: Object does not have a Physics body" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "AddObjectShapeBox: positionVec3 ID not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( rotationVec3, "AddObjectShapeBox: rotationVec3 ID not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( sizeVec3, "AddObjectShapeBox: sizeVec3 ID not valid" ) )
		return;

	btCollisionShape* collShape = body->getCollisionShape(); 

	if ( collShape != NULL && collShape->isCompound() ){
		//Create Child shape scaled
		btVector3 sizeVec3Scaled = AGKToBullet::GetBtVector3FromVecID( sizeVec3 );
		sizeVec3Scaled /= (btScalar)(GetCurrentDynamicsWorld()->m_scaleFactor / 2.0);
		btCollisionShape* childShape = CollisionShapes::Box( sizeVec3Scaled );
		//Convert the position and rotation vectors
		btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
		scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
		btVector3 rotVecRadians = AGKToBullet::GetBtVector3ToRadians( rotationVec3 );
		//Create the child transform
		btTransform childTrans;
		btMatrix3x3 childMatrix;
		childMatrix.setEulerYPR( rotVecRadians.getZ(), rotVecRadians.getY(), rotVecRadians.getX() );
		childTrans.setIdentity();
		childTrans.setOrigin( scaledPos );
		childTrans.setBasis( childMatrix );
		btCompoundShape* parentShape = static_cast<btCompoundShape*>( collShape );
		parentShape->addChildShape( childTrans, childShape );
	}
	else{
		Error( "AddObjectShapeBox: Object needs to be set to compound shape to be able to add shape" );
	}
}

//****f* 3DPhysics/CompoundCollisionShapes/AddObjectShapeSphere
// FUNCTION
//   Adds a sphere collision shape to a compound shape.
//   First set the objects shape to a compound collision shape with <i>SetObjectShapeCompound()</i>.
// INPUTS
//  objID -- object ID
//  positionVec3 -- The vector Id of the vector with the world position for the center of the shape.
//  diameter -- size of sphere shape
// SOURCE
void agk::AddObjectShapeSphere( int objID, int positionVec3, float diameter )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "AddObjectShapeSphere: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "AddObjectShapeSphere: Object does not have a Physics body" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "AddObjectShapeSphere: positionVec3 ID not valid" ) )
		return;
	btCollisionShape* collShape = body->getCollisionShape(); 

	if ( collShape != NULL && collShape->isCompound() ){
		//Create Child shape scaled
		btCollisionShape* childShape = CollisionShapes::Sphere( diameter / GetCurrentDynamicsWorld()->m_scaleFactor );
		//Convert the position and rotation vectors
		btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
		scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
		//Create the child transform
		btTransform childTrans;
		btMatrix3x3 childMatrix;
		childMatrix.setEulerYPR( 0.0, 0.0, 0.0 );
		childTrans.setIdentity();
		childTrans.setOrigin( scaledPos );
		childTrans.setBasis( childMatrix );
		btCompoundShape* parentShape = static_cast<btCompoundShape*>( collShape );
		parentShape->addChildShape( childTrans, childShape );
	}
	else{
		Error( "AddObjectShapeBox: Object needs to be set to compound shape to be able to add shape" );
	}

}

//****f* 3DPhysics/CompoundCollisionShapes/AddObjectShapeCapsule
// FUNCTION
//   Adds a capsule collision shape to a compound shape.
//   First set the objects shape to a compound collision shape with <i>SetObjectShapeCompound()</i>.
// INPUTS
//  objID -- object ID
//  positionVec3 -- The vector Id of the vector with the world position for the center of the shape.
//  rotationVec3 -- The vector ID of the vector with the world rotation of the shape.
//  sizeVec3 -- The vector ID of the vector with the size of the shape.
//  axis -- 0 = X axis, 1 = Y axis, 2 = Z axis.
// SOURCE
void agk::AddObjectShapeCapsule( int objID, int positionVec3, int rotationVec3, int sizeVec3, int axis )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "AddObjectShapeCapsule: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "AddObjectShapeCapsule: Object does not have a Physics body" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "AddObjectShapeCapsule: positionVec3 ID not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( rotationVec3, "AddObjectShapeCapsule: rotationVec3 ID not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( sizeVec3, "AddObjectShapeCapsule: sizeVec3 ID not valid" ) )
		return;

	btCollisionShape* collShape = body->getCollisionShape(); 

	if ( collShape != NULL && collShape->isCompound() ){
		//Create Child shape scaled
		btVector3 sizeVec3Scaled = AGKToBullet::GetBtVector3FromVecID( sizeVec3 );
		sizeVec3Scaled /= (btScalar)(GetCurrentDynamicsWorld()->m_scaleFactor / 2.0);
		btCollisionShape* childShape = CollisionShapes::Capsule( sizeVec3Scaled, axis );
		//Convert the position and rotation vectors
		btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
		scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
		btVector3 rotVecRadians = AGKToBullet::GetBtVector3ToRadians( rotationVec3 );
		//Create the child transform
		btTransform childTrans;
		btMatrix3x3 childMatrix;
		childMatrix.setEulerYPR( rotVecRadians.getZ(), rotVecRadians.getY(), rotVecRadians.getX() );
		childTrans.setIdentity();
		childTrans.setOrigin( scaledPos );
		childTrans.setBasis( childMatrix );
		btCompoundShape* parentShape = static_cast<btCompoundShape*>( collShape );
		parentShape->addChildShape( childTrans, childShape );
	}
	else{
		Error( "AddObjectShapeCapsule: Object needs to be set to compound shape to be able to add shape" );
	}
}

//****f* 3DPhysics/CompoundCollisionShapes/AddObjectShapeCone
// FUNCTION
//   Adds a cone collision shape to a compound shape.
//   First set the objects shape to a compound collision shape with <i>SetObjectShapeCompound()</i>.
// INPUTS
//  objID -- object ID
//  positionVec3 -- The vector Id of the vector with the world position for the center of the shape.
//  rotationVec3 -- The vector ID of the vector with the world rotation of the shape.
//  sizeVec3 -- The vector ID of the vector with the size of the shape.
//  axis -- 0 = X axis, 1 = Y axis, 2 = Z axis.
// SOURCE
void agk::AddObjectShapeCone( int objID, int positionVec3, int rotationVec3, int sizeVec3, int axis)
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "AddObjectShapeCone: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "AddObjectShapeCone: Object does not have a Physics body" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "AddObjectShapeCone: positionVec3 ID not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( rotationVec3, "AddObjectShapeCone: rotationVec3 ID not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( sizeVec3, "AddObjectShapeCone: sizeVec3 ID not valid" ) )
		return;

	btCollisionShape* collShape = body->getCollisionShape(); 

	if ( collShape != NULL && collShape->isCompound() ){
		//Create Child shape scaled
		btVector3 sizeVec3Scaled = AGKToBullet::GetBtVector3FromVecID( sizeVec3 );
		sizeVec3Scaled /= GetCurrentDynamicsWorld()->m_scaleFactor;
		btCollisionShape* childShape = CollisionShapes::Cone( sizeVec3Scaled, axis );
		//Convert the position and rotation vectors
		btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
		scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
		btVector3 rotVecRadians = AGKToBullet::GetBtVector3ToRadians( rotationVec3 );
		//Create the child transform
		btTransform childTrans;
		btMatrix3x3 childMatrix;
		childMatrix.setEulerYPR( rotVecRadians.getZ(), rotVecRadians.getY(), rotVecRadians.getX() );
		childTrans.setIdentity();
		childTrans.setOrigin( scaledPos );
		childTrans.setBasis( childMatrix );
		btCompoundShape* parentShape = static_cast<btCompoundShape*>( collShape );
		parentShape->addChildShape( childTrans, childShape );
	}
	else{
		Error( "AddObjectShapeCone: Object needs to be set to compound shape to be able to add shape" );
	}
}

//****f* 3DPhysics/CompoundCollisionShapes/AddObjectShapeCylinder
// FUNCTION
//   Adds a cylinder collision shape to a compound shape.
//   First set the objects shape to a compound collision shape with <i>SetObjectShapeCompound()</i>.
// INPUTS
//  objID -- object ID
//  positionVec3 -- The vector Id of the vector with the world position for the center of the shape.
//  rotationVec3 -- The vector ID of the vector with the world rotation of the shape.
//  sizeVec3 -- The vector ID of the vector with the size of the shape.
//  axis -- 0 = X axis, 1 = Y axis, 2 = Z axis.
// SOURCE
void agk::AddObjectShapeCylinder( int objID, int positionVec3, int rotationVec3, int sizeVec3, int axis)
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "AddObjectShapeCylinder: Object ID Is Not Valid" ) )
		return;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "AddObjectShapeCylinder: Object does not have a Physics body" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( positionVec3, "AddObjectShapeCylinder: positionVec3 ID not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( rotationVec3, "AddObjectShapeCylinder: rotationVec3 ID not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( sizeVec3, "AddObjectShapeCylinder: sizeVec3 ID not valid" ) )
		return;

	btCollisionShape* collShape = body->getCollisionShape(); 

	if ( collShape != NULL && collShape->isCompound() ){
		//Create Child shape scaled
		btVector3 sizeVec3Scaled = AGKToBullet::GetBtVector3FromVecID( sizeVec3 );
		sizeVec3Scaled /= (btScalar)(GetCurrentDynamicsWorld()->m_scaleFactor / 2.0);
		btCollisionShape* childShape = CollisionShapes::Cylinder( sizeVec3Scaled, axis );
		//Convert the position and rotation vectors
		btVector3 scaledPos = AGKToBullet::GetBtVector3FromVecID( positionVec3 );
		scaledPos /= GetCurrentDynamicsWorld()->m_scaleFactor;
		btVector3 rotVecRadians = AGKToBullet::GetBtVector3ToRadians( rotationVec3 );
		//Create the child transform
		btTransform childTrans;
		btMatrix3x3 childMatrix;
		childMatrix.setEulerYPR( rotVecRadians.getZ(), rotVecRadians.getY(), rotVecRadians.getX() );
		childTrans.setIdentity();
		childTrans.setOrigin( scaledPos );
		childTrans.setBasis( childMatrix );
		btCompoundShape* parentShape = static_cast<btCompoundShape*>( collShape );
		parentShape->addChildShape( childTrans, childShape );
	}
	else{
		Error( "AddObjectShapeCylinder: Object needs to be set to compound shape to be able to add shape" );
	}
}

//****f* 3DPhysics/SavingAndLoading/SaveObjectShape
// FUNCTION
//  Saves the objects collision shape to a .bcs (Bullet Collision Shape) file.
//  Returns true if succeeded.
// INPUTS
//  objID -- object ID
//  fileName -- the name of the file as a string. 
// SOURCE
int agk::SaveObjectShape( uint32_t objID, const char* fileName )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "SaveObjectShape: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "SaveObjectShape: Object does not have a Physics body" ) )
		return 0;
	
	if ( body ){
		btCollisionShape* collShape = body->getCollisionShape(); 
		char fullDir [255];
		int maxSerializeBufferSize = 1024*1024*5;
		btDefaultSerializer*	serializer = new btDefaultSerializer(maxSerializeBufferSize);

		serializer->startSerialization();
		collShape->serializeSingleShape(serializer);
		serializer->finishSerialization(); 

		char* currentDir = agk::GetFolder();
		sprintf(fullDir, "%s//%s.bcs",currentDir ,fileName);
		delete [] currentDir;
	
		FILE* bcsFile = AGKfopen(fullDir,"wb");
		if(!bcsFile){
			Error("SaveObjectShape: Error: Unable to open file to write");
		}
		else{
			fwrite(serializer->getBufferPointer(),serializer->getCurrentBufferSize(),1,bcsFile);
			fclose(bcsFile);
			delete serializer;
			return 1;
		}
		delete serializer;
	}
	return 0;
}

//****f* 3DPhysics/SavingAndLoading/LoadObjectShape
// FUNCTION
//   loads a collision shape from a .bcs (Bullet Collision Shape) file and sets it to the object.
//  Returns true if succeeded.
// INPUTS
//  objID -- object ID
//  fileName -- file name
// SOURCE
int agk::LoadObjectShape( uint32_t objID, const char* fileName )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "LoadObjectShape: Object ID Is Not Valid" ) )
		return 0;
	btRigidBody* body = rigidBodyManager.GetItem( objID ) ? rigidBodyManager.GetItem( objID )->GetRigidBody() : NULL;
	if ( !AGKToBullet::AssertValidBody( body, "LoadObjectShape: Object does not have a Physics body" ) )
		return 0;
	
	if ( body ){
		char fullDir [255];
		char* currentDir = agk::GetFolder();
		sprintf(fullDir, "%s//%s",currentDir ,fileName);
		delete [] currentDir;

		FILE * fid = AGKfopen(fullDir, "r");
		if(!fid) {
			agk::Error( "LoadObjectShape: File Path Not Valid" );
		}
		else{
		fclose(fid);
		}
		btBulletWorldImporter loader(0);//don't store info into the world
		loader.setVerboseMode(false);

		if (!loader.loadFile(fullDir))
			agk::Error( "LoadObjectShape: ERROR: Unable To Load File " );

		btCollisionShape* collShape = NULL;
		if (loader.getNumCollisionShapes()>0) collShape = loader.getCollisionShapeByIndex(0);
		delete body->getCollisionShape();
		body->setCollisionShape( collShape );
		return 1;
	}
	return 0;
}

//****f* Maths/Vectors/CreateVector3
// FUNCTION
//  Creates an empty vector, returns a vector ID
// SOURCE
int agk::CreateVector3()
//****
{
	int vectorID = vectorManager.GetFreeID();
	vectorManager.AddItem( new Vector(vectorID, new AGKVector()), vectorID );
	return vectorID;
}

//****f* Maths/Vectors/CreateVector3
// FUNCTION
//  Creates a vector and fills it with the values passed in.
//  Returns a vector ID
// INPUTS
//  x -- The x component of the vector
//  y -- The y component of the vector
//  z -- The z component of the vector
// SOURCE
int agk::CreateVector3( float x, float y, float z )
//****
{
	int vectorID = vectorManager.GetFreeID();
	vectorManager.AddItem(  new Vector(vectorID, new AGKVector( x, y, z )), vectorID );
	return vectorID;
}

//****f* Maths/Vectors/SetVector3
// FUNCTION
//  Fills the specified vector.
// INPUTS
//  vectorID -- Id of Vector
//  x -- The x component of the vector
//  y -- The y component of the vector
//  z -- The z component of the vector
// SOURCE
void agk::SetVector3( uint32_t vectorID, float x, float y, float z )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(vectorID, "SetVector3: Vector ID not valid") )
		return;
	AGKVector* vec = vectorManager.GetItem( vectorID )->GetAGKVector();
	if ( vec )
		vec->Set( x, y, z );
}

//****f* Maths/Vectors/DeleteVector3
// FUNCTION
//   Deletes the Vector
// INPUTS
//  vectorID -- Id of Vector
// SOURCE
void agk::DeleteVector3( uint32_t vectorID )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(vectorID, "DeleteVector3: Vector ID not valid") )
		return;
	delete vectorManager.RemoveItem( vectorID );
}

//****f* Maths/Vectors/GetVector3X
// FUNCTION
//  Gets the x from the vector.  
// INPUTS
//  vectorID -- id of the vector
// SOURCE
float agk::GetVector3X( uint32_t vectorID )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(vectorID, "GetVector3X: Vector ID not valid") )
		return 0;
	AGKVector* vec = vectorManager.GetItem(vectorID)->GetAGKVector();
	if ( vec ) return vec->x;
	else return 0;
}

//****f* Maths/Vectors/GetVector3Y
// FUNCTION
//  Gets the y from the vector. 
// INPUTS
//  vectorID -- id of the vector
// SOURCE
float agk::GetVector3Y( uint32_t vectorID )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(vectorID, "GetVector3Y: Vector ID not valid") )
		return 0;
	AGKVector* vec = vectorManager.GetItem(vectorID)->GetAGKVector();
	if ( vec ) return vec->y;
	else return 0;
}

//****f* Maths/Vectors/GetVector3Z
// FUNCTION
//  Gets the z from the vector.
// INPUTS
//  vectorID -- id of the vector
// SOURCE
float agk::GetVector3Z( uint32_t vectorID )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(vectorID, "GetVector3Z: Vector ID not valid") )
		return 0;
	AGKVector* vec = vectorManager.GetItem(vectorID)->GetAGKVector();
	if ( vec ) return vec->z;
	else return 0;
}

//****f* Maths/Vectors/GetVector3Distance
// FUNCTION
//   Returns the distance between the 2 vectors.
// INPUTS
//  vectorU -- ID of the first vector
//  vectorV -- ID of the second vector
// SOURCE
float agk::GetVector3Distance( uint32_t vectorU, uint32_t vectorV )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(vectorU, "GetVector3Distance: VectorU ID not valid") )
		return 0;
	AGKVector* vecU = vectorManager.GetItem(vectorU)->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(vectorV, "GetVector3Distance: VectorV ID not valid") )
		return 0;
	AGKVector* vecV = vectorManager.GetItem(vectorV)->GetAGKVector();
	return vecU->GetDist( *vecV );
}

//****f* Maths/Vectors/GetVector3Length
// FUNCTION
//   Returns the length of the vector 
// INPUTS
//  vectorID -- ID of the vector 
// SOURCE
float agk::GetVector3Length( uint32_t vectorID )
//****
{
	if ( !AGKToBullet::AssertValidVectorID( vectorID, "GetVector3Length: Vector ID is not valid" ) )
		return 0;
	AGKVector* vec = vectorManager.GetItem( vectorID )->GetAGKVector();
	return vec->Length();
}

//****f* Maths/Vectors/GetVector3Dot
// FUNCTION
//   Returns the dot product of 2 vectors
// INPUTS
//  vectorU -- ID of the first vector
//  vectorV -- ID of the second vector
// SOURCE
float agk::GetVector3Dot( uint32_t vectorU, uint32_t vectorV )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(vectorU, "GetVector3Dot: VectorU ID not valid") )
		return 0;
	AGKVector* vecU = vectorManager.GetItem(vectorU)->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(vectorV, "GetVector3Dot: VectorV ID not valid") )
		return 0;
	AGKVector* vecV = vectorManager.GetItem(vectorV)->GetAGKVector();
	return vecU->Dot( *vecV );
}

//****f* Maths/Vectors/GetVector3Cross
// FUNCTION
//   Fills the result vector with the cross product of 2 vectors passed in.
// INPUTS
//	 resultVec -- ID of Vector for results
//  vectorU -- ID of the first vector
//  vectorV -- ID of the second vector
// SOURCE
void agk::GetVector3Cross( uint32_t resultVec, uint32_t vectorU, uint32_t vectorV )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(vectorU, "GetVector3Cross: vectorU ID not valid") )
		return;
	AGKVector* vecU = vectorManager.GetItem(vectorU)->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(vectorV, "GetVector3Cross: vectorV ID not valid") )
		return;
	AGKVector* vecV = vectorManager.GetItem(vectorV)->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(resultVec, "GetVector3Cross: resultVec ID not valid") )
		return;
	AGKVector* vecResult = vectorManager.GetItem(resultVec)->GetAGKVector();
	vecResult->Cross( *vecU, *vecV );
}

//****f* Maths/Vectors/GetVector3Multiply
// FUNCTION
//   Multiplies the components of the given vector by the given multiplier
// INPUTS
//  resultVec -- ID of the vector to multiply.
//  multiplier -- float value to multiply by.
// SOURCE
void agk::GetVector3Multiply( uint32_t resultVec, float multiplier )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(resultVec, "GetVector3Multiply: Vector ID not valid") )
		return;
	AGKVector* vecResult = vectorManager.GetItem(resultVec)->GetAGKVector();
	vecResult->Mult( multiplier );
}

//****f* Maths/Vectors/GetVector3Add
// FUNCTION
//   Fills the resultVec vector with the sum of the resultVec vector and the addVec vector.
// INPUTS
//  resultVec -- ID of the vector to add and hold results.
//  addVec -- ID of vector to add.
// SOURCE
void agk::GetVector3Add( uint32_t resultVec, uint32_t addVec )
//****
{
	if ( !AGKToBullet::AssertValidVectorID(resultVec, "GetVector3Add: resultVec ID not valid") )
		return;
	AGKVector* vecResult = vectorManager.GetItem(resultVec)->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(addVec, "GetVector3Add: addVec ID not valid") )
		return;
	AGKVector* vecAdd = vectorManager.GetItem(addVec)->GetAGKVector();
	vecResult->operator+=( *vecAdd );
}


//****************************** Ray Casting Commands ****************************************************************

//****f* 3DPhysics/RayCast/Create3DPhysicsRay
// FUNCTION
// Returns the ID of the ray created.
// INPUTS
// SOURCE
int agk::Create3DPhysicsRay()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	int rayID = rayManager.GetFreeID();
	rayManager.AddItem( new Ray( rayID), rayID );
	return rayID;
}

//****f* 3DPhysics/RayCast/Delete3DPhysicsRay
// FUNCTION
//   Deletes a physics ray and all associated data.
// INPUTS
//  rayID -- ID of the ray to delete. 
// SOURCE
void agk::Delete3DPhysicsRay( uint32_t rayID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidRayID( rayID, "Delete3DPhysicsRay: Ray ID is not valid" ) )
		return;
	delete rayManager.RemoveItem( rayID );
}

//****f* 3DPhysics/RayCast/Ray3DPhysicsExist
// FUNCTION
//  Return a 1 if the ray exists. Returns a 0 if it does not.
// INPUTS
//  rayID -- ID of the ray
// SOURCE
int agk::Ray3DPhysicsExist( uint32_t rayID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	return rayManager.GetItem( rayID ) != NULL;
}

//****f* 3DPhysics/RayCast/RayCast3DPhysics
// FUNCTION
//  Cast a ray
// INPUTS
//  rayID -- ID of the ray
//  fromVec3ID -- ID of the starting point vector. Create a vector with the <i>CreateVector3()</i> command.
//  toVec3ID -- ID of the destination vector
//  allOrClosest -- 1 = all contacts, 0 = closest contact
// SOURCE
void agk::RayCast3DPhysics( uint32_t rayID, int fromVec3ID, int toVec3ID, int allOrClosest )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidRayID( rayID, "RayCast3DPhysics: Ray ID is not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( fromVec3ID, "RayCast3DPhysics: Vector ID not valid") )
		return;
	AGKVector* fromVec3 = vectorManager.GetItem( fromVec3ID )->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(toVec3ID, "RayCast3DPhysics: Vector ID not valid") )
		return;
	AGKVector* toVec3 = vectorManager.GetItem( toVec3ID )->GetAGKVector();
	btVector3 from = AGKToBullet::GetBtVector3( *fromVec3);
	btVector3 to = AGKToBullet::GetBtVector3( *toVec3);
	from /= GetCurrentDynamicsWorld()->m_scaleFactor;
	to /= GetCurrentDynamicsWorld()->m_scaleFactor;
	rayManager.GetItem( rayID )->Cast( from, to, allOrClosest!=0 );
}

//****f* 3DPhysics/RayCast/RayCast3DPhysicsObject
// FUNCTION
//  Cast a ray and checks against the object.
// INPUTS
//  objID -- Id of object to check against.
//  rayID -- ID of the ray
//  fromVec3ID -- ID of the starting point vector. Create a vector with the <i>CreateVector3()</i> command.
//  toVec3ID -- ID of the destination vector
//  allOrClosest -- 1 = all contacts, 0 = closest contact
// SOURCE
int agk::RayCast3DPhysicsObject( uint32_t objID, uint32_t rayID, int fromVec3ID, int toVec3ID, int allOrClosest )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidRayID( rayID, "RayCast3DPhysicsObject: Ray ID is not valid" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( fromVec3ID, "RayCast3DPhysicsObject: Vector ID not valid") )
		return 0;
	AGKVector* fromVec3 = vectorManager.GetItem( fromVec3ID )->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(toVec3ID, "RayCast3DPhysicsObject: Vector ID not valid") )
		return 0;
	AGKVector* toVec3 = vectorManager.GetItem( toVec3ID )->GetAGKVector();
	btVector3 from = AGKToBullet::GetBtVector3( *fromVec3);
	btVector3 to = AGKToBullet::GetBtVector3( *toVec3);
	from /= GetCurrentDynamicsWorld()->m_scaleFactor;
	to /= GetCurrentDynamicsWorld()->m_scaleFactor;
	rayManager.GetItem( rayID )->Cast( from, to, allOrClosest!=0 );
	if(allOrClosest){
		for (int i = 0; i < rayManager.GetItem( rayID )->GetNumberOfContacts(); i++){
			if (rayManager.GetItem( rayID )->GetContactObjectID( i ) == objID)
				return true;
		}
	}
	return rayManager.GetItem( rayID )->GetClosestContactObjectID();
}

//****f* 3DPhysics/RayCast/Get3DPhysicsRayCastObjectHit
// FUNCTION
//  Return the ID of the Object hit by the ray at the index.
// INPUTS
//  rayID -- ID of the ray
//  fractionIndex -- value returned by Get3DPhysicsRayCastFraction() command.
// SOURCE
int agk::Get3DPhysicsRayCastObjectHit( uint32_t rayID, float fractionIndex )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidRayID( rayID, "Get3DPhysicsRayCastObjectHit: Ray ID is not valid" ) )
		return 0;
	return rayManager.GetItem( rayID )->GetContactObjectID( (int)fractionIndex );
}

//****f* 3DPhysics/RayCast/Get3DPhysicsRayCastClosestObjectHit
// FUNCTION
//   Return the Closest Object hit by the ray.
// INPUTS
//  rayID -- ID of the ray
// SOURCE
int agk::Get3DPhysicsRayCastClosestObjectHit( uint32_t rayID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidRayID( rayID, "Get3DPhysicsRayCastClosestObjectHit: Ray ID is not valid" ) )
		return 0;
	return rayManager.GetItem( rayID )->GetClosestContactObjectID();
}

//****f* 3DPhysics/RayCast/Get3DPhysicsRayCastFraction
// FUNCTION
//   Returns the distance along the ray until collision where 1.0 = full length, 0.0 = beginning.
// INPUTS
//  rayID -- ID of the ray
// SOURCE
float agk::Get3DPhysicsRayCastFraction( uint32_t rayID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidRayID( rayID, "Get3DPhysicsRayCastFraction: Ray ID is not valid" ) )
		return 0;
	return rayManager.GetItem( rayID )->GetClosestHitFraction();
}

//****f* 3DPhysics/RayCast/Get3DPhysicsRayCastContactPosition
// FUNCTION
//  Returns true if there is a contact vector and fills the vector outVec3ID.
//  First create a vector with <i>CreateVector3()</i> then pass in the ID.
//  The vector you have created and passed in will be filled with the results.
// INPUTS
//  rayID -- ID of the ray
//  fractionIndex -- value returned by Get3DPhysicsRayCastFraction() command.
//  outVec3ID -- Id of the vector that will be filled with the position.
// SOURCE
int agk::Get3DPhysicsRayCastContactPosition( uint32_t rayID, float fractionIndex, int outVec3ID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidRayID( rayID, "Get3DPhysicsRayCastContactPosition: Ray ID is not valid" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID(outVec3ID, "Get3DPhysicsRayCastContactPosition: Vector ID not valid") )
		return 0;
	btVector3 ccp = rayManager.GetItem( rayID )->GetContactPosition((int)fractionIndex);
	ccp *= GetCurrentDynamicsWorld()->m_scaleFactor;
	AGKVector* outVec3 = vectorManager.GetItem( outVec3ID )->GetAGKVector();
	outVec3->Set( ccp.getX(), ccp.getY(), ccp.getZ() );
	return 1;
}

//****f* 3DPhysics/RayCast/Get3DPhysicsRayCastClosestContactPosition
// FUNCTION
//  Returns true if there is a closest contact vector and fills the vector outVec3ID.
//  First create a vector with <i>CreateVector3()</i> then pass in the ID.
//  The vector you have created and passed in will be filled with the results.
// INPUTS
//  rayID -- ID of the ray
//  outVec3ID -- Id of the vector that will be filled with the position.
// SOURCE
int agk::Get3DPhysicsRayCastClosestContactPosition( uint32_t rayID, int outVec3ID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidRayID( rayID, "Get3DPhysicsRayCastContactPosition: Ray ID is not valid" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID(outVec3ID, "Get3DPhysicsRayCastContactPosition: Vector ID not valid") )
		return 0;
	btVector3 ccp = rayManager.GetItem( rayID )->GetClosestContactPosition();
	ccp *= GetCurrentDynamicsWorld()->m_scaleFactor;
	AGKVector* outVec3 = vectorManager.GetItem( outVec3ID )->GetAGKVector();
	outVec3->Set( ccp.getX(), ccp.getY(), ccp.getZ() );
	return 1;
}

//****f* 3DPhysics/RayCast/Get3DPhysicsRayCastNormalVector
// FUNCTION
//   Fills the vector passed in with the Normals values from the ray.
//   first create a physics ray then cast the ray before calling <i>Get3DPhysicsRayCastNormalVector()</i>.
// INPUTS
//  rayID -- The ID of the ray which is returned by calling <i>Create3DPhysicsRay()</i>.
//  returnVec3ID -- The Id of a vector. Vector ID is the return value from <i>CreateVector3()</i> command.
// SOURCE
void agk::Get3DPhysicsRayCastNormalVector( uint32_t rayID, int returnVec3ID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidRayID( rayID, "Get3DPhysicsRayCastNormalVector: Ray ID is not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID(returnVec3ID, "Get3DPhysicsRayCastNormalVector: Vector ID not valid") )
		return;
	AGKVector* resultVec3 = vectorManager.GetItem( returnVec3ID )->GetAGKVector();
	btVector3 normalVec = rayManager.GetItem( rayID )->GetHitNormal();
	resultVec3->Set( normalVec.getX(), normalVec.getY(), normalVec.getZ() );
}

//****f* 3DPhysics/RayCast/Get3DPhysicsRayCastNumHits
// FUNCTION
//   Returns the total number of hits the ray has along its length.
// INPUTS
//  rayID -- The ID of the ray which is returned by calling <i>Create3DPhysicsRay()</i>.
// SOURCE
int agk::Get3DPhysicsRayCastNumHits( uint32_t rayID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return -1;
	if ( !AGKToBullet::AssertValidRayID( rayID, "Get3DPhysicsRayCastNumHits: Ray ID is not valid" ) )
		return -1;
	return rayManager.GetItem( rayID )->GetNumberOfContacts();
}

//****f* 3DPhysics/RayCast/SphereCast3DPhysics
// FUNCTION
//  Casts a sphere collision shape along the length of the ray.
// INPUTS
//  rayID -- The ID of the ray which is returned by calling <i>Create3DPhysicsRay()</i>.
//  fromVec3ID -- The ID of the vector holding the start point
//  toVec3ID -- The ID of the vector holding the end point
//  radius -- The radius of the sphere
// SOURCE
void agk::SphereCast3DPhysics( uint32_t rayID, int fromVec3ID, int toVec3ID, float radius )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidRayID( rayID, "SphereCast3DPhysics: Ray ID is not valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( fromVec3ID, "SphereCast3DPhysics: Vector ID not valid") )
		return;
	AGKVector* fromVec3 = vectorManager.GetItem( fromVec3ID )->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(toVec3ID, "SphereCast3DPhysics: Vector ID not valid") )
		return;
	AGKVector* toVec3 = vectorManager.GetItem( toVec3ID )->GetAGKVector();
	btVector3 from = AGKToBullet::GetBtVector3( *fromVec3);
	btVector3 to = AGKToBullet::GetBtVector3( *toVec3);
	from /= GetCurrentDynamicsWorld()->m_scaleFactor;
	to /= GetCurrentDynamicsWorld()->m_scaleFactor;
	rayManager.GetItem( rayID )->ConvexCast( radius, from, to );
}

//****f* 3DPhysics/RayCast/SphereCast3DPhysicsObject
// FUNCTION
//  Casts a sphere collision shape along the length of the ray.
//   Returns 1 if the specified object has been hit and 0 if it has not.
// INPUTS
//  objID -- object ID
//  rayID -- The ID of the ray which is returned by calling <i>Create3DPhysicsRay()</i>.
//  fromVec3ID -- The ID of the vector holding the start point
//  toVec3ID -- The ID of the vector holding the end point
//  radius -- The radius of the sphere
// SOURCE
int agk::SphereCast3DPhysicsObject( uint32_t objID, uint32_t rayID, int fromVec3ID, int toVec3ID, float radius )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidRayID( rayID, "SphereCast3DPhysicsObject: Ray ID is not valid" ) )
		return 0;
	if ( !AGKToBullet::AssertValidVectorID( fromVec3ID, "SphereCast3DPhysicsObject: Vector ID not valid") )
		return 0;
	AGKVector* fromVec3 = vectorManager.GetItem( fromVec3ID )->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(toVec3ID, "SphereCast3DPhysicsObject: Vector ID not valid") )
		return 0;
	AGKVector* toVec3 = vectorManager.GetItem( toVec3ID )->GetAGKVector();
	btVector3 from = AGKToBullet::GetBtVector3( *fromVec3);
	btVector3 to = AGKToBullet::GetBtVector3( *toVec3);
	from /= GetCurrentDynamicsWorld()->m_scaleFactor;
	to /= GetCurrentDynamicsWorld()->m_scaleFactor;
	rayManager.GetItem( rayID )->ConvexCast( radius, from, to );
	return rayManager.GetItem( rayID )->GetClosestContactObjectID() == objID;
}

//********************** Ragdoll Commands *******************************************

//****f* 3DPhysics/Ragdoll/Create3DPhysicsRagDoll
// FUNCTION
//  Starts the creation of a Physics ragdoll for the object. You must add at least 
//  one bone to the ragdoll before you call Finalize3DPhysicsRagDoll(). The models bones must have
//  a zero rotation in the default position/first frame of the animation. 
// INPUTS
//  objID -- object ID
//  objTotalWeight -- Total weight in lbs. This weight gets divided up among the ragdoll bones based on volume of the bones.
// SOURCE
void agk::Create3DPhysicsRagDoll( uint32_t objID, float objTotalWeight )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Create3DPhysicsRagDoll: Object ID Is Not Valid" ) )
		return;
	if ( !RagDoll::AssertRagdollExist( objID, "Create3DPhysicsRagDoll: Ragdoll already exists ", false ) )
		return;
	currentRagDoll = new RagDoll( objID );
	ragDollManager.AddItem( currentRagDoll, objID );
	currentRagDoll->SetTotalWeight( objTotalWeight );	
}

//****f* 3DPhysics/Ragdoll/Add3DPhysicsRagDollBone
// FUNCTION
//   Creates a ragdoll bone capsule between the objects start and end bone location.
//   Returns ragdoll bone ID. If this command fails to create a bone it will return a -1.
// INPUTS
//  startBoneID -- objects bone ID
//  endBoneID -- objects bone ID
//  diameter -- size of the capsule that will be the ragdoll bone.
//	 collisionGroup -- collision group that this Physics object belongs too.
//	 group1 = 2,
//	 group2 = 4,
//	 group3 = 8,
//	 group4 = 16,
//	 group5 = 32
//  collisionMask --  collision groups you want masked from collision.
//	 mask1 = 2,
//	 mask2 = 4,
//	 mask3 = 8,
//	 mask4 = 16,
//	 mask5 = 32
//  -1 is all Maskes
// SOURCE
int agk::Add3DPhysicsRagDollBone( uint32_t startBoneID, uint32_t endBoneID, float diameter, int collisionGroup, int collisionMask )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return -1;
	if( currentRagDoll != NULL ){
		return currentRagDoll->AddBone(currentRagDoll->GetID(), startBoneID, endBoneID, diameter, collisionGroup, collisionMask);
	}
	else{
		Error("You Must Call Create3DPhysicsRagDoll before Add3DPhysicsRagDollBone" );
	}
	return -1;
}

//****f* 3DPhysics/Ragdoll/AssignTo3DPhysicsRagDollBoneObjectBone
// FUNCTION
//  Assigns the objects bone to the ragdoll bone.
//  The objects bones that are in between the bones that are used to create a ragdoll bone.
// INPUTS
// ragdollBoneID -- ID of ragdoll bone.
// objBoneID -- Id of objects bone to be controlled by the ragdoll bone.
// SOURCE
void agk::AssignTo3DPhysicsRagDollBoneObjectBone( uint32_t ragdollBoneID, uint32_t objBoneID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if( currentRagDoll != NULL ){
		currentRagDoll->AssignLimbIDToBone( ragdollBoneID, objBoneID );
	}
	else{
		Error("You Must Call Create3DPhysicsRagDoll before AssignTo3DPhysicsRagollBoneObjectBone" );
	}
}

//****f* 3DPhysics/Ragdoll/Add3DPhysicsRagDollHingeJoint
// FUNCTION
//   Creates a physics hinge joint between ragdoll bone A and B at the location of the objects bone.
// INPUTS
//  boneAID -- ID of the RagDoll bone returned from Add3DPhysicsRagDollBone
//  boneBID -- ID of the RagDoll bone returned from Add3DPhysicsRagDollBone
//  objBoneID -- ID of the bone in the object which will be the location of the ragdoll joint
//  jointRotationVec3 -- Id of the vector with the rotation of the joint.
//  minLimit -- float value in angular degrees
//  maxLimit -- float value in angular degrees
// SOURCE
void agk::Add3DPhysicsRagDollHingeJoint( uint32_t boneAID, uint32_t boneBID, uint32_t objBoneID, int jointRotationVec3, float minLimit, float maxLimit )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidVectorID( jointRotationVec3, "Add3DPhysicsRagDollHingeJoint: jointRotationVec3 ID not valid") )
		return;
	if( currentRagDoll != NULL ){
		AGKVector* rotVec3 = vectorManager.GetItem( jointRotationVec3 )->GetAGKVector();
		currentRagDoll->AddHingeJoint( boneAID, boneBID, objBoneID, AGKToBullet::GetBtVector3( *rotVec3 ), btScalar( minLimit ), btScalar( maxLimit ) );
	}else
	{
		Error( "Can not call Add3DPhysicsRagDollHingeJoint before Create3DPhysicsRagDoll" );
	}
}

//****f* 3DPhysics/Ragdoll/Add3DPhysicsRagDollTwistJoint
// FUNCTION
//  Creates a physics Cone Twist joint between ragdoll bone A and B at the location of the objects bone.
// INPUTS
//  boneAID -- ID of the RagDoll bone returned from Add3DPhysicsRagDollBone
//  boneBID -- ID of the RagDoll bone returned from Add3DPhysicsRagDollBone
//  objBoneID -- ID of the bone in the object which will be the location of the ragdoll joint
//  jointRotationVec3 -- ID of the vector with the rotation of the joint.
//  limitsVec3 -- ID of the vector with the joint limits
// SOURCE
void agk::Add3DPhysicsRagDollTwistJoint( uint32_t boneAID, uint32_t boneBID, uint32_t objBoneID, int jointRotationVec3, int limitsVec3 )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidVectorID( jointRotationVec3, "Add3DPhysicsRagDollTwistJoint: jointRotationVec3 ID not valid") )
		return;
	AGKVector* rotVec3 = vectorManager.GetItem( jointRotationVec3 )->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID( limitsVec3, "Add3DPhysicsRagDollTwistJoint: limitsVec3 ID not valid") )
		return;
	AGKVector* limtsVec3 = vectorManager.GetItem( limitsVec3 )->GetAGKVector();
	if( currentRagDoll != NULL ){
		currentRagDoll->AddTwistConstraint( boneAID, boneBID, objBoneID, AGKToBullet::GetBtVector3( *rotVec3 ),
																				AGKToBullet::GetBtVector3( *limtsVec3 ) );
	}
	else{
		Error( "Can not call Add3DPhysicsRagDollTwistJoint before Create3DPhysicsRagDoll" );
	}
}

//****f* 3DPhysics/Ragdoll/Finalize3DPhysicsRagDoll
// FUNCTION
//  Finishes the construction of the ragdoll. Call this command when you have added all the bones and joints for your ragdoll.
//  Make sure you call Create3DPhysicsRagDoll first before calling this command.
// INPUTS
// SOURCE
void agk::Finalize3DPhysicsRagDoll()
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if( currentRagDoll != NULL ){
		currentRagDoll->Finalize();
		currentRagDoll = NULL;
	}
	else{
		Error( "Can not call Finalize3DPhysicsRagDoll before Create3DPhysicsRagDoll" );
	}
}

//****f* 3DPhysics/Ragdoll/Delete3DPhysicsRagdoll
// FUNCTION
//   Deletes the Ragdoll for the object.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::Delete3DPhysicsRagdoll( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Delete3DPhysicsRagdoll: Object ID Is Not Valid" ) )
		return;
	RagDoll* doll = ragDollManager.GetItem( objID );
	if ( doll ){
		doll->ResetObjectParametersForAnimation();
		delete ragDollManager.RemoveItem( objID );
	}
}

//****f* 3DPhysics/Ragdoll/Get3DPhysicsRagdollExist
// FUNCTION
//   Returns true if a ragdoll exists for the object.
// INPUTS
//  objID -- object ID
// SOURCE
int agk::Get3DPhysicsRagdollExist( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "Get3DPhysicsRagdollExist: Object ID Is Not Valid" ) )
		return 0;
	return ragDollManager.GetItem(objID) != NULL;
}

//****f* 3DPhysics/Ragdoll/Get3DPhysicsRagdollFromBoneObject
// FUNCTION
//   Returns the object ID of the Model with the ragdoll which contains the 
//  ragdoll bone object passed in.
// INPUTS
//  objID -- object ID of a ragdoll bone capsule.
// SOURCE
int agk::Get3DPhysicsRagdollFromBoneObject( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "Get3DPhysicsRagdollFromBoneObject: Bone Object ID Is Not Valid" ) )
		return 0;
	if ( !RagDoll::AssertRagdollExist( objID, "Get3DPhysicsRagdollFromBoneObject: Ragdoll does not exist ", true ) )
		return 0;
	return RagDoll::GetIDFromBoneObject(objID);
}

//****f* 3DPhysics/Ragdoll/Is3dPhysicsRagdollStatic
// FUNCTION
//   Returns a 1 if the Ragdoll is static.
// INPUTS
//  objID -- object ID
// SOURCE
int agk::Is3dPhysicsRagdollStatic( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "Is3dPhysicsRagdollStatic: Object ID Is Not Valid" ) )
		return 0;
	if ( !RagDoll::AssertRagdollExist( objID, "Is3dPhysicsRagdollStatic: Ragdoll does not exist ", true ) )
		return 0;
	RagDoll* ragdoll = ragDollManager.GetItem( objID );
	if ( ragdoll ){
		return ragdoll->IsStatic();
	}
	return 0;
}

//****f* 3DPhysics/Ragdoll/Set3DphysicsRagdollStatic
// FUNCTION
//   Sets the ragdoll static by changing the mass of all the ragdoll bones to zero.
// INPUTS
//  objID -- object ID
//  isStatic -- 1 = true, 0 = false
// SOURCE
void agk::Set3DphysicsRagdollStatic( uint32_t objID, int isStatic )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Set3DphysicsRagdollStatic: Object ID Is Not Valid" ) )
		return;
	if ( !RagDoll::AssertRagdollExist( objID, "Set3DphysicsRagdollStatic: Ragdoll does not exist ", true ) )
		return;
	RagDoll* ragdoll = ragDollManager.GetItem( objID );
	if(ragdoll){
		ragdoll->SetStatic(isStatic != 0);
	}
}

//****f* 3DPhysics/Ragdoll/Set3DPhysicsRagdollBonesVisible
// FUNCTION
//   Shows the ragdoll bone objects and hides the object.
// INPUTS
//  objID -- object ID
//  isVisible -- 1 = true, 0 = false
// SOURCE
void agk::Set3DPhysicsRagdollBonesVisible( uint32_t objID, int isVisible )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Set3DPhysicsRagdollBonesVisible: Object ID Is Not Valid" ) )
		return;
	if ( !RagDoll::AssertRagdollExist( objID, "Set3DPhysicsRagdollBonesVisible: Ragdoll does not exist ", true ) )
		return;
	RagDoll* ragdoll = ragDollManager.GetItem( objID );
	if ( ragdoll ){
		if ( isVisible ){
			ragdoll->ShowBones();
		}
		else{
			ragdoll->HideBones();
		}
	}
}

//****f* 3DPhysics/Ragdoll/Set3DPhysicsRagdollDamping
// FUNCTION
//  Sets the damping for the ragdoll being created. The default values should be
//  good for most situations. Only call if you wish to change these values.
//  Must be called before Finalize3DPhysicsRagDoll()
// INPUTS
//  linear -- Default value is 0.08
//  angular -- Default value is 0.95
// SOURCE
void agk::Set3DPhysicsRagdollDamping( float linear, float angular )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( currentRagDoll ){
		currentRagDoll->SetDamping( btScalar( linear ), btScalar( angular ) );
	}
	else{
		agk::Error( "Set3DPhysicsRagdollDamping: Ragdoll does not exist " );
	}
}

//****f* 3DPhysics/Ragdoll/Set3DPhysicsRagdollSleepingThresholds
// FUNCTION
//  Sets the sleeping thresholds for the ragdoll being created. The default values should be
//  good for most situations. Only call if you wish to change these values.
//  Must be called before Finalize3DPhysicsRagDoll()
// INPUTS
//  linear -- Default value is 1.8
//  angular -- Default value is 2.8
// SOURCE
void agk::Set3DPhysicsRagdollSleepingThresholds( float linear, float angular )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( currentRagDoll ){
		currentRagDoll->SetSleepingThresholds( btScalar( linear ), btScalar( angular ) );
	}
	else{
		agk::Error( "Set3DPhysicsRagdollSleepingThresholds: Ragdoll does not exist " );
	}
}

//****f* 3DPhysics/Ragdoll/Set3DPhysicsRagdollDeactivationTime
// FUNCTION
//  Sets the deactivation time for the ragdoll being created. The default values should be
//  good for most situations. Only call if you wish to change these values.
//  Must be called before Finalize3DPhysicsRagDoll()
// INPUTS
//  time --  Default value is 0.8
// SOURCE
void agk::Set3DPhysicsRagdollDeactivationTime( float time )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( currentRagDoll ){
		currentRagDoll->SetDeactivationTime( btScalar( time ) );
	}
	else{
		agk::Error( "Set3DPhysicsRagdollDeactivationTime: Ragdoll does not exist " );
	}
}

//****f* 3DPhysics/Ragdoll/Set3DPhysicsRagdollDeactivation
// FUNCTION
//   Keeps physics ragdoll active. Does not allow the automatic deactivation when ragdoll comes to rest.
// INPUTS
//  objID -- object ID
//  isDisabled -- 1 = true, 0 = false
// SOURCE
void agk::Set3DPhysicsRagdollDeactivation( uint32_t objID, int isDisabled )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Set3DPhysicsRagdollDeactivation: Object ID Is Not Valid" ) )
		return;
	if ( !RagDoll::AssertRagdollExist( objID, "Set3DPhysicsRagdollDeactivation: Ragdoll does not exist ", true ) )
		return;
	RagDoll* ragdoll = ragDollManager.GetItem( objID );
	if ( ragdoll ){
		ragdoll->DisableDeactivation( isDisabled );
	}
}


//************************************ CHARACTER CONTROLLER  **************************************************

//****f* 3DPhysics/CharacterController/Create3DPhysicsCharacterController
// FUNCTION
//  Creates a 3D physics Character Controller for the model. Character controller can be 
//  created on the X, Y, or Z axis. For example a standing character would be on the Y axis.
//  A lying down character could be on the X or Z. If the model has an offset from origin the 
//  objOffsetVec3 is neede to line up the character controller with the object. If the object does not 
//  face down the positive Z axis use the objOrientationVec3 to adjust. Crouch scale adjusts the crouch
//  capsule size to fit the height of your crouched model.
// INPUTS
//  objID -- object ID
//  axis -- 0 = X axis, 1= Y axis, 2 = Z axis,
//  objOffsetVec3 -- This vector is half the amount that the model is offset from origin.
//  objOrientationVec3 -- This vector is used to line up the rotation of your model with the character controller.
//  crouchScale -- Percentage amount to scale the crouched capsule to fit crouched model.
// SOURCE
void agk::Create3DPhysicsCharacterController( uint32_t objID, int axis, int objOffsetVec3, int objOrientationVec3, float crouchScale )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Create3DPhysicsCharacterController: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidVectorID( objOffsetVec3, "Create3DPhysicsCharacterController: Vector ID not valid") )
		return;
	AGKVector* offSetVec = vectorManager.GetItem( objOffsetVec3 )->GetAGKVector();
	if ( !AGKToBullet::AssertValidVectorID(objOrientationVec3, "Create3DPhysicsCharacterController: Vector ID not valid") )
		return;
	AGKVector* orientationVec = vectorManager.GetItem( objOrientationVec3 )->GetAGKVector();
	btVector3 offSet = AGKToBullet::GetBtVector3( *offSetVec);
	btVector3 orientation = AGKToBullet::GetBtVector3( *orientationVec);
	CharacterController::Create( objID, axis, offSet, orientation, crouchScale );
}

//****f* 3DPhysics/CharacterController/Delete3DPhysicsCharacterController
// FUNCTION
//   Deletes the controller for the object.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::Delete3DPhysicsCharacterController( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Delete3DPhysicsCharacterController: Object ID Is Not Valid" ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		delete characterControllerManager.RemoveItem( objID );
	}
}

//****f* 3DPhysics/CharacterController/Get3DPhysicsCharacterControllerExists
// FUNCTION
//   Returns a 1 if the object has a controller otherwise 0.
// INPUTS
//  objID -- object ID
// SOURCE
int agk::Get3DPhysicsCharacterControllerExists( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return 0;
	if ( !AGKToBullet::AssertValidObject( objID, "Get3DPhysicsCharacterControllerExists: Object ID Is Not Valid" ) )
		return 0;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		return 1;
	}
	return 0;
}

//****f* 3DPhysics/CharacterController/Set3DPhysicsCharacterControllerGravity
// FUNCTION
//  Sets the gravity for the character controller. This gravity is not the same as the physics world gravity.
//  and only affects the individual character controller.
// INPUTS
//  objID -- object ID
//  gravity -- Default value is (9.8 * 3)
// SOURCE
void agk::Set3DPhysicsCharacterControllerGravity( uint32_t objID, float gravity )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Set3DPhysicsCharacterControllerGravity: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Set3DPhysicsCharacterControllerGravity: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		controller->setGravity( btScalar( gravity ) );
	}
}

//****f* 3DPhysics/CharacterController/Set3DPhysicsCharacterControllerFallSpeed
// FUNCTION
//   Sets the speed at which the controller will fall.
// INPUTS
//  objID -- object ID
//  fallSpeed -- Default value is 55.0 which is the terminal velocity of a sky diver in meters per second.
// SOURCE
void agk::Set3DPhysicsCharacterControllerFallSpeed( uint32_t objID, float fallSpeed )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Set3DPhysicsCharacterControllerFallSpeed: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Set3DPhysicsCharacterControllerFallSpeed: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		controller->setFallSpeed( btScalar( fallSpeed ) );
	}
}

//****f* 3DPhysics/CharacterController/Set3DPhysicsCharacterControllerJumpSpeed
// FUNCTION
//   Set the speed at which the controller moves up when jump is called.
// INPUTS
//  objID -- object ID
//  jumpSpeed -- Default is 10.0
// SOURCE
void agk::Set3DPhysicsCharacterControllerJumpSpeed( uint32_t objID, float jumpSpeed )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Set3DPhysicsCharacterControllerJumpSpeed: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Set3DPhysicsCharacterControllerJumpSpeed: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		controller->setJumpSpeed( btScalar( jumpSpeed ) );
	}
}

//****f* 3DPhysics/CharacterController/Set3DPhysicsCharacterControllerMaxSlope
// FUNCTION
//   set the max slope in angle degrees that a controller can climb.
// INPUTS
//  objID -- object ID
//  maxSlopeDegress -- Default value is 45.0 degrees.
// SOURCE
void agk::Set3DPhysicsCharacterControllerMaxSlope( uint32_t objID, float maxSlopeDegress )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Set3DPhysicsCharacterControllerMaxSlope: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Set3DPhysicsCharacterControllerMaxSlope: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		controller->setMaxSlope( btScalar( btRadians( maxSlopeDegress ) ) );
	}
}

//****f* 3DPhysics/CharacterController/Set3DPhysicsCharacterControllerStepHeight
// FUNCTION
//   Sets the height that the controller can step up and over.
// INPUTS
//  objID -- object ID
//  stepHeight -- Step height in world values.
// SOURCE
void agk::Set3DPhysicsCharacterControllerStepHeight( uint32_t objID, float stepHeight )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Set3DPhysicsCharacterControllerStepHeight: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Set3DPhysicsCharacterControllerStepHeight: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		stepHeight /= GetCurrentDynamicsWorld()->m_scaleFactor;
		controller->SetStepHeight( btScalar( stepHeight ) );
	}
}

//****f* 3DPhysics/CharacterController/Get3DPhysicsCharacterControllerMaxSlope
// FUNCTION
//   Returns the maximum slope in degrees.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::Get3DPhysicsCharacterControllerMaxSlope( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return -1;
	if ( !AGKToBullet::AssertValidObject( objID, "Get3DPhysicsCharacterControllerMaxSlope: Object ID Is Not Valid" ) )
		return -1;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Get3DPhysicsCharacterControllerMaxSlope: object does not have a controller. " ) )
		return -1;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		return btDegrees( controller->getMaxSlope() );
	}
	return -1;
}

//****f* 3DPhysics/CharacterController/Get3DPhysicsCharacterControllerGravity
// FUNCTION
//   Returns the controller gravity.
// INPUTS
//  objID -- object ID
// SOURCE
float agk::Get3DPhysicsCharacterControllerGravity( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return -1;
	if ( !AGKToBullet::AssertValidObject( objID, "Get3DPhysicsCharacterControllerGravity: Object ID Is Not Valid" ) )
		return -1;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Get3DPhysicsCharacterControllerGravity: object does not have a controller. " ) )
		return -1;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		return controller->getGravity();
	}
	return -1;
}

//****f* 3DPhysics/CharacterController/Move3DPhysicsCharacterController
// FUNCTION
//   Moves the Controller.
// INPUTS
//  objID -- object ID
//  direction -- 0 = stop, 1 = forward, 2 = backward, 3 = strafe left, 4 = strafe right
//  velocity -- travel speed
// SOURCE
void agk::Move3DPhysicsCharacterController( uint32_t objID, int direction, float velocity )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Move3DPhysicsCharacterController: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Move3DPhysicsCharacterController: Object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		btScalar scaleFactor = GetCurrentDynamicsWorld()->m_scaleFactor;
		velocity = velocity / scaleFactor;
		btVector3 moveDirection;
		if(direction == 0)
			moveDirection = btVector3(0.0, 0.0, 0.0);
		if(direction == 1)
			moveDirection = btVector3(0.0, 0.0, 1.0);
		if(direction == 2)
			moveDirection = btVector3(0.0, 0.0, -1.0);
		if(direction == 3)
			moveDirection = btVector3(-1.0, 0.0, 0.0);
		if(direction == 4)
			moveDirection = btVector3(1.0, 0.0, 0.0);
		//SITDS:Order Matters Call velocity before direction.
		controller->SetWalkVelocity( btScalar( velocity ) );		
		controller->setWalkDirection( moveDirection );
	}
}

//****f* 3DPhysics/CharacterController/Move3DPhysicsCharacterController
// FUNCTION
//   Moves the Controller.
// INPUTS
//  objID -- object ID
//  x -- The amount to move in the x direction, this will be normalised with the z direction
//  z -- The amount to move in the z direction, this will be normalised with the x direction
//  velocity -- travel speed
// SOURCE
void agk::Move3DPhysicsCharacterController( uint32_t objID, float x, float z, float velocity )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Move3DPhysicsCharacterController: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Move3DPhysicsCharacterController: Object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		btScalar scaleFactor = GetCurrentDynamicsWorld()->m_scaleFactor;
		velocity = velocity / scaleFactor;
		float length = agk::Sqrt( x*x + z*z );
		if ( length > 0 ) { x /= length; z /= length; }
		btVector3 moveDirection = btVector3(x, 0.0, z);
		//SITDS:Order Matters Call velocity before direction.
		controller->SetWalkVelocity( btScalar( velocity ) );		
		controller->setWalkDirection( moveDirection );
	}
}

//****f* 3DPhysics/CharacterController/Rotate3DPhysicsCharacterController
// FUNCTION
//   Rotates the controller.
// INPUTS
//  objID -- object ID
//  angle -- amount in degrees
// SOURCE
void agk::Rotate3DPhysicsCharacterController( uint32_t objID, float angle )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Rotate3DPhysicsCharacterController: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Rotate3DPhysicsCharacterController: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		btMatrix3x3 rotationMat;
		rotationMat.setEulerYPR( 0.0, btRadians( angle ), 0.0 );
		controller->SetRotation( rotationMat );
	}
}

//****f* 3DPhysics/CharacterController/Jump3DPhysicsCharacterController
// FUNCTION
//   Moves the controller up to the jump height.
// INPUTS
//  objID -- object ID
// SOURCE
void agk::Jump3DPhysicsCharacterController( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Jump3DPhysicsCharacterController: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Jump3DPhysicsCharacterController: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		controller->jump();
	}
}

//****f* 3DPhysics/CharacterController/Crouch3DPhysicsCharacterController
// FUNCTION
//   Crouches the controller
// INPUTS
//  objID -- object ID
// SOURCE
void agk::Crouch3DPhysicsCharacterController( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Crouch3DPhysicsCharacterController: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Crouch3DPhysicsCharacterController: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		controller->Crouch();
	}
}

//****f* 3DPhysics/CharacterController/Stand3DPhysicsCharacterController
// FUNCTION
//   Stands the controller
// INPUTS
//  objID -- object ID
// SOURCE
void agk::Stand3DPhysicsCharacterController( uint32_t objID )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Stand3DPhysicsCharacterController: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Stand3DPhysicsCharacterController: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		controller->Stand();
	}
}

//****f* 3DPhysics/CharacterController/Debug3DPhysicsCharacterController
// FUNCTION
//   Shows the Capsule objects the represent the controller.
// INPUTS
//  objID -- object ID
//  isDebug -- 1 = true, 0 = false
// SOURCE
void agk::Debug3DPhysicsCharacterController( uint32_t objID, int isDebug )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Debug3DPhysicsCharacterController: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Debug3DPhysicsCharacterController: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		controller->SetDebugMode( isDebug != 0 );
	}
}

//****f* 3DPhysics/CharacterController/Set3DPhysicsCharacterControllerPosition
// FUNCTION
//  Repositions the Controller to the new coordinates passed in. Do not position the controller inside another physics object.
// INPUTS
//  objID -- object ID
//  posX -- The new X coordinate
//  posY -- The new Y coordinate
//  posZ -- The new Z coordinate
// SOURCE
void agk::Set3DPhysicsCharacterControllerPosition( uint32_t objID, float posX, float posY, float posZ )
//****
{
	if ( !AGKToBullet::AssertValidPhysicsWorld() )
		return;
	if ( !AGKToBullet::AssertValidObject( objID, "Set3DPhysicsCharacterControllerPosition: Object ID Is Not Valid" ) )
		return;
	if ( !AGKToBullet::AssertValidCharacterController( objID, "Set3DPhysicsCharacterControllerPosition: object does not have a controller. " ) )
		return;
	CharacterController* controller = characterControllerManager.GetItem( objID );
	if ( controller ){
		btVector3 pos( posX, posY, posZ );
		pos /= GetCurrentDynamicsWorld()->m_scaleFactor;
		controller->SetPosition( pos );
	}
}

//****f* Core/Noise/SetupNoise
// FUNCTION
//  Initialises Open Simplex noise generation.
// INPUTS
//  frequency -- Frequency (width) of the first octave of noise e.g. 1.0
//  amplitude -- Amplitude (height) of the first octave of noise e.g. 1.0
//  lacunarity --  Lacunarity specifies the frequency multiplier between successive octaves e.g. 2.0.
//  persistence -- Persistence is the loss of amplitude between successive octaves (usually 1/lacunarity)
// SOURCE
void agk::SetupNoise ( float frequency, float amplitude, float lacunarity, float persistence )
//****
{
	if ( m_pNoise )
		delete m_pNoise;

	m_pNoise = new SimplexNoise ( frequency, amplitude, lacunarity, persistence );
}

//****f* Core/Noise/GetNoiseX
// FUNCTION
//  Returns 1D Perlin simplex noise
// INPUTS
//  x -- x float coordinate
// SOURCE
float agk::GetNoiseX ( float x )
//****
{
	if ( !m_pNoise )
		return 0.0f;

	return m_pNoise->noise ( x );
}

//****f* Core/Noise/GetNoiseXY
// FUNCTION
//  Returns 2D Perlin simplex noise
// INPUTS
//  x -- x float coordinate
//  y -- y float coordinate
// SOURCE
float agk::GetNoiseXY ( float x, float y )
//****
{
	if ( !m_pNoise )
		return 0.0f;

	return m_pNoise->noise ( x, y );
}

//****f* Core/Noise/GetNoiseXYZ
// FUNCTION
//  Returns 3D Perlin simplex noise
// INPUTS
//  x -- x float coordinate
//  y -- y float coordinate
//  z -- z float coordinate
// SOURCE
float agk::GetNoiseXYZ ( float x, float y, float z )
//****
{
	if ( !m_pNoise )
		return 0.0f;

	return m_pNoise->noise ( x, y, z );
}

//****f* Core/Noise/GetFractalX
// FUNCTION
//  Returns Fractal/Fractional Brownian Motion
// INPUTS
//  octaves -- number of fraction of noise to sum
//  x -- x float coordinate
// SOURCE
float agk::GetFractalX ( uint32_t octaves, float x )
//****
{
	if ( !m_pNoise )
		return 0.0f;

	return m_pNoise->fractal ( octaves, x );
}

//****f* Core/Noise/GetFractalXY
// FUNCTION
//  Returns Fractal/Fractional Brownian Motion
// INPUTS
//  octaves -- number of fraction of noise to sum
//  x -- x float coordinate
//  y -- y float coordinate
// SOURCE
float agk::GetFractalXY ( uint32_t octaves, float x, float y )
//****
{
	if ( !m_pNoise )
		return 0.0f;

	return m_pNoise->fractal ( octaves, x, y );
}

//****f* Core/Noise/GetFractalXYZ
// FUNCTION
//  Returns Fractal/Fractional Brownian Motion
// INPUTS
//  octaves -- number of fraction of noise to sum
//  x -- x float coordinate
//  y -- y float coordinate
//  z -- z float coordinate
// SOURCE
float agk::GetFractalXYZ ( uint32_t octaves, float x, float y, float z )
//****
{
	if ( !m_pNoise )
		return 0.0f;

	return m_pNoise->fractal ( octaves, x, y, z );
}

} 




